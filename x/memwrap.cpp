// Module: Memwrap.obj
// Source: C:\Copter\Source\X\Memwrap.cpp
// autogenerated by simcopter_tool from PDB file

// Type: void * __ptr32;

// Type: /*unpacked*/ class Memory (forward reference);
class Memory{ // not packed(0x1 bytes) TI: 0x334e
	using MemPool = long;
	using HState = long;
	enum /* __unnamed */ {
		kLocked = 128,
		kPurgeable = 64,
		kResrc = 32,
	};
public:
	// calltype: NearC
	static long Error();
	// calltype: NearC
	static void * __ptr32 HAlloc(long, long);
	// calltype: NearC
	static void HUnpurge(void * __ptr32, long);
	// calltype: NearC
	static unsigned char * PAlloc(long *, long);
	// calltype: NearC
	static void HFree(void * __ptr32);
	// calltype: NearC
	static void PFree(unsigned char *);
	// calltype: NearC
	static unsigned long HGetSize(void * __ptr32);
	// calltype: NearC
	static unsigned long PGetSize(unsigned char *);
	// calltype: NearC
	static unsigned char * HLock(void * __ptr32);
	// calltype: NearC
	static void HUnlock(void * __ptr32);
	// calltype: NearC
	static void HMoveHi(void * __ptr32);
	// calltype: NearC
	static void HPurge(void * __ptr32);
	// calltype: NearC
	static void HNoPurge(void * __ptr32);
	// calltype: NearC
	static unsigned short HIsLocked(void * __ptr32);
	// calltype: NearC
	static long HGetState(void * __ptr32);
	// calltype: NearC
	static void HSetState(void * __ptr32, long);
	// calltype: NearC
	static unsigned char * Stash(void * __ptr32);
	// calltype: NearC
	static void BlockMove(void * __ptr32, void * __ptr32, unsigned long);
	// calltype: NearC
	static void BlockCopy(void * __ptr32, void * __ptr32, unsigned long);
	// calltype: NearC
	static void BlockFill(void * __ptr32, unsigned char, unsigned long);
	// calltype: NearC
	static unsigned short BlockCompare(void * __ptr32, void * __ptr32, unsigned long);
	// calltype: NearC
	static long HSetSize(void * __ptr32, unsigned long);
	// calltype: NearC
	static void HCopy(void * __ptr32*);
	// calltype: NearC
	static void * __ptr32 HGetCopy(void * __ptr32);
	enum PoolType {
		kAnyBlockSize = 0,
		kUniformBlockSize = 1,
	};
public:
	// calltype: NearC
	static long * PoolAlloc(long, enum Memory::PoolType);
	// calltype: NearC
	static void PoolFree(long *);
	// calltype: NearC
	static void HLeaks(/*unpacked*/ struct AllocRecord*);
	// calltype: NearC
	static void * __ptr32 AdoptPlatformHandle(void * __ptr32);
	// calltype: NearC
	static void * __ptr32 DetachPlatformHandle(void * __ptr32);
	// calltype: NearC
	static void * __ptr32 GetPlatformHandle(void * __ptr32);
};

// Type: long;

// Type: unsigned long;

// Type: unsigned char *;

// Type: void;

// Type: long *;

// Type: short;

// Type: unsigned char;

// Type: unsigned short;

// Type: enum Memory::PoolType;
enum PoolType {
	kAnyBlockSize = 0,
	kUniformBlockSize = 1,
};



// Contribution: 1:00153720-00153f24 Module: 198, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00554720
void * __ptr32 Memory::DetachPlatformHandle(void * __ptr32 mh) {
// LINE 104:
	return mh;
// LINE 105:
}

// FUNCTION: COPTER_D 0x00554733
void * __ptr32 Memory::GetPlatformHandle(void * __ptr32 mh) {
// LINE 108:
	return mh;
// LINE 109:
}

// FUNCTION: COPTER_D 0x00554746
void * __ptr32 Memory::AdoptPlatformHandle(void * __ptr32 mem) {
// LINE 115:
	return mem;
// LINE 116:
}

// FUNCTION: COPTER_D 0x00554759
void * __ptr32 Memory::HAlloc(long size, long state) {
	/*bp-0x4*/   unsigned long wstate;
	/*bp-0x8*/   void * __ptr32 mem;

// LINE 151:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 160:
	wstate = 0x2;
// LINE 162:
	__asm        test   reinterpret_cast<uint8_t>(state), 0x40;
	__asm        je     _T29;

	__asm        or     wstate, 0xF00;
// LINE 165:
_T29:
	__asm        mov    eax, size;
	__asm        push   eax;
	__asm        mov    eax, wstate;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3728];
	__asm        mov    mem, eax;
// LINE 166:
	__asm        cmp    mem, 0;
	__asm        je     _T5a;

	__asm        test   reinterpret_cast<uint8_t>(state), 0x80;
	__asm        je     _T5a;

	Memory::HLock(mem);
// LINE 168:
_T5a:
	__asm        cmp    mem, 0;
	__asm        jne    _T80;

	doAssert(0x8c085, 0x5bc130, 0xa8, 0x5bc14c);
// LINE 169:
_T80:
	__asm        cmp    mem, 0;
	__asm        je     _Te2;
// LINE 172:
// Block start:
	/*bp-0xc*/   unsigned char * p;
	p = Memory::HLock(mem);
// LINE 173:
	__asm        cmp    p, 0;
	__asm        je     _Tc6;
// LINE 175:
	Memory::BlockFill(size, 0x0, p);
// LINE 176:
	Memory::HUnlock(mem);
// LINE 178:
	__asm        jmp    _Te2;
// LINE 180:
_Tc6:
	doAssert(0x8c085, 0x5bc16c, 0xb4, 0x5bc184);
// LINE 183:
// Block end:
_Te2:
	return mem;
// LINE 184:
}

// FUNCTION: COPTER_D 0x00554848
void Memory::HUnpurge(void * __ptr32 purged, long oldSize) {
// LINE 191:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 195:
	__asm        push   2;
	__asm        mov    eax, oldSize;
	__asm        push   eax;
	__asm        mov    eax, purged;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C371C];
// LINE 197:
	return;
}

// FUNCTION: COPTER_D 0x00554870
unsigned char * Memory::PAlloc(long * pool, long size) {
	/*bp-0x4*/   void * __ptr32 mem;

// LINE 203:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 210:
	__asm        push   0x60;
	__asm        mov    eax, size;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3728];
	__asm        mov    mem, eax;
// LINE 211:
	__asm        cmp    mem, 0;
	__asm        jne    _T46;

	doAssert(0x8c085, 0x5bc1a4, 0xd3, 0x5bc1c0);
// LINE 212:
_T46:
	return mem;
// LINE 214:
}

// FUNCTION: COPTER_D 0x005548c3
void Memory::HFree(void * __ptr32 mem) {
	/*bp-0x4*/   unsigned char * p;

// LINE 220:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 225:
	p = Memory::HLock(mem);
// LINE 226:
	__asm        cmp    p, 0;
	__asm        je     _T59;
// LINE 228:
	Memory::BlockFill(Memory::HGetSize(mem), 0xa3, p);
// LINE 229:
	Memory::HUnlock(mem);
// LINE 231:
	__asm        jmp    _T75;
// LINE 233:
_T59:
	doAssert(0x8c085, 0x5bc1e0, 0xe9, 0x5bc1f8);
// LINE 240:
_T75:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3714];
// LINE 242:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        test   eax, eax;
	__asm        je     _Ta9;

	doAssert(0x8c085, 0x5bc218, 0xf2, 0x5bc228);
// LINE 243:
_Ta9:
	return;
}

// FUNCTION: COPTER_D 0x00554976
void Memory::PFree(unsigned char * mem) {
// LINE 249:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 251:
	Memory::BlockFill(Memory::PGetSize(mem), 0xa3, mem);
// LINE 257:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3714];
// LINE 259:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        test   eax, eax;
	__asm        je     _T60;

	doAssert(0x8c085, 0x5bc248, 0x103, 0x5bc258);
// LINE 260:
_T60:
	return;
}

// FUNCTION: COPTER_D 0x005549e0
unsigned char * Memory::HLock(void * __ptr32 mem) {
	/*bp-0x4*/   unsigned char * p;
	/*bp-0x8*/   short err;

// LINE 266:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 274:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3710];
	__asm        mov    p, eax;
// LINE 278:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        mov    err, ax;
// LINE 279:
	__asm        movsx  eax, err;
	__asm        test   eax, eax;
	__asm        je     _T50;

	doAssert(reinterpret_cast<int16_t>(err), 0x5bc278, 0x117, 0x5bc290);
// LINE 289:
_T50:
	return p;
// LINE 290:
}

// FUNCTION: COPTER_D 0x00554a3d
void Memory::HUnlock(void * __ptr32 mem) {
	/*bp-0x4*/   short err;

// LINE 296:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 300:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C370C];
// LINE 304:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        mov    err, ax;
// LINE 305:
	__asm        movsx  eax, err;
	__asm        test   eax, eax;
	__asm        je     _T4d;

	doAssert(0x8c085, 0x5bc2b0, 0x131, 0x5bc2c4);
// LINE 307:
_T4d:
	return;
}

// FUNCTION: COPTER_D 0x00554a94
void Memory::HMoveHi(void * __ptr32 h) {
// LINE 313:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 320:
	return;
}

// FUNCTION: COPTER_D 0x00554aac
void Memory::HPurge(void * __ptr32 h) {
// LINE 328:
	doAssert(0x8c085, 0x5bc2e4, 0x148, 0x5bc314);
// LINE 332:
	return;
}

// FUNCTION: COPTER_D 0x00554ad8
void Memory::HNoPurge(void * __ptr32 h) {
// LINE 340:
	doAssert(0x8c085, 0x5bc334, 0x154, 0x5bc364);
// LINE 344:
	return;
}

// FUNCTION: COPTER_D 0x00554b04
unsigned char * Memory::Stash(void * __ptr32 h) {
	/*bp-0x4*/   unsigned long flags;

// LINE 351:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 353:
	Memory::HUnlock(h);
// LINE 354:
	Memory::HMoveHi(h);
// LINE 360:
	__asm        mov    eax, h;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3708];
	__asm        mov    flags, eax;
// LINE 361:
	__asm        test   *reinterpret_cast<uint8_t*>(reinterpret_cast<char*>(&flags) + 1), 0xF;
	__asm        je     _T5c;

	doAssert(0x8c085, 0x5bc384, 0x169, 0x5bc3a4);
// LINE 363:
_T5c:
	return Memory::HLock(h);
// LINE 364:
}

// FUNCTION: COPTER_D 0x00554b76
void Memory::BlockMove(void * __ptr32 from, void * __ptr32 to, unsigned long size) {
// LINE 371:
	__asm        cmp    size, 0x7A1200;
	__asm        jb     _T2f;

	doAssert(0x8c085, 0x5bc3c4, 0x173, 0x5bc3fc);
// LINE 375:
_T2f:
	memmove(size, from, to);
// LINE 377:
	return;
}

// FUNCTION: COPTER_D 0x00554bc3
void Memory::BlockCopy(void * __ptr32 from, void * __ptr32 to, unsigned long size) {
// LINE 381:
	__asm        cmp    size, 0x7A1200;
	__asm        jb     _T2f;

	doAssert(0x8c085, 0x5bc41c, 0x17d, 0x5bc454);
// LINE 385:
_T2f:
	memcpy(size, from, to);
// LINE 387:
	return;
}

// FUNCTION: COPTER_D 0x00554c10
void Memory::BlockFill(void * __ptr32 mem, unsigned char byteVal, unsigned long size) {
	/*bp-0x4*/   short err;

// LINE 393:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 395:
	__asm        mov    eax, size;
	__asm        push   eax;
	__asm        xor    eax, eax;
	__asm        mov    al, byteVal;
	__asm        push   eax;
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 397:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        mov    err, ax;
// LINE 398:
	__asm        movsx  eax, err;
	__asm        test   eax, eax;
	__asm        je     _T59;

	doAssert(0x8c085, 0x5bc474, 0x18e, 0x5bc484);
// LINE 399:
_T59:
	return;
}

// FUNCTION: COPTER_D 0x00554c73
unsigned short Memory::BlockCompare(void * __ptr32 first, void * __ptr32 second, unsigned long size) {
// LINE 402:
	__asm        mov    eax, size;
	__asm        push   eax;
	__asm        mov    eax, second;
	__asm        push   eax;
	__asm        mov    eax, first;
	__asm        push   eax;
	__asm        call   memcmp;
	__asm        add    esp, 0xC;
	__asm        test   eax, eax;
	__asm        jne    _T2b;

	__asm        mov    ax, 1;
	__asm        jmp    _T2e;
_T2b:
	__asm        xor    ax, ax;
_T2e:
	__asm        jmp    __RETURN;
// LINE 403:
__RETURN:
}

// FUNCTION: COPTER_D 0x00554cab
long * Memory::PoolAlloc(long totalSize, enum Memory::PoolType poolType) {
// LINE 409:
	doAssert(0x8c085, 0x5bc4a4, 0x199, 0x5bc4bc);
// LINE 410:
	return 0x0;
// LINE 411:
}

// FUNCTION: COPTER_D 0x00554cd9
void Memory::PoolFree(long * pool) {
// LINE 417:
	doAssert(0x8c085, 0x5bc4dc, 0x1a1, 0x5bc4f4);
// LINE 418:
	return;
}

// FUNCTION: COPTER_D 0x00554d05
unsigned long Memory::HGetSize(void * __ptr32 mem) {
	/*bp-0x4*/   unsigned long size;

// LINE 424:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 429:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3704];
	__asm        mov    size, eax;
// LINE 431:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        test   eax, eax;
	__asm        je     _T48;

	doAssert(0x8c085, 0x5bc514, 0x1af, 0x5bc52c);
// LINE 432:
_T48:
	return size;
// LINE 433:
}

// FUNCTION: COPTER_D 0x00554d5a
unsigned long Memory::PGetSize(unsigned char * mem) {
	/*bp-0x4*/   unsigned long size;

// LINE 439:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 444:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3704];
	__asm        mov    size, eax;
// LINE 446:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        test   eax, eax;
	__asm        je     _T48;

	doAssert(0x8c085, 0x5bc54c, 0x1be, 0x5bc564);
// LINE 447:
_T48:
	return size;
// LINE 448:
}

// FUNCTION: COPTER_D 0x00554daf
unsigned short Memory::HIsLocked(void * __ptr32 h) {
	/*bp-0x4*/   long state;

// LINE 455:
	state = Memory::HGetState(h);
// LINE 456:
_T2b:
_T2e:
	return ((reinterpret_cast<uint8_t>(state) & 0x80) == 0x0);
// LINE 457:
}

// FUNCTION: COPTER_D 0x00554de7
long Memory::HGetState(void * __ptr32 h) {
	/*bp-0x4*/   unsigned long wstate;
	/*bp-0x8*/   long state;

// LINE 463:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 468:
	__asm        mov    eax, h;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3708];
	__asm        mov    wstate, eax;
// LINE 469:
	state = 0x0;
// LINE 470:
	__asm        cmp    reinterpret_cast<uint8_t>(wstate), 0;
	__asm        je     _T36;

	__asm        or     state, 0x80;
// LINE 471:
_T36:
	__asm        test   *reinterpret_cast<uint8_t*>(reinterpret_cast<char*>(&wstate) + 1), 0xF;
	__asm        je     _T44;

	__asm        or     state, 0x40;
// LINE 472:
_T44:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        test   eax, eax;
	__asm        je     _T6e;

	doAssert(0x8c085, 0x5bc584, 0x1d8, 0x5bc5a4);
// LINE 474:
_T6e:
	return state;
// LINE 475:
}

// FUNCTION: COPTER_D 0x00554e62
void Memory::HSetState(void * __ptr32 h, long newState) {
// LINE 486:
	__asm        test   reinterpret_cast<uint8_t>(newState), 0x80;
	__asm        je     _T21;

	Memory::HLock(h);
// LINE 487:
	__asm        jmp    _T2d;
_T21:
	Memory::HUnlock(h);
// LINE 489:
_T2d:
	return;
}

// FUNCTION: COPTER_D 0x00554e99
long Memory::HSetSize(void * __ptr32 mem, unsigned long newSize) {
	/*bp-0x4*/   long err;

// LINE 495:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3720];
// LINE 502:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   Memory::HIsLocked;
	__asm        add    esp, 4;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T44;

	doAssert(0x8c085, 0x5bc5c4, 0x1f6, 0x5bc5dc);
// LINE 503:
_T44:
	__asm        push   2;
	__asm        mov    eax, newSize;
	__asm        push   eax;
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C371C];
	__asm        mov    mem, eax;
// LINE 504:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        mov    err, eax;
// LINE 506:
	return err;
// LINE 507:
}

// FUNCTION: COPTER_D 0x00554f06
long Memory::Error() {
	/*bp-0x4*/   long err;

// LINE 541:
	__asm        call   dword ptr ds:[0x6C3718];
	__asm        mov    err, eax;
// LINE 543:
	return err;
// LINE 544:
}



// Contribution: 3:00025130-000255fa Module: 198, 4 byte alignment, initialized_data, read, write, 
