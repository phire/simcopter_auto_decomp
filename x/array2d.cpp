// Module: Array2d.obj
// Source: C:\Copter\Source\X\Array2d.cpp
// autogenerated by simcopter_tool from PDB file

// Type: unsigned short;

// Type: /*unpacked*/ class _cArray (forward reference);
// VTABLE: COPTER_D 0x00593738
class _cArray{ // not packed(0x50 bytes) TI: 0x3254
	using ArrayName = unsigned char[16];
	using TinyName = unsigned long;
	using FileNameStr = unsigned char[16];
	enum /* __unnamed */ {
		kHeaderSize = 8,
		kMaxArrays = 1024,
		kMaxLoadable = 64,
		kFileNameLength = 15,
		kArrayNameLength = 15,
	};
	struct _cArray::FileAndType{ // not packed(0x8 bytes) TI: 0x3256
		/*+0x0*/   /*unpacked*/ class ResFile *file;
		/*+0x4*/   unsigned long type;
	};
	struct _cArray::Header{ // not packed(0x8 bytes) TI: 0x32ad
		/*+0x0*/   short entrySize; // 0x2 bytes
		/*+0x2*/   short xSize; // 0x2 bytes
		/*+0x4*/   short ySize; // 0x2 bytes
		/*+0x6*/   short _pad; // 0x2 bytes
	};
public:
	static /*unpacked*/ class _cArray **sArrayTable;
	// calltype: NearC
	static void MakeTable();
	// calltype: NearC
	static void DeleteTable();
private:
	void CheckIntoTable();
	unsigned short SetSize(long, long);
	void SetXPointers();
	void FillHeader();
	void SetSizeAndHeaders(long, long);
	unsigned char * _GetPointer(long, long);
protected:
	/*+0x4*/   void * __ptr32 *fData;
public:
	/*+0x8*/   void * __ptr32 fDataHandle;
	/*+0xc*/   unsigned char * fDataPtr;
	/*+0x10*/  long fySize;
	/*+0x14*/  long fxSize;
	/*+0x18*/  long fEntrySize;
protected:
	/*+0x1c*/  unsigned long fDataHandleSize;
	/*+0x20*/  short fResID; // 0x2 bytes
	/*+0x22*/  short _pad; // 0x2 bytes
	/*+0x24*/  /*unpacked*/ class ResFile *fFile;
	/*+0x28*/  unsigned long fType;
	/*+0x2c*/  unsigned char fFileName[16]; // 0x10 bytes
	/*+0x3c*/  unsigned char fName[16]; // 0x10 bytes
	/*+0x4c*/  unsigned long fTinyName;
	static /*unpacked*/ struct _cArray::FileAndType fsLoaded[64];
public:
	void _cArray(long, long, long, unsigned long, /*unpacked*/ class ResFile*, unsigned long);
	void _cArray(long, long, long, unsigned char *, /*unpacked*/ class ResFile*, unsigned long);
protected:
	void _cArray(void * __ptr32, /*unpacked*/ class ResFile*, long, void (*)(void * __ptr32, long));
private:
	void BeginCreate(long, long, long, unsigned char *, /*unpacked*/ class ResFile*, unsigned long);
	void FromDiskCreate(void * __ptr32, /*unpacked*/ class ResFile*, long, void (*)(void * __ptr32, long));
public:
	unsigned long GetName();
	void GetName(unsigned char *);
	// calltype: NearC
	static /*unpacked*/ class _cArray* GetArray(unsigned long, short);
	// calltype: NearC
	static /*unpacked*/ class _cArray* GetArrayByType(unsigned long, short);
	// calltype: NearC
	static short GetArrayIndexInType(/*unpacked*/ class _cArray*);
	// calltype: NearC
	static short GetNumArraysByType(unsigned long);
	// calltype: NearC
	static short GetLoadedIndex(/*unpacked*/ class ResFile*, unsigned long);
	// calltype: NearC
	static void LoadAllArrays(/*unpacked*/ class ResFile*, unsigned long, short, void (*)(void * __ptr32, long));
	static unsigned short sAllLoaded;
	// calltype: NearC
	static void DeleteAllArrays();
	void ClearBytes(signed char);
	short InsertRow(short);
	short InsertColumn(short);
	short DeleteRow(short);
	short DeleteColumn(short);
	unsigned short Resize(long, long, signed char);
	virtual void WriteToDisk(); // vtable+0x0
	void CopyFrom(/*unpacked*/ class _cArray*);
	void CopyFrom(unsigned long);
	void CopyFrom(unsigned char *);
	void CopyToByFTN(/*unpacked*/ class ResFile*, unsigned long, unsigned char *);
	void CopyTo(/*unpacked*/ class _cArray*);
	void CopyTo(unsigned long);
	void CopyTo(unsigned char *);
	void ~_cArray();
	void DeleteResource();
	// calltype: NearC
	static unsigned short IsNameTaken(unsigned long, short);
};

// Type: /*unpacked*/ struct _cArray::FileAndType (forward reference);
struct _cArray::FileAndType{ // not packed(0x8 bytes) TI: 0x3256
	/*+0x0*/   /*unpacked*/ class ResFile *file;
	/*+0x4*/   unsigned long type;
};

// Type: /*unpacked*/ class ResFile (forward reference);
// VTABLE: COPTER_D 0x00593518
class ResFile : public FlatResFile
{ // not packed(0x11c bytes) TI: 0x3334
public:
	long OpenFromOtherFile(/*unpacked*/ class ResFile*);
};

// Type: void * __ptr32;

// Type: long;

// Type: void (void * __ptr32, long);

// Type: signed char *;

// Type: /*unpacked*/ struct _cArray::Header (forward reference);
struct _cArray::Header{ // not packed(0x8 bytes) TI: 0x32ad
	/*+0x0*/   short entrySize; // 0x2 bytes
	/*+0x2*/   short xSize; // 0x2 bytes
	/*+0x4*/   short ySize; // 0x2 bytes
	/*+0x6*/   short _pad; // 0x2 bytes
};

// Type: unsigned char;

// Type: void;

// Type: unsigned char *;

// Type: unsigned long;

// Type: signed char;

// Type: short;

// Type: /*unpacked*/ class _cArray;
// VTABLE: COPTER_D 0x00593738
class _cArray{ // not packed(0x50 bytes) TI: 0x3254
	using ArrayName = unsigned char[16];
	using TinyName = unsigned long;
	using FileNameStr = unsigned char[16];
	enum /* __unnamed */ {
		kHeaderSize = 8,
		kMaxArrays = 1024,
		kMaxLoadable = 64,
		kFileNameLength = 15,
		kArrayNameLength = 15,
	};
	struct _cArray::FileAndType{ // not packed(0x8 bytes) TI: 0x3256
		/*+0x0*/   /*unpacked*/ class ResFile *file;
		/*+0x4*/   unsigned long type;
	};
	struct _cArray::Header{ // not packed(0x8 bytes) TI: 0x32ad
		/*+0x0*/   short entrySize; // 0x2 bytes
		/*+0x2*/   short xSize; // 0x2 bytes
		/*+0x4*/   short ySize; // 0x2 bytes
		/*+0x6*/   short _pad; // 0x2 bytes
	};
public:
	static /*unpacked*/ class _cArray **sArrayTable;
	// calltype: NearC
	static void MakeTable();
	// calltype: NearC
	static void DeleteTable();
private:
	void CheckIntoTable();
	unsigned short SetSize(long, long);
	void SetXPointers();
	void FillHeader();
	void SetSizeAndHeaders(long, long);
	unsigned char * _GetPointer(long, long);
protected:
	/*+0x4*/   void * __ptr32 *fData;
public:
	/*+0x8*/   void * __ptr32 fDataHandle;
	/*+0xc*/   unsigned char * fDataPtr;
	/*+0x10*/  long fySize;
	/*+0x14*/  long fxSize;
	/*+0x18*/  long fEntrySize;
protected:
	/*+0x1c*/  unsigned long fDataHandleSize;
	/*+0x20*/  short fResID; // 0x2 bytes
	/*+0x22*/  short _pad; // 0x2 bytes
	/*+0x24*/  /*unpacked*/ class ResFile *fFile;
	/*+0x28*/  unsigned long fType;
	/*+0x2c*/  unsigned char fFileName[16]; // 0x10 bytes
	/*+0x3c*/  unsigned char fName[16]; // 0x10 bytes
	/*+0x4c*/  unsigned long fTinyName;
	static /*unpacked*/ struct _cArray::FileAndType fsLoaded[64];
public:
	void _cArray(long, long, long, unsigned long, /*unpacked*/ class ResFile*, unsigned long);
	void _cArray(long, long, long, unsigned char *, /*unpacked*/ class ResFile*, unsigned long);
protected:
	void _cArray(void * __ptr32, /*unpacked*/ class ResFile*, long, void (*)(void * __ptr32, long));
private:
	void BeginCreate(long, long, long, unsigned char *, /*unpacked*/ class ResFile*, unsigned long);
	void FromDiskCreate(void * __ptr32, /*unpacked*/ class ResFile*, long, void (*)(void * __ptr32, long));
public:
	unsigned long GetName();
	void GetName(unsigned char *);
	// calltype: NearC
	static /*unpacked*/ class _cArray* GetArray(unsigned long, short);
	// calltype: NearC
	static /*unpacked*/ class _cArray* GetArrayByType(unsigned long, short);
	// calltype: NearC
	static short GetArrayIndexInType(/*unpacked*/ class _cArray*);
	// calltype: NearC
	static short GetNumArraysByType(unsigned long);
	// calltype: NearC
	static short GetLoadedIndex(/*unpacked*/ class ResFile*, unsigned long);
	// calltype: NearC
	static void LoadAllArrays(/*unpacked*/ class ResFile*, unsigned long, short, void (*)(void * __ptr32, long));
	static unsigned short sAllLoaded;
	// calltype: NearC
	static void DeleteAllArrays();
	void ClearBytes(signed char);
	short InsertRow(short);
	short InsertColumn(short);
	short DeleteRow(short);
	short DeleteColumn(short);
	unsigned short Resize(long, long, signed char);
	virtual void WriteToDisk(); // vtable+0x0
	void CopyFrom(/*unpacked*/ class _cArray*);
	void CopyFrom(unsigned long);
	void CopyFrom(unsigned char *);
	void CopyToByFTN(/*unpacked*/ class ResFile*, unsigned long, unsigned char *);
	void CopyTo(/*unpacked*/ class _cArray*);
	void CopyTo(unsigned long);
	void CopyTo(unsigned char *);
	void ~_cArray();
	void DeleteResource();
	// calltype: NearC
	static unsigned short IsNameTaken(unsigned long, short);
};

// Type: /*unpacked*/ struct _cArray::FileAndType;
struct _cArray::FileAndType{ // not packed(0x8 bytes) TI: 0x3256
	/*+0x0*/   /*unpacked*/ class ResFile *file;
	/*+0x4*/   unsigned long type;
};

// Type: /*unpacked*/ class FlatResFile;
// VTABLE: COPTER_D 0x00593508
class FlatResFile : public FlatFile
{ // not packed(0x11c bytes) TI: 0x330e
protected:
	/*+0x110*/ /*unpacked*/ class ResMap *fMap;
	/*+0x114*/ long fError;
	/*+0x118*/ short _alignPad; // 0x2 bytes
public:
	void FlatResFile();
	virtual void ~FlatResFile() /* override */;
	void LoadResMap(void * __ptr32*, short *, long *);
	unsigned short FileEquals(/*unpacked*/ class FlatResFile*);
	virtual long Open(unsigned char *) /* override */;
	virtual long Open(char *) /* override */;
	long OpenFromName();
	virtual long Close() /* override */;
	short CountTypes();
	unsigned long GetIndType(short);
	short Count(unsigned long);
	void * __ptr32 GetByID(unsigned long, short, void (*)(void * __ptr32, long));
	void * __ptr32 GetByName(unsigned long, unsigned char *, void (*)(void * __ptr32, long));
	void * __ptr32 GetByIndex(unsigned long, short, void (*)(void * __ptr32, long));
	void GetName(void * __ptr32, unsigned char *);
	void GetID(void * __ptr32, short *);
	unsigned long GetResType(void * __ptr32);
	void Release(void * __ptr32);
	void Detach(void * __ptr32);
	void Load(void * __ptr32);
	long GetError();
	void Add(void * __ptr32, unsigned long, short, unsigned char *);
	void ExclusiveAdd(void * __ptr32, unsigned long, short, unsigned char *);
	void FindUniqueName(unsigned long, unsigned char *);
	short FindUniqueID(unsigned long);
	void Write(void * __ptr32);
	void Remove(void * __ptr32);
	void GetString(unsigned char *, short, short);
	// calltype: NearC
	static short CheckForLeaks();
};

// Type: /*unpacked*/ class FlatFile;
// VTABLE: COPTER_D 0x00593620
class FlatFile{ // not packed(0x110 bytes) TI: 0x32f4
	enum /* __unnamed */ {
		kMaxNameLen = 255,
	};
protected:
	/*+0x4*/   /*unpacked*/ class FlatFile *fNext;
	/*+0x8*/   unsigned char fName[256]; // 0x100 bytes
	/*+0x108*/ long fFileID;
	/*+0x10c*/ /*unpacked*/ struct _iobuf *fFile;
	long UniqueID();
private:
	static /*unpacked*/ class FlatFile *sList;
	static long sLastFileID;
	void Link();
	void Unlink();
	unsigned short Exclusive();
public:
	void FlatFile();
	virtual void ~FlatFile(); // vtable+0x0
	// calltype: NearC
	static /*unpacked*/ class FlatFile* FindByName(unsigned char *);
	unsigned short SameFile(/*unpacked*/ class FlatFile*);
	virtual long Open(unsigned char *); // vtable+0x4
	virtual long Open(char *); // vtable+0x8
	virtual long Close(); // vtable+0xc
	void OpenFromOtherFile(/*unpacked*/ class FlatFile*);
	long GetFileName(unsigned char *);
	unsigned short ValidFile();
	long ReadBlock(void * __ptr32, long *);
	long Read4(long *);
	long Read2(short *);
	long Read1(signed char *);
	long SetPos(long);
	long Advance(long);
	// calltype: NearC
	static short CheckForLeaks();
	long GetFileID();
	/*unpacked*/ struct _iobuf* GetFile();
};



// Contribution: 1:001664e0-001683d3 Module: 180, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x005674e0
unsigned short OpenFile(/*unpacked*/ class ResFile *pFile) {
// LINE 17:
	__asm        mov    ecx, pFile;
	__asm        call   FlatFile::ValidFile;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T65;
// LINE 18:
	__asm        mov    eax, pFile;
	__asm        add    eax, 8;
	__asm        push   eax;
	__asm        mov    eax, pFile;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pFile;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    near ptr 0x00567510;
// LINE 19:
	__asm        mov    ecx, pFile;
	__asm        call   FlatFile::ValidFile;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T5c;
// LINE 20:
	__asm        push   0x8C085;
	__asm        push   0x5BF754;
	__asm        push   0x14;
	__asm        push   0x5BF768;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 21:
_T5c:
	__asm        mov    ax, 1;
	__asm        jmp    _T6d;
// LINE 23:
_T65:
	__asm        xor    ax, ax;
	__asm        jmp    _T6d;
// LINE 24:
_T6d:
}

// FUNCTION: COPTER_D 0x00567552
void _cArray::FromDiskCreate(void * __ptr32 hArray, /*unpacked*/ class ResFile *pFile, long entrySize, void (*Swizzler)(void * __ptr32, long)) {
	/*bp-0x100*/ unsigned char tmpname[256]; // 0x100 bytes
	/*bp-0x104*/ /*unpacked*/ struct _cArray::Header *header;
	/*bp-0x108*/ signed char * data;
	/*bp-0x10c*/ unsigned short fileOpened;

// LINE 30:
	this->fFile = pFile;
// LINE 31:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        push   eax;
	__asm        call   OpenFile;
	__asm        add    esp, 4;
	__asm        mov    fileOpened, ax;
// LINE 33:
	this->fDataHandle = hArray;
// LINE 34:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::HGetSize;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1C], eax;
// LINE 37:
	__asm        jmp    _T7c;

	__asm        push   0x8C085;
	__asm        push   0x5BF788;
	__asm        push   0x25;
	__asm        push   0x5BF7A0;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 38:
_T7c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x24];
	__asm        call   FlatResFile::GetResType;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x28], eax;
// LINE 52:
	__asm        mov    eax, this;
	__asm        add    eax, 0x20;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x24];
	__asm        call   FlatResFile::GetID;
// LINE 55:
	__asm        lea    eax, tmpname[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x24];
	__asm        call   FlatResFile::GetName;
// LINE 56:
	__asm        xor    eax, eax;
	__asm        mov    al, tmpname[0];
	__asm        test   eax, eax;
	__asm        jg     _T107;

	__asm        push   0x8C085;
	__asm        push   0x5BF7C0;
	__asm        push   0x38;
	__asm        push   0x5BF7EC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 57:
_T107:
	__asm        xor    eax, eax;
	__asm        mov    al, tmpname[0];
	__asm        cmp    eax, 0xF;
	__asm        jle    _T11f;
// LINE 58:
	tmpname[0] = 0xf;
// LINE 61:
_T11f:
	__asm        push   0x10;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        push   eax;
	__asm        lea    eax, tmpname[0];
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 62:
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        push   eax;
	__asm        call   PStr2Long;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x4C], eax;
// LINE 63:
	__asm        mov    ecx, this;
	__asm        call   _cArray::CheckIntoTable;
// LINE 67:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::Stash;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xC], eax;
// LINE 68:
	header = this->fDataPtr;
// LINE 70:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x24];
	__asm        call   FlatResFile::Detach;
// LINE 71:
	__asm        test   reinterpret_cast<uint32_t>(fileOpened), 0xFFFF;
	__asm        je     _T1c9;
// LINE 72:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x24];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x24];
	__asm        call   dword ptr [edx+0xC];
// LINE 75:
_T1c9:
	__asm        mov    eax, header;
	__asm        movsx  eax, word ptr [eax];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x18], eax;
// LINE 76:
	__asm        mov    eax, this;
	__asm        add    eax, 0x18;
	__asm        push   eax;
	__asm        call   Swizzle2;
	__asm        add    esp, 4;
// LINE 77:
	__asm        mov    eax, this;
	__asm        mov    ecx, entrySize;
	__asm        cmp    [eax+0x18], ecx;
	__asm        je     _T218;

	__asm        push   0x8C085;
	__asm        push   0x5BF80C;
	__asm        push   0x4D;
	__asm        push   0x5BF848;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 79:
_T218:
	__asm        mov    eax, header;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14], eax;
// LINE 80:
	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        push   eax;
	__asm        call   Swizzle2;
	__asm        add    esp, 4;
// LINE 81:
	__asm        mov    eax, header;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x10], eax;
// LINE 82:
	__asm        mov    eax, this;
	__asm        add    eax, 0x10;
	__asm        push   eax;
	__asm        call   Swizzle2;
	__asm        add    esp, 4;
// LINE 84:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        lea    eax, [eax+ecx*4];
	__asm        add    eax, 8;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+0x1C];
	__asm        jbe    _T2b6;

	__asm        push   0x8C085;
	__asm        push   0x5BF868;
	__asm        push   0x54;
	__asm        push   0x5BF87C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 89:
_T2b6:
	__asm        mov    ecx, this;
	__asm        call   _cArray::SetXPointers;
// LINE 92:
	__asm        cmp    Swizzler, 0;
	__asm        je     _T3a2;
// LINE 94:
// Block start:
	/*bp-0x110*/ long ycount;
	/*bp-0x114*/ long xcount;
	__asm        mov    xcount, 0;
	__asm        jmp    _T2e0;
_T2da:
	xcount++;
_T2e0:
	__asm        mov    eax, this;
	__asm        mov    ecx, xcount;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _T3a2;
// LINE 95:
	__asm        mov    ycount, 0;
	__asm        jmp    _T30a;
_T304:
	ycount++;
_T30a:
	__asm        mov    eax, this;
	__asm        mov    ecx, ycount;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jle    _T39d;
// LINE 96:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        add    eax, 8;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+4];
	__asm        je     _T353;

	__asm        push   0x8C085;
	__asm        push   0x5BF89C;
	__asm        push   0x60;
	__asm        push   0x5BF8D4;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 97:
_T353:
	data = this->fData->;
// LINE 98:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        imul   eax, ycount;
	__asm        add    data, eax;
// LINE 99:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        call   Swizzler;
	__asm        add    esp, 8;
// LINE 100:
	__asm        jmp    _T304;
// LINE 101:
_T39d:
	__asm        jmp    _T2da;
// LINE 105:
// Block end:
_T3a2:
	__asm        jmp    near ptr 0x005678F9;
}

// FUNCTION: COPTER_D 0x00567900
void _cArray::BeginCreate(long entrySize, long xSize, long ySize, unsigned char * name, /*unpacked*/ class ResFile *pFile, unsigned long rType) {
// LINE 123:
	__asm        cmp    pFile, 0;
	__asm        jne    _T20;

	__asm        cmp    rType, 0;
	__asm        je     _T39;
_T20:
	__asm        push   0x8C085;
	__asm        push   0x5BF8F4;
	__asm        push   0x7B;
	__asm        push   0x5BF944;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 127:
_T39:
	this->fFile = pFile;
// LINE 128:
	this->fType = rType;
// LINE 129:
	this->fEntrySize = entrySize;
// LINE 132:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x10], 0xFFFFFFFF;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14], eax;
// LINE 133:
	__asm        cmp    name, 0;
	__asm        je     _Tab;
// LINE 135:
	__asm        push   0x10;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        push   eax;
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 136:
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        push   eax;
	__asm        call   PStr2Long;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x4C], eax;
// LINE 139:
	__asm        mov    ecx, this;
	__asm        call   _cArray::CheckIntoTable;
// LINE 141:
	__asm        jmp    _Tbc;
// LINE 143:
_Tab:
	this->fTinyName = 0x0;
// LINE 144:
	this->fName[0] = 0x0;
// LINE 147:
_Tbc:
	this->fResID = 0xffff;
// LINE 151:
	__asm        mov    eax, ySize;
	__asm        push   eax;
	__asm        mov    eax, xSize;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::SetSizeAndHeaders;
// LINE 153:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   _cArray::ClearBytes;
// LINE 154:
	__asm        jmp    near ptr 0x005679E4;
}

// FUNCTION: COPTER_D 0x005679eb
void _cArray::~_cArray() {

	this-><vftable> = 0x593738;
// LINE 160:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T40;
// LINE 162:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::HUnlock;
	__asm        add    esp, 4;
// LINE 163:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::HFree;
	__asm        add    esp, 4;
// LINE 167:
_T40:
	__asm        cmp    _cArray::sArrayTable, 0;
	__asm        je     _T126;
// LINE 169:
// Block start:
	/*bp-0x4*/   unsigned short bFound;
	/*bp-0x8*/   long cnt;
	bFound = 0x0;
// LINE 172:
	__asm        mov    cnt, 0;
	__asm        jmp    _T62;
_T5f:
	cnt++;
_T62:
	__asm        cmp    cnt, 0x400;
	__asm        jge    _T126;
// LINE 173:
	__asm        mov    eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        je     _Tb4;

	__asm        mov    eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        jne    _Tb4;

	__asm        push   0x8C085;
	__asm        push   0x5BF964;
	__asm        push   0xAD;
	__asm        push   0x5BF97C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 174:
_Tb4:
	__asm        mov    eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        je     _T121;

	__asm        mov    eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x4C];
	__asm        cmp    [eax+0x4C], ecx;
	__asm        jne    _T121;
// LINE 176:
	__asm        test   reinterpret_cast<uint32_t>(bFound), 0xFFFF;
	__asm        je     _T10b;

	__asm        push   0x8C085;
	__asm        push   0x5BF99C;
	__asm        push   0xB0;
	__asm        push   0x5BF9D8;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 179:
_T10b:
	_cArray::sArrayTable-> = 0x0;
// LINE 182:
	bFound = 0x1;
// LINE 187:
_T121:
	__asm        jmp    _T5f;
// LINE 190:
// Block end:
_T126:
	__asm        jmp    near ptr 0x00567B16;
}

// FUNCTION: COPTER_D 0x00567b1b
void _cArray::MakeTable() {
// LINE 195:
	__asm        cmp    _cArray::sArrayTable, 0;
	__asm        jne    _T82;
// LINE 196:
// Block start:
	/*bp-0x4*/   long count;
	__asm        push   0x1000;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    _cArray::sArrayTable, eax;
// LINE 197:
	__asm        cmp    _cArray::sArrayTable, 0;
	__asm        jne    _T51;

	__asm        push   0x8C085;
	__asm        push   0x5BF9F8;
	__asm        push   0xC5;
	__asm        push   0x5BFA18;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 198:
_T51:
	__asm        mov    count, 0;
	__asm        jmp    _T60;
_T5d:
	count++;
_T60:
	__asm        cmp    count, 0x400;
	__asm        jge    _T82;
// LINE 199:
	_cArray::sArrayTable-> = 0x0;
// LINE 200:
	__asm        jmp    _T5d;
// LINE 202:
// Block end:
_T82:
	__asm        jmp    near ptr 0x00567BA2;
}

// FUNCTION: COPTER_D 0x00567ba7
void _cArray::DeleteTable() {
// LINE 206:
	__asm        cmp    _cArray::sArrayTable, 0;
	__asm        je     _T30;
// LINE 207:
	__asm        mov    eax, _cArray::sArrayTable;
	__asm        mov    [ebp-4], eax;
	__asm        mov    eax, [ebp-4];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 208:
_T30:
	__asm        jmp    near ptr 0x00567BDC;
}

// FUNCTION: COPTER_D 0x00567be1
void _cArray::WriteToDisk() {
// LINE 246:
	__asm        jmp    near ptr 0x00567BF2;
}

// FUNCTION: COPTER_D 0x00567bf7
void _cArray::CheckIntoTable() {
// LINE 249:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        je     _T111;
// LINE 250:
// Block start:
	/*bp-0x4*/   long count;
	/*bp-0x8*/   long foundcount;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        jne    _T42;

	__asm        push   0x8C085;
	__asm        push   0x5BFA38;
	__asm        push   0xFA;
	__asm        push   0x5BFA60;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 252:
_T42:
	__asm        call   _cArray::MakeTable;
// LINE 254:
	foundcount = 0xffffffff;
// LINE 255:
	__asm        mov    count, 0;
	__asm        jmp    _T5d;
_T5a:
	count++;
_T5d:
	__asm        cmp    count, 0x400;
	__asm        jge    _Tdc;
// LINE 256:
	__asm        mov    eax, count;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        je     _Tb4;

	__asm        mov    eax, count;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x4C];
	__asm        cmp    [eax+0x4C], ecx;
	__asm        jne    _Tb4;

	__asm        push   0x8C085;
	__asm        push   0x5BFA80;
	__asm        push   0x100;
	__asm        push   0x5BFAA0;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 257:
_Tb4:
	__asm        cmp    foundcount, 0xFFFFFFFF;
	__asm        jne    _Td7;

	__asm        mov    eax, count;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        jne    _Td7;
// LINE 258:
	foundcount = count;
// LINE 259:
_Td7:
	__asm        jmp    _T5a;
// LINE 261:
_Tdc:
	__asm        cmp    foundcount, 0xFFFFFFFF;
	__asm        jne    _T102;

	__asm        push   0x8C085;
	__asm        push   0x5BFAC0;
	__asm        push   0x105;
	__asm        push   0x5BFAF4;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 262:
_T102:
	_cArray::sArrayTable-> = this;
// LINE 264:
// Block end:
_T111:
	__asm        jmp    near ptr 0x00567D0D;
}

// FUNCTION: COPTER_D 0x00567d12
void _cArray::FillHeader() {
	/*bp-0x4*/   /*unpacked*/ struct _cArray::Header *header;
	/*bp-0x8*/   unsigned long debugsize;

// LINE 305:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::HGetSize;
	__asm        add    esp, 4;
	__asm        mov    debugsize, eax;
// LINE 306:
	__asm        mov    eax, this;
	__asm        mov    ecx, debugsize;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jbe    _T49;

	__asm        push   0x8C085;
	__asm        push   0x5BFB14;
	__asm        push   0x132;
	__asm        push   0x5BFB30;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 308:
_T49:
	__asm        jmp    _T6a;

	__asm        push   0x8C085;
	__asm        push   0x5BFB50;
	__asm        push   0x134;
	__asm        push   0x5BFB68;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 309:
_T6a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        lea    eax, [eax+ecx*4];
	__asm        add    eax, 8;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+0x1C];
	__asm        je     _Tb2;

	__asm        push   0x8C085;
	__asm        push   0x5BFB88;
	__asm        push   0x135;
	__asm        push   0x5BFBA8;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 310:
_Tb2:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::HIsLocked;
	__asm        add    esp, 4;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _Te8;

	__asm        push   0x8C085;
	__asm        push   0x5BFBC8;
	__asm        push   0x136;
	__asm        push   0x5BFBDC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 312:
_Te8:
	header = this->fDataPtr;
// LINE 313:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ecx, header;
	__asm        mov    [ecx+2], ax;
// LINE 314:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, header;
	__asm        mov    [ecx+4], ax;
// LINE 315:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, header;
	__asm        mov    [ecx], ax;
// LINE 316:
	__asm        jmp    near ptr 0x00567E2E;
}

// FUNCTION: COPTER_D 0x00567e33
void _cArray::SetSizeAndHeaders(long newxSize, long newySize) {
// LINE 320:
	__asm        mov    eax, newySize;
	__asm        push   eax;
	__asm        mov    eax, newxSize;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::SetSize;
// LINE 321:
	__asm        mov    ecx, this;
	__asm        call   _cArray::FillHeader;
// LINE 322:
	__asm        mov    ecx, this;
	__asm        call   _cArray::SetXPointers;
// LINE 323:
	__asm        jmp    near ptr 0x00567E64;
}

// FUNCTION: COPTER_D 0x00567e6b
void _cArray::ClearBytes(signed char zeropad) {
	/*bp-0x4*/   signed char * fillPtr;
	/*bp-0x8*/   long cnt;
	/*bp-0xc*/   unsigned char * end;
	/*bp-0x10*/  long numBytes;
	/*bp-0x14*/  unsigned char * begin;
	/*bp-0x18*/  unsigned long debugsize;
	/*bp-0x1c*/  unsigned char * writeplace;

// LINE 327:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T26;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        jne    _T2b;
// LINE 329:
_T26:
	__asm        jmp    _T174;
// LINE 334:
_T2b:
	begin = this->fDataPtr;
// LINE 335:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::HGetSize;
	__asm        add    esp, 4;
	__asm        mov    debugsize, eax;
// LINE 336:
	__asm        mov    eax, this;
	__asm        mov    ecx, debugsize;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jbe    _T71;

	__asm        push   0x8C085;
	__asm        push   0x5BFBFC;
	__asm        push   0x150;
	__asm        push   0x5BFC04;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 337:
_T71:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0xC];
	__asm        mov    end, eax;
// LINE 340:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        shl    eax, 2;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        mov    fillPtr, eax;
// LINE 341:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, fillPtr;
	__asm        cmp    [eax], ecx;
	__asm        je     _Tbf;

	__asm        push   0x8C085;
	__asm        push   0x5BFC24;
	__asm        push   0x155;
	__asm        push   0x5BFC58;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 342:
_Tbf:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        mov    numBytes, eax;
// LINE 343:
	__asm        cmp    numBytes, 0;
	__asm        jle    _Ted;

	__asm        cmp    numBytes, 0x7A1200;
	__asm        jl     _T109;
_Ted:
	__asm        push   0x8C085;
	__asm        push   0x5BFC78;
	__asm        push   0x157;
	__asm        push   0x5BFC9C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 344:
_T109:
	__asm        mov    cnt, 0;
	__asm        jmp    _T118;
_T115:
	cnt++;
_T118:
	__asm        mov    eax, cnt;
	__asm        cmp    numBytes, eax;
	__asm        jle    _T16f;
// LINE 346:
	writeplace = fillPtr;
// LINE 347:
	__asm        mov    eax, begin;
	__asm        cmp    writeplace, eax;
	__asm        jb     _T143;

	__asm        mov    eax, writeplace;
	__asm        inc    eax;
	__asm        cmp    eax, end;
	__asm        jbe    _T15f;
// LINE 348:
_T143:
	__asm        push   0x8C085;
	__asm        push   0x5BFCBC;
	__asm        push   0x15C;
	__asm        push   0x5BFCD8;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 350:
_T15f:
	fillPtr[0] = zeropad;
// LINE 351:
	fillPtr++;
// LINE 352:
	__asm        jmp    _T115;
// LINE 354:
_T16f:
	__asm        jmp    _T174;
_T174:
}

// FUNCTION: COPTER_D 0x00567fe6
short _cArray::InsertRow(short afterwhich) {
	/*bp-0x4*/   long oldysize;
	/*bp-0x8*/   long oldxsize;
	/*bp-0xc*/   short beforewhich;

// LINE 360:
	oldxsize = this->fxSize;
// LINE 361:
	oldysize = this->fySize;
// LINE 363:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        inc    eax;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::Resize;
// LINE 365:
	__asm        mov    eax, this;
	__asm        mov    ecx, oldxsize;
	__asm        inc    ecx;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jne    _T56;

	__asm        mov    eax, this;
	__asm        mov    ecx, oldysize;
	__asm        cmp    [eax+0x10], ecx;
	__asm        je     _T72;
_T56:
	__asm        push   0x8C085;
	__asm        push   0x5BFCF8;
	__asm        push   0x16D;
	__asm        push   0x5BFD00;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 367:
_T72:
	__asm        movsx  eax, afterwhich;
	__asm        inc    eax;
	__asm        mov    beforewhich, ax;
// LINE 368:
	__asm        mov    eax, this;
	__asm        movsx  ecx, beforewhich;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _T132;
// LINE 369:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T132;
// LINE 371:
// Block start:
	/*bp-0x10*/  short count;
	/*bp-0x14*/  unsigned char * moveto;
	/*bp-0x18*/  unsigned char * movefrom;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        dec    eax;
	__asm        mov    count, ax;
	__asm        jmp    _Tac;
_Ta8:
	count--;
_Tac:
	__asm        movsx  eax, count;
	__asm        movsx  ecx, beforewhich;
	__asm        cmp    eax, ecx;
	__asm        jle    _T132;
// LINE 373:
	__asm        jmp    near ptr 0x005680A7;

	__asm        movsx  eax, count;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    eax, [ecx+eax*4-4];
	__asm        mov    movefrom, eax;
// LINE 374:
	__asm        jmp    near ptr 0x005680BD;

	moveto = this->fData->;
// LINE 375:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, moveto;
	__asm        push   eax;
	__asm        mov    eax, movefrom;
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 378:
	__asm        movsx  eax, count;
	__asm        test   eax, eax;
	__asm        jge    _T12d;

	__asm        push   0x8C085;
	__asm        push   0x5BFD20;
	__asm        push   0x17A;
	__asm        push   0x5BFD28;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 379:
_T12d:
	__asm        jmp    _Ta8;
// LINE 382:
// Block end:
_T132:
	__asm        mov    ax, beforewhich;
	__asm        jmp    near ptr 0x00568121;
// LINE 383:
}

// FUNCTION: COPTER_D 0x00568128
short _cArray::InsertColumn(short afterwhich) {
	/*bp-0x4*/   long oldysize;
	/*bp-0x8*/   long oldxsize;
	/*bp-0xc*/   short beforewhich;

// LINE 388:
	oldxsize = this->fxSize;
// LINE 389:
	oldysize = this->fySize;
// LINE 391:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        inc    eax;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::Resize;
// LINE 392:
	__asm        mov    eax, this;
	__asm        mov    ecx, oldxsize;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jne    _T56;

	__asm        mov    eax, this;
	__asm        mov    ecx, oldysize;
	__asm        inc    ecx;
	__asm        cmp    [eax+0x10], ecx;
	__asm        je     _T72;
_T56:
	__asm        push   0x8C085;
	__asm        push   0x5BFD48;
	__asm        push   0x188;
	__asm        push   0x5BFD50;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 394:
_T72:
	__asm        movsx  eax, afterwhich;
	__asm        inc    eax;
	__asm        mov    beforewhich, ax;
// LINE 395:
	__asm        mov    eax, this;
	__asm        movsx  ecx, beforewhich;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jle    _T15c;
// LINE 397:
// Block start:
	/*bp-0x10*/  short xcount;
	/*bp-0x14*/  unsigned char * moveto;
	/*bp-0x18*/  unsigned char * movefrom;
	__asm        mov    xcount, 0;
	__asm        jmp    _T9a;
_T96:
	xcount++;
_T9a:
	__asm        mov    eax, this;
	__asm        movsx  ecx, xcount;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _T15c;
// LINE 398:
// Block start:
	/*bp-0x1c*/  short ycount;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        dec    eax;
	__asm        mov    ycount, ax;
	__asm        jmp    _Tbe;
_Tba:
	ycount--;
_Tbe:
	__asm        movsx  eax, ycount;
	__asm        movsx  ecx, beforewhich;
	__asm        cmp    eax, ecx;
	__asm        jle    _T157;
// LINE 399:
	__asm        movsx  eax, ycount;
	__asm        test   eax, eax;
	__asm        jge    _Tf6;

	__asm        push   0x8C085;
	__asm        push   0x5BFD70;
	__asm        push   0x18F;
	__asm        push   0x5BFD78;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 400:
_Tf6:
	__asm        jmp    near ptr 0x00568223;

	__asm        movsx  eax, ycount;
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        movsx  ecx, xcount;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+4];
	__asm        add    eax, [edx+ecx*4];
	__asm        mov    movefrom, eax;
// LINE 401:
	__asm        jmp    near ptr 0x00568244;

	__asm        movsx  eax, xcount;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x18];
	__asm        movsx  edx, ycount;
	__asm        imul   ecx, edx;
	__asm        add    eax, ecx;
	__asm        mov    moveto, eax;
// LINE 402:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, moveto;
	__asm        push   eax;
	__asm        mov    eax, movefrom;
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 403:
	__asm        jmp    _Tba;
// LINE 404:
// Block end:
_T157:
	__asm        jmp    _T96;
// LINE 406:
// Block end:
_T15c:
	__asm        mov    ax, beforewhich;
	__asm        jmp    near ptr 0x0056828D;
// LINE 407:
}

// FUNCTION: COPTER_D 0x00568294
short _cArray::DeleteRow(short which) {
	/*bp-0x4*/   long oldysize;
	/*bp-0x8*/   long oldxsize;
	/*bp-0xc*/   unsigned char * moveto;
	/*bp-0x10*/  unsigned char * movefrom;

// LINE 413:
	oldxsize = this->fxSize;
// LINE 414:
	oldysize = this->fySize;
// LINE 415:
	__asm        cmp    oldxsize, 0;
	__asm        jg     _T44;

	__asm        push   0x8C085;
	__asm        push   0x5BFD98;
	__asm        push   0x19F;
	__asm        push   0x5BFDA8;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 417:
_T44:
	__asm        mov    eax, this;
	__asm        movsx  ecx, which;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _T60;

	__asm        movsx  eax, which;
	__asm        test   eax, eax;
	__asm        jge    _T7c;
_T60:
	__asm        push   0x8C085;
	__asm        push   0x5BFDC8;
	__asm        push   0x1A1;
	__asm        push   0x5BFDDC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 418:
_T7c:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _Tfb;
// LINE 419:
// Block start:
	/*bp-0x14*/  short count;
	__asm        mov    ax, which;
	__asm        mov    count, ax;
	__asm        jmp    _T9a;
_T96:
	count++;
_T9a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        dec    eax;
	__asm        movsx  ecx, count;
	__asm        cmp    eax, ecx;
	__asm        jle    _Tfb;
// LINE 420:
	__asm        jmp    near ptr 0x00568346;

	__asm        movsx  eax, count;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    eax, [ecx+eax*4+4];
	__asm        mov    movefrom, eax;
// LINE 421:
	__asm        jmp    near ptr 0x0056835C;

	moveto = this->fData->;
// LINE 422:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, moveto;
	__asm        push   eax;
	__asm        mov    eax, movefrom;
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 423:
	__asm        jmp    _T96;
// LINE 426:
// Block end:
_Tfb:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        dec    eax;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::Resize;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T13b;

	__asm        push   0x8C085;
	__asm        push   0x5BFDFC;
	__asm        push   0x1AA;
	__asm        push   0x5BFE04;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 427:
_T13b:
	__asm        mov    eax, this;
	__asm        mov    ecx, oldysize;
	__asm        cmp    [eax+0x10], ecx;
	__asm        je     _T166;

	__asm        push   0x8C085;
	__asm        push   0x5BFE24;
	__asm        push   0x1AB;
	__asm        push   0x5BFE2C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 428:
_T166:
	__asm        mov    eax, this;
	__asm        mov    ecx, oldxsize;
	__asm        dec    ecx;
	__asm        cmp    [eax+0x14], ecx;
	__asm        je     _T192;

	__asm        push   0x8C085;
	__asm        push   0x5BFE4C;
	__asm        push   0x1AC;
	__asm        push   0x5BFE54;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 429:
_T192:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x14];
	__asm        jmp    near ptr 0x00568432;
// LINE 430:
}

// FUNCTION: COPTER_D 0x00568439
short _cArray::DeleteColumn(short which) {
	/*bp-0x4*/   long oldysize;
	/*bp-0x8*/   unsigned char * nextone;
	/*bp-0xc*/   short xcount;
	/*bp-0x10*/  long oldxsize;
	/*bp-0x14*/  unsigned char * thisone;

// LINE 436:
	oldysize = this->fySize;
// LINE 437:
	oldxsize = this->fxSize;
// LINE 438:
	__asm        cmp    oldysize, 0;
	__asm        jg     _T44;

	__asm        push   0x8C085;
	__asm        push   0x5BFE74;
	__asm        push   0x1B6;
	__asm        push   0x5BFE84;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 440:
_T44:
	__asm        movsx  eax, which;
	__asm        test   eax, eax;
	__asm        jl     _T60;

	__asm        mov    eax, this;
	__asm        movsx  ecx, which;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jg     _T7c;
_T60:
	__asm        push   0x8C085;
	__asm        push   0x5BFEA4;
	__asm        push   0x1B8;
	__asm        push   0x5BFEBC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 441:
_T7c:
	__asm        mov    xcount, 0;
	__asm        jmp    _T8b;
_T87:
	xcount++;
_T8b:
	__asm        mov    eax, this;
	__asm        movsx  ecx, xcount;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _T1cc;
// LINE 442:
// Block start:
	/*bp-0x18*/  short ycount;
	__asm        mov    ax, which;
	__asm        mov    ycount, ax;
	__asm        jmp    _Tac;
_Ta8:
	ycount++;
_Tac:
	__asm        mov    eax, this;
	__asm        movsx  ecx, ycount;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jle    _T12e;
// LINE 443:
	__asm        movsx  eax, ycount;
	__asm        inc    eax;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+0x10];
	__asm        jge    _T129;
// LINE 444:
	__asm        jmp    near ptr 0x0056850B;

	__asm        movsx  eax, xcount;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x18];
	__asm        movsx  edx, ycount;
	__asm        imul   ecx, edx;
	__asm        add    eax, ecx;
	__asm        mov    thisone, eax;
// LINE 445:
	__asm        jmp    near ptr 0x0056852F;

	__asm        movsx  eax, ycount;
	__asm        inc    eax;
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        movsx  ecx, xcount;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+4];
	__asm        add    eax, [edx+ecx*4];
	__asm        mov    nextone, eax;
// LINE 446:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, thisone;
	__asm        push   eax;
	__asm        mov    eax, nextone;
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 448:
_T129:
	__asm        jmp    _Ta8;
// LINE 450:
_T12e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        dec    eax;
	__asm        movsx  ecx, which;
	__asm        cmp    eax, ecx;
	__asm        jle    _T1c7;
// LINE 451:
// Block start:
	/*bp-0x1c*/  unsigned char * nextToLast;
	/*bp-0x20*/  unsigned char * lastPart;
	__asm        jmp    near ptr 0x0056857F;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        movsx  ecx, xcount;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+4];
	__asm        add    eax, [edx+ecx*4];
	__asm        mov    lastPart, eax;
// LINE 452:
	__asm        jmp    near ptr 0x005685A2;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        sub    eax, 2;
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        movsx  ecx, xcount;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+4];
	__asm        add    eax, [edx+ecx*4];
	__asm        mov    nextToLast, eax;
// LINE 453:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, lastPart;
	__asm        push   eax;
	__asm        mov    eax, nextToLast;
	__asm        push   eax;
	__asm        call   Memory::BlockCompare;
	__asm        add    esp, 0xC;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T1c7;

	__asm        push   0x8C085;
	__asm        push   0x5BFEDC;
	__asm        push   0x1C5;
	__asm        push   0x5BFEE4;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 456:
// Block end:
// Block end:
_T1c7:
	__asm        jmp    _T87;
// LINE 457:
_T1cc:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        dec    eax;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::Resize;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T20c;

	__asm        push   0x8C085;
	__asm        push   0x5BFF04;
	__asm        push   0x1C9;
	__asm        push   0x5BFF0C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 458:
_T20c:
	__asm        mov    eax, this;
	__asm        mov    ecx, oldysize;
	__asm        dec    ecx;
	__asm        cmp    [eax+0x10], ecx;
	__asm        je     _T238;

	__asm        push   0x8C085;
	__asm        push   0x5BFF2C;
	__asm        push   0x1CA;
	__asm        push   0x5BFF34;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 459:
_T238:
	__asm        mov    eax, this;
	__asm        mov    ecx, oldxsize;
	__asm        cmp    [eax+0x14], ecx;
	__asm        je     _T263;

	__asm        push   0x8C085;
	__asm        push   0x5BFF54;
	__asm        push   0x1CB;
	__asm        push   0x5BFF5C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 460:
_T263:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x10];
	__asm        jmp    near ptr 0x005686A8;
// LINE 461:
}

// FUNCTION: COPTER_D 0x005686af
unsigned short _cArray::Resize(long newxSize, long newySize, signed char zeropad) {
	/*bp-0x10*/  unsigned char * dest;
	/*bp-0x14*/  long xcnt;
	/*bp-0x64*/  /*unpacked*/ class _cArray temp; // 0x50 bytes
	/*bp-0x68*/  long ycnt;
	/*bp-0x6c*/  unsigned char * src;

	// Function registers exception cleanup function at 0x0056885e

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    [ebp-0x74], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    [ebp-0x7C], eax;
// LINE 468:
	__asm        mov    temp<vftable>, 0x593738;
	__asm        jmp    _T4d;

	__asm        call   _cArray::MakeTable;
_T4d:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, [ebp-0x74];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x78];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        push   eax;
	__asm        lea    ecx, temp<vftable>;
	__asm        call   _cArray::BeginCreate;
	__asm        jmp    near ptr 0x0056871B;

	__asm        mov    dword ptr [ebp-4], 0;
// LINE 469:
	__asm        lea    eax, temp<vftable>;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::CopyTo;
// LINE 471:
	__asm        mov    eax, newySize;
	__asm        push   eax;
	__asm        mov    eax, newxSize;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::SetSizeAndHeaders;
// LINE 472:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        add    eax, 8;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+4];
	__asm        je     _Tc0;

	__asm        push   0x8C085;
	__asm        push   0x5BFF7C;
	__asm        push   0x1D8;
	__asm        push   0x5BFFB4;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 474:
_Tc0:
	__asm        mov    eax, reinterpret_cast<uint32_t>(zeropad);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::ClearBytes;
// LINE 477:
	__asm        mov    xcnt, 0;
	__asm        jmp    _Tdb;
_Td8:
	xcnt++;
_Tdb:
	__asm        mov    eax, this;
	__asm        mov    ecx, xcnt;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _T18b;
// LINE 478:
	__asm        mov    eax, xcnt;
	__asm        cmp    temp.fxSize, eax;
	__asm        jle    _T186;
// LINE 479:
	__asm        mov    ycnt, 0;
	__asm        jmp    _T105;
_T102:
	ycnt++;
_T105:
	__asm        mov    eax, this;
	__asm        mov    ecx, ycnt;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jle    _T186;
// LINE 480:
	__asm        mov    eax, ycnt;
	__asm        cmp    temp.fySize, eax;
	__asm        jle    _T17c;
// LINE 481:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, xcnt;
	__asm        mov    eax, [eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x18];
	__asm        imul   ecx, ycnt;
	__asm        add    eax, ecx;
	__asm        mov    dest, eax;
// LINE 482:
	__asm        mov    eax, temp.fData;
	__asm        mov    ecx, xcnt;
	__asm        mov    eax, [eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x18];
	__asm        imul   ecx, ycnt;
	__asm        add    eax, ecx;
	__asm        mov    src, eax;
// LINE 483:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T177;
// LINE 484:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, dest;
	__asm        push   eax;
	__asm        mov    eax, src;
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 485:
_T177:
	__asm        jmp    _T181;
// LINE 486:
_T17c:
	__asm        jmp    _T186;
// LINE 487:
_T181:
	__asm        jmp    _T102;
// LINE 488:
_T186:
	__asm        jmp    _Td8;
// LINE 489:
_T18b:
	__asm        mov    word ptr [ebp-0x70], 1;
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        call   _L27257;
	__asm        mov    ax, [ebp-0x70];
	__asm        jmp    _T1b9;
// LINE 490:
_L27257:
	__asm        lea    ecx, temp<vftable>;
	__asm        call   _cArray::~_cArray;
	__asm        ret;
_L27256:
	__asm        mov    eax, 0x5961E0;
	__asm        jmp    near ptr 0x0056F590;
_T1b9:
	__asm        mov    ecx, [ebp-0xC];
	__asm        mov    fs:[0], ecx;
}

// FUNCTION: COPTER_D 0x00568879
unsigned short _cArray::SetSize(long newxSize, long newySize) {
// LINE 494:
	__asm        mov    eax, this;
	__asm        mov    ecx, newySize;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T33;

	__asm        mov    eax, this;
	__asm        mov    ecx, newxSize;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jne    _T33;

	__asm        mov    ax, 1;
	__asm        jmp    _T14c;
// LINE 496:
_T33:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0xFFFFFFFF;
	__asm        je     _T69;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0xFFFFFFFF;
	__asm        je     _T69;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T69;
// LINE 498:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::HFree;
	__asm        add    esp, 4;
// LINE 501:
_T69:
	__asm        mov    eax, newySize;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x10], eax;
	__asm        mov    eax, newxSize;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14], eax;
// LINE 503:
	__asm        jmp    _T9c;

	__asm        push   0x8C085;
	__asm        push   0x5BFFD4;
	__asm        push   0x1F7;
	__asm        push   0x5BFFEC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 504:
_T9c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x14];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        lea    eax, [eax+ecx*4];
	__asm        add    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1C], eax;
// LINE 505:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1C], 0x7A1200;
	__asm        jb     _Tee;

	__asm        push   0x8C085;
	__asm        push   0x5C000C;
	__asm        push   0x1F9;
	__asm        push   0x5C0024;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 506:
_Tee:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   Memory::HAlloc;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
// LINE 507:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jne    _T12e;

	__asm        push   0x8C085;
	__asm        push   0x5C0044;
	__asm        push   0x1FB;
	__asm        push   0x5C0054;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 509:
_T12e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   Memory::Stash;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xC], eax;
// LINE 511:
	__asm        mov    ax, 1;
	__asm        jmp    _T14c;
// LINE 512:
_T14c:
}

// FUNCTION: COPTER_D 0x005689cc
void _cArray::SetXPointers() {
	/*bp-0x4*/   short count;

// LINE 517:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        add    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+4], eax;
// LINE 519:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        jne    _T2d;

	__asm        jmp    _T97;
// LINE 521:
_T2d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        shl    eax, 2;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
// LINE 523:
	__asm        mov    count, 1;
	__asm        jmp    _T53;
_T4f:
	count++;
_T53:
	__asm        mov    eax, this;
	__asm        movsx  ecx, count;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _T92;
// LINE 524:
	__asm        movsx  eax, count;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    eax, [ecx+eax*4-4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x18];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0x10];
	__asm        add    eax, ecx;
	__asm        movsx  ecx, count;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+4];
	__asm        mov    [edx+ecx*4], eax;
// LINE 526:
	__asm        jmp    _T4f;
// LINE 527:
_T92:
	__asm        jmp    _T97;
_T97:
}

// FUNCTION: COPTER_D 0x00568a68
void _cArray::CopyFrom(unsigned char * fromName) {
// LINE 538:
	__asm        mov    eax, fromName;
	__asm        push   eax;
	__asm        call   PStr2Long;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::CopyFrom;
// LINE 539:
	__asm        jmp    near ptr 0x00568A8E;
}

// FUNCTION: COPTER_D 0x00568a95
void _cArray::CopyFrom(unsigned long oldname) {
	/*bp-0x4*/   /*unpacked*/ class _cArray *src;

// LINE 543:
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, oldname;
	__asm        push   eax;
	__asm        call   _cArray::GetArray;
	__asm        add    esp, 8;
	__asm        mov    src, eax;
// LINE 544:
	__asm        mov    eax, src;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::CopyFrom;
// LINE 545:
	__asm        jmp    near ptr 0x00568AC3;
}

// FUNCTION: COPTER_D 0x00568aca
void _cArray::CopyFrom(/*unpacked*/ class _cArray *src) {
	/*bp-0x4*/   long howmuch;

// LINE 549:
	__asm        cmp    src, 0;
	__asm        jne    _T32;

	__asm        push   0x8C085;
	__asm        push   0x5C0074;
	__asm        push   0x225;
	__asm        push   0x5C0098;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 550:
_T32:
	__asm        mov    eax, this;
	__asm        mov    ecx, src;
	__asm        mov    ecx, [ecx+0x18];
	__asm        cmp    [eax+0x18], ecx;
	__asm        je     _T60;

	__asm        push   0x8C085;
	__asm        push   0x5C00B8;
	__asm        push   0x226;
	__asm        push   0x5C00E0;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 551:
_T60:
	__asm        mov    eax, this;
	__asm        mov    ecx, src;
	__asm        mov    ecx, [ecx+0x14];
	__asm        cmp    [eax+0x14], ecx;
	__asm        jne    _T84;

	__asm        mov    eax, this;
	__asm        mov    ecx, src;
	__asm        mov    ecx, [ecx+0x10];
	__asm        cmp    [eax+0x10], ecx;
	__asm        je     _Ta0;
_T84:
	__asm        push   0x8C085;
	__asm        push   0x5C0100;
	__asm        push   0x227;
	__asm        push   0x5C0124;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 553:
_Ta0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        mov    howmuch, eax;
// LINE 554:
	__asm        cmp    howmuch, 0;
	__asm        jl     _Tce;

	__asm        cmp    howmuch, 0x7A1200;
	__asm        jl     _Tea;
_Tce:
	__asm        push   0x8C085;
	__asm        push   0x5C0144;
	__asm        push   0x22A;
	__asm        push   0x5C0160;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 555:
_Tea:
	__asm        cmp    howmuch, 0;
	__asm        je     _T112;
// LINE 556:
	__asm        mov    eax, howmuch;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, src;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 557:
_T112:
	__asm        jmp    near ptr 0x00568BE1;
}

// FUNCTION: COPTER_D 0x00568be8
void _cArray::CopyTo(/*unpacked*/ class _cArray *dest) {
	/*bp-0x4*/   long howmuch;

// LINE 569:
	__asm        cmp    dest, 0;
	__asm        jne    _T32;

	__asm        push   0x8C085;
	__asm        push   0x5C0180;
	__asm        push   0x239;
	__asm        push   0x5C01A4;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 570:
_T32:
	__asm        mov    eax, dest;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x18];
	__asm        cmp    [eax+0x18], ecx;
	__asm        je     _T60;

	__asm        push   0x8C085;
	__asm        push   0x5C01C4;
	__asm        push   0x23A;
	__asm        push   0x5C01EC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 571:
_T60:
	__asm        mov    eax, this;
	__asm        mov    ecx, dest;
	__asm        mov    ecx, [ecx+0x14];
	__asm        cmp    [eax+0x14], ecx;
	__asm        jne    _T84;

	__asm        mov    eax, this;
	__asm        mov    ecx, dest;
	__asm        mov    ecx, [ecx+0x10];
	__asm        cmp    [eax+0x10], ecx;
	__asm        je     _Ta0;
_T84:
	__asm        push   0x8C085;
	__asm        push   0x5C020C;
	__asm        push   0x23B;
	__asm        push   0x5C022C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 573:
_Ta0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x10];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x18];
	__asm        mov    howmuch, eax;
// LINE 574:
	__asm        cmp    howmuch, 0;
	__asm        jl     _Tce;

	__asm        cmp    howmuch, 0x7A1200;
	__asm        jl     _Tea;
_Tce:
	__asm        push   0x8C085;
	__asm        push   0x5C024C;
	__asm        push   0x23E;
	__asm        push   0x5C0278;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 575:
_Tea:
	__asm        cmp    howmuch, 0;
	__asm        je     _T112;
// LINE 576:
	__asm        mov    eax, howmuch;
	__asm        push   eax;
	__asm        mov    eax, dest;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 577:
_T112:
	__asm        jmp    near ptr 0x00568CFF;
}

// FUNCTION: COPTER_D 0x00568d06
void _cArray::CopyTo(unsigned long oldname) {
	/*bp-0x4*/   /*unpacked*/ class _cArray *dest;

// LINE 581:
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, oldname;
	__asm        push   eax;
	__asm        call   _cArray::GetArray;
	__asm        add    esp, 8;
	__asm        mov    dest, eax;
// LINE 582:
	__asm        mov    eax, dest;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::CopyTo;
// LINE 583:
	__asm        jmp    near ptr 0x00568D34;
}

// FUNCTION: COPTER_D 0x00568d3b
void _cArray::CopyTo(unsigned char * toName) {
// LINE 587:
	__asm        mov    eax, toName;
	__asm        push   eax;
	__asm        call   PStr2Long;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   _cArray::CopyTo;
// LINE 588:
	__asm        jmp    near ptr 0x00568D61;
}

// FUNCTION: COPTER_D 0x00568d68
void _cArray::GetName(unsigned char * name) {
// LINE 592:
	__asm        push   0x10;
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        push   eax;
	__asm        call   Memory::BlockMove;
	__asm        add    esp, 0xC;
// LINE 593:
	__asm        jmp    near ptr 0x00568D8E;
}

// FUNCTION: COPTER_D 0x00568d95
unsigned long _cArray::GetName() {
// LINE 597:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        jmp    near ptr 0x00568DAC;
// LINE 598:
}

// FUNCTION: COPTER_D 0x00568db1
/*unpacked*/ class _cArray* _cArray::GetArray(unsigned long tinyname, short numChars) {
	/*bp-0x4*/   short cnt;

// LINE 612:
	__asm        call   _cArray::MakeTable;
// LINE 613:
	__asm        mov    cnt, 0;
	__asm        jmp    _T1d;
_T19:
	cnt++;
_T1d:
	__asm        movsx  eax, cnt;
	__asm        cmp    eax, 0x400;
	__asm        jge    _T168;
// LINE 614:
	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        je     _T73;

	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        jne    _T73;

	__asm        push   0x8C085;
	__asm        push   0x5C0298;
	__asm        push   0x266;
	__asm        push   0x5C02B0;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 615:
_T73:
	__asm        movsx  eax, numChars;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _Tc4;

	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        je     _Tc4;

	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    ecx, tinyname;
	__asm        cmp    [eax+0x4C], ecx;
	__asm        jne    _Tc4;
// LINE 616:
	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        jmp    _T16f;
// LINE 618:
	__asm        jmp    _T163;
_Tc4:
	__asm        movsx  eax, numChars;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T163;

	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        je     _T163;
// LINE 619:
// Block start:
	/*bp-0x8*/   short shiftnum;
	__asm        mov    eax, 4;
	__asm        movsx  ecx, numChars;
	__asm        sub    eax, ecx;
	__asm        shl    eax, 3;
	__asm        mov    shiftnum, ax;
// LINE 620:
	__asm        movsx  eax, shiftnum;
	__asm        test   eax, eax;
	__asm        jl     _T110;

	__asm        movsx  eax, shiftnum;
	__asm        cmp    eax, 0x20;
	__asm        jb     _T12c;
_T110:
	__asm        push   0x8C085;
	__asm        push   0x5C02D0;
	__asm        push   0x26C;
	__asm        push   0x5C02F8;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 621:
_T12c:
	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    cl, reinterpret_cast<uint8_t>(shiftnum);
	__asm        shr    eax, cl;
	__asm        mov    edx, tinyname;
	__asm        mov    cl, reinterpret_cast<uint8_t>(shiftnum);
	__asm        shr    edx, cl;
	__asm        cmp    eax, edx;
	__asm        jne    _T163;
// LINE 622:
	__asm        movsx  eax, cnt;
	__asm        mov    ecx, _cArray::sArrayTable;
	__asm        mov    eax, [ecx+eax*4];
	__asm        jmp    _T16f;
// LINE 624:
// Block end:
_T163:
	__asm        jmp    _T19;
// LINE 625:
_T168:
	__asm        xor    eax, eax;
	__asm        jmp    _T16f;
// LINE 626:
_T16f:
}

// FUNCTION: COPTER_D 0x00568f25
/*unpacked*/ class _cArray* _cArray::GetArrayByType(unsigned long rType, short which) {
	/*bp-0x4*/   /*unpacked*/ class _cArray *arr;
	/*bp-0x8*/   short count;
	/*bp-0xc*/   short found;

// LINE 630:
	__asm        call   _cArray::MakeTable;
// LINE 631:
	found = 0x0;
// LINE 633:
	__asm        mov    count, 0;
	__asm        jmp    _T23;
_T1f:
	count++;
_T23:
	__asm        movsx  eax, count;
	__asm        cmp    eax, 0x400;
	__asm        jge    _T77;
// LINE 634:
	arr = _cArray::sArrayTable->;
// LINE 635:
	__asm        mov    eax, arr;
	__asm        mov    ecx, rType;
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T72;
// LINE 636:
	__asm        movsx  eax, found;
	__asm        movsx  ecx, which;
	__asm        cmp    eax, ecx;
	__asm        jne    _T6e;
// LINE 637:
	__asm        mov    eax, arr;
	__asm        jmp    _T7e;
// LINE 638:
	__asm        jmp    _T72;
// LINE 639:
_T6e:
	found++;
// LINE 641:
_T72:
	__asm        jmp    _T1f;
// LINE 642:
_T77:
	__asm        xor    eax, eax;
	__asm        jmp    _T7e;
// LINE 643:
_T7e:
}

// FUNCTION: COPTER_D 0x00568fa8
short _cArray::GetNumArraysByType(unsigned long rType) {
	/*bp-0x4*/   short numByType;
	/*bp-0x8*/   short cnt;

// LINE 647:
	__asm        call   _cArray::MakeTable;
// LINE 648:
	numByType = 0x0;
// LINE 649:
	__asm        mov    cnt, 0;
	__asm        jmp    _T23;
_T1f:
	cnt++;
_T23:
	__asm        movsx  eax, cnt;
	__asm        cmp    eax, 0x400;
	__asm        jge    _T5a;
// LINE 650:
// Block start:
	/*bp-0xc*/   /*unpacked*/ class _cArray *tmp;
	tmp = _cArray::sArrayTable->;
// LINE 651:
	__asm        mov    eax, tmp;
	__asm        mov    ecx, rType;
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T55;
// LINE 652:
	numByType++;
// LINE 653:
// Block end:
_T55:
	__asm        jmp    _T1f;
// LINE 654:
_T5a:
	__asm        mov    ax, numByType;
	__asm        jmp    near ptr 0x0056900B;
// LINE 655:
}

// FUNCTION: COPTER_D 0x00569010
short _cArray::GetArrayIndexInType(/*unpacked*/ class _cArray *findarr) {
	/*bp-0x4*/   /*unpacked*/ class _cArray *arr;
	/*bp-0x8*/   short count;
	/*bp-0xc*/   short found;

// LINE 659:
	__asm        call   _cArray::MakeTable;
// LINE 660:
	found = 0x0;
// LINE 662:
	__asm        mov    count, 0;
	__asm        jmp    _T23;
_T1f:
	count++;
_T23:
	__asm        movsx  eax, count;
	__asm        cmp    eax, 0x400;
	__asm        jge    _T77;
// LINE 663:
	arr = _cArray::sArrayTable->;
// LINE 664:
	__asm        mov    eax, arr;
	__asm        mov    ecx, findarr;
	__asm        mov    ecx, [ecx+0x28];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T72;
// LINE 665:
	__asm        mov    eax, findarr;
	__asm        cmp    arr, eax;
	__asm        jne    _T6e;
// LINE 666:
	__asm        mov    ax, found;
	__asm        jmp    _T80;
// LINE 667:
	__asm        jmp    _T72;
// LINE 668:
_T6e:
	found++;
// LINE 670:
_T72:
	__asm        jmp    _T1f;
// LINE 671:
_T77:
	__asm        mov    ax, 0xFFFF;
	__asm        jmp    _T80;
// LINE 672:
_T80:
}

// FUNCTION: COPTER_D 0x00569095
void _cArray::LoadAllArrays(/*unpacked*/ class ResFile *pFile, unsigned long rType, short entrySize, void (*Swizzler)(void * __ptr32, long)) {
	/*bp-0x10*/  /*unpacked*/ struct _cArray::Header *header;
	/*bp-0x18*/  /*unpacked*/ struct _cArray::FileAndType ft; // 0x8 bytes
	/*bp-0x1c*/  short count;
	/*bp-0x20*/  unsigned short fileOpened;
	/*bp-0x24*/  short foundcount;
	/*bp-0x28*/  short diskEntrySize;
	/*bp-0x2c*/  short numArrays;

	// Function registers exception cleanup function at 0x00569305
// LINE 706:
	__asm        cmp    pFile, 0;
	__asm        jne    _T44;

	__asm        push   0x8C085;
	__asm        push   0x5C0318;
	__asm        push   0x2C2;
	__asm        push   0x5C0338;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 712:
_T44:
	__asm        push   0;
	__asm        push   0;
	__asm        call   _cArray::GetLoadedIndex;
	__asm        add    esp, 8;
	__asm        mov    foundcount, ax;
// LINE 713:
	__asm        movsx  eax, foundcount;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T7d;

	__asm        push   0x8C085;
	__asm        push   0x5C0358;
	__asm        push   0x2C9;
	__asm        push   0x5C0378;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 714:
_T7d:
	__asm        mov    eax, pFile;
	__asm        mov    ft.file, eax;
	__asm        mov    eax, rType;
	__asm        mov    ft.type, eax;
// LINE 715:
	__asm        mov    eax, ft.file;
	__asm        mov    ecx, ft.type;
	__asm        movsx  edx, foundcount;
	__asm        lea    edx, _cArray::fsLoaded[0].file[edx*8];
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 717:
	__asm        mov    eax, pFile;
	__asm        push   eax;
	__asm        call   OpenFile;
	__asm        add    esp, 4;
	__asm        mov    fileOpened, ax;
// LINE 721:
	__asm        mov    eax, rType;
	__asm        push   eax;
	__asm        mov    ecx, pFile;
	__asm        call   FlatResFile::Count;
	__asm        mov    numArrays, ax;
// LINE 722:
	__asm        mov    count, 1;
	__asm        jmp    _Tce;
_Tca:
	count++;
_Tce:
	__asm        movsx  eax, numArrays;
	__asm        movsx  ecx, count;
	__asm        cmp    eax, ecx;
	__asm        jl     _T246;
// LINE 724:
// Block start:
	/*bp-0x30*/  /*unpacked*/ class _cArray *tmp;
	/*bp-0x34*/  void * __ptr32 hArray;
	/*bp-0x38*/  unsigned char * dataPtr;
	__asm        push   0;
	__asm        mov    eax, reinterpret_cast<uint32_t>(count);
	__asm        push   eax;
	__asm        mov    eax, rType;
	__asm        push   eax;
	__asm        mov    ecx, pFile;
	__asm        call   FlatResFile::GetByIndex;
	__asm        mov    hArray, eax;
// LINE 725:
	__asm        cmp    hArray, 0;
	__asm        jne    _T119;

	__asm        push   0x8C085;
	__asm        push   0x5C0398;
	__asm        push   0x2D5;
	__asm        push   0x5C03C8;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 727:
_T119:
	__asm        mov    eax, hArray;
	__asm        push   eax;
	__asm        call   Memory::HLock;
	__asm        add    esp, 4;
	__asm        mov    dataPtr, eax;
// LINE 728:
	header = dataPtr;
// LINE 729:
	diskEntrySize = header->entrySize;
// LINE 730:
	__asm        lea    eax, diskEntrySize;
	__asm        push   eax;
	__asm        call   Swizzle2;
	__asm        add    esp, 4;
// LINE 731:
	__asm        movsx  eax, entrySize;
	__asm        movsx  ecx, diskEntrySize;
	__asm        cmp    eax, ecx;
	__asm        je     _T170;

	__asm        push   0x8C085;
	__asm        push   0x5C03E8;
	__asm        push   0x2DB;
	__asm        push   0x5C0420;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 733:
_T170:
	__asm        mov    eax, hArray;
	__asm        push   eax;
	__asm        call   Memory::HUnlock;
	__asm        add    esp, 4;
// LINE 736:
	__asm        push   0x50;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    dword ptr [ebp-4], 0;
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        je     _T1d1;

	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    dword ptr [eax], 0x593738;
	__asm        call   _cArray::MakeTable;
	__asm        mov    eax, Swizzler;
	__asm        push   eax;
	__asm        movsx  eax, entrySize;
	__asm        push   eax;
	__asm        mov    eax, pFile;
	__asm        push   eax;
	__asm        mov    eax, hArray;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x3C];
	__asm        call   _cArray::FromDiskCreate;
	__asm        jmp    near ptr 0x0056925B;

	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x40], eax;
	__asm        jmp    _T1d8;
_T1d1:
	__asm        mov    dword ptr [ebp-0x40], 0;
_T1d8:
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    tmp, eax;
// LINE 737:
	__asm        mov    eax, tmp;
	__asm        mov    ecx, rType;
	__asm        cmp    [eax+0x28], ecx;
	__asm        je     _T210;

	__asm        push   0x8C085;
	__asm        push   0x5C0440;
	__asm        push   0x2E1;
	__asm        push   0x5C044C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 738:
_T210:
	__asm        mov    eax, tmp;
	__asm        mov    eax, [eax+0xC];
	__asm        add    eax, 8;
	__asm        mov    ecx, tmp;
	__asm        cmp    eax, [ecx+4];
	__asm        je     _T241;

	__asm        push   0x8C085;
	__asm        push   0x5C046C;
	__asm        push   0x2E2;
	__asm        push   0x5C04A4;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 755:
// Block end:
_T241:
	__asm        jmp    _Tca;
// LINE 756:
_T246:
	__asm        test   reinterpret_cast<uint32_t>(fileOpened), 0xFFFF;
	__asm        je     _T25e;
// LINE 757:
	__asm        mov    eax, pFile;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pFile;
	__asm        call   dword ptr [eax+0xC];
// LINE 760:
_T25e:
	__asm        jmp    _T27a;
_L27272:
	__asm        mov    eax, [ebp-0x3C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        ret;
_L27271:
	__asm        mov    eax, 0x596208;
	__asm        jmp    near ptr 0x0056F590;
_T27a:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    fs:[0], eax;
}

// FUNCTION: COPTER_D 0x0056931d
short _cArray::GetLoadedIndex(/*unpacked*/ class ResFile *pFile, unsigned long rType) {
	/*bp-0x8*/   /*unpacked*/ struct _cArray::FileAndType ft; // 0x8 bytes
	/*bp-0xc*/   short cnt;
	/*bp-0x10*/  short foundcount;

// LINE 779:
	foundcount = 0xffff;
// LINE 780:
	__asm        mov    eax, pFile;
	__asm        mov    ft.file, eax;
	__asm        mov    eax, rType;
	__asm        mov    ft.type, eax;
// LINE 781:
	__asm        mov    cnt, 0;
	__asm        jmp    _T2a;
_T26:
	cnt++;
_T2a:
	__asm        movsx  eax, cnt;
	__asm        cmp    eax, 0x40;
	__asm        jge    _Ta9;
// LINE 782:
	__asm        movsx  eax, cnt;
	__asm        mov    ecx, ft.file;
	__asm        cmp    _cArray::fsLoaded[0].file[eax*8], ecx;
	__asm        jne    _Ta4;

	__asm        movsx  eax, cnt;
	__asm        mov    ecx, ft.type;
	__asm        cmp    _cArray::fsLoaded[0].type[eax*8], ecx;
	__asm        jne    _Ta4;
// LINE 784:
	__asm        cmp    ft.file, 0;
	__asm        je     _T9c;

	__asm        cmp    ft.type, 0;
	__asm        je     _T9c;
// LINE 785:
	__asm        movsx  eax, foundcount;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T9c;

	__asm        push   0x8C085;
	__asm        push   0x5C04C4;
	__asm        push   0x311;
	__asm        push   0x5C04EC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 787:
_T9c:
	foundcount = cnt;
// LINE 792:
_Ta4:
	__asm        jmp    _T26;
// LINE 793:
_Ta9:
	__asm        mov    ax, foundcount;
	__asm        jmp    near ptr 0x005693CF;
// LINE 794:
}



// Contribution: 2:000071e0-0000722f Module: 180, 8 byte alignment, initialized_data, read, 


// Contribution: 3:0002874c-0002950a Module: 180, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005bf74c
/*unpacked*/ class _cArray **_cArray::sArrayTable = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005bf750
unsigned short _cArray::sAllLoaded = 0;



// Contribution: 3:000a1998-000a1b97 Module: 180, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00638998
/*unpacked*/ struct _cArray::FileAndType _cArray::fsLoaded[64];

