// Module: Animutil.obj
// Source: C:\Copter\Source\X\Animutil.cpp
// autogenerated by simcopter_tool from PDB file

// Type: float;

// Type: /*unpacked*/ struct DXZY;
struct DXZY{ // not packed(0x10 bytes) TI: 0x3420
	/*+0x0*/   float x;
	/*+0x4*/   float z;
	/*+0x8*/   float y;
	/*+0xc*/   float info;
};

// Type: /*unpacked*/ struct DXZY (forward reference);
struct DXZY{ // not packed(0x10 bytes) TI: 0x3420
	/*+0x0*/   float x;
	/*+0x4*/   float z;
	/*+0x8*/   float y;
	/*+0xc*/   float info;
};

// Type: void;

// Type: short;

// Type: unsigned short;

// Type: /*unpacked*/ struct XZY (forward reference);
struct XZY{ // not packed(0x8 bytes) TI: 0x3508
	/*+0x0*/   short x; // 0x2 bytes
	/*+0x2*/   short z; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short _win8pad; // 0x2 bytes
};

// Type: float *;

// Type: short *;

// Type: /*unpacked*/ struct Polar (forward reference);
struct Polar{ // not packed(0x18 bytes) TI: 0x34dc
	/*+0x0*/   float phi;
	/*+0x4*/   float psi;
	/*+0x8*/   float tau;
	/*+0xc*/   float _win8pad;
	/*+0x10*/  short lng; // 0x2 bytes
	/*+0x12*/  short lat; // 0x2 bytes
	/*+0x14*/  short trq; // 0x2 bytes
	/*+0x16*/  short _win8pad2; // 0x2 bytes
};

// Type: /*unpacked*/ struct Polar;
struct Polar{ // not packed(0x18 bytes) TI: 0x34dc
	/*+0x0*/   float phi;
	/*+0x4*/   float psi;
	/*+0x8*/   float tau;
	/*+0xc*/   float _win8pad;
	/*+0x10*/  short lng; // 0x2 bytes
	/*+0x12*/  short lat; // 0x2 bytes
	/*+0x14*/  short trq; // 0x2 bytes
	/*+0x16*/  short _win8pad2; // 0x2 bytes
};

// Type: double;

// Type: /*unpacked*/ struct Rect (forward reference);
struct Rect{ // not packed(0x8 bytes) TI: 0x3463
	/*+0x0*/   short top; // 0x2 bytes
	/*+0x2*/   short left; // 0x2 bytes
	/*+0x4*/   short bottom; // 0x2 bytes
	/*+0x6*/   short right; // 0x2 bytes
};

// Type: /*unpacked*/ struct Point (forward reference);
struct Point{ // not packed(0x4 bytes) TI: 0x341c
	/*+0x0*/   short v; // 0x2 bytes
	/*+0x2*/   short h; // 0x2 bytes
};

// Type: /*unpacked*/ struct Point;
struct Point{ // not packed(0x4 bytes) TI: 0x341c
	/*+0x0*/   short v; // 0x2 bytes
	/*+0x2*/   short h; // 0x2 bytes
};

// Type: /*unpacked*/ struct Rect;
struct Rect{ // not packed(0x8 bytes) TI: 0x3463
	/*+0x0*/   short top; // 0x2 bytes
	/*+0x2*/   short left; // 0x2 bytes
	/*+0x4*/   short bottom; // 0x2 bytes
	/*+0x6*/   short right; // 0x2 bytes
};

// Type: unsigned long;

// Type: enum UseDrawGrid;
enum UseDrawGrid {
	kReturnPosition = 0,
	kActuallyDrawGrid = 1,
};

// Type: void * __ptr32;



// Contribution: 1:00161610-00162e95 Module: 187, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00562610
void GetAxis(float XY2Par, float XZ2Par, /*unpacked*/ struct DXZY paraxis, /*unpacked*/ struct DXZY *childaxis) {
// LINE 47:
	__asm        mov    eax, childaxis;
	__asm        push   eax;
	__asm        mov    eax, paraxis.info;
	__asm        push   eax;
	__asm        mov    eax, paraxis.y;
	__asm        push   eax;
	__asm        mov    eax, paraxis.z;
	__asm        push   eax;
	__asm        mov    eax, paraxis.x;
	__asm        push   eax;
	__asm        fld    XZ2Par;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    XZ2Par;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    XY2Par;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    XY2Par;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        call   XYIncrementCartesian;
	__asm        add    esp, 0x24;
	__asm        jmp    _T83;
// LINE 48:
_T83:
	return;
}

// FUNCTION: COPTER_D 0x0056269d
void GetAxes(float XY2Par, float XZ2Par, /*unpacked*/ struct DXZY parmaj, /*unpacked*/ struct DXZY parmin, /*unpacked*/ struct DXZY *maj, /*unpacked*/ struct DXZY *min, float majrad, float minrad) {
// LINE 52:
	GetAxis(maj, parmaj.info, parmaj.y, parmaj.z, parmaj.x, XZ2Par, XY2Par);
// LINE 53:
	GetAxis(min, parmin.info, parmin.y, parmin.z, parmin.x, XZ2Par, XY2Par);
// LINE 54:
	return;
}

// FUNCTION: COPTER_D 0x005626f5
unsigned short PutInPerspective(/*unpacked*/ struct DXZY *xzy, short cH) {
// LINE 59:
	__asm        mov    eax, xzy;
	__asm        fld    dword ptr [eax+8];
	__asm        fcomp  qword ptr ds:[0x593740];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T25;
// LINE 60:
	return 0x0;
// LINE 61:
_T25:
	__asm        mov    eax, xzy;
	__asm        fld    dword ptr [eax];
	__asm        fmul   qword ptr ds:[0x593748];
	__asm        mov    eax, xzy;
	__asm        fld    dword ptr [eax+8];
	__asm        fadd   qword ptr ds:[0x593748];
	__asm        fdivp;
	__asm        mov    eax, xzy;
	__asm        fstp   dword ptr [eax];
// LINE 62:
	__asm        mov    eax, xzy;
	__asm        fld    dword ptr [eax+4];
	__asm        fmul   qword ptr ds:[0x593748];
	__asm        mov    eax, xzy;
	__asm        fld    dword ptr [eax+8];
	__asm        fadd   qword ptr ds:[0x593748];
	__asm        fdivp;
	__asm        mov    eax, xzy;
	__asm        fstp   dword ptr [eax+4];
// LINE 63:
	return 0x1;
// LINE 64:
}

// FUNCTION: COPTER_D 0x00562766
unsigned short PutInPerspective(/*unpacked*/ struct XZY *xzy, short cH) {
	/*bp-0x10*/  /*unpacked*/ struct DXZY dxzy; // 0x10 bytes

// LINE 68:
	__asm        mov    eax, xzy;
	__asm        movsx  eax, word ptr [eax];
	__asm        mov    [ebp-0x14], eax;
	__asm        fild   dword ptr [ebp-0x14];
	__asm        fstp   dxzy.x;
	__asm        mov    eax, xzy;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        mov    [ebp-0x18], eax;
	__asm        fild   dword ptr [ebp-0x18];
	__asm        fstp   dxzy.z;
	__asm        mov    eax, xzy;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        mov    [ebp-0x1C], eax;
	__asm        fild   dword ptr [ebp-0x1C];
	__asm        fstp   dxzy.y;
	__asm        mov    dxzy.info, 0;
// LINE 69:
	__asm        mov    eax, reinterpret_cast<uint32_t>(cH);
	__asm        push   eax;
	__asm        lea    eax, dxzy.x;
	__asm        push   eax;
	__asm        call   PutInPerspective;
	__asm        add    esp, 8;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T62;
// LINE 70:
	return 0x0;
// LINE 71:
_T62:
	__asm        fld    dxzy.x;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, xzy;
	__asm        mov    [ecx], ax;
	__asm        fld    dxzy.z;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, xzy;
	__asm        mov    [ecx+2], ax;
	__asm        fld    dxzy.y;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, xzy;
	__asm        mov    [ecx+4], ax;
// LINE 72:
	return 0x1;
// LINE 73:
}

// FUNCTION: COPTER_D 0x00562802
void XY2Cartesian(float radius, float phi, float psi, float * xres, float * zres, float * yres) {
	/*bp-0x10*/  /*unpacked*/ struct DXZY transformed; // 0x10 bytes
	/*bp-0x14*/  float x;
	/*bp-0x18*/  float y;
	/*bp-0x1c*/  float z;
	/*bp-0x2c*/  /*unpacked*/ struct DXZY dpt; // 0x10 bytes

// LINE 77:
	doAssert(0x8c085, 0x5becd8, 0x4d, 0x5becf4);
// LINE 79:
	x = 0x0;
	z = 0x0;
	y = radius;
// LINE 80:
	dpt.x = x;
	dpt.z = z;
	dpt.y = y;
	dpt.info = 0x0;
// LINE 81:
	__asm        lea    eax, transformed.x;
	__asm        push   eax;
	__asm        mov    eax, dpt.info;
	__asm        push   eax;
	__asm        mov    eax, dpt.y;
	__asm        push   eax;
	__asm        mov    eax, dpt.z;
	__asm        push   eax;
	__asm        mov    eax, dpt.x;
	__asm        push   eax;
	__asm        fld    psi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    psi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    phi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    phi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        call   XYIncrementCartesian;
	__asm        add    esp, 0x24;
// LINE 82:
	xres[0] = transformed.x;
// LINE 83:
	zres[0] = transformed.z;
// LINE 84:
	yres[0] = transformed.y;
// LINE 85:
	return;
}

// FUNCTION: COPTER_D 0x005628eb
void XYIncrementCartesian(float sinXangle, float cosXangle, float sinYangle, float cosYangle, /*unpacked*/ struct DXZY dpt, /*unpacked*/ struct DXZY *transformed) {
// LINE 94:
	__asm        fld    dpt.x;
	__asm        fmul   cosYangle;
	__asm        fld    dpt.y;
	__asm        fmul   sinYangle;
	__asm        fsubp;
	__asm        mov    eax, transformed;
	__asm        fstp   dword ptr [eax];
// LINE 95:
	__asm        fld    dpt.x;
	__asm        fmul   sinYangle;
	__asm        fld    dpt.y;
	__asm        fmul   cosYangle;
	__asm        faddp;
	__asm        mov    eax, transformed;
	__asm        fstp   dword ptr [eax+8];
// LINE 97:
	__asm        fld    dpt.z;
	__asm        fmul   cosXangle;
	__asm        mov    eax, transformed;
	__asm        fld    dword ptr [eax+8];
	__asm        fmul   sinXangle;
	__asm        faddp;
	__asm        mov    eax, transformed;
	__asm        fstp   dword ptr [eax+4];
// LINE 98:
	__asm        mov    eax, transformed;
	__asm        fld    dword ptr [eax+8];
	__asm        fmul   cosXangle;
	__asm        fld    dpt.z;
	__asm        fmul   sinXangle;
	__asm        fsubp;
	__asm        mov    eax, transformed;
	__asm        fstp   dword ptr [eax+8];
// LINE 99:
	return;
}

// FUNCTION: COPTER_D 0x00562950
void TransformToAxes(/*unpacked*/ struct DXZY *xAxis, /*unpacked*/ struct DXZY *zAxis, /*unpacked*/ struct DXZY *yAxis, /*unpacked*/ struct DXZY prist, /*unpacked*/ struct DXZY *real) {
// LINE 103:
	real->x = 0x0;
	real->z = 0x0;
	real->y = 0x0;
// LINE 104:
	__asm        mov    eax, xAxis;
	__asm        fld    dword ptr [eax];
	__asm        fmul   prist.x;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax];
// LINE 105:
	__asm        mov    eax, xAxis;
	__asm        fld    dword ptr [eax+4];
	__asm        fmul   prist.x;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax+4];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax+4];
// LINE 106:
	__asm        mov    eax, xAxis;
	__asm        fld    dword ptr [eax+8];
	__asm        fmul   prist.x;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax+8];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax+8];
// LINE 108:
	__asm        mov    eax, zAxis;
	__asm        fld    dword ptr [eax];
	__asm        fmul   prist.z;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax];
// LINE 109:
	__asm        mov    eax, zAxis;
	__asm        fld    dword ptr [eax+4];
	__asm        fmul   prist.z;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax+4];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax+4];
// LINE 110:
	__asm        mov    eax, zAxis;
	__asm        fld    dword ptr [eax+8];
	__asm        fmul   prist.z;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax+8];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax+8];
// LINE 112:
	__asm        mov    eax, yAxis;
	__asm        fld    dword ptr [eax];
	__asm        fmul   prist.y;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax];
// LINE 113:
	__asm        mov    eax, yAxis;
	__asm        fld    dword ptr [eax+4];
	__asm        fmul   prist.y;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax+4];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax+4];
// LINE 114:
	__asm        mov    eax, yAxis;
	__asm        fld    dword ptr [eax+8];
	__asm        fmul   prist.y;
	__asm        mov    eax, real;
	__asm        fadd   dword ptr [eax+8];
	__asm        mov    eax, real;
	__asm        fstp   dword ptr [eax+8];
// LINE 115:
	return;
}

// FUNCTION: COPTER_D 0x00562a31
void AxisTransformToScreen(/*unpacked*/ struct DXZY *xAxis, /*unpacked*/ struct DXZY *zAxis, /*unpacked*/ struct DXZY *yAxis, /*unpacked*/ struct DXZY *centeroffset, /*unpacked*/ struct DXZY *dxzy) {
	/*bp-0x10*/  /*unpacked*/ struct DXZY tf; // 0x10 bytes

// LINE 121:
	TransformToAxes(tf.x, dxzy->info, dxzy->y, dxzy->z, dxzy->x, yAxis, zAxis, xAxis);
// LINE 122:
	__asm        cmp    centeroffset, 0;
	__asm        je     _T60;
// LINE 123:
	__asm        mov    eax, centeroffset;
	__asm        fld    dword ptr [eax];
	__asm        fadd   tf.x;
	__asm        fstp   tf.x;
// LINE 124:
	__asm        mov    eax, centeroffset;
	__asm        fld    dword ptr [eax+4];
	__asm        fadd   tf.z;
	__asm        fstp   tf.z;
// LINE 125:
	__asm        mov    eax, centeroffset;
	__asm        fld    dword ptr [eax+8];
	__asm        fadd   tf.y;
	__asm        fstp   tf.y;
// LINE 127:
_T60:
	PutInPerspective(0x0, tf.x);
// LINE 128:
	__asm        lea    eax, tf.x;
	__asm        mov    ecx, dxzy;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 129:
	return;
}

// FUNCTION: COPTER_D 0x00562ac5
void XYTransformToScreen(float sinXangle, float cosXangle, float sinYangle, float cosYangle, float scale, /*unpacked*/ struct DXZY dpt, short * ptH, short * ptV, short * ptDepth, unsigned short perspective) {
	/*bp-0x10*/  /*unpacked*/ struct DXZY transformed; // 0x10 bytes

// LINE 134:
	XYIncrementCartesian(transformed.x, dpt.info, dpt.y, dpt.z, dpt.x, cosYangle, sinYangle, cosXangle, sinXangle);
// LINE 136:
	__asm        fld    transformed.x;
	__asm        fmul   scale;
	__asm        fstp   transformed.x;
// LINE 137:
	__asm        fld    transformed.y;
	__asm        fmul   scale;
	__asm        fstp   transformed.y;
// LINE 138:
	__asm        fld    transformed.z;
	__asm        fmul   scale;
	__asm        fstp   transformed.z;
// LINE 140:
	__asm        test   reinterpret_cast<uint32_t>(perspective), 0xFFFF;
	__asm        je     _T6b;
// LINE 141:
	PutInPerspective(0x0, transformed.x);
// LINE 143:
_T6b:
	__asm        cmp    ptH, 0;
	__asm        je     _T83;

	__asm        fld    transformed.x;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, ptH;
	__asm        mov    [ecx], ax;
// LINE 144:
_T83:
	__asm        cmp    ptV, 0;
	__asm        je     _T9b;

	__asm        fld    transformed.z;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, ptV;
	__asm        mov    [ecx], ax;
// LINE 145:
_T9b:
	__asm        cmp    ptDepth, 0;
	__asm        je     _Tb3;

	__asm        fld    transformed.y;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, ptDepth;
	__asm        mov    [ecx], ax;
// LINE 146:
_Tb3:
	return;
}

// FUNCTION: COPTER_D 0x00562b82
void IncrementXY(/*unpacked*/ struct Polar *inc, /*unpacked*/ struct Polar *partPolar) {
// LINE 152:
	doAssert(0x8c085, 0x5bed14, 0x98, 0x5bed3c);
// LINE 153:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax];
	__asm        mov    eax, inc;
	__asm        fadd   dword ptr [eax];
	__asm        mov    eax, partPolar;
	__asm        fstp   dword ptr [eax];
// LINE 154:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax+4];
	__asm        mov    eax, inc;
	__asm        fadd   dword ptr [eax+4];
	__asm        mov    eax, partPolar;
	__asm        fstp   dword ptr [eax+4];
// LINE 155:
	Keep0to2pi(partPolar);
// LINE 156:
	return;
}

// FUNCTION: COPTER_D 0x00562bdb
void Keep0to2pi(float * radians) {
// LINE 160:
_T06:
	__asm        mov    eax, radians;
	__asm        fld    dword ptr [eax];
	__asm        fcomp  qword ptr ds:[0x593758];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        jne    _T31;
// LINE 161:
	__asm        mov    eax, radians;
	__asm        fld    dword ptr [eax];
	__asm        fsub   dword ptr ds:[0x593760];
	__asm        mov    eax, radians;
	__asm        fstp   dword ptr [eax];
	__asm        jmp    _T06;
// LINE 162:
_T31:
	__asm        mov    eax, radians;
	__asm        fld    dword ptr [eax];
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T5c;
// LINE 163:
	__asm        mov    eax, radians;
	__asm        fld    dword ptr [eax];
	__asm        fadd   dword ptr ds:[0x593760];
	__asm        mov    eax, radians;
	__asm        fstp   dword ptr [eax];
	__asm        jmp    _T31;
// LINE 164:
_T5c:
	return;
}

// FUNCTION: COPTER_D 0x00562c41
void Keep0to2pi(/*unpacked*/ struct Polar *polar) {
// LINE 168:
	Keep0to2pi(polar);
// LINE 169:
	Keep0to2pi((polar + 0x4));
// LINE 170:
	Keep0to2pi((polar + 0x8));
// LINE 171:
	return;
}

// FUNCTION: COPTER_D 0x00562c7b
float Keep0to2pi(float radians) {
// LINE 175:
	Keep0to2pi(radians);
// LINE 176:
	__asm        fld    radians;
	__asm        jmp    __RETURN;
// LINE 177:
__RETURN:
}

// FUNCTION: COPTER_D 0x00562c9a
void IncrementFloat(/*unpacked*/ struct Polar inc, /*unpacked*/ struct Polar *partPolar) {
// LINE 181:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax];
	__asm        fadd   inc.phi;
	__asm        mov    eax, partPolar;
	__asm        fstp   dword ptr [eax];
// LINE 182:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax+4];
	__asm        fadd   inc.psi;
	__asm        mov    eax, partPolar;
	__asm        fstp   dword ptr [eax+4];
// LINE 183:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax+8];
	__asm        fadd   inc.tau;
	__asm        mov    eax, partPolar;
	__asm        fstp   dword ptr [eax+8];
// LINE 184:
	Keep0to2pi(partPolar);
// LINE 185:
	return;
}

// FUNCTION: COPTER_D 0x00562ce1
float my_acos(float x, float rad) {
	/*bp-0x4*/   float res;

// LINE 190:
	__asm        fld    rad;
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        jne    _T28;

	__asm        mov    eax, rad;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T30;
_T28:
	__asm        fld    rad;
	__asm        fchs;
	__asm        fstp   dword ptr [ebp-8];
_T30:
	__asm        fld    dword ptr [ebp-8];
	__asm        fcomp  qword ptr ds:[0x593768];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _Ta7;
// LINE 192:
	__asm        fld    x;
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        jne    _T63;

	__asm        mov    eax, x;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T6b;
_T63:
	__asm        fld    x;
	__asm        fchs;
	__asm        fstp   dword ptr [ebp-0xC];
_T6b:
	__asm        fld    dword ptr [ebp-0xC];
	__asm        fcomp  qword ptr ds:[0x593770];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        jne    _T9b;
// LINE 193:
	doAssert(0x8c085, 0x5bed5c, 0xc1, 0x5bed78);
// LINE 195:
_T9b:
	res = 0x0;
// LINE 197:
	__asm        jmp    _T104;
_Ta7:
	__asm        fld    x;
	__asm        fdiv   rad;
	__asm        fcomp  qword ptr ds:[0x593778];
	__asm        fnstsw ax;
	__asm        test   ah, 0x41;
	__asm        jne    _Tca;
// LINE 198:
	res = 0x0;
// LINE 199:
	__asm        jmp    _T104;
_Tca:
	__asm        fld    x;
	__asm        fdiv   rad;
	__asm        fcomp  qword ptr ds:[0x593780];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _Ted;
// LINE 200:
	res = 0x40490fdb;
// LINE 201:
	__asm        jmp    _T104;
// LINE 202:
_Ted:
	__asm        fld    x;
	__asm        fdiv   rad;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x005757CA;
	__asm        add    esp, 8;
	__asm        fstp   res;
// LINE 203:
_T104:
	__asm        fld    res;
	__asm        jmp    __RETURN;
// LINE 204:
__RETURN:
}

// FUNCTION: COPTER_D 0x00562df2
void NormalizeTo1(/*unpacked*/ struct DXZY *vec) {
// LINE 209:
	return;
}

// FUNCTION: COPTER_D 0x00562e02
double GetLength(float x, float z, float y) {
	/*bp-0x8*/   double rad; // 0x8 bytes

// LINE 214:
	__asm        fld    x;
	__asm        fmul   x;
	__asm        fld    z;
	__asm        fmul   z;
	__asm        faddp;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056EC10;
	__asm        add    esp, 8;
	__asm        fst    rad;
// LINE 215:
	__asm        fmul   rad;
	__asm        fld    y;
	__asm        fmul   y;
	__asm        faddp;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056EC10;
	__asm        add    esp, 8;
	__asm        fst    rad;
// LINE 216:
	__asm        jmp    __RETURN;
// LINE 217:
__RETURN:
}

// FUNCTION: COPTER_D 0x00562e50
void DrawDirectionDisk(/*unpacked*/ struct Rect *rect, short latint, short lngint, short latincs, short lngincs, unsigned short polarAngles, /*unpacked*/ struct Point *ctr, short length) {
	/*bp-0x4*/   float psi;
	/*bp-0x8*/   float phi;
	/*bp-0xc*/   float junk;

// LINE 226:
	PolarIncs2Double(junk, psi, phi, 0xa, reinterpret_cast<uint32_t>(lngincs), reinterpret_cast<uint32_t>(latincs), 0x0, reinterpret_cast<uint32_t>(lngint), reinterpret_cast<uint32_t>(latint));
// LINE 227:
	DrawDirectionDisk(reinterpret_cast<uint32_t>(length), ctr, reinterpret_cast<uint32_t>(polarAngles), psi, phi, rect);
// LINE 228:
	return;
}

// FUNCTION: COPTER_D 0x00562eab
void DrawDirectionDisk(/*unpacked*/ struct Rect *rect, float phi, float psi, unsigned short polarAngles, /*unpacked*/ struct Point *ctr, short length) {
	/*bp-0x4*/   float ydist;
	/*bp-0x8*/   /*unpacked*/ struct Point centerPt;
	/*bp-0xc*/   float rad;
	/*bp-0x10*/  float zdist;
	/*bp-0x14*/  float xdist;

// LINE 236:
	Keep0to2pi(phi);
// LINE 237:
	Keep0to2pi(psi);
// LINE 239:
	__asm        cmp    ctr, 0;
	__asm        je     _T110;
// LINE 240:
	__asm        movsx  eax, length;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T54;

	doAssert(0x8c085, 0x5bed98, 0xf0, 0x5bedbc);
// LINE 241:
_T54:
	__asm        cmp    rect, 0;
	__asm        je     _T7a;

	doAssert(0x8c085, 0x5beddc, 0xf1, 0x5bedfc);
// LINE 242:
_T7a:
	__asm        movsx  eax, length;
	__asm        mov    [ebp-0x28], eax;
	__asm        fild   dword ptr [ebp-0x28];
	__asm        fstp   rad;
// LINE 243:
	__asm        test   reinterpret_cast<uint32_t>(polarAngles), 0xFFFF;
	__asm        je     _Tb9;
// LINE 244:
	Polar2Cartesian(ydist, zdist, xdist, psi, phi, rad);
// LINE 245:
	__asm        jmp    _Td9;
// LINE 246:
_Tb9:
	XY2Cartesian(ydist, zdist, xdist, psi, phi, rad);
// LINE 247:
_Td9:
	reinterpret_cast<uint32_t>(centerPt.v) = reinterpret_cast<uint32_t>(ctr->v);
// LINE 248:
	__asm        movsx  ebx, centerPt.h;
	__asm        fld    xdist;
	__asm        call   0x0056EBE8;
	__asm        movsx  eax, ax;
	__asm        add    ebx, eax;
	__asm        mov    centerPt.h, bx;
// LINE 249:
	__asm        fld    zdist;
	__asm        call   0x0056EBE8;
	__asm        movsx  eax, ax;
	__asm        movsx  ecx, centerPt.v;
	__asm        add    eax, ecx;
	__asm        mov    centerPt.v, ax;
// LINE 251:
	__asm        jmp    _T1f6;
// LINE 252:
// Block start:
	/*bp-0x18*/  short origwidth;
	/*bp-0x20*/  /*unpacked*/ struct Rect myRect; // 0x8 bytes
_T110:
	__asm        mov    eax, rect;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    reinterpret_cast<uint32_t>(myRect.top), ecx;
	__asm        mov    reinterpret_cast<uint32_t>(myRect.bottom), eax;
// LINE 253:
	__asm        movsx  eax, myRect.right;
	__asm        movsx  ecx, myRect.left;
	__asm        sub    eax, ecx;
	__asm        mov    origwidth, ax;
// LINE 254:
	EraseRect(myRect.top);
// LINE 255:
	__asm        mov    ecx, 6;
	__asm        movsx  eax, origwidth;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        push   eax;
	__asm        mov    ecx, 6;
	__asm        movsx  eax, origwidth;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        push   eax;
	__asm        lea    eax, myRect.top;
	__asm        push   eax;
	__asm        call   InsetRect;
	__asm        add    esp, 0xC;
// LINE 256:
	__asm        movsx  eax, myRect.right;
	__asm        movsx  ecx, myRect.top;
	__asm        add    eax, ecx;
	__asm        movsx  ecx, myRect.left;
	__asm        sub    eax, ecx;
	__asm        mov    myRect.bottom, ax;
// LINE 257:
	__asm        lea    eax, myRect.top;
	__asm        push   eax;
	__asm        call   center;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x24], eax;
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    reinterpret_cast<uint32_t>(centerPt.v), eax;
// LINE 258:
	__asm        movsx  eax, myRect.right;
	__asm        mov    [ebp-0x2C], eax;
	__asm        fild   dword ptr [ebp-0x2C];
	__asm        movsx  eax, myRect.left;
	__asm        mov    [ebp-0x30], eax;
	__asm        fisub  dword ptr [ebp-0x30];
	__asm        fdiv   dword ptr ds:[0x59378C];
	__asm        fstp   rad;
// LINE 259:
	__asm        test   reinterpret_cast<uint32_t>(polarAngles), 0xFFFF;
	__asm        je     _T1d6;
// LINE 260:
	Polar2Cartesian(ydist, zdist, xdist, psi, phi, rad);
// LINE 261:
	__asm        jmp    _T1f6;
// LINE 262:
_T1d6:
	XY2Cartesian(ydist, zdist, xdist, psi, phi, rad);
// LINE 264:
// Block end:
_T1f6:
	__asm        cmp    ctr, 1;
	__asm        sbb    eax, eax;
	__asm        neg    eax;
	__asm        push   eax;
	__asm        mov    eax, rad;
	__asm        push   eax;
	__asm        mov    eax, ydist;
	__asm        push   eax;
	__asm        mov    eax, zdist;
	__asm        push   eax;
	__asm        mov    eax, xdist;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(centerPt.v);
	__asm        push   eax;
	__asm        call   DrawDirectionDisk;
	__asm        add    esp, 0x18;
// LINE 265:
	return;
}

// FUNCTION: COPTER_D 0x005630d0
void DrawDirectionDisk(/*unpacked*/ struct Point centerPt, /*unpacked*/ struct DXZY unitvector, float rad) {
// LINE 269:
	__asm        push   0;
	__asm        mov    eax, rad;
	__asm        push   eax;
	__asm        fld    unitvector.y;
	__asm        fmul   rad;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    unitvector.z;
	__asm        fmul   rad;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    unitvector.x;
	__asm        fmul   rad;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        mov    eax, reinterpret_cast<uint32_t>(centerPt.v);
	__asm        push   eax;
	__asm        call   DrawDirectionDisk;
	__asm        add    esp, 0x18;
// LINE 270:
	return;
}

// FUNCTION: COPTER_D 0x00563116
void DrawDirectionDisk(/*unpacked*/ struct DXZY start, /*unpacked*/ struct DXZY end) {
	/*bp-0x4*/   float ydist;
	/*bp-0x8*/   /*unpacked*/ struct Point startpt;
	/*bp-0xc*/   float rad;
	/*bp-0x10*/  float zdist;
	/*bp-0x14*/  float xdist;

// LINE 274:
	__asm        fld    start.z;
	__asm        call   0x0056EBE8;
	__asm        mov    startpt.v, ax;
	__asm        fld    start.x;
	__asm        call   0x0056EBE8;
	__asm        mov    startpt.h, ax;
// LINE 275:
	__asm        fld    end.x;
	__asm        fsub   start.x;
	__asm        fstp   xdist;
	__asm        fld    end.z;
	__asm        fsub   start.z;
	__asm        fstp   zdist;
	__asm        fld    end.y;
	__asm        fsub   start.y;
	__asm        fstp   ydist;
// LINE 276:
	__asm        fld    zdist;
	__asm        fmul   zdist;
	__asm        fld    xdist;
	__asm        fmul   xdist;
	__asm        faddp;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056EC10;
	__asm        add    esp, 8;
	__asm        fstp   rad;
// LINE 277:
	__asm        fld    ydist;
	__asm        fmul   ydist;
	__asm        fld    rad;
	__asm        fmul   rad;
	__asm        faddp;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056EC10;
	__asm        add    esp, 8;
	__asm        fstp   rad;
// LINE 278:
	__asm        push   0;
	__asm        mov    eax, rad;
	__asm        push   eax;
	__asm        fld    end.y;
	__asm        fsub   start.y;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    end.z;
	__asm        fsub   start.z;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        fld    end.x;
	__asm        fsub   start.x;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        mov    eax, reinterpret_cast<uint32_t>(startpt.v);
	__asm        push   eax;
	__asm        call   DrawDirectionDisk;
	__asm        add    esp, 0x18;
// LINE 279:
	return;
}

// FUNCTION: COPTER_D 0x005631d0
void DrawDirectionDisk(/*unpacked*/ struct Point centerPt, float hdist, float vdist, float depth, float rad, unsigned short bigol) {
// LINE 355:
	return;
}

// FUNCTION: COPTER_D 0x005631e0
void Score(/*unpacked*/ struct Point centerPt, /*unpacked*/ struct Point leftOff, /*unpacked*/ struct Point rightOff) {
// LINE 370:
	return;
}

// FUNCTION: COPTER_D 0x005631f0
unsigned short DrawGrid(float phiOff, float psiOff, short cntrh, short cntrv, unsigned short persp, float scale, short thickness, unsigned long edgecolor, unsigned long hatchcolor, enum UseDrawGrid how, short pth, short ptv, short ptdepth) {
// LINE 498:
	return 0x1;
// LINE 499:
}

// FUNCTION: COPTER_D 0x00563204
void GetChildIncrement(/*unpacked*/ struct Polar *passedInc, /*unpacked*/ struct Polar *parentPolar, /*unpacked*/ struct Polar *partPolar) {
	/*bp-0x4*/   float psiComp;
	/*bp-0x8*/   float tauComp;
	/*bp-0xc*/   float phiComp;
	/*bp-0x24*/  /*unpacked*/ struct Polar incFromParent; // 0x18 bytes
	/*bp-0x28*/  /*unpacked*/ struct Polar *amountToInc;

// LINE 509:
	__asm        lea    edi, incFromParent.phi;
	__asm        mov    esi, passedInc;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
// LINE 510:
	amountToInc = passedInc;
// LINE 511:
	__asm        cmp    parentPolar, 0;
	__asm        je     _Tb9;
// LINE 513:
// Block start:
	/*bp-0x40*/  /*unpacked*/ struct Polar startPolar; // 0x18 bytes
	/*bp-0x58*/  /*unpacked*/ struct Polar resPolar; // 0x18 bytes
	__asm        lea    edi, startPolar.phi;
	__asm        mov    esi, partPolar;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
	__asm        lea    edi, resPolar.phi;
	__asm        mov    esi, partPolar;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
// LINE 515:
	IncrementPhiPsi(resPolar.phi, parentPolar, passedInc);
// LINE 516:
	__asm        fld    resPolar.phi;
	__asm        fsub   startPolar.phi;
	__asm        mov    eax, amountToInc;
	__asm        fstp   dword ptr [eax];
// LINE 517:
	__asm        fld    resPolar.psi;
	__asm        fsub   startPolar.psi;
	__asm        mov    eax, amountToInc;
	__asm        fstp   dword ptr [eax+4];
// LINE 520:
	__asm        lea    esi, resPolar.phi;
	__asm        lea    edi, startPolar.phi;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
// LINE 521:
	IncrementTorque(resPolar.phi, parentPolar, passedInc->tau);
// LINE 522:
	__asm        fld    resPolar.phi;
	__asm        fsub   startPolar.phi;
	__asm        mov    eax, amountToInc;
	__asm        fadd   dword ptr [eax];
	__asm        mov    eax, amountToInc;
	__asm        fstp   dword ptr [eax];
// LINE 523:
	__asm        fld    resPolar.psi;
	__asm        fsub   startPolar.psi;
	__asm        mov    eax, amountToInc;
	__asm        fadd   dword ptr [eax+4];
	__asm        mov    eax, amountToInc;
	__asm        fstp   dword ptr [eax+4];
// LINE 525:
// Block end:
	__asm        jmp    _Tb9;
// LINE 534:
_Tb9:
	__asm        cmp    parentPolar, 0;
	__asm        je     _T1df;
// LINE 538:
// Block start:
	/*bp-0x70*/  /*unpacked*/ struct Polar tmpinc; // 0x18 bytes
	/*bp-0x74*/  float angleToPsiMovement;
	/*bp-0x78*/  float alpha;
	/*bp-0x90*/  /*unpacked*/ struct Polar partPol; // 0x18 bytes
	/*bp-0x94*/  float angleToPhiMovement;
	__asm        lea    edi, partPol.phi;
	__asm        mov    esi, partPolar;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
// LINE 540:
	__asm        mov    tmpinc.trq, 0;
	__asm        mov    ax, tmpinc.trq;
	__asm        mov    tmpinc.lat, ax;
	__asm        mov    ax, tmpinc.lat;
	__asm        mov    tmpinc.lng, ax;
	__asm        movsx  eax, tmpinc.lng;
	__asm        mov    [ebp-0x98], eax;
	__asm        fild   dword ptr [ebp-0x98];
	__asm        fstp   tmpinc.tau;
	__asm        mov    eax, tmpinc.tau;
	__asm        mov    tmpinc.psi, eax;
	__asm        mov    eax, tmpinc.psi;
	__asm        mov    tmpinc.phi, eax;
// LINE 541:
	__asm        mov    eax, parentPolar;
	__asm        fld    dword ptr [eax+4];
	__asm        fchs;
	__asm        fstp   tmpinc.psi;
// LINE 542:
	__asm        mov    eax, parentPolar;
	__asm        fld    dword ptr [eax];
	__asm        fchs;
	__asm        fstp   tmpinc.phi;
// LINE 543:
	IncrementPhiPsi(partPol.phi, parentPolar, tmpinc.phi);
// LINE 544:
	angleToPhiMovement = partPol.psi;
// LINE 545:
	__asm        fld    angleToPhiMovement;
	__asm        fsub   dword ptr ds:[0x593790];
	__asm        fstp   angleToPsiMovement;
// LINE 548:
	alpha = partPol.phi;
// LINE 550:
	__asm        fld    angleToPhiMovement;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        fstp   qword ptr [ebp-0xA0];
	__asm        fld    alpha;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        fmul   qword ptr [ebp-0xA0];
	__asm        fmul   incFromParent.phi;
	__asm        fstp   phiComp;
// LINE 551:
	__asm        fld    alpha;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        fstp   qword ptr [ebp-0xA8];
	__asm        fld    angleToPsiMovement;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        fmul   qword ptr [ebp-0xA8];
	__asm        fmul   incFromParent.psi;
	__asm        fstp   psiComp;
// LINE 552:
	__asm        fld    alpha;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        fmul   incFromParent.tau;
	__asm        fstp   tauComp;
// LINE 554:
// Block end:
	__asm        jmp    _T203;
// LINE 556:
_T1df:
	phiComp = 0x0;
// LINE 557:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax];
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        fstp   psiComp;
// LINE 558:
	tauComp = 0x0;
// LINE 564:
_T203:
	__asm        fld    tauComp;
	__asm        fadd   psiComp;
	__asm        fadd   phiComp;
	__asm        mov    eax, amountToInc;
	__asm        fstp   dword ptr [eax+8];
// LINE 565:
	return;
}

// FUNCTION: COPTER_D 0x00563420
void IncrementAngles(float incPhi, float incPsi, float pivotPhi, float pivotPsi, float * phi, float * psi, unsigned short polarAngles) {
	/*bp-0x18*/  /*unpacked*/ struct Polar inc; // 0x18 bytes
	/*bp-0x30*/  /*unpacked*/ struct Polar polar; // 0x18 bytes
	/*bp-0x48*/  /*unpacked*/ struct Polar pivot; // 0x18 bytes

// LINE 570:
	polar.phi = phi[0];
	polar.psi = psi[0];
	polar.tau = 0x0;
// LINE 571:
	inc.phi = incPhi;
	inc.psi = incPsi;
	inc.tau = 0x0;
// LINE 572:
	pivot.phi = pivotPhi;
	pivot.psi = pivotPsi;
	pivot.tau = 0x0;
// LINE 573:
	polar.trq = 0x0;
	polar.lng = polar.trq;
	polar.lat = polar.lng;
	pivot.trq = polar.lat;
	pivot.lng = pivot.trq;
	pivot.lat = pivot.lng;
	inc.trq = pivot.lat;
	inc.lng = inc.trq;
	inc.lat = inc.lng;
// LINE 575:
	__asm        test   reinterpret_cast<uint32_t>(polarAngles), 0xFFFF;
	__asm        je     _Tb2;
// LINE 576:
	IncrementPhiPsi(polar.phi, pivot.phi, inc.phi);
// LINE 577:
	__asm        jmp    _Tc2;
// LINE 578:
_Tb2:
	IncrementXY(polar.phi, inc.phi);
// LINE 579:
_Tc2:
	phi[0] = polar.phi;
	psi[0] = polar.psi;
// LINE 580:
	return;
}

// FUNCTION: COPTER_D 0x005634fc
void IncrementPhiPsi(/*unpacked*/ struct Polar *inc, /*unpacked*/ struct Polar *parentPolar, /*unpacked*/ struct Polar *partPolar) {
// LINE 584:
	__asm        mov    eax, inc;
	__asm        movsx  eax, word ptr [eax+0x12];
	__asm        test   eax, eax;
	__asm        je     _T4a;

	__asm        mov    eax, inc;
	__asm        fld    dword ptr [eax];
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 0x40;
	__asm        je     _T4a;

	doAssert(0x8c085, 0x5bee1c, 0x248, 0x5bee44);
// LINE 585:
_T4a:
	__asm        mov    eax, inc;
	__asm        movsx  eax, word ptr [eax+0x10];
	__asm        test   eax, eax;
	__asm        je     _T8c;

	__asm        mov    eax, inc;
	__asm        fld    dword ptr [eax+4];
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 0x40;
	__asm        je     _T8c;

	doAssert(0x8c085, 0x5bee64, 0x249, 0x5bee8c);
// LINE 586:
_T8c:
	__asm        mov    eax, inc;
	__asm        movsx  eax, word ptr [eax+0x14];
	__asm        test   eax, eax;
	__asm        je     _Tce;

	__asm        mov    eax, inc;
	__asm        fld    dword ptr [eax+8];
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 0x40;
	__asm        je     _Tce;

	doAssert(0x8c085, 0x5beeac, 0x24a, 0x5beed4);
// LINE 588:
_Tce:
	__asm        cmp    parentPolar, 0;
	__asm        jne    _Tec;
// LINE 589:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax];
	__asm        mov    eax, inc;
	__asm        fadd   dword ptr [eax];
	__asm        mov    eax, partPolar;
	__asm        fstp   dword ptr [eax];
// LINE 590:
	__asm        jmp    _T1b1;
// LINE 593:
// Block start:
	/*bp-0x4*/   float z2;
	/*bp-0x8*/   float tmprad;
	/*bp-0xc*/   float psiToZero;
	/*bp-0x10*/  float tmprad2;
	/*bp-0x28*/  /*unpacked*/ struct Polar tmpPolar2; // 0x18 bytes
	/*bp-0x2c*/  float x;
	/*bp-0x44*/  /*unpacked*/ struct Polar resPolar; // 0x18 bytes
	/*bp-0x48*/  float x2;
	/*bp-0x4c*/  float y;
	/*bp-0x50*/  float z;
	/*bp-0x68*/  /*unpacked*/ struct Polar tmpPolar; // 0x18 bytes
	/*bp-0x6c*/  float y2;
_Tec:
	__asm        lea    edi, tmpPolar.phi;
	__asm        mov    esi, partPolar;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
// LINE 595:
	psiToZero = parentPolar->psi;
// LINE 596:
	__asm        fld    tmpPolar.psi;
	__asm        fsub   psiToZero;
	__asm        fstp   tmpPolar.psi;
// LINE 600:
	Polar2Cartesian(y, z, x, tmpPolar.psi, tmpPolar.phi, 0x41200000);
// LINE 603:
	Cartesian2Polar(tmprad, tmpPolar2.psi, tmpPolar2.phi, z, y, x);
// LINE 605:
	__asm        fld    tmpPolar2.psi;
	__asm        mov    eax, inc;
	__asm        fsub   dword ptr [eax];
	__asm        fstp   tmpPolar2.psi;
// LINE 607:
	Polar2Cartesian(y2, z2, x2, tmpPolar2.psi, tmpPolar2.phi, tmprad);
// LINE 610:
	Cartesian2Polar(tmprad2, resPolar.psi, resPolar.phi, z2, y2, x2);
// LINE 612:
	__asm        fld    resPolar.psi;
	__asm        fadd   psiToZero;
	__asm        fstp   resPolar.psi;
// LINE 613:
	partPolar->phi = resPolar.phi;
// LINE 614:
	partPolar->psi = resPolar.psi;
// LINE 616:
// Block end:
_T1b1:
	__asm        mov    eax, partPolar;
	__asm        fld    dword ptr [eax+4];
	__asm        mov    eax, inc;
	__asm        fadd   dword ptr [eax+4];
	__asm        mov    eax, partPolar;
	__asm        fstp   dword ptr [eax+4];
// LINE 618:
	Keep0to2pi(partPolar);
// LINE 619:
	return;
}

// FUNCTION: COPTER_D 0x005636d5
void FillLatLngTrq(/*unpacked*/ struct Polar *polar, short latincs, short lngIncs, short trqincs) {
// LINE 624:
	__asm        mov    eax, polar;
	__asm        movsx  eax, word ptr [eax+0x12];
	__asm        test   eax, eax;
	__asm        jne    _T61;

	__asm        mov    eax, polar;
	__asm        movsx  eax, word ptr [eax+0x10];
	__asm        test   eax, eax;
	__asm        jne    _T61;
// LINE 625:
	PolarDouble2Incs((polar + 0x14), (polar + 0x10), (polar + 0x12), reinterpret_cast<uint32_t>(trqincs), reinterpret_cast<uint32_t>(lngIncs), reinterpret_cast<uint32_t>(latincs), polar->tau, polar->psi, polar->phi);
// LINE 627:
_T61:
	Keep0to2pi(polar);
// LINE 628:
	return;
}

// FUNCTION: COPTER_D 0x0056374c
void FillPhiPsiTau(/*unpacked*/ struct Polar *polar, short latincs, short lngIncs, short trqincs) {
// LINE 632:
	__asm        mov    eax, polar;
	__asm        fld    dword ptr [eax];
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 0x40;
	__asm        je     _T71;

	__asm        mov    eax, polar;
	__asm        fld    dword ptr [eax+4];
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 0x40;
	__asm        je     _T71;
// LINE 633:
	__asm        mov    eax, polar;
	__asm        add    eax, 8;
	__asm        push   eax;
	__asm        mov    eax, polar;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        mov    eax, polar;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(trqincs);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(lngIncs);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(latincs);
	__asm        push   eax;
	__asm        mov    eax, polar;
	__asm        mov    ax, [eax+0x14];
	__asm        push   eax;
	__asm        mov    eax, polar;
	__asm        mov    ax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, polar;
	__asm        mov    ax, [eax+0x12];
	__asm        push   eax;
	__asm        call   PolarIncs2Double;
	__asm        add    esp, 0x24;
// LINE 635:
_T71:
	Keep0to2pi(polar);
// LINE 636:
	return;
}

// FUNCTION: COPTER_D 0x005637d3
void SnapToIncs(/*unpacked*/ struct Polar *polar, short latIncs, short lngIncs, short trqIncs) {
// LINE 640:
	polar->trq = 0x0;
	polar->lng = polar->trq;
	polar->lat = polar->lng;
// LINE 641:
	FillLatLngTrq(reinterpret_cast<uint32_t>(trqIncs), reinterpret_cast<uint32_t>(lngIncs), reinterpret_cast<uint32_t>(latIncs), polar);
// LINE 642:
	polar->tau = 0x0;
	polar->psi = polar->tau;
	polar->phi = polar->psi;
// LINE 643:
	FillPhiPsiTau(reinterpret_cast<uint32_t>(trqIncs), reinterpret_cast<uint32_t>(lngIncs), reinterpret_cast<uint32_t>(latIncs), polar);
// LINE 644:
	return;
}

// FUNCTION: COPTER_D 0x00563859
void PolarDouble2Incs(float phi, float psi, float tau, short latincs, short lngincs, short trqincs, short * lat, short * lng, short * trq) {
	/*bp-0x4*/   float dlat;
	/*bp-0x8*/   float dtrq;
	/*bp-0xc*/   float lngsPerRadian;
	/*bp-0x10*/  float dlng;
	/*bp-0x14*/  float latsPerRadian;
	/*bp-0x18*/  float trqsPerRadian;

// LINE 650:
	__asm        movsx  eax, latincs;
	__asm        mov    [ebp-0x20], eax;
	__asm        fild   dword ptr [ebp-0x20];
	__asm        fdiv   dword ptr ds:[0x593760];
	__asm        fstp   latsPerRadian;
// LINE 651:
	__asm        movsx  eax, lngincs;
	__asm        mov    [ebp-0x24], eax;
	__asm        fild   dword ptr [ebp-0x24];
	__asm        fdiv   dword ptr ds:[0x593760];
	__asm        fstp   lngsPerRadian;
// LINE 652:
	__asm        movsx  eax, trqincs;
	__asm        mov    [ebp-0x28], eax;
	__asm        fild   dword ptr [ebp-0x28];
	__asm        fdiv   dword ptr ds:[0x593760];
	__asm        fstp   trqsPerRadian;
// LINE 655:
	Keep0to2pi(phi);
// LINE 656:
	Keep0to2pi(psi);
// LINE 657:
	Keep0to2pi(tau);
// LINE 658:
	__asm        fld    phi;
	__asm        fmul   latsPerRadian;
	__asm        fstp   dlat;
// LINE 659:
	__asm        fld    psi;
	__asm        fmul   lngsPerRadian;
	__asm        fstp   dlng;
// LINE 660:
	__asm        fld    tau;
	__asm        fmul   trqsPerRadian;
	__asm        fstp   dtrq;
// LINE 662:
	lat[0] = Round(dlat);
// LINE 663:
	lng[0] = Round(dlng);
// LINE 664:
	trq[0] = Round(dtrq);
// LINE 665:
	__asm        mov    eax, lat;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, latincs;
	__asm        cmp    eax, ecx;
	__asm        jg     _T117;

	__asm        mov    eax, lng;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, lngincs;
	__asm        cmp    eax, ecx;
	__asm        jg     _T117;

	__asm        mov    eax, trq;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, trqincs;
	__asm        cmp    eax, ecx;
	__asm        jg     _T117;

	__asm        mov    eax, lat;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   eax, eax;
	__asm        jl     _T117;

	__asm        mov    eax, lng;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   eax, eax;
	__asm        jl     _T117;

	__asm        mov    eax, trq;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   eax, eax;
	__asm        jge    _T121;
// LINE 666:
// Block start:
	/*bp-0x1c*/  short trouble;
_T117:
	trouble = trq[0];
// LINE 667:
// Block end:
_T121:
	__asm        mov    eax, lat;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, latincs;
	__asm        cmp    eax, ecx;
	__asm        jne    _T13b;

	lat[0] = 0x0;
// LINE 668:
_T13b:
	__asm        mov    eax, lng;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, lngincs;
	__asm        cmp    eax, ecx;
	__asm        jne    _T155;

	lng[0] = 0x0;
// LINE 669:
_T155:
	__asm        mov    eax, trq;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, trqincs;
	__asm        cmp    eax, ecx;
	__asm        jne    _T16f;

	trq[0] = 0x0;
// LINE 670:
_T16f:
	return;
}

// FUNCTION: COPTER_D 0x005639d2
void PolarIncs2Double(short lat, short lng, short trq, short latincs, short lngincs, short trqincs, float * phi, float * psi, float * tau) {
// LINE 674:
	__asm        movsx  eax, lat;
	__asm        mov    [ebp-4], eax;
	__asm        fild   dword ptr [ebp-4];
	__asm        fmul   qword ptr ds:[0x593758];
	__asm        movsx  eax, latincs;
	__asm        mov    [ebp-8], eax;
	__asm        fidiv  dword ptr [ebp-8];
	__asm        mov    eax, phi;
	__asm        fstp   dword ptr [eax];
// LINE 675:
	__asm        movsx  eax, lng;
	__asm        mov    [ebp-0xC], eax;
	__asm        fild   dword ptr [ebp-0xC];
	__asm        fmul   qword ptr ds:[0x593758];
	__asm        movsx  eax, lngincs;
	__asm        mov    [ebp-0x10], eax;
	__asm        fidiv  dword ptr [ebp-0x10];
	__asm        mov    eax, psi;
	__asm        fstp   dword ptr [eax];
// LINE 676:
	__asm        movsx  eax, trq;
	__asm        mov    [ebp-0x14], eax;
	__asm        fild   dword ptr [ebp-0x14];
	__asm        fmul   qword ptr ds:[0x593758];
	__asm        movsx  eax, trqincs;
	__asm        mov    [ebp-0x18], eax;
	__asm        fidiv  dword ptr [ebp-0x18];
	__asm        mov    eax, tau;
	__asm        fstp   dword ptr [eax];
// LINE 677:
	return;
}

// FUNCTION: COPTER_D 0x00563a42
void Polar2Cartesian(float radius, float phi, float psi, float * x, float * z, float * y) {
	/*bp-0x4*/   float debugpsi;
	/*bp-0x8*/   float debugrad;
	/*bp-0xc*/   float debugphi;
	/*bp-0x10*/  float debugwhatever;

// LINE 686:
	debugphi = phi;
// LINE 687:
	debugpsi = psi;
// LINE 688:
	debugrad = radius;
// LINE 689:
	__asm        fld    debugrad;
	__asm        fadd   debugpsi;
	__asm        fadd   debugphi;
	__asm        fstp   debugwhatever;
// LINE 690:
	__asm        fld    phi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        fstp   qword ptr [ebp-0x18];
	__asm        fld    psi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        fmul   qword ptr [ebp-0x18];
	__asm        fmul   radius;
	__asm        mov    eax, x;
	__asm        fstp   dword ptr [eax];
// LINE 691:
	__asm        fld    phi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F32A;
	__asm        add    esp, 8;
	__asm        fmul   radius;
	__asm        mov    eax, z;
	__asm        fstp   dword ptr [eax];
// LINE 692:
	__asm        fld    phi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        fstp   qword ptr [ebp-0x20];
	__asm        fld    psi;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056F320;
	__asm        add    esp, 8;
	__asm        fmul   qword ptr [ebp-0x20];
	__asm        fmul   radius;
	__asm        mov    eax, y;
	__asm        fstp   dword ptr [eax];
// LINE 693:
	return;
}

// FUNCTION: COPTER_D 0x00563aec
void Polar2Cartesian(float radius, /*unpacked*/ struct Polar *polar, /*unpacked*/ struct DXZY *dxzy) {
// LINE 697:
	Polar2Cartesian((dxzy + 0x8), (dxzy + 0x4), dxzy, polar->psi, polar->phi, radius);
// LINE 698:
	return;
}

// FUNCTION: COPTER_D 0x00563b27
void PolarTransformToScreen(float phiOff, float psiOff, float scale, /*unpacked*/ struct DXZY *donttouch, /*unpacked*/ struct DXZY *origin, short * ptH, short * ptV, short * ptDepth, unsigned short perspective) {
	/*bp-0x4*/   float psi;
	/*bp-0x8*/   float phi;
	/*bp-0xc*/   float radius;
	/*bp-0x1c*/  /*unpacked*/ struct DXZY dpt; // 0x10 bytes

// LINE 703:
	__asm        mov    eax, donttouch;
	__asm        lea    ecx, dpt.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 705:
	Cartesian2Polar(radius, psi, phi, dpt.y, dpt.z, dpt.x);
// LINE 706:
	IncrementAngles(0x1, psi, phi, 0x0, 0x0, psiOff, phiOff);
// LINE 707:
	__asm        fld    scale;
	__asm        fmul   radius;
	__asm        fstp   radius;
// LINE 708:
	Polar2Cartesian(dpt.y, dpt.z, dpt.x, psi, phi, radius);
// LINE 709:
	__asm        test   reinterpret_cast<uint32_t>(perspective), 0xFFFF;
	__asm        je     _Ta7;
// LINE 710:
	PutInPerspective(0x0, dpt.x);
// LINE 711:
_Ta7:
	__asm        cmp    ptH, 0;
	__asm        je     _Tbf;
// LINE 712:
	__asm        fld    dpt.x;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, ptH;
	__asm        mov    [ecx], ax;
// LINE 713:
_Tbf:
	__asm        cmp    ptV, 0;
	__asm        je     _Td7;
// LINE 714:
	__asm        fld    dpt.z;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, ptV;
	__asm        mov    [ecx], ax;
// LINE 715:
_Td7:
	__asm        cmp    ptDepth, 0;
	__asm        je     _Tef;
// LINE 716:
	__asm        fld    dpt.y;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, ptDepth;
	__asm        mov    [ecx], ax;
// LINE 717:
_Tef:
	return;
}

// FUNCTION: COPTER_D 0x00563c20
void Cartesian2Polar(float x, float z, float y, float * phi, float * psi, float * radius) {
	/*bp-0x8*/   double projrad; // 0x8 bytes
	/*bp-0x10*/  double rad; // 0x8 bytes

// LINE 741:
	__asm        mov    eax, y;
	__asm        push   eax;
	__asm        mov    eax, z;
	__asm        push   eax;
	__asm        mov    eax, x;
	__asm        push   eax;
	__asm        call   GetLength;
	__asm        add    esp, 0xC;
	__asm        fstp   rad;
// LINE 745:
	__asm        jmp    _T25;
_T25:
	__asm        jmp    _T2a;
_T2a:
	__asm        fld    rad;
	__asm        fabs;
	__asm        fld    z;
	__asm        fabs;
	__asm        fcompp;
	__asm        fnstsw ax;
	__asm        test   ah, 0x40;
	__asm        je     _T54;
// LINE 746:
	reinterpret_cast<uint32_t>(projrad) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&projrad) + 4) = 0x0;
// LINE 747:
	__asm        jmp    _T73;
// LINE 748:
_T54:
	__asm        fld    rad;
	__asm        fmul   rad;
	__asm        fld    z;
	__asm        fmul   z;
	__asm        fsubp;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   0x0056EC10;
	__asm        add    esp, 8;
	__asm        fstp   projrad;
// LINE 751:
_T73:
	__asm        fld    rad;
	__asm        mov    eax, radius;
	__asm        fstp   dword ptr [eax];
// LINE 752:
	__asm        fld    projrad;
	__asm        sub    esp, 4;
	__asm        fstp   dword ptr [esp];
	__asm        mov    eax, x;
	__asm        push   eax;
	__asm        call   my_acos;
	__asm        add    esp, 8;
	__asm        mov    eax, psi;
	__asm        fstp   dword ptr [eax];
// LINE 753:
	__asm        fld    y;
	__asm        fcomp  dword ptr ds:[0x593750];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _Tb5;
// LINE 754:
	__asm        mov    eax, psi;
	__asm        fld    dword ptr [eax];
	__asm        fchs;
	__asm        mov    eax, psi;
	__asm        fstp   dword ptr [eax];
// LINE 755:
_Tb5:
	__asm        mov    eax, radius;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, z;
	__asm        push   eax;
	__asm        call   my_acos;
	__asm        add    esp, 8;
	__asm        mov    eax, phi;
	__asm        fstp   dword ptr [eax];
// LINE 760:
	return;
}

// FUNCTION: COPTER_D 0x00563cf6
void Cartesian2Polar(/*unpacked*/ struct DXZY dxzy, /*unpacked*/ struct Polar *polar, float * radius) {
// LINE 764:
	Cartesian2Polar(radius, (polar + 0x4), polar, dxzy.y, dxzy.z, dxzy.x);
// LINE 765:
	polar->tau = 0x0;
// LINE 766:
	return;
}

// FUNCTION: COPTER_D 0x00563d33
void IncrementTorque(float dinc, /*unpacked*/ struct Polar *parentPolar, /*unpacked*/ struct Polar *childPolar) {
	/*bp-0x18*/  /*unpacked*/ struct Polar inc; // 0x18 bytes
	/*bp-0x1c*/  float parPhiToZero;
	/*bp-0x34*/  /*unpacked*/ struct Polar parPolar; // 0x18 bytes

// LINE 940:
	__asm        lea    edi, parPolar.phi;
	__asm        mov    esi, parentPolar;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
// LINE 942:
	parPhiToZero = parPolar.phi;
// LINE 943:
	__asm        mov    inc.trq, 0;
	__asm        mov    ax, inc.trq;
	__asm        mov    inc.lng, ax;
	__asm        mov    ax, inc.lng;
	__asm        mov    inc.lat, ax;
	__asm        mov    inc.tau, 0;
	__asm        mov    eax, inc.tau;
	__asm        mov    inc.psi, eax;
	__asm        fld    parPhiToZero;
	__asm        fchs;
	__asm        fstp   inc.phi;
// LINE 944:
	IncrementPhiPsi(childPolar, parPolar.phi, inc.phi);
// LINE 945:
	__asm        fld    parPolar.phi;
	__asm        fsub   parPhiToZero;
	__asm        fstp   parPolar.phi;
// LINE 947:
	__asm        mov    eax, childPolar;
	__asm        fld    dword ptr [eax+4];
	__asm        fadd   dinc;
	__asm        mov    eax, childPolar;
	__asm        fstp   dword ptr [eax+4];
// LINE 948:
	inc.phi = parPhiToZero;
// LINE 950:
	IncrementPhiPsi(childPolar, parPolar.phi, inc.phi);
// LINE 951:
	__asm        fld    parPolar.phi;
	__asm        fadd   parPhiToZero;
	__asm        fstp   parPolar.phi;
// LINE 952:
	return;
}

// FUNCTION: COPTER_D 0x00563dd3
void IncrementXYTorque(float dinc, /*unpacked*/ struct Polar *parentPolar, /*unpacked*/ struct Polar *childPolar) {
	/*bp-0x18*/  /*unpacked*/ struct Polar inc; // 0x18 bytes
	/*bp-0x1c*/  float parY20;
	/*bp-0x20*/  float parX20;
	/*bp-0x38*/  /*unpacked*/ struct Polar parPolar; // 0x18 bytes

// LINE 956:
	__asm        lea    edi, parPolar.phi;
	__asm        mov    esi, parentPolar;
	__asm        mov    ecx, 6;
	__asm        rep movsd;
// LINE 957:
	parX20 = parPolar.phi;
	parY20 = parPolar.psi;
// LINE 958:
	__asm        mov    inc.trq, 0;
	__asm        mov    ax, inc.trq;
	__asm        mov    inc.lng, ax;
	__asm        mov    ax, inc.lng;
	__asm        mov    inc.lat, ax;
	__asm        mov    inc.tau, 0;
	__asm        fld    parY20;
	__asm        fchs;
	__asm        fstp   inc.psi;
	__asm        fld    parX20;
	__asm        fchs;
	__asm        fstp   inc.phi;
// LINE 959:
	IncrementXY(childPolar, inc.phi);
// LINE 960:
	__asm        mov    eax, childPolar;
	__asm        fld    dword ptr [eax+4];
	__asm        fadd   dinc;
	__asm        mov    eax, childPolar;
	__asm        fstp   dword ptr [eax+4];
// LINE 961:
	inc.psi = parY20;
	inc.phi = parX20;
// LINE 962:
	IncrementXY(childPolar, inc.phi);
// LINE 963:
	return;
}

// FUNCTION: COPTER_D 0x00563e67
unsigned short IsPixelFilled(void * __ptr32 h, short x, short y) {
// LINE 1816:
	doAssert(0x8c085, 0x5beef4, 0x718, 0x5bef04);
// LINE 1819:
	return 0x0;
// LINE 1820:
}



// Contribution: 2:00004740-0000479f Module: 187, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00027cd8-00027f23 Module: 187, 4 byte alignment, initialized_data, read, write, 
