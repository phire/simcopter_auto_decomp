// Module: Bods3drw.obj
// Source: C:\Copter\Source\X\Objects\Bods3drw.c
// autogenerated by simcopter_tool from PDB file

// Type: long;

// Type: double;

// Type: int32_t;

// Type: /*unpacked*/ struct _dPoint2d (forward reference);
struct _dPoint2d{ // not packed(0x10 bytes) TI: 0x34b4
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double z; // 0x8 bytes
};

// Type: char *;

// Type: short;

// Type: unsigned char;

// Type: void;

// Type: /*unpacked*/ struct Point3d;
struct Point3d{ // not packed(0xc bytes) TI: 0x348f
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: float;

// Type: /*unpacked*/ struct BmpLineInfo;
struct BmpLineInfo{ // not packed(0x18 bytes) TI: 0x3495
	/*+0x0*/   long width;
	/*+0x4*/   long index;
	/*+0x8*/   double xStride; // 0x8 bytes
	/*+0x10*/  unsigned char * ptr;
};

// Type: unsigned char *;

// Type: /*unpacked*/ struct VRBmpHdr (forward reference);
struct VRBmpHdr{ // not packed(0x10 bytes) TI: 0x34b9
	/*+0x0*/   /*unpacked*/ struct VRBmpInfo info; // 0xc bytes
	/*+0xc*/   int32_t ScanOffset[1];
};

// Type: /*unpacked*/ struct Point3D;
struct Point3D{ // not packed(0x18 bytes) TI: 0x349b
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double y; // 0x8 bytes
	/*+0x10*/  double z; // 0x8 bytes
};

// Type: /*unpacked*/ struct BmpLineInfo (forward reference);
struct BmpLineInfo{ // not packed(0x18 bytes) TI: 0x3495
	/*+0x0*/   long width;
	/*+0x4*/   long index;
	/*+0x8*/   double xStride; // 0x8 bytes
	/*+0x10*/  unsigned char * ptr;
};

// Type: /*unpacked*/ struct Point3d (forward reference);
struct Point3d{ // not packed(0xc bytes) TI: 0x348f
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: char;

// Type: unsigned long;



// Contribution: 1:00162ea0-00164a36 Module: 186, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00563ea0
int32_t Check_Pointer(char * ptr, short numchars, char * text) {
// LINE 119:
	return 0x1;
// LINE 120:
}

// FUNCTION: COPTER_D 0x00563eb5
void MyPixel(int32_t x, int32_t y, unsigned char color) {
	/*bp-0x4*/   char * ptr;

// LINE 148:
	__asm        cmp    x, 0;
	__asm        jl     _T1d;

	__asm        cmp    y, 0;
	__asm        jge    _T22;
_T1d:
	return;
// LINE 149:
_T22:
	__asm        mov    eax, Pwinwidth;
	__asm        dec    eax;
	__asm        cmp    eax, x;
	__asm        jl     _T40;

	__asm        mov    eax, Pwinheight;
	__asm        dec    eax;
	__asm        cmp    eax, y;
	__asm        jge    _T45;
_T40:
	return;
// LINE 151:
_T45:
	ptr = (((y * Pbufwidth) + x) + buffer1);
// LINE 152:
	__asm        push   0x5BEF48;
	__asm        push   1;
	__asm        mov    eax, ptr;
	__asm        push   eax;
	__asm        call   Check_Pointer;
	__asm        add    esp, 0xC;
	__asm        test   eax, eax;
	__asm        jne    _T7b;

	return;
// LINE 153:
_T7b:
	ptr[0] = color;
// LINE 155:
	__asm        cmp    G_video_mode, 0x10;
	__asm        jne    __RETURN;
// LINE 157:
	ptr++;
// LINE 158:
	__asm        push   0x5BEF50;
	__asm        push   1;
	__asm        mov    eax, ptr;
	__asm        push   eax;
	__asm        call   Check_Pointer;
	__asm        add    esp, 0xC;
	__asm        test   eax, eax;
	__asm        jne    _Tb3;

	return;
// LINE 159:
_Tb3:
	ptr[0] = color;
// LINE 160:
	ptr += (Pbufwidth - 1);
// LINE 161:
	__asm        push   0x5BEF58;
	__asm        push   1;
	__asm        mov    eax, ptr;
	__asm        push   eax;
	__asm        call   Check_Pointer;
	__asm        add    esp, 0xC;
	__asm        test   eax, eax;
	__asm        jne    _Te4;

	return;
// LINE 162:
_Te4:
	ptr[0] = color;
// LINE 163:
	ptr++;
// LINE 164:
	__asm        push   0x5BEF60;
	__asm        push   1;
	__asm        mov    eax, ptr;
	__asm        push   eax;
	__asm        call   Check_Pointer;
	__asm        add    esp, 0xC;
	__asm        test   eax, eax;
	__asm        jne    _T10f;

	return;
// LINE 165:
_T10f:
	ptr[0] = color;
// LINE 169:
__RETURN:
}

// FUNCTION: COPTER_D 0x00563fd1
void DrawSphere(/*unpacked*/ struct Point3d centerPt, long diameter, unsigned char color, int32_t shadeFlag) {
	/*bp-0x4*/   int32_t endX;
	/*bp-0x8*/   unsigned char shftCt;
	/*bp-0xa4*/  unsigned char pat[3][51]; // 0x99 bytes
	/*bp-0xac*/  double bandSize; // 0x8 bytes
	/*bp-0xb0*/  unsigned char hiColor;
	/*bp-0xb4*/  int32_t radiusSquared;
	/*bp-0xb8*/  long i;
	/*bp-0xbc*/  long j;
	/*bp-0xc0*/  long ditherLimit;
	/*bp-0xc4*/  long radius;
	/*bp-0xf8*/  unsigned char shade[51]; // 0x33 bytes
	/*bp-0xfc*/  int32_t startX;
	/*bp-0x100*/ int32_t xOffset;
	/*bp-0x104*/ int32_t lineY;

// LINE 189:
	shftCt = 0x0;
// LINE 191:
	__asm        cmp    diameter, 0;
	__asm        jne    _T1f;
// LINE 192:
	return;
// LINE 194:
_T1f:
	__asm        cmp    diameter, 0x33;
	__asm        jle    _T2e;
// LINE 195:
	return;
// LINE 198:
_T2e:
	__asm        cmp    diameter, 3;
	__asm        jge    _T3f;
// LINE 199:
	shadeFlag = 0x0;
// LINE 201:
_T3f:
	__asm        cmp    shadeFlag, 2;
	__asm        jne    _T7c;

	__asm        fld    qword ptr ds:[0x5939B0];
	__asm        fdiv   G_figureShadeSpread;
	__asm        mov    eax, diameter;
	__asm        mov    [ebp-0x108], eax;
	__asm        fimul  dword ptr [ebp-0x108];
	__asm        call   __ftol;
	__asm        sub    eax, 2;
	__asm        cmp    eax, 1;
	__asm        jge    _T7c;
// LINE 202:
	shadeFlag = 0x1;
// LINE 204:
_T7c:
	__asm        mov    eax, diameter;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    radius, eax;
// LINE 205:
	radiusSquared = (radius * radius);
// LINE 207:
	__asm        cmp    shadeFlag, 1;
	__asm        jne    _T12a;
// LINE 209:
_FOR_b7:
	for (i = 0x0; (i < diameter); i++) {
// LINE 210:
		__asm        mov    eax, i;
		__asm        mov    [ebp-0x10C], eax;
		__asm        fild   dword ptr [ebp-0x10C];
		__asm        mov    eax, diameter;
		__asm        dec    eax;
		__asm        mov    [ebp-0x110], eax;
		__asm        fidiv  dword ptr [ebp-0x110];
		__asm        fmul   G_figureShadeSpread;
		__asm        call   __ftol;
		__asm        xor    ecx, ecx;
		__asm        mov    cl, color;
		__asm        add    eax, ecx;
		__asm        mov    ecx, i;
		__asm        mov    [ebp+ecx-0xF8], al;
		__asm        jmp    _FOR_NEXT_b7;
	}
// LINE 212:
_T112:
	__asm        mov    eax, radius;
	__asm        mov    al, [ebp+eax-0xF8];
	__asm        mov    hiColor, al;
// LINE 214:
	__asm        jmp    _T2f2;
_T12a:
	__asm        cmp    shadeFlag, 2;
	__asm        jne    _T2f2;
// LINE 216:
_FOR_143:
	for (i = 0x0; (i < diameter); i++) {
// LINE 217:
		__asm        mov    eax, i;
		__asm        mov    [ebp-0x114], eax;
		__asm        fild   dword ptr [ebp-0x114];
		__asm        mov    eax, diameter;
		__asm        dec    eax;
		__asm        mov    [ebp-0x118], eax;
		__asm        fidiv  dword ptr [ebp-0x118];
		__asm        fmul   G_figureShadeSpread;
		__asm        call   __ftol;
		__asm        xor    ecx, ecx;
		__asm        mov    cl, color;
		__asm        add    eax, ecx;
		__asm        mov    ecx, i;
		__asm        mov    [ebp+ecx-0xF8], al;
		__asm        jmp    _FOR_NEXT_143;
	}
// LINE 219:
_T19e:
	__asm        mov    eax, radius;
	__asm        mov    al, [ebp+eax-0xF8];
	__asm        mov    hiColor, al;
// LINE 223:
_FOR_1c0:
	for (j = 0x0; (j < diameter); j += 0x6) {
// LINE 225:
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0xA4], al;
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0xA3], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0xA2], al;
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0xA1], al;
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0xA0], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x9F], al;
// LINE 226:
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x71], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x70], al;
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x6F], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x6E], al;
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x6D], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x6C], al;
// LINE 227:
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x3E], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x3D], al;
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x3C], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x3B], al;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        inc    eax;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x3A], al;
		__asm        mov    al, color;
		__asm        mov    ecx, j;
		__asm        mov    [ebp+ecx-0x39], al;
	}
// LINE 231:
_T2f2:
	__asm        cmp    shadeFlag, 1;
	__asm        jne    _T430;
// LINE 233:
_FOR_30b:
	for (i = 0x0; (i < radius); i++) {
// LINE 236:
		__asm        mov    eax, radiusSquared;
		__asm        mov    ecx, radius;
		__asm        sub    ecx, i;
		__asm        mov    edx, radius;
		__asm        sub    edx, i;
		__asm        imul   ecx, edx;
		__asm        sub    eax, ecx;
		__asm        mov    eax, g_sqrtTable[eax*4];
		__asm        mov    xOffset, eax;
// LINE 240:
		startX = (centerPt.x - xOffset);
// LINE 241:
		endX = (centerPt.x + xOffset);
// LINE 242:
		lineY = (((radius - i) + centerPt.y) - 1);
// LINE 243:
		__asm        mov    eax, i;
		__asm        mov    eax, [ebp+eax-0xF8];
		__asm        push   eax;
		__asm        mov    eax, lineY;
		__asm        push   eax;
		__asm        mov    eax, endX;
		__asm        push   eax;
		__asm        mov    eax, startX;
		__asm        push   eax;
		__asm        call   DrawHorzLine;
		__asm        add    esp, 0x10;
// LINE 245:
		lineY = (centerPt.y - (radius - i));
// LINE 246:
		__asm        mov    eax, diameter;
		__asm        sub    eax, i;
		__asm        mov    eax, [ebp+eax-0xF8];
		__asm        push   eax;
		__asm        mov    eax, lineY;
		__asm        push   eax;
		__asm        mov    eax, endX;
		__asm        push   eax;
		__asm        mov    eax, startX;
		__asm        push   eax;
		__asm        call   DrawHorzLine;
		__asm        add    esp, 0x10;
	}
// LINE 249:
_T3f3:
	__asm        test   reinterpret_cast<uint8_t>(diameter), 1;
	__asm        je     _T42b;
// LINE 250:
	__asm        mov    eax, radius;
	__asm        mov    eax, [ebp+eax-0xF8];
	__asm        push   eax;
	__asm        mov    eax, centerPt.y;
	__asm        push   eax;
	__asm        mov    eax, centerPt.x;
	__asm        add    eax, radius;
	__asm        push   eax;
	__asm        mov    eax, centerPt.x;
	__asm        sub    eax, radius;
	__asm        push   eax;
	__asm        call   DrawHorzLine;
	__asm        add    esp, 0x10;
// LINE 252:
_T42b:
	return;
_T430:
	__asm        cmp    shadeFlag, 2;
	__asm        jne    _FOR_69b;
// LINE 254:
	__asm        fld    qword ptr ds:[0x5939B0];
	__asm        fdiv   G_figureShadeSpread;
	__asm        mov    eax, diameter;
	__asm        mov    [ebp-0x11C], eax;
	__asm        fimul  dword ptr [ebp-0x11C];
// LINE 255:
	__asm        fcom   qword ptr ds:[0x5939B0];
	__asm        fstp   bandSize;
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T480;
// LINE 256:
	reinterpret_cast<uint32_t>(bandSize) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&bandSize) + 4) = 0x3ff00000;
// LINE 258:
_T480:
	__asm        fld    bandSize;
	__asm        fcomp  qword ptr ds:[0x5939B8];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T4b0;
// LINE 259:
	__asm        fld    bandSize;
	__asm        call   __ftol;
	__asm        sub    eax, 2;
	__asm        mov    ditherLimit, eax;
// LINE 260:
	__asm        jmp    _T4ba;
// LINE 261:
_T4b0:
	ditherLimit = 0x2;
// LINE 263:
_T4ba:
	i = 0x0;
__WHILE_4c4:
	while ((i < diameter)) {
// LINE 265:
		__asm        fld    bandSize;
		__asm        call   __ftol;
		__asm        mov    ebx, eax;
		__asm        fld    bandSize;
		__asm        call   __ftol;
		__asm        mov    ecx, eax;
		__asm        mov    eax, i;
		__asm        cdq;
		__asm        idiv   ecx;
		__asm        sub    ebx, edx;
		__asm        cmp    ebx, ditherLimit;
		__asm        jne    _T5f5;
// LINE 267:
_FOR_513:
		for (j = 0x0; (ditherLimit >= j); j++) {
// LINE 270:
			__asm        mov    eax, radiusSquared;
			__asm        mov    ecx, radius;
			__asm        sub    ecx, i;
			__asm        mov    edx, radius;
			__asm        sub    edx, i;
			__asm        imul   ecx, edx;
			__asm        sub    eax, ecx;
			__asm        mov    eax, g_sqrtTable[eax*4];
			__asm        mov    xOffset, eax;
// LINE 274:
			startX = (centerPt.x - xOffset);
// LINE 275:
			endX = (centerPt.x + xOffset);
// LINE 276:
			lineY = ((radius - i) + centerPt.y);
// LINE 278:
			__asm        mov    eax, diameter;
			__asm        cmp    i, eax;
			__asm        jge    _T5e3;
// LINE 280:
			__asm        push   0x3FF00000;
			__asm        push   0;
			__asm        mov    eax, reinterpret_cast<uint32_t>(shftCt);
			__asm        push   eax;
			__asm        mov    eax, j;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [ecx+eax*2];
			__asm        lea    eax, [ebp+eax-0xA4];
			__asm        push   eax;
			__asm        mov    eax, lineY;
			__asm        push   eax;
			__asm        mov    eax, endX;
			__asm        push   eax;
			__asm        mov    eax, startX;
			__asm        push   eax;
			__asm        call   DrawHorzLinePat;
			__asm        add    esp, 0x1C;
// LINE 281:
			i++;
// LINE 283:
			__asm        jmp    _T5e8;
// LINE 285:
_T5e3:
			return;
// LINE 287:
_T5e8:
		}
// LINE 288:
_T5ed:
		shftCt++;
// LINE 290:
		__asm        jmp    _T682;
// LINE 293:
_T5f5:
		__asm        mov    eax, radiusSquared;
		__asm        mov    ecx, radius;
		__asm        sub    ecx, i;
		__asm        mov    edx, radius;
		__asm        sub    edx, i;
		__asm        imul   ecx, edx;
		__asm        sub    eax, ecx;
		__asm        mov    eax, g_sqrtTable[eax*4];
		__asm        mov    xOffset, eax;
// LINE 297:
		startX = (centerPt.x - xOffset);
// LINE 298:
		endX = (centerPt.x + xOffset);
// LINE 299:
		lineY = ((radius - i) + centerPt.y);
// LINE 301:
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        xor    ecx, ecx;
		__asm        mov    cl, shftCt;
		__asm        add    eax, ecx;
		__asm        push   eax;
		__asm        mov    eax, lineY;
		__asm        push   eax;
		__asm        mov    eax, endX;
		__asm        push   eax;
		__asm        mov    eax, startX;
		__asm        push   eax;
		__asm        call   DrawHorzLine;
		__asm        add    esp, 0x10;
// LINE 302:
		i++;
// LINE 304:
_T682:
	}
// LINE 306:
_T687:
	return;
// LINE 308:
_FOR_69b:
	for (i = 0x0; (i < radius); i++) {
// LINE 311:
		__asm        mov    eax, radiusSquared;
		__asm        mov    ecx, radius;
		__asm        sub    ecx, i;
		__asm        mov    edx, radius;
		__asm        sub    edx, i;
		__asm        imul   ecx, edx;
		__asm        sub    eax, ecx;
		__asm        mov    eax, g_sqrtTable[eax*4];
		__asm        mov    xOffset, eax;
// LINE 315:
		startX = (centerPt.x - xOffset);
// LINE 316:
		endX = (centerPt.x + xOffset);
// LINE 317:
		lineY = (((radius - i) + centerPt.y) - 1);
// LINE 318:
		DrawHorzLine(startX, endX, lineY, color);
// LINE 320:
		lineY = (centerPt.y - (radius - i));
// LINE 321:
		DrawHorzLine(startX, endX, lineY, color);
	}
// LINE 324:
_T76c:
	__asm        test   reinterpret_cast<uint8_t>(diameter), 1;
	__asm        je     __RETURN;
// LINE 325:
	DrawHorzLine((centerPt.x - radius), (centerPt.x + radius), centerPt.y, color);
// LINE 328:
__RETURN:
}

// FUNCTION: COPTER_D 0x00564770
void DrawFaceTwo(/*unpacked*/ struct Point3d centerPt, long vertRad, float psi, double scaleFactor, short facenum) {
	/*bp-0x4*/   long yScanLine;
	/*bp-0x10*/  /*unpacked*/ struct Point3d faceCenter; // 0xc bytes
	/*bp-0x18*/  double aSquared; // 0x8 bytes
	/*bp-0x1c*/  long endX;
	/*bp-0x20*/  /*unpacked*/ struct VRBmpHdr *bhdr;
	/*bp-0x28*/  double bSquared; // 0x8 bytes
	/*bp-0x2c*/  unsigned char * pixPtr;
	/*bp-0x38*/  /*unpacked*/ struct Point3d offset; // 0xc bytes
	/*bp-0x3c*/  long i;
	/*bp-0x54*/  /*unpacked*/ struct BmpLineInfo pixLine; // 0x18 bytes
	/*bp-0x58*/  long startX;
	/*bp-0x60*/  double yStride; // 0x8 bytes
	/*bp-0x64*/  long yLine;

// LINE 416:
	bhdr = 0x0;
// LINE 422:
	__asm        cmp    vertRad, 0;
	__asm        jne    _T1f;
// LINE 423:
	return;
// LINE 425:
_T1f:
	__asm        movsx  eax, facenum;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T48;

	doAssert(0x5bef90, 0x1a9, 0x5bef68, 0x8c085);
// LINE 431:
_T48:
	bhdr = VRInt2BmpHdr(G_restex, reinterpret_cast<int16_t>(facenum));
// LINE 432:
	__asm        cmp    bhdr, 0;
	__asm        jne    _T84;

	doAssert(0x5befdc, 0x1b0, 0x5befb8, 0x8c085);
// LINE 434:
_T84:
	pixPtr = bhdr;
// LINE 435:
	pixPtr += ((bhdr->info.height << 0x2) + 0xc);
// LINE 440:
	FindFaceQuadrant2(bhdr, psi, faceCenter.x);
// LINE 444:
	faceCenter.y = 0xc;
// LINE 447:
	__asm        mov    eax, vertRad;
	__asm        imul   eax, vertRad;
	__asm        mov    [ebp-0x68], eax;
	__asm        fild   dword ptr [ebp-0x68];
	__asm        fst    bSquared;
// LINE 448:
	__asm        fmul   G_figureHeadShapeRatio;
	__asm        fmul   G_figureHeadShapeRatio;
	__asm        fstp   aSquared;
// LINE 450:
	pixLine.width = 0x34;
// LINE 451:
	__asm        fld    qword ptr ds:[0x5939B0];
	__asm        fdiv   scaleFactor;
	__asm        fstp   pixLine.xStride;
// LINE 453:
	__asm        mov    eax, vertRad;
	__asm        mov    [ebp-0x6C], eax;
	__asm        fild   dword ptr [ebp-0x6C];
	__asm        fmul   qword ptr ds:[0x5939C0];
	__asm        fdivr  qword ptr ds:[0x5939C8];
	__asm        fstp   yStride;
// LINE 455:
_FOR_10a:
	for (i = 0x0; (vertRad > i); i++) {
// LINE 459:
		__asm        mov    eax, vertRad;
		__asm        sub    eax, i;
		__asm        mov    ecx, vertRad;
		__asm        sub    ecx, i;
		__asm        imul   eax, ecx;
		__asm        mov    [ebp-0x70], eax;
		__asm        fild   dword ptr [ebp-0x70];
		__asm        fdiv   bSquared;
		__asm        fsubr  qword ptr ds:[0x5939B0];
		__asm        fmul   aSquared;
		__asm        call   __ftol;
		__asm        mov    eax, g_sqrtTable[eax*4];
		__asm        mov    offset.x, eax;
// LINE 463:
		startX = (centerPt.x - offset.x);
// LINE 464:
		endX = (centerPt.x + offset.x);
// LINE 465:
		offset.y = (vertRad - i);
// LINE 466:
		__asm        mov    eax, offset.y;
		__asm        mov    [ebp-0x74], eax;
		__asm        fild   dword ptr [ebp-0x74];
		__asm        fmul   yStride;
		__asm        call   __ftol;
		__asm        mov    yScanLine, eax;
// LINE 467:
		yLine = (centerPt.y + offset.y);
// LINE 469:
		pixLine.ptr = (((faceCenter.y - yScanLine) * pixLine.width) + pixPtr);
// LINE 470:
		DrawLineOnFace(startX, endX, yLine, offset.x, offset.y, offset.z, faceCenter.x, faceCenter.y, faceCenter.z, pixLine.width);
// LINE 473:
		yLine = (centerPt.y - offset.y);
// LINE 474:
		pixLine.ptr = (((faceCenter.y + yScanLine) * pixLine.width) + pixPtr);
// LINE 475:
		DrawLineOnFace(startX, endX, yLine, offset.x, offset.y, offset.z, faceCenter.x, faceCenter.y, faceCenter.z, pixLine.width);
	}
// LINE 478:
_T20f:
	pixLine.ptr = ((faceCenter.y * pixLine.width) + pixPtr);
// LINE 479:
	DrawLineOnFace(startX, endX, centerPt.y, offset.x, offset.y, offset.z, faceCenter.x, faceCenter.y, faceCenter.z, pixLine.width);
// LINE 482:
}

// FUNCTION: COPTER_D 0x005649c1
long ComputeViewToFigureOffset(/*unpacked*/ struct Point3D view, int32_t index) {
// LINE 516:
	return 0x0;
// LINE 517:
}

// FUNCTION: COPTER_D 0x005649d3
void DrawLineOnFace(long startX, long endX, long yLine, /*unpacked*/ struct Point3d offset, /*unpacked*/ struct Point3d faceCenter, /*unpacked*/ struct BmpLineInfo *pixLine) {
	/*bp-0x4*/   unsigned char * ptr;
	/*bp-0x8*/   long end;
	/*bp-0xc*/   long hiBitmapLimit;
	/*bp-0x10*/  long begin;
	/*bp-0x1c*/  /*unpacked*/ struct Point3d scaledOffset; // 0xc bytes
	/*bp-0x20*/  long loBitmapLimit;

// LINE 536:
	__asm        mov    eax, offset.x;
	__asm        mov    [ebp-0x24], eax;
	__asm        fild   dword ptr [ebp-0x24];
	__asm        mov    eax, pixLine;
	__asm        fmul   qword ptr [eax+8];
	__asm        call   __ftol;
	__asm        mov    scaledOffset.x, eax;
// LINE 537:
	loBitmapLimit = (faceCenter.x - scaledOffset.x);
// LINE 538:
	hiBitmapLimit = (faceCenter.x + scaledOffset.x);
// LINE 541:
	__asm        cmp    loBitmapLimit, 0;
	__asm        jl     _T83;

	__asm        mov    eax, pixLine;
	__asm        mov    ecx, hiBitmapLimit;
	__asm        cmp    [eax], ecx;
	__asm        jle    _T83;
// LINE 543:
	ptr = ((faceCenter.x - scaledOffset.x) + pixLine->ptr);
// LINE 544:
	DrawHorzLinePat(startX, endX, yLine, ptr, 0x0, reinterpret_cast<uint32_t>(pixLine->xStride), *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&pixLine->xStride) + 4));
// LINE 546:
	return;
_T83:
	__asm        cmp    loBitmapLimit, 0;
	__asm        jge    _Ta5;

	__asm        mov    eax, pixLine;
	__asm        mov    ecx, hiBitmapLimit;
	__asm        cmp    [eax], ecx;
	__asm        jge    _Ta5;
// LINE 548:
	return;
// LINE 550:
	return;
_Ta5:
	__asm        cmp    loBitmapLimit, 0;
	__asm        jge    _T14b;
// LINE 552:
	ptr = (((faceCenter.x - scaledOffset.x) + pixLine->width) + pixLine->ptr);
// LINE 553:
	begin = startX;
// LINE 555:
	__asm        mov    eax, loBitmapLimit;
	__asm        neg    eax;
	__asm        mov    [ebp-0x28], eax;
	__asm        fild   dword ptr [ebp-0x28];
	__asm        mov    eax, pixLine;
	__asm        fdiv   qword ptr [eax+8];
	__asm        call   __ftol;
	__asm        mov    ecx, startX;
	__asm        add    ecx, eax;
	__asm        mov    end, ecx;
// LINE 556:
	DrawHorzLinePat(begin, end, yLine, ptr, 0x0, reinterpret_cast<uint32_t>(pixLine->xStride), *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&pixLine->xStride) + 4));
// LINE 558:
	ptr = pixLine->ptr;
// LINE 559:
	begin = end;
// LINE 560:
	end = endX;
// LINE 561:
	DrawHorzLinePat(begin, end, yLine, ptr, 0x0, reinterpret_cast<uint32_t>(pixLine->xStride), *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&pixLine->xStride) + 4));
// LINE 563:
	return;
// LINE 565:
_T14b:
	ptr = ((faceCenter.x - scaledOffset.x) + pixLine->ptr);
// LINE 566:
	begin = startX;
// LINE 567:
	__asm        mov    eax, pixLine;
	__asm        mov    eax, [eax];
	__asm        sub    eax, loBitmapLimit;
	__asm        mov    [ebp-0x2C], eax;
	__asm        fild   dword ptr [ebp-0x2C];
	__asm        mov    eax, pixLine;
	__asm        fdiv   qword ptr [eax+8];
	__asm        call   __ftol;
	__asm        mov    ecx, startX;
	__asm        add    ecx, eax;
	__asm        mov    end, ecx;
// LINE 568:
	DrawHorzLinePat(begin, end, yLine, ptr, 0x0, reinterpret_cast<uint32_t>(pixLine->xStride), *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&pixLine->xStride) + 4));
// LINE 570:
	ptr = pixLine->ptr;
// LINE 571:
	begin = end;
// LINE 572:
	end = endX;
// LINE 573:
	DrawHorzLinePat(begin, end, yLine, ptr, 0x0, reinterpret_cast<uint32_t>(pixLine->xStride), *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&pixLine->xStride) + 4));
// LINE 576:
}

// FUNCTION: COPTER_D 0x00564bb8
void FindFaceQuadrant(/*unpacked*/ struct VRBmpHdr *bhdr, long dir, /*unpacked*/ struct Point3D viewPos, /*unpacked*/ struct Point3d *faceCenter) {
	/*bp-0x8*/   double widthOverTwo; // 0x8 bytes

// LINE 586:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xC], eax;
	__asm        fild   dword ptr [ebp-0xC];
	__asm        fdiv   qword ptr ds:[0x5939C0];
	__asm        fstp   widthOverTwo;
// LINE 588:
	dir -= 0x6;
// LINE 589:
	__asm        cmp    dir, 0xFFFFFFFD;
	__asm        jge    _T2f;
// LINE 590:
	dir += 0x8;
// LINE 592:
_T2f:
	__asm        mov    eax, dir;
	__asm        mov    [ebp-0x10], eax;
	__asm        fild   dword ptr [ebp-0x10];
	__asm        fmul   widthOverTwo;
	__asm        fdiv   qword ptr ds:[0x5939B8];
	__asm        fsubr  widthOverTwo;
	__asm        call   __ftol;
	__asm        mov    ecx, faceCenter;
	__asm        mov    [ecx], eax;
// LINE 594:
	return;
// LINE 595:
}

// FUNCTION: COPTER_D 0x00564c10
void FindFaceQuadrant2(/*unpacked*/ struct VRBmpHdr *bhdr, float psi, /*unpacked*/ struct Point3d *faceCenter) {
	/*bp-0x8*/   double mydir; // 0x8 bytes
	/*bp-0x10*/  double widthOverTwo; // 0x8 bytes

// LINE 604:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x14], eax;
	__asm        fild   dword ptr [ebp-0x14];
	__asm        fdiv   qword ptr ds:[0x5939C0];
// LINE 605:
	__asm        fcom   qword ptr ds:[0x5939D0];
	__asm        fstp   widthOverTwo;
	__asm        fnstsw ax;
	__asm        test   ah, 0x40;
	__asm        jne    _T4a;

	doAssert(0x5bf014, 0x25d, 0x5bf004, 0x8c085);
// LINE 610:
_T4a:
	__asm        fld    psi;
	__asm        fcomp  dword ptr ds:[0x5939D8];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        jne    _T72;

	__asm        fld    psi;
	__asm        fcomp  qword ptr ds:[0x5939E0];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        jne    _T8e;
_T72:
	doAssert(0x5bf050, 0x262, 0x5bf03c, 0x8c085);
// LINE 611:
_T8e:
	__asm        fld    psi;
	__asm        fmul   dword ptr ds:[0x5939E8];
	__asm        fdiv   qword ptr ds:[0x5939E0];
	__asm        fst    mydir;
// LINE 612:
	__asm        fsub   qword ptr ds:[0x5939F0];
// LINE 613:
	__asm        fcom   qword ptr ds:[0x5939F8];
	__asm        fstp   mydir;
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _Tc6;
// LINE 614:
	__asm        fld    mydir;
	__asm        fadd   qword ptr ds:[0x593A00];
	__asm        fstp   mydir;
// LINE 615:
_Tc6:
	__asm        fld    mydir;
	__asm        fcomp  qword ptr ds:[0x5939F8];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _Te8;

	reinterpret_cast<uint32_t>(mydir) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&mydir) + 4) = 0xc0080000;
// LINE 616:
_Te8:
	__asm        fld    mydir;
	__asm        fcomp  qword ptr ds:[0x5939B8];
	__asm        fnstsw ax;
	__asm        test   ah, 0x41;
	__asm        jne    _T10a;

	reinterpret_cast<uint32_t>(mydir) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&mydir) + 4) = 0x40100000;
// LINE 626:
_T10a:
	__asm        fld    mydir;
	__asm        fmul   widthOverTwo;
	__asm        fdiv   qword ptr ds:[0x5939B8];
	__asm        fsubr  widthOverTwo;
	__asm        call   __ftol;
	__asm        mov    ecx, faceCenter;
	__asm        mov    [ecx], eax;
// LINE 627:
	__asm        mov    eax, faceCenter;
	__asm        cmp    dword ptr [eax], 0x34;
	__asm        jl     _T14b;

	doAssert(0x5bf0a8, 0x273, 0x5bf078, 0x8c085);
// LINE 628:
_T14b:
	__asm        mov    eax, faceCenter;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jge    _T173;

	doAssert(0x5bf100, 0x274, 0x5bf0d0, 0x8c085);
// LINE 630:
_T173:
	return;
// LINE 631:
}

// FUNCTION: COPTER_D 0x00564d8d
void DrawTaperedLine(/*unpacked*/ struct Point3d startPt, /*unpacked*/ struct Point3d endPt, long taper, unsigned char color, long width) {
	/*bp-0x1c*/  char col[26]; // 0x1a bytes
	/*bp-0x20*/  long endWidth;
	/*bp-0x24*/  char * writeBuffer;
	/*bp-0x2c*/  double colorLimit; // 0x8 bytes
	/*bp-0x30*/  char * writeBufferTmp;
	/*bp-0x34*/  long segLen;
	/*bp-0x38*/  long fourByteWrites;
	/*bp-0x3c*/  long oneByteWrites;
	/*bp-0x40*/  long i;
	/*bp-0x44*/  long longColor;
	/*bp-0x48*/  long j;
	/*bp-0x4c*/  long xInc;
	/*bp-0x50*/  long tapWidth;
	/*bp-0x54*/  long yInc;
	/*bp-0x5c*/  double step; // 0x8 bytes
	/*bp-0x60*/  long cInc;
	/*bp-0x64*/  long error;
	/*bp-0x68*/  long startWidth;
	/*bp-0x6c*/  long dx;
	/*bp-0x70*/  long dy;

// LINE 648:
	error = 0x0;
// LINE 656:
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&colorLimit) + 4) = *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&G_figureShadeSpread) + 4);
	reinterpret_cast<uint32_t>(colorLimit) = reinterpret_cast<uint32_t>(G_figureShadeSpread);
// LINE 659:
	__asm        cmp    width, 0x19;
	__asm        jle    _T32;
// LINE 660:
	return;
// LINE 662:
_T32:
	__asm        cmp    width, 0;
	__asm        jne    _T41;
// LINE 663:
	return;
// LINE 666:
_T41:
	__asm        cmp    taper, 0;
	__asm        jne    _T52;
// LINE 667:
	taper = 0x1;
// LINE 669:
_T52:
	__asm        mov    eax, taper;
	__asm        cmp    width, eax;
	__asm        jne    _FOR_6d;
// LINE 670:
	width++;
// LINE 677:
_FOR_6d:
	for (i = 0x0; (width > i); i++) {
// LINE 679:
		__asm        fld    colorLimit;
		__asm        mov    eax, width;
		__asm        mov    [ebp-0x7C], eax;
		__asm        fidiv  dword ptr [ebp-0x7C];
		__asm        fstp   step;
// LINE 680:
		__asm        cmp    i, 0x1A;
		__asm        jl     _Tb1;

		doAssert(0x5bf174, 0x2a8, 0x5bf128, 0x8c085);
// LINE 681:
_Tb1:
		__asm        mov    eax, i;
		__asm        mov    [ebp-0x80], eax;
		__asm        fild   dword ptr [ebp-0x80];
		__asm        fmul   step;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        mov    [ebp-0x84], eax;
		__asm        fiadd  dword ptr [ebp-0x84];
		__asm        call   __ftol;
		__asm        mov    ecx, i;
		__asm        mov    [ebp+ecx-0x1C], al;
	}
// LINE 685:
_Tdf:
	__asm        cmp    startPt.x, 0;
	__asm        jl     _Tf3;

	__asm        cmp    endPt.x, 0;
	__asm        jge    _Tf8;
// LINE 686:
_Tf3:
	return;
// LINE 687:
_Tf8:
	__asm        cmp    startPt.y, 0;
	__asm        jl     _T10c;

	__asm        cmp    endPt.y, 0;
	__asm        jge    _T111;
// LINE 688:
_T10c:
	return;
// LINE 689:
_T111:
	__asm        mov    eax, Pwinwidth;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, startPt.x;
	__asm        jl     _T139;

	__asm        mov    eax, Pwinwidth;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, endPt.x;
	__asm        jge    _T13e;
// LINE 690:
_T139:
	return;
// LINE 691:
_T13e:
	__asm        mov    eax, Pwinheight;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, startPt.y;
	__asm        jl     _T166;

	__asm        mov    eax, Pwinheight;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, endPt.y;
	__asm        jge    _T16b;
// LINE 692:
_T166:
	return;
// LINE 695:
_T16b:
	dx = (endPt.x - startPt.x);
// LINE 696:
	dy = (endPt.y - startPt.y);
// LINE 699:
	__asm        cmp    dx, 0;
	__asm        jl     _T193;
// LINE 700:
	xInc = 0x1;
// LINE 701:
	__asm        jmp    _T1a2;
// LINE 703:
_T193:
	xInc = 0xffffffff;
// LINE 704:
	dx = -dx;
// LINE 707:
_T1a2:
	__asm        cmp    dy, 0;
	__asm        jl     _T1b9;
// LINE 708:
	yInc = Pbufwidth;
// LINE 709:
	__asm        jmp    _T1cb;
// LINE 711:
_T1b9:
	yInc = -Pbufwidth;
// LINE 712:
	dy = -dy;
// LINE 717:
_T1cb:
	__asm        mov    eax, dx;
	__asm        cmp    dy, eax;
	__asm        jge    _T2d8;
// LINE 720:
	__asm        mov    ecx, startPt.y;
	__asm        mov    eax, width;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        imul   ecx, Pbufwidth;
	__asm        add    ecx, startPt.x;
	__asm        add    ecx, buffer1;
	__asm        mov    writeBuffer, ecx;
// LINE 722:
	__asm        mov    eax, dx;
	__asm        mov    ecx, taper;
	__asm        inc    ecx;
	__asm        inc    eax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    segLen, eax;
// LINE 723:
	__asm        cmp    segLen, 1;
	__asm        jge    _FOR_221;

	return;
// LINE 725:
_FOR_221:
	for (i = 0x0; (i < dx); i++) {
// LINE 727:
		writeBufferTmp = writeBuffer;
// LINE 731:
		__asm        mov    eax, i;
		__asm        cdq;
		__asm        idiv   segLen;
		__asm        mov    startWidth, eax;
// LINE 735:
		endWidth = (width - startWidth);
// LINE 736:
		writeBufferTmp += (startWidth * Pbufwidth);
// LINE 738:
_FOR_261:
		for (j = startWidth; (endWidth > j); j++) {
// LINE 740:
			__asm        push   0;
			__asm        push   1;
			__asm        mov    eax, writeBufferTmp;
			__asm        push   eax;
			__asm        call   Check_Pointer;
			__asm        add    esp, 0xC;
			__asm        test   eax, eax;
			__asm        jne    _T28d;

			return;
// LINE 741:
_T28d:
			__asm        mov    eax, j;
			__asm        mov    al, [ebp+eax-0x1C];
			__asm        mov    ecx, writeBufferTmp;
			__asm        mov    [ecx], al;
// LINE 742:
			writeBufferTmp += Pbufwidth;
		}
// LINE 745:
_T2a6:
		error += dy;
// LINE 746:
		__asm        mov    eax, dx;
		__asm        cmp    error, eax;
		__asm        jle    _T2c8;
// LINE 748:
		error -= dx;
// LINE 749:
		writeBuffer += yInc;
// LINE 751:
_T2c8:
		writeBuffer += xInc;
	}
// LINE 754:
_T2d3:
	return;
// LINE 756:
_T2d8:
	__asm        mov    ecx, startPt.x;
	__asm        mov    eax, width;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    eax, startPt.y;
	__asm        imul   eax, Pbufwidth;
	__asm        add    ecx, eax;
	__asm        add    ecx, buffer1;
	__asm        mov    writeBuffer, ecx;
// LINE 758:
	__asm        mov    eax, dy;
	__asm        mov    ecx, taper;
	__asm        inc    ecx;
	__asm        inc    eax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    segLen, eax;
// LINE 759:
	__asm        cmp    segLen, 1;
	__asm        jge    _T318;

	return;
// LINE 761:
_T318:
	__asm        cmp    segLen, 0;
	__asm        jne    _FOR_335;
// LINE 762:
	segLen = 0x1;
// LINE 764:
_FOR_335:
	for (i = 0x0; (i < dy); i++) {
// LINE 766:
		writeBufferTmp = writeBuffer;
// LINE 775:
		__asm        mov    eax, i;
		__asm        cdq;
		__asm        idiv   segLen;
		__asm        mov    startWidth, eax;
// LINE 776:
		endWidth = (width - startWidth);
// LINE 777:
		tapWidth = (endWidth - startWidth);
// LINE 778:
		writeBufferTmp += startWidth;
// LINE 780:
		cInc = startWidth;
// LINE 786:
		oneByteWrites = (tapWidth & 0x3);
// LINE 787:
		fourByteWrites = (tapWidth >> 0x2);
// LINE 790:
		__asm        cmp    oneByteWrites, 0;
		__asm        jge    __WHILE_393;

		return;
		{
// LINE 791:
__WHILE_393:
			__asm        mov    eax, oneByteWrites;
			__asm        mov    [ebp-0x74], eax;
			__asm        dec    oneByteWrites;
			__asm        cmp    dword ptr [ebp-0x74], 0;
			__asm        je     _T3dd;
// LINE 794:
			__asm        push   0x5BF19C;
			__asm        push   1;
			__asm        mov    eax, writeBufferTmp;
			__asm        push   eax;
			__asm        call   Check_Pointer;
			__asm        add    esp, 0xC;
			__asm        test   eax, eax;
			__asm        jne    _T3c6;

			return;
// LINE 795:
_T3c6:
			__asm        mov    eax, cInc;
			__asm        mov    al, [ebp+eax-0x1C];
			__asm        mov    ecx, writeBufferTmp;
			__asm        mov    [ecx], al;
			__asm        inc    cInc;
			__asm        inc    writeBufferTmp;
// LINE 796:
			__asm        jmp    __WHILE_393;
		}
// LINE 798:
_T3dd:
		__asm        cmp    fourByteWrites, 0;
		__asm        jge    __WHILE_3ec;

		return;
		{
// LINE 800:
__WHILE_3ec:
			__asm        mov    eax, fourByteWrites;
			__asm        mov    [ebp-0x78], eax;
			__asm        dec    fourByteWrites;
			__asm        cmp    dword ptr [ebp-0x78], 0;
			__asm        je     _T466;
// LINE 802:
			__asm        push   0x5BF1B0;
			__asm        push   4;
			__asm        mov    eax, writeBufferTmp;
			__asm        push   eax;
			__asm        call   Check_Pointer;
			__asm        add    esp, 0xC;
			__asm        test   eax, eax;
			__asm        jne    _T41f;

			return;
// LINE 803:
_T41f:
			__asm        mov    eax, cInc;
			__asm        movsx  eax, byte ptr [ebp+eax-0x1A];
			__asm        shl    eax, 0x10;
			__asm        mov    ecx, cInc;
			__asm        movsx  ecx, byte ptr [ebp+ecx-0x19];
			__asm        shl    ecx, 0x18;
			__asm        add    eax, ecx;
			__asm        mov    ecx, cInc;
			__asm        movsx  ecx, byte ptr [ebp+ecx-0x1B];
			__asm        shl    ecx, 8;
			__asm        add    eax, ecx;
			__asm        mov    ecx, cInc;
			__asm        movsx  ecx, byte ptr [ebp+ecx-0x1C];
			__asm        add    eax, ecx;
			__asm        mov    longColor, eax;
// LINE 804:
			__asm        mov    eax, longColor;
			__asm        mov    ecx, writeBufferTmp;
			__asm        mov    [ecx], eax;
// LINE 805:
			writeBufferTmp += 0x4;
// LINE 806:
			cInc += 0x4;
// LINE 807:
			__asm        jmp    __WHILE_3ec;
		}
// LINE 809:
_T466:
		error += dx;
// LINE 810:
		__asm        mov    eax, dy;
		__asm        cmp    error, eax;
		__asm        jle    _T488;
// LINE 812:
		error -= dy;
// LINE 813:
		writeBuffer += xInc;
// LINE 815:
_T488:
		writeBuffer += yInc;
	}
// LINE 818:
__RETURN:
}

// FUNCTION: COPTER_D 0x00565225
void DrawLine(/*unpacked*/ struct Point3d startPt, /*unpacked*/ struct Point3d endPt, unsigned char color, long width) {
	/*bp-0x1c*/  char col[26]; // 0x1a bytes
	/*bp-0x20*/  char * writeBuffer;
	/*bp-0x28*/  double colorLimit; // 0x8 bytes
	/*bp-0x2c*/  char * writeBufferTmp;
	/*bp-0x30*/  long fourByteWrites;
	/*bp-0x34*/  long oneByteWrites;
	/*bp-0x38*/  long i;
	/*bp-0x3c*/  long longColor;
	/*bp-0x40*/  long j;
	/*bp-0x44*/  long xInc;
	/*bp-0x48*/  long yInc;
	/*bp-0x4c*/  long cInc;
	/*bp-0x54*/  double step; // 0x8 bytes
	/*bp-0x58*/  long error;
	/*bp-0x5c*/  long dx;
	/*bp-0x60*/  long dy;

// LINE 833:
	error = 0x0;
// LINE 836:
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&colorLimit) + 4) = *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&G_figureShadeSpread) + 4);
	reinterpret_cast<uint32_t>(colorLimit) = reinterpret_cast<uint32_t>(G_figureShadeSpread);
// LINE 848:
	__asm        cmp    width, 0x19;
	__asm        jle    _T2f;
// LINE 849:
	return;
// LINE 851:
_T2f:
	__asm        cmp    width, 0;
	__asm        jne    _FOR_4a;
// LINE 852:
	return;
// LINE 855:
_FOR_4a:
	for (i = 0x0; (i < width); i++) {
// LINE 857:
		__asm        fld    colorLimit;
		__asm        mov    eax, width;
		__asm        mov    [ebp-0x6C], eax;
		__asm        fidiv  dword ptr [ebp-0x6C];
		__asm        fstp   step;
// LINE 858:
		__asm        cmp    i, 0x1A;
		__asm        jl     _T8e;

		doAssert(0x5bf1e0, 0x35a, 0x5bf1c4, 0x8c085);
// LINE 859:
_T8e:
		__asm        mov    eax, i;
		__asm        mov    [ebp-0x70], eax;
		__asm        fild   dword ptr [ebp-0x70];
		__asm        fmul   step;
		__asm        xor    eax, eax;
		__asm        mov    al, color;
		__asm        mov    [ebp-0x74], eax;
		__asm        fiadd  dword ptr [ebp-0x74];
		__asm        call   __ftol;
		__asm        mov    ecx, i;
		__asm        mov    [ebp+ecx-0x1C], al;
	}
// LINE 862:
_Tb6:
	__asm        cmp    startPt.x, 0;
	__asm        jl     _Tca;

	__asm        cmp    endPt.x, 0;
	__asm        jge    _Tcf;
// LINE 863:
_Tca:
	return;
// LINE 864:
_Tcf:
	__asm        cmp    startPt.y, 0;
	__asm        jl     _Te3;

	__asm        cmp    endPt.y, 0;
	__asm        jge    _Te8;
// LINE 865:
_Te3:
	return;
// LINE 866:
_Te8:
	__asm        mov    eax, Pwinwidth;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, startPt.x;
	__asm        jl     _T110;

	__asm        mov    eax, Pwinwidth;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, endPt.x;
	__asm        jge    _T115;
// LINE 867:
_T110:
	return;
// LINE 868:
_T115:
	__asm        mov    eax, Pwinheight;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, startPt.y;
	__asm        jl     _T13d;

	__asm        mov    eax, Pwinheight;
	__asm        mov    ecx, width;
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, endPt.y;
	__asm        jge    _T142;
// LINE 869:
_T13d:
	return;
// LINE 871:
_T142:
	dx = (endPt.x - startPt.x);
// LINE 872:
	dy = (endPt.y - startPt.y);
// LINE 875:
	__asm        cmp    dx, 0;
	__asm        jl     _T16a;
// LINE 876:
	xInc = 0x1;
// LINE 877:
	__asm        jmp    _T179;
// LINE 879:
_T16a:
	xInc = 0xffffffff;
// LINE 880:
	dx = -dx;
// LINE 883:
_T179:
	__asm        cmp    dy, 0;
	__asm        jl     _T190;
// LINE 884:
	yInc = Pbufwidth;
// LINE 885:
	__asm        jmp    _T1a2;
// LINE 887:
_T190:
	yInc = -Pbufwidth;
// LINE 888:
	dy = -dy;
// LINE 892:
_T1a2:
	__asm        mov    eax, dx;
	__asm        cmp    dy, eax;
	__asm        jge    _T273;
// LINE 894:
	__asm        mov    ecx, startPt.y;
	__asm        mov    eax, width;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        imul   ecx, Pbufwidth;
	__asm        add    ecx, startPt.x;
	__asm        add    ecx, buffer1;
	__asm        mov    writeBuffer, ecx;
// LINE 896:
_FOR_1db:
	for (i = 0x0; (i < dx); i++) {
// LINE 898:
		writeBufferTmp = writeBuffer;
// LINE 900:
_FOR_1fc:
		for (j = 0x0; (j < width); j++) {
// LINE 902:
			__asm        push   0;
			__asm        push   1;
			__asm        mov    eax, writeBufferTmp;
			__asm        push   eax;
			__asm        call   Check_Pointer;
			__asm        add    esp, 0xC;
			__asm        test   eax, eax;
			__asm        jne    _T228;

			return;
// LINE 903:
_T228:
			__asm        mov    eax, j;
			__asm        mov    al, [ebp+eax-0x1C];
			__asm        mov    ecx, writeBufferTmp;
			__asm        mov    [ecx], al;
// LINE 904:
			writeBufferTmp += Pbufwidth;
		}
// LINE 907:
_T241:
		error += dy;
// LINE 908:
		__asm        mov    eax, dx;
		__asm        cmp    error, eax;
		__asm        jle    _T263;
// LINE 910:
		error -= dx;
// LINE 911:
		writeBuffer += yInc;
// LINE 913:
_T263:
		writeBuffer += xInc;
	}
// LINE 916:
_T26e:
	return;
// LINE 918:
_T273:
	__asm        mov    ecx, startPt.x;
	__asm        mov    eax, width;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    eax, startPt.y;
	__asm        imul   eax, Pbufwidth;
	__asm        add    ecx, eax;
	__asm        add    ecx, buffer1;
	__asm        mov    writeBuffer, ecx;
// LINE 920:
_FOR_2a2:
	for (i = 0x0; (i < dy); i++) {
// LINE 922:
		writeBufferTmp = writeBuffer;
// LINE 923:
		cInc = 0x0;
// LINE 929:
		oneByteWrites = (width & 0x3);
// LINE 930:
		fourByteWrites = (width >> 0x2);
// LINE 931:
		__asm        cmp    oneByteWrites, 0;
		__asm        jge    _T2fb;
// LINE 932:
		return;
// LINE 933:
		doAssert(0x5bf234, 0x3a5, 0x5bf208, 0x8c085);
// LINE 935:
_T2fb:
		__asm        cmp    fourByteWrites, 0;
		__asm        jge    __WHILE_326;
// LINE 936:
		return;
// LINE 937:
		doAssert(0x5bf288, 0x3a9, 0x5bf25c, 0x8c085);
		{
// LINE 940:
__WHILE_326:
			__asm        mov    eax, oneByteWrites;
			__asm        mov    [ebp-0x64], eax;
			__asm        dec    oneByteWrites;
			__asm        cmp    dword ptr [ebp-0x64], 0;
			__asm        je     __WHILE_370;
// LINE 943:
			__asm        push   0x5BF2B0;
			__asm        push   1;
			__asm        mov    eax, writeBufferTmp;
			__asm        push   eax;
			__asm        call   Check_Pointer;
			__asm        add    esp, 0xC;
			__asm        test   eax, eax;
			__asm        jne    _T359;

			return;
// LINE 944:
_T359:
			__asm        mov    eax, cInc;
			__asm        mov    al, [ebp+eax-0x1C];
			__asm        mov    ecx, writeBufferTmp;
			__asm        mov    [ecx], al;
			__asm        inc    cInc;
			__asm        inc    writeBufferTmp;
// LINE 945:
			__asm        jmp    __WHILE_326;
		}
		{
// LINE 947:
__WHILE_370:
			__asm        mov    eax, fourByteWrites;
			__asm        mov    [ebp-0x68], eax;
			__asm        dec    fourByteWrites;
			__asm        cmp    dword ptr [ebp-0x68], 0;
			__asm        je     _T3ea;
// LINE 949:
			__asm        push   0x5BF2BC;
			__asm        push   4;
			__asm        mov    eax, writeBufferTmp;
			__asm        push   eax;
			__asm        call   Check_Pointer;
			__asm        add    esp, 0xC;
			__asm        test   eax, eax;
			__asm        jne    _T3a3;

			return;
// LINE 950:
_T3a3:
			__asm        mov    eax, cInc;
			__asm        movsx  eax, byte ptr [ebp+eax-0x1A];
			__asm        shl    eax, 0x10;
			__asm        mov    ecx, cInc;
			__asm        movsx  ecx, byte ptr [ebp+ecx-0x19];
			__asm        shl    ecx, 0x18;
			__asm        add    eax, ecx;
			__asm        mov    ecx, cInc;
			__asm        movsx  ecx, byte ptr [ebp+ecx-0x1B];
			__asm        shl    ecx, 8;
			__asm        add    eax, ecx;
			__asm        mov    ecx, cInc;
			__asm        movsx  ecx, byte ptr [ebp+ecx-0x1C];
			__asm        add    eax, ecx;
			__asm        mov    longColor, eax;
// LINE 951:
			__asm        mov    eax, longColor;
			__asm        mov    ecx, writeBufferTmp;
			__asm        mov    [ecx], eax;
// LINE 952:
			writeBufferTmp += 0x4;
// LINE 953:
			cInc += 0x4;
// LINE 954:
			__asm        jmp    __WHILE_370;
		}
// LINE 956:
_T3ea:
		error += dx;
// LINE 957:
		__asm        mov    eax, dy;
		__asm        cmp    error, eax;
		__asm        jle    _T40c;
// LINE 959:
		error -= dy;
// LINE 960:
		writeBuffer += xInc;
// LINE 962:
_T40c:
		writeBuffer += yInc;
	}
// LINE 966:
__RETURN:
}

// FUNCTION: COPTER_D 0x00565641
void DrawHorzLinePat(long startX, long endX, long yPos, unsigned char * pixPtr, unsigned char colorShift, double xStride) {
	/*bp-0x4*/   unsigned char * writeBuffer;
	/*bp-0xc*/   double stride4; // 0x8 bytes
	/*bp-0x10*/  long fourByteWrites;
	/*bp-0x18*/  double curPatOffset; // 0x8 bytes
	/*bp-0x1c*/  long oneByteWrites;
	/*bp-0x20*/  long longColor;
	/*bp-0x28*/  double stride2; // 0x8 bytes
	/*bp-0x30*/  double stride3; // 0x8 bytes
	/*bp-0x34*/  long dx;
	/*bp-0x3c*/  double stride1; // 0x8 bytes

// LINE 989:
	reinterpret_cast<uint32_t>(curPatOffset) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&curPatOffset) + 4) = 0x0;
// LINE 991:
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&stride1) + 4) = *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&xStride) + 4);
	reinterpret_cast<uint32_t>(stride1) = reinterpret_cast<uint32_t>(xStride);
// LINE 992:
	__asm        fld    xStride;
	__asm        fmul   qword ptr ds:[0x5939C0];
	__asm        fstp   stride2;
// LINE 993:
	__asm        fld    xStride;
	__asm        fmul   qword ptr ds:[0x593A10];
	__asm        fstp   stride3;
// LINE 994:
	__asm        fld    xStride;
	__asm        fmul   qword ptr ds:[0x5939B8];
	__asm        fstp   stride4;
// LINE 997:
	__asm        cmp    startX, 0;
	__asm        jl     _T5b;

	__asm        cmp    endX, 0;
	__asm        jge    _T60;
// LINE 998:
_T5b:
	return;
// LINE 999:
_T60:
	__asm        cmp    yPos, 0;
	__asm        jge    _T6f;
// LINE 1000:
	return;
// LINE 1001:
_T6f:
	__asm        mov    eax, startX;
	__asm        cmp    Pwinwidth, eax;
	__asm        jl     _T8d;

	__asm        mov    eax, endX;
	__asm        cmp    Pwinwidth, eax;
	__asm        jge    _T92;
// LINE 1002:
_T8d:
	return;
// LINE 1003:
_T92:
	__asm        mov    eax, yPos;
	__asm        cmp    Pwinheight, eax;
	__asm        jge    _Ta6;
// LINE 1004:
	return;
// LINE 1006:
_Ta6:
	writeBuffer = (((yPos * Pbufwidth) + startX) + buffer1);
// LINE 1008:
	dx = ((endX - startX) + 1);
// LINE 1015:
	oneByteWrites = (dx & 0x3);
// LINE 1016:
	fourByteWrites = (dx >> 0x2);
// LINE 1018:
	__asm        cmp    oneByteWrites, 0;
	__asm        jge    _T103;
// LINE 1019:
	return;
// LINE 1020:
	doAssert(0x5bf2fc, 0x3fc, 0x5bf2c8, 0x8c085);
// LINE 1022:
_T103:
	__asm        cmp    fourByteWrites, 0;
	__asm        jge    __WHILE_12e;
// LINE 1023:
	return;
// LINE 1024:
	doAssert(0x5bf35c, 0x400, 0x5bf324, 0x8c085);
	{
// LINE 1027:
__WHILE_12e:
		__asm        mov    eax, oneByteWrites;
		__asm        mov    [ebp-0x40], eax;
		__asm        dec    oneByteWrites;
		__asm        cmp    dword ptr [ebp-0x40], 0;
		__asm        je     __WHILE_18e;
// LINE 1030:
		__asm        push   0x5BF384;
		__asm        push   1;
		__asm        mov    eax, writeBuffer;
		__asm        push   eax;
		__asm        call   Check_Pointer;
		__asm        add    esp, 0xC;
		__asm        test   eax, eax;
		__asm        jne    _T161;

		return;
// LINE 1031:
_T161:
		__asm        fld    curPatOffset;
		__asm        call   __ftol;
		__asm        mov    ecx, pixPtr;
		__asm        xor    edx, edx;
		__asm        mov    dl, [ecx+eax];
		__asm        xor    eax, eax;
		__asm        mov    al, colorShift;
		__asm        add    edx, eax;
		__asm        mov    eax, writeBuffer;
		__asm        mov    [eax], dl;
		__asm        inc    writeBuffer;
// LINE 1032:
		__asm        fld    stride1;
		__asm        fadd   curPatOffset;
		__asm        fstp   curPatOffset;
// LINE 1033:
		__asm        jmp    __WHILE_12e;
	}
	{
// LINE 1036:
__WHILE_18e:
		__asm        mov    eax, fourByteWrites;
		__asm        mov    [ebp-0x44], eax;
		__asm        dec    fourByteWrites;
		__asm        cmp    dword ptr [ebp-0x44], 0;
		__asm        je     __RETURN;
// LINE 1038:
		__asm        push   0x5BF394;
		__asm        push   4;
		__asm        mov    eax, writeBuffer;
		__asm        push   eax;
		__asm        call   Check_Pointer;
		__asm        add    esp, 0xC;
		__asm        test   eax, eax;
		__asm        jne    _T1c1;

		return;
// LINE 1042:
_T1c1:
		__asm        fld    stride2;
		__asm        fadd   curPatOffset;
		__asm        call   __ftol;
		__asm        mov    ecx, pixPtr;
		__asm        xor    ebx, ebx;
		__asm        mov    bl, [ecx+eax];
		__asm        xor    eax, eax;
		__asm        mov    al, colorShift;
		__asm        add    ebx, eax;
		__asm        shl    ebx, 0x10;
		__asm        fld    stride3;
		__asm        fadd   curPatOffset;
		__asm        call   __ftol;
		__asm        mov    ecx, pixPtr;
		__asm        xor    edx, edx;
		__asm        mov    dl, [ecx+eax];
		__asm        xor    eax, eax;
		__asm        mov    al, colorShift;
		__asm        add    edx, eax;
		__asm        shl    edx, 0x18;
		__asm        add    ebx, edx;
		__asm        fld    stride1;
		__asm        fadd   curPatOffset;
		__asm        call   __ftol;
		__asm        mov    ecx, pixPtr;
		__asm        xor    edx, edx;
		__asm        mov    dl, [ecx+eax];
		__asm        xor    eax, eax;
		__asm        mov    al, colorShift;
		__asm        add    edx, eax;
		__asm        shl    edx, 8;
		__asm        add    ebx, edx;
		__asm        fld    curPatOffset;
		__asm        call   __ftol;
		__asm        mov    ecx, pixPtr;
		__asm        xor    edx, edx;
		__asm        mov    dl, [ecx+eax];
		__asm        add    ebx, edx;
		__asm        xor    eax, eax;
		__asm        mov    al, colorShift;
		__asm        add    ebx, eax;
		__asm        mov    longColor, ebx;
// LINE 1044:
		__asm        mov    eax, longColor;
		__asm        mov    ecx, writeBuffer;
		__asm        mov    [ecx], eax;
// LINE 1045:
		writeBuffer += 0x4;
// LINE 1046:
		__asm        fld    stride4;
		__asm        fadd   curPatOffset;
		__asm        fstp   curPatOffset;
// LINE 1047:
		__asm        jmp    __WHILE_18e;
	}
// LINE 1050:
__RETURN:
}

// FUNCTION: COPTER_D 0x00565898
void DrawHorzLine(long startX, long endX, long yPos, unsigned char color) {
	/*bp-0x4*/   char * writeBuffer;
	/*bp-0x8*/   unsigned long fourByteColor;
	/*bp-0xc*/   long fourByteWrites;
	/*bp-0x10*/  long oneByteWrites;
	/*bp-0x14*/  long dx;

// LINE 1075:
	__asm        cmp    startX, 0;
	__asm        jl     _T1d;

	__asm        cmp    endX, 0;
	__asm        jge    _T22;
// LINE 1076:
_T1d:
	return;
// LINE 1077:
_T22:
	__asm        cmp    yPos, 0;
	__asm        jge    _T31;
// LINE 1078:
	return;
// LINE 1079:
_T31:
	__asm        mov    eax, Pwinwidth;
	__asm        cmp    startX, eax;
	__asm        jg     _T4d;

	__asm        mov    eax, Pwinwidth;
	__asm        cmp    endX, eax;
	__asm        jle    _T52;
// LINE 1080:
_T4d:
	return;
// LINE 1081:
_T52:
	__asm        mov    eax, Pwinheight;
	__asm        cmp    yPos, eax;
	__asm        jle    _T65;
// LINE 1082:
	return;
// LINE 1084:
_T65:
	writeBuffer = (((yPos * Pbufwidth) + startX) + buffer1);
// LINE 1086:
	dx = ((endX - startX) + 1);
// LINE 1088:
	__asm        xor    eax, eax;
	__asm        mov    al, color;
	__asm        shl    eax, 0x18;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, color;
	__asm        shl    ecx, 8;
	__asm        add    eax, ecx;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, color;
	__asm        shl    ecx, 0x10;
	__asm        add    eax, ecx;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, color;
	__asm        add    eax, ecx;
	__asm        mov    fourByteColor, eax;
// LINE 1097:
	oneByteWrites = (dx & 0x3);
// LINE 1098:
	fourByteWrites = (dx >> 0x2);
// LINE 1099:
	__asm        cmp    oneByteWrites, 0;
	__asm        jge    _Te8;
// LINE 1100:
	return;
// LINE 1101:
	doAssert(0x5bf3d4, 0x44d, 0x5bf3a4, 0x8c085);
// LINE 1103:
_Te8:
	__asm        cmp    fourByteWrites, 0;
	__asm        jge    __WHILE_113;
// LINE 1104:
	return;
// LINE 1105:
	doAssert(0x5bf430, 0x451, 0x5bf3fc, 0x8c085);
	{
// LINE 1108:
__WHILE_113:
		__asm        mov    eax, oneByteWrites;
		__asm        mov    [ebp-0x18], eax;
		__asm        dec    oneByteWrites;
		__asm        cmp    dword ptr [ebp-0x18], 0;
		__asm        je     __WHILE_156;
// LINE 1111:
		__asm        push   0x5BF458;
		__asm        push   1;
		__asm        mov    eax, writeBuffer;
		__asm        push   eax;
		__asm        call   Check_Pointer;
		__asm        add    esp, 0xC;
		__asm        test   eax, eax;
		__asm        jne    _T146;

		return;
// LINE 1112:
_T146:
		writeBuffer[0] = color;
		writeBuffer++;
// LINE 1113:
		__asm        jmp    __WHILE_113;
	}
	{
// LINE 1115:
__WHILE_156:
		__asm        mov    eax, fourByteWrites;
		__asm        mov    [ebp-0x1C], eax;
		__asm        dec    fourByteWrites;
		__asm        cmp    dword ptr [ebp-0x1C], 0;
		__asm        je     __RETURN;
// LINE 1117:
		__asm        push   0x5BF468;
		__asm        push   4;
		__asm        mov    eax, writeBuffer;
		__asm        push   eax;
		__asm        call   Check_Pointer;
		__asm        add    esp, 0xC;
		__asm        test   eax, eax;
		__asm        jne    _T189;

		return;
// LINE 1118:
_T189:
		__asm        mov    eax, fourByteColor;
		__asm        mov    ecx, writeBuffer;
		__asm        mov    [ecx], eax;
// LINE 1119:
		writeBuffer += 0x4;
// LINE 1120:
		__asm        jmp    __WHILE_156;
	}
// LINE 1123:
__RETURN:
}



// Contribution: 2:000047a0-00004a17 Module: 186, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x005937a0
static const int32_t TurnTable3[4][8] = {{0, 1, 2, 3, 4, 5, 6, 7}, {2, 3, 4, 5, 6, 7, 0, 1}, {6, 7, 0, 1, 2, 3, 4, 5}, {4, 5, 6, 7, 0, 1, 2, 3}};

// GLOBAL: COPTER_D 0x00593820
static const int32_t TurnTable2[4][4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {3, 0, 1, 2}, {2, 3, 0, 1}};

// GLOBAL: COPTER_D 0x00593860
static const int32_t IndexToType[4] = {1, 2, 4, 8};

// GLOBAL: COPTER_D 0x00593870
static const int32_t TypeToIndex2[16] = {-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1};

// GLOBAL: COPTER_D 0x005938b0
static const int32_t TILUT[4][4] = {{0, 1, 3, 2}, {2, 0, 1, 3}, {3, 2, 0, 1}, {1, 3, 2, 0}};

// GLOBAL: COPTER_D 0x005938f0
static const /*unpacked*/ struct _dPoint2d OT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00593930
static const /*unpacked*/ struct _dPoint2d RRT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00593970
static const /*unpacked*/ struct _dPoint2d LRT[4] = { 0 /* todo */ };



// Contribution: 3:00027f28-00028474 Module: 186, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005bef28
long Pbufwidth = 0;

// GLOBAL: COPTER_D 0x005bef2c
long Pwinwidth = 0;

// GLOBAL: COPTER_D 0x005bef30
long Pwinheight = 0;

// GLOBAL: COPTER_D 0x005bef38
double G_figureHeadShapeRatio = 2.93747e-319;

// GLOBAL: COPTER_D 0x005bef40
double G_figureShadeSpread = -6.065988000073924e+66;

