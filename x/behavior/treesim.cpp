// Module: Treesim.obj
// Source: C:\Copter\Source\X\Behavior\Treesim.cpp
// autogenerated by simcopter_tool from PDB file

// Type: short;

// Type: /*unpacked*/ class Behavior (forward reference);
// VTABLE: COPTER_D 0x005936d8
class Behavior{ // not packed(0x1c bytes) TI: 0x35de
protected:
	/*+0x4*/   /*unpacked*/ class NResFile *fGlobFile;
	/*+0x8*/   /*unpacked*/ class NResFile *fPrivFile;
	/*+0xc*/   /*unpacked*/ class StdResLoader *fGlobalTrees;
	/*+0x10*/  /*unpacked*/ class StdResLoader *fPrivateTrees;
	/*+0x14*/  /*unpacked*/ class Language *fLanguage;
	/*+0x18*/  void (*fSwizzler)(void * __ptr32, long);
	enum /* __unnamed */ {
		kPrimitiveBase = 0,
		kPrimitiveMax = 255,
		kActionBase = 256,
		kGlobalBase = 256,
		kGlobalMax = 4095,
		kPrivateBase = 4096,
		kPrivateMax = 8191,
		kSemiGlobalBase = 8192,
		kSemiGlobalMax = 30000,
		kTreeMax = 30000,
		kPrimitives = 0,
		kGlobalTrees = 1,
		kPrivateTrees = 2,
		kSemiGlobalTrees = 3,
		kMaxTreeClass = 3,
	};
	struct Behavior::NodeParameter{ // not packed(0x8 bytes) TI: 0x35e5
		/*+0x0*/   short p1; // 0x2 bytes
		/*+0x2*/   short p2; // 0x2 bytes
		/*+0x4*/   short p3; // 0x2 bytes
		/*+0x6*/   short p4; // 0x2 bytes
	};
	struct Behavior::Node{ // not packed(0xc bytes) TI: 0x35e3
		/*+0x0*/   short treeID; // 0x2 bytes
		/*+0x0*/   short primCode; // 0x2 bytes
		/*+0x2*/   signed char trueTrans; // 0x1 bytes
		/*+0x3*/   signed char falseTrans; // 0x1 bytes
		/*+0x4*/   /*unpacked*/ struct Behavior::NodeParameter param; // 0x8 bytes
	};
	enum /* __unnamed */ {
		kUndefined = -3,
		kPopOutTrue = -2,
		kPopOutFalse = -1,
	};
	struct Behavior::Tree{ // not packed(0xe bytes) TI: 0x35e1
		/*+0x0*/   short numNodes; // 0x2 bytes
		/*+0x2*/   /*unpacked*/ struct Behavior::Node nodes[1]; // 0xc bytes
	};
public:
	void Behavior(/*unpacked*/ class Language*, /*unpacked*/ class NResFile*, /*unpacked*/ class NResFile*);
	void ~Behavior();
	void GetNode(short, short, /*unpacked*/ struct Behavior::Node*);
	virtual const /*unpacked*/ struct Behavior::Node* GetNodeRef(short, short); // vtable+0x0
	virtual void GetNodeText(short, short, unsigned char *); // vtable+0x4
	void GetNodeText(/*unpacked*/ struct Behavior::Node*, unsigned char *);
	virtual void GetTreeName(short, unsigned char *); // vtable+0x8
	short CountPrimitives();
	/*unpacked*/ class Language* GetLanguage();
	/*unpacked*/ class ResFile* GetPrivFile();
	/*unpacked*/ class ResFile* GetGlobFile();
	virtual /*unpacked*/ class ResFile* GetResFile(short); // vtable+0xc
	// calltype: NearC
	static short GetBaseID(short);
	// calltype: NearC
	static short GetMaxID(short);
	// calltype: NearC
	static short GetTreeClass(short);
	// calltype: NearC
	static void GetClassNameA(short, unsigned char *);
	using ParamSwizzleProc = void (*)(short, /*unpacked*/ struct Behavior::NodeParameter*);
public:
	// calltype: NearC
	static void StdTreeSwizzle(/*unpacked*/ struct Behavior::Tree*, long, void (*)(short, /*unpacked*/ struct Behavior::NodeParameter*));
	// calltype: NearC
	static unsigned short IsDefaultParam(/*unpacked*/ struct Behavior::NodeParameter*);
	// calltype: NearC
	static void SetDefaultParam(/*unpacked*/ struct Behavior::NodeParameter*);
};

// Type: short *;

// Type: void;

// Type: /*unpacked*/ class TreeSim (forward reference);
// VTABLE: COPTER_D 0x00593630
class TreeSim{ // not packed(0x14 bytes) TI: 0x3610
	enum /* __unnamed */ {
		kNumLocals = 4,
		kMaxIterations = 128,
	};
	struct TreeSim::StackElem{ // not packed(0x14 bytes) TI: 0x3614
		/*+0x0*/   short treeID; // 0x2 bytes
		/*+0x2*/   short nodeNum; // 0x2 bytes
		/*+0x4*/   short objectID; // 0x2 bytes
		/*+0x4*/   short _pad; // 0x2 bytes
		/*+0x4*/   unsigned char * objectPtr;
		/*+0x8*/   short locals[4]; // 0x8 bytes
		/*+0x10*/  /*unpacked*/ class Behavior *pBehavior;
		void GetTreeName(unsigned char *);
	};
private:
	/*+0x4*/   /*unpacked*/ struct TreeSim::StackElem *fStack;
	/*+0x8*/   short fStackSize; // 0x2 bytes
	/*+0xa*/   short fMaxStackSize; // 0x2 bytes
	/*+0xc*/   short fIterations; // 0x2 bytes
	/*+0xe*/   short _pad; // 0x2 bytes
	/*+0x10*/  short * fAutoStackArea;
	enum ReturnCode {
		kTrueComplete = 1,
		kFalseComplete = 0,
		kEngaged = 2,
		kError = -1,
		kStackLoaded = 3,
	};
	enum /* __unnamed */ {
		kStackErrorBase = 1000,
		kStackOverflow = 1000,
		kUndefinedTransition = 1001,
		kTooManyIterations = 1002,
		kStackUnderflow = 1003,
		kStackErrorMax = 1004,
	};
protected:
	virtual enum TreeSim::ReturnCode TryElement(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*); // vtable+0x0
	virtual void Error(short); // vtable+0x4
	void GetCurrentNode(short *, short *);
	void Reset(/*unpacked*/ class Behavior*, short);
	signed char NodeComplete(unsigned short);
	unsigned short Gosub(/*unpacked*/ class Behavior*, short *, short);
public:
	void TreeSim(short, short *);
	void TreeSim(short, short, /*unpacked*/ class Behavior*, short *);
	virtual void ~TreeSim(); // vtable+0x8
	virtual unsigned short Simulate(long, unsigned short); // vtable+0xc
	/*unpacked*/ struct TreeSim::StackElem* GetHighLevelAction();
	/*unpacked*/ struct TreeSim::StackElem* GetCurElem();
	/*unpacked*/ struct TreeSim::StackElem* GetNthElem(short);
	short GetStackSize();
	short GetMaxStackSize();
};

// Type: /*unpacked*/ struct TreeSim::StackElem (forward reference);
struct TreeSim::StackElem{ // not packed(0x14 bytes) TI: 0x3614
	/*+0x0*/   short treeID; // 0x2 bytes
	/*+0x2*/   short nodeNum; // 0x2 bytes
	/*+0x4*/   short objectID; // 0x2 bytes
	/*+0x4*/   short _pad; // 0x2 bytes
	/*+0x4*/   unsigned char * objectPtr;
	/*+0x8*/   short locals[4]; // 0x8 bytes
	/*+0x10*/  /*unpacked*/ class Behavior *pBehavior;
	void GetTreeName(unsigned char *);
};

// Type: unsigned short;

// Type: long;

// Type: /*unpacked*/ struct Behavior::Node (forward reference);
struct Behavior::Node{ // not packed(0xc bytes) TI: 0x35e3
	/*+0x0*/   short treeID; // 0x2 bytes
	/*+0x0*/   short primCode; // 0x2 bytes
	/*+0x2*/   signed char trueTrans; // 0x1 bytes
	/*+0x3*/   signed char falseTrans; // 0x1 bytes
	/*+0x4*/   /*unpacked*/ struct Behavior::NodeParameter param; // 0x8 bytes
};

// Type: enum TreeSim::ReturnCode;
enum ReturnCode {
	kTrueComplete = 1,
	kFalseComplete = 0,
	kEngaged = 2,
	kError = -1,
	kStackLoaded = 3,
};

// Type: signed char;

// Type: /*unpacked*/ class ExtSim (forward reference);
class ExtSim : public TreeSim
{ // not packed(0x18 bytes) TI: 0x35f6
private:
	/*+0x14*/  /*unpacked*/ class TreeSim *fExt;
public:
	void ExtSim(/*unpacked*/ class TreeSim*, short);
	virtual enum TreeSim::ReturnCode TryElement(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*) /* override */;
	virtual void Error(short) /* override */;
	virtual unsigned short Simulate(long, unsigned short) /* override */;
};

// Type: uint32_t;

// Type: /*unpacked*/ class TreeSim;
// VTABLE: COPTER_D 0x00593630
class TreeSim{ // not packed(0x14 bytes) TI: 0x3610
	enum /* __unnamed */ {
		kNumLocals = 4,
		kMaxIterations = 128,
	};
	struct TreeSim::StackElem{ // not packed(0x14 bytes) TI: 0x3614
		/*+0x0*/   short treeID; // 0x2 bytes
		/*+0x2*/   short nodeNum; // 0x2 bytes
		/*+0x4*/   short objectID; // 0x2 bytes
		/*+0x4*/   short _pad; // 0x2 bytes
		/*+0x4*/   unsigned char * objectPtr;
		/*+0x8*/   short locals[4]; // 0x8 bytes
		/*+0x10*/  /*unpacked*/ class Behavior *pBehavior;
		void GetTreeName(unsigned char *);
	};
private:
	/*+0x4*/   /*unpacked*/ struct TreeSim::StackElem *fStack;
	/*+0x8*/   short fStackSize; // 0x2 bytes
	/*+0xa*/   short fMaxStackSize; // 0x2 bytes
	/*+0xc*/   short fIterations; // 0x2 bytes
	/*+0xe*/   short _pad; // 0x2 bytes
	/*+0x10*/  short * fAutoStackArea;
	enum ReturnCode {
		kTrueComplete = 1,
		kFalseComplete = 0,
		kEngaged = 2,
		kError = -1,
		kStackLoaded = 3,
	};
	enum /* __unnamed */ {
		kStackErrorBase = 1000,
		kStackOverflow = 1000,
		kUndefinedTransition = 1001,
		kTooManyIterations = 1002,
		kStackUnderflow = 1003,
		kStackErrorMax = 1004,
	};
protected:
	virtual enum TreeSim::ReturnCode TryElement(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*); // vtable+0x0
	virtual void Error(short); // vtable+0x4
	void GetCurrentNode(short *, short *);
	void Reset(/*unpacked*/ class Behavior*, short);
	signed char NodeComplete(unsigned short);
	unsigned short Gosub(/*unpacked*/ class Behavior*, short *, short);
public:
	void TreeSim(short, short *);
	void TreeSim(short, short, /*unpacked*/ class Behavior*, short *);
	virtual void ~TreeSim(); // vtable+0x8
	virtual unsigned short Simulate(long, unsigned short); // vtable+0xc
	/*unpacked*/ struct TreeSim::StackElem* GetHighLevelAction();
	/*unpacked*/ struct TreeSim::StackElem* GetCurElem();
	/*unpacked*/ struct TreeSim::StackElem* GetNthElem(short);
	short GetStackSize();
	short GetMaxStackSize();
};



// Contribution: 1:0015bb10-0015c4b2 Module: 194, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0055cb10
void TreeSim::TreeSim(short maxStackSize, short startTreeID, /*unpacked*/ class Behavior *startBehavior, short * autoStackArea) {

	__asm        mov    ax, maxStackSize;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA], ax;
	__asm        mov    eax, autoStackArea;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x10], eax;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x593630;
// LINE 13:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        test   eax, eax;
	__asm        jg     _T51;

	__asm        push   0x8C085;
	__asm        push   0x5BDE9C;
	__asm        push   0xD;
	__asm        push   0x5BDEA8;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 14:
_T51:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+4], eax;
// LINE 15:
	this->fStackSize = 0x0;
// LINE 16:
	__asm        mov    eax, reinterpret_cast<uint32_t>(startTreeID);
	__asm        push   eax;
	__asm        mov    eax, startBehavior;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::Reset;
// LINE 17:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0055cba5
void TreeSim::TreeSim(short maxStackSize, short * autoStackArea) {

	__asm        mov    ax, maxStackSize;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA], ax;
	__asm        mov    eax, autoStackArea;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x10], eax;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x593630;
// LINE 26:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        test   eax, eax;
	__asm        jg     _T51;

	__asm        push   0x8C085;
	__asm        push   0x5BDED0;
	__asm        push   0x1A;
	__asm        push   0x5BDEDC;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 27:
_T51:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+4], eax;
// LINE 28:
	this->fStackSize = 0x0;
// LINE 29:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0055cc2a
void TreeSim::~TreeSim() {

	this-><vftable> = 0x593630;
// LINE 36:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 37:
	return;
}

// FUNCTION: COPTER_D 0x0055cc58
void TreeSim::Reset(/*unpacked*/ class Behavior *startBehavior, short startTreeID) {
	/*bp-0x4*/   /*unpacked*/ struct TreeSim::StackElem *bottom;

// LINE 44:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T28;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        test   eax, eax;
	__asm        jg     _T41;
_T28:
	__asm        push   0x8C085;
	__asm        push   0x5BDF04;
	__asm        push   0x2C;
	__asm        push   0x5BDF10;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 45:
_T41:
	this->fStackSize = 0x1;
// LINE 47:
	bottom = this->fStack;
// LINE 48:
	bottom->treeID = startTreeID;
// LINE 49:
	bottom->nodeNum = 0x0;
// LINE 50:
	__asm        mov    eax, bottom;
	__asm        mov    word ptr [eax+4], 0;
// LINE 51:
	__asm        mov    eax, bottom;
	__asm        mov    dword ptr [eax+4], 0;
// LINE 52:
	bottom->pBehavior = startBehavior;
// LINE 53:
	__asm        mov    eax, bottom;
	__asm        mov    word ptr [eax+4], 0;
// LINE 54:
	return;
}

// FUNCTION: COPTER_D 0x0055ccef
/*unpacked*/ struct TreeSim::StackElem* TreeSim::GetHighLevelAction() {
	/*bp-0x4*/   /*unpacked*/ class Behavior *curBeh;
	/*bp-0x8*/   short stackSize;

// LINE 63:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        sub    eax, 2;
	__asm        mov    stackSize, ax;
// LINE 64:
	__asm        jmp    _T24;
_T24:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    eax, [eax+ecx+0x10];
	__asm        mov    curBeh, eax;
// LINE 65:
_T42:
	__asm        movsx  eax, stackSize;
	__asm        test   eax, eax;
	__asm        jl     _T115;
// LINE 66:
	__asm        movsx  eax, stackSize;
	__asm        test   eax, eax;
	__asm        jl     _T6d;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        movsx  ecx, stackSize;
	__asm        cmp    eax, ecx;
	__asm        jg     _T87;
_T6d:
	__asm        mov    eax, 0x10;
	__asm        mov    ecx, curBeh;
	__asm        cmp    [eax], ecx;
	__asm        je     _T10c;

	__asm        jmp    _Tb8;

	__asm        jmp    _Ta9;
_T87:
	__asm        movsx  eax, stackSize;
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    edx, curBeh;
	__asm        cmp    [eax+ecx+0x10], edx;
	__asm        je     _T10c;

	__asm        jmp    _Tb8;
_Ta9:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    ecx, curBeh;
	__asm        cmp    [eax+0x10], ecx;
	__asm        je     _T10c;
// LINE 67:
_Tb8:
	__asm        movsx  eax, stackSize;
	__asm        inc    eax;
	__asm        movsx  eax, ax;
	__asm        test   eax, eax;
	__asm        jl     _Tdf;

	__asm        movsx  eax, stackSize;
	__asm        inc    eax;
	__asm        movsx  eax, ax;
	__asm        mov    ecx, this;
	__asm        movsx  ecx, word ptr [ecx+8];
	__asm        cmp    eax, ecx;
	__asm        jl     _Teb;
_Tdf:
	__asm        xor    eax, eax;
	__asm        jmp    _T107;

	__asm        jmp    _T104;
_Teb:
	__asm        movsx  eax, stackSize;
	__asm        inc    eax;
	__asm        movsx  eax, ax;
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        jmp    _T107;
_T104:
	__asm        mov    eax, [ebp-0x10];
_T107:
	__asm        jmp    _T143;
// LINE 68:
_T10c:
	stackSize--;
// LINE 69:
	__asm        jmp    _T42;
// LINE 70:
_T115:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        test   eax, eax;
	__asm        jg     _T130;

	__asm        xor    eax, eax;
	__asm        jmp    _T13e;

	__asm        jmp    _T13b;
_T130:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        jmp    _T13e;
_T13b:
	__asm        mov    eax, [ebp-0x14];
_T13e:
	__asm        jmp    _T143;
// LINE 71:
_T143:
}

// FUNCTION: COPTER_D 0x0055ce37
unsigned short TreeSim::Gosub(/*unpacked*/ class Behavior *pTransfer, short * stack, short treeID) {
// LINE 84:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        mov    ecx, this;
	__asm        movsx  ecx, word ptr [ecx+0xA];
	__asm        cmp    eax, ecx;
	__asm        jge    _Te1;
// LINE 86:
// Block start:
	/*bp-0x4*/   /*unpacked*/ struct TreeSim::StackElem *fill;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        mov    fill, eax;
// LINE 87:
	fill->treeID = treeID;
// LINE 88:
	fill->nodeNum = 0x0;
// LINE 89:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    ax, [eax+ecx+4];
	__asm        mov    ecx, fill;
	__asm        mov    [ecx+4], ax;
// LINE 90:
	__asm        cmp    pTransfer, 0;
	__asm        je     _T86;
// LINE 91:
	fill->pBehavior = pTransfer;
// LINE 92:
	__asm        jmp    _Ta7;
// LINE 93:
_T86:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    eax, [eax+ecx+0x10];
	__asm        mov    ecx, fill;
	__asm        mov    [ecx+0x10], eax;
// LINE 95:
_Ta7:
	__asm        cmp    stack, 0;
	__asm        jne    _Tba;

	stack = this->fAutoStackArea;
// LINE 97:
_Tba:
	__asm        mov    eax, stack;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, fill;
	__asm        mov    [ecx+8], eax;
// LINE 98:
	__asm        mov    eax, stack;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, fill;
	__asm        mov    [ecx+0xC], eax;
// LINE 100:
	this->fStackSize++;
// LINE 101:
	return 0x1;
// LINE 104:
// Block end:
_Te1:
	__asm        push   0x3E8;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 105:
	return 0x0;
// LINE 106:
}

// FUNCTION: COPTER_D 0x0055cf37
unsigned short TreeSim::Simulate(long ticks, unsigned short bOnceOnly) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   const /*unpacked*/ struct Behavior::Node *node;
	/*bp-0xc*/   unsigned short done;
	/*bp-0x10*/  /*unpacked*/ struct TreeSim::StackElem *elem;

// LINE 120:
	done = 0x0;
// LINE 123:
	this->fIterations = 0x0;
// LINE 124:
	done = bOnceOnly;
// LINE 127:
_T23:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        mov    elem, eax;
// LINE 128:
	__asm        mov    eax, elem;
	__asm        mov    ax, [eax+2];
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        mov    ax, [eax];
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        mov    ecx, elem;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx];
	__asm        mov    node, eax;
// LINE 129:
	__asm        mov    eax, node;
	__asm        movsx  eax, word ptr [eax];
	__asm        cmp    eax, 0x100;
	__asm        jl     _T118;
// LINE 130:
// Block start:
	/*bp-0x14*/  short * stackPass;
	/*bp-0x18*/  short treeID;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        mov    ecx, this;
	__asm        movsx  ecx, word ptr [ecx+0xA];
	__asm        cmp    eax, ecx;
	__asm        jl     _Ta0;

	__asm        push   0x3E8;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T280;

	__asm        jmp    tree_error;
// LINE 133:
_Ta0:
	stackPass = 0x0;
// LINE 134:
	treeID = node->treeID;
// LINE 135:
	__asm        mov    eax, node;
	__asm        cmp    dword ptr [eax+4], 0xFFFFFFFF;
	__asm        jne    _Td5;

	__asm        mov    eax, node;
	__asm        cmp    dword ptr [eax+8], 0xFFFFFFFF;
	__asm        jne    _Td5;

	__asm        jmp    _Tf0;

	__asm        jmp    _Td5;
_Td5:
	__asm        jmp    _Te7;

	__asm        test   dword ptr [ebp-0x1C], 0xFFFF;
	__asm        jne    _Tf0;
// LINE 136:
_Te7:
	__asm        mov    eax, node;
	__asm        add    eax, 4;
	__asm        mov    stackPass, eax;
// LINE 138:
_Tf0:
	__asm        mov    eax, reinterpret_cast<uint32_t>(treeID);
	__asm        push   eax;
	__asm        mov    eax, stackPass;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::Gosub;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T113;
// LINE 140:
	done = 0x1;
// LINE 142:
// Block end:
_T113:
	__asm        jmp    _T214;
// LINE 144:
_T118:
	__asm        mov    eax, node;
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax];
	__asm        mov    result, eax;
	__asm        mov    eax, result;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T1e9;
// LINE 146:
_T138:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::NodeComplete;
	__asm        movsx  eax, al;
	__asm        cmp    eax, 0xFFFFFFFD;
	__asm        jne    _T168;
// LINE 148:
	__asm        push   0x3E9;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T27b;

	__asm        jmp    tree_error;
// LINE 150:
_T168:
	__asm        jmp    _T214;
// LINE 152:
_T16d:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::NodeComplete;
	__asm        movsx  eax, al;
	__asm        cmp    eax, 0xFFFFFFFD;
	__asm        jne    _T19d;
// LINE 154:
	__asm        push   0x3E9;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T276;

	__asm        jmp    tree_error;
// LINE 156:
_T19d:
	__asm        jmp    _T214;
// LINE 159:
_T1a2:
	__asm        jmp    _T214;
// LINE 161:
_T1a7:
	done = 0x1;
// LINE 162:
	__asm        jmp    _T214;
// LINE 164:
_T1b2:
	done = 0x1;
// LINE 165:
	__asm        jmp    _T214;
// LINE 167:
_T1bd:
	done = 0x1;
// LINE 168:
	__asm        push   0x8C085;
	__asm        push   0x5BDF38;
	__asm        push   0xA8;
	__asm        push   0x5BDF48;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 169:
	__asm        jmp    _T214;
// LINE 170:
	__asm        jmp    _T214;
_T1e9:
	__asm        inc    dword ptr [ebp-0x24];
	__asm        cmp    dword ptr [ebp-0x24], 4;
	__asm        ja     _T1bd;

	__asm        mov    eax, [ebp-0x24];
	__asm        jmp    _Switch_200[0][eax*4];
// Switch pointers:
//   _T1b2
//   _T16d
//   _T138
//   _T1a7
//   _T1a2
// LINE 173:
_T214:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        cmp    eax, 0x80;
	__asm        jle    _T240;
// LINE 175:
	__asm        push   0x3EA;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T271;

	__asm        jmp    tree_error;
// LINE 177:
_T240:
	__asm        test   reinterpret_cast<uint32_t>(done), 0xFFFF;
	__asm        je     _T23;
// LINE 179:
	__asm        cmp    result, 2;
	__asm        jne    _T260;

	__asm        mov    ax, 1;
	__asm        jmp    _T263;
_T260:
	__asm        xor    ax, ax;
_T263:
	__asm        jmp    _T285;
// LINE 188:
tree_error:
	__asm        mov    ax, 1;
	__asm        jmp    _T285;
// LINE 190:
_T271:
	__asm        jmp    tree_error;
_T276:
	__asm        jmp    tree_error;
_T27b:
	__asm        jmp    tree_error;
_T280:
	__asm        jmp    tree_error;
_T285:
}

// FUNCTION: COPTER_D 0x0055d1c3
signed char TreeSim::NodeComplete(unsigned short success) {
	/*bp-0x4*/   const /*unpacked*/ struct Behavior::Node *node;
	/*bp-0x8*/   unsigned short done;
	/*bp-0xc*/   /*unpacked*/ struct TreeSim::StackElem *elem;
	/*bp-0x10*/  signed char trans;

// LINE 202:
	done = 0x0;
// LINE 204:
_T12:
	__asm        test   reinterpret_cast<uint32_t>(done), 0xFFFF;
	__asm        jne    _T11f;
// LINE 205:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        cmp    eax, 1;
	__asm        jge    _T49;
// LINE 207:
	__asm        push   0x3EB;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T12e;

	__asm        jmp    tree_error;
// LINE 209:
_T49:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        mov    elem, eax;
// LINE 210:
	__asm        mov    eax, elem;
	__asm        mov    ax, [eax+2];
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        mov    ax, [eax];
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        mov    ecx, elem;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx];
	__asm        mov    node, eax;
// LINE 211:
	__asm        test   reinterpret_cast<uint32_t>(success), 0xFFFF;
	__asm        je     _Ta0;

	trans = node->trueTrans;
// LINE 212:
	__asm        jmp    _Ta9;
_Ta0:
	trans = node->falseTrans;
// LINE 214:
_Ta9:
	__asm        movsx  eax, trans;
	__asm        cmp    eax, 0xFFFFFFFE;
	__asm        jne    _Tce;
// LINE 215:
	done = 0x0;
// LINE 216:
	this->fStackSize--;
// LINE 217:
	success = 0x1;
// LINE 218:
	__asm        jmp    _T11a;
_Tce:
	__asm        movsx  eax, trans;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _Tf3;
// LINE 219:
	done = 0x0;
// LINE 220:
	this->fStackSize--;
// LINE 221:
	success = 0x0;
// LINE 222:
	__asm        jmp    _T11a;
// LINE 223:
_Tf3:
	done = 0x1;
// LINE 224:
	__asm        movsx  ax, trans;
	__asm        mov    ecx, this;
	__asm        movsx  ecx, word ptr [ecx+8];
	__asm        lea    ecx, [ecx*4-4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+4];
	__asm        mov    [ecx+edx+2], ax;
// LINE 226:
_T11a:
	__asm        jmp    _T12;
// LINE 227:
_T11f:
	return trans;
// LINE 231:
tree_error:
	return 0xfd;
// LINE 233:
_T12e:
	__asm        jmp    tree_error;
}

// FUNCTION: COPTER_D 0x0055d2fd
void TreeSim::GetCurrentNode(short * treeID, short * nodeNum) {
	/*bp-0x4*/   /*unpacked*/ struct TreeSim::StackElem *elem;

// LINE 240:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        test   eax, eax;
	__asm        jg     _T37;

	__asm        push   0x8C085;
	__asm        push   0x5BDF70;
	__asm        push   0xF0;
	__asm        push   0x5BDF7C;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 241:
_T37:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        mov    ecx, this;
	__asm        movsx  ecx, word ptr [ecx+0xA];
	__asm        cmp    eax, ecx;
	__asm        jle    _T69;

	__asm        push   0x8C085;
	__asm        push   0x5BDFA4;
	__asm        push   0xF1;
	__asm        push   0x5BDFB4;
	__asm        call   doAssert;
	__asm        add    esp, 0x10;
// LINE 243:
_T69:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        mov    elem, eax;
// LINE 245:
	treeID[0] = elem->treeID;
// LINE 246:
	nodeNum[0] = elem->nodeNum;
// LINE 247:
	return;
}

// FUNCTION: COPTER_D 0x0055d3a5
enum TreeSim::ReturnCode ExtSim::TryElement(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
// LINE 256:
	__asm        mov    eax, node;
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx];
	__asm        jmp    _T29;
// LINE 257:
_T29:
}

// FUNCTION: COPTER_D 0x0055d3d5
void ExtSim::Error(short errNum) {
// LINE 263:
	__asm        mov    eax, reinterpret_cast<uint32_t>(errNum);
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
// LINE 264:
	return;
}

// FUNCTION: COPTER_D 0x0055d402
unsigned short ExtSim::Simulate(long ticks, unsigned short bOnceOnly) {
	/*bp-0x4*/   short savestacksize;
	/*bp-0x8*/   short savemaxstacksize;
	/*bp-0xc*/   unsigned short ret;
	/*bp-0x10*/  /*unpacked*/ struct TreeSim::StackElem *savestack;

// LINE 272:
	savestack = this->fExt->fStack;
// LINE 273:
	savestacksize = this->fExt->fStackSize;
// LINE 274:
	savemaxstacksize = this->fExt->fMaxStackSize;
// LINE 276:
	this->fExt->fStack = this->fStack;
// LINE 277:
	this->fExt->fStackSize = this->fStackSize;
// LINE 278:
	this->fExt->fMaxStackSize = this->fMaxStackSize;
// LINE 280:
	__asm        mov    eax, reinterpret_cast<uint32_t>(bOnceOnly);
	__asm        push   eax;
	__asm        mov    eax, ticks;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::Simulate;
	__asm        mov    ret, ax;
// LINE 282:
	this->fExt->fStack = savestack;
// LINE 283:
	this->fExt->fStackSize = savestacksize;
// LINE 284:
	this->fExt->fMaxStackSize = savemaxstacksize;
// LINE 286:
	return ret;
// LINE 287:
}



// Contribution: 1:0015c4c0-0015c4f8 Module: 194, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0055d4c0
// TreeSim::`scalar deleting destructor'



// Contribution: 2:00004630-0000463f Module: 194, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for TreeSim @ 0x00593630
//   00: _purecall @ 0x0056cfa0
//   01: _purecall @ 0x0056cfa0
//   02: TreeSim::`scalar deleting destructor' @ 0x0055d4c0
//   03: TreeSim::Simulate @ 0x0055cf37
//   4 entries



// Contribution: 3:00026e9c-00026fdb Module: 194, 4 byte alignment, initialized_data, read, write, 
