// Module: Yobjsim.obj
// Source: C:\Copter\Source\X\Y\Yobjsim.cpp
// autogenerated by simcopter_tool from PDB file

// Type: enum TreeSim::ReturnCode (/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);

// Type: int32_t;

// Type: /*unpacked*/ struct Point3d;
struct Point3d{ // not packed(0xc bytes) TI: 0x348f
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: unsigned short;

// Type: /*unpacked*/ class cYObject (forward reference);
// VTABLE: COPTER_D 0x005935e0
class cYObject : public TreeSim, public YObjLang
{ // not packed(0x168 bytes) TI: 0x48a0
	using DataType = short;
	enum /* __unnamed */ {
		kNumData = 48,
		kNumTemp = 8,
		kNumPointers = 4,
	};
	struct cYObject::ObjDefHeader{ // not packed(0x1c bytes) TI: 0x374c
		/*+0x0*/   long version;
		/*+0x4*/   short stackSize; // 0x2 bytes
		/*+0x6*/   short baseGraphic; // 0x2 bytes
		/*+0x8*/   short numGraphics; // 0x2 bytes
		/*+0xa*/   short initBhav; // 0x2 bytes
		/*+0xc*/   short toolbarPict; // 0x2 bytes
		/*+0xe*/   short treeTableID; // 0x2 bytes
		/*+0x10*/  short personalityID; // 0x2 bytes
		/*+0x12*/  short type; // 0x2 bytes
		/*+0x14*/  short red; // 0x2 bytes
		/*+0x16*/  short green; // 0x2 bytes
		/*+0x18*/  short blue; // 0x2 bytes
		/*+0x1a*/  short _padding2; // 0x2 bytes
	};
	enum MoveErrorCode {
		kMoveError = -1,
		kMoveSuccess = 0,
		kMoveFailTooHigh = 1,
		kMoveFailTooLow = 2,
		kMoveFailNonNeutralTerritory = 3,
		kMoveFailDynObjGeneric = 4,
		kMoveFailDynObjPerson = 5,
		kMoveFailOutOfDynObjRect = 6,
		kMoveFailNoSpeed = 7,
		kMoveFailFinishedMoving = 8,
		kMoveFailStaticObj = 9,
		kMoveFailStackObject = 10,
		kMoveFailUnwalkableLoctype = 11,
		kMoveFailOutOfRoad = 12,
	};
	enum ObjectType {
		kPerson = 0,
		kNumObjectTypes = 1,
	};
public:
	static short sStackSize[1];
	void SetToLoc(/*unpacked*/ struct _DYOBJ_INST*);
	unsigned short Gosub(short);
	short GetTree();
	void ReceiveHit(long, /*unpacked*/ struct _DYOBJ_INST*, /*unpacked*/ struct _DYOBJ_INST*, long, long);
	void Die();
	enum MissionUpdates {
		kPickedUp = 0,
		kOuttaHere = 1,
		kReportNewPickupLocation = 2,
		kJoinedRiot = 3,
		kDrivenFromRiot = 4,
		kLeftRiotOfOwnVolition = 5,
		kReportNewLocation = 6,
		kMedVicToted = 7,
		kMedVicPickedUp = 8,
		kPersonCaught = 9,
	};
	enum Checks {
		kHeliLanded = 0,
		kHeliLow = 1,
		kMasterObjectLow = 2,
		kMasterObjectMovingSlowly = 3,
		kStackObjectLow = 4,
	};
	enum CompareMyLocWith {
		kMissionDestLoc = 0,
		kStackPointer = 1,
		kHeli = 2,
		kBucket = 3,
		kLastHitter = 4,
		kClosestMedevacVictim = 5,
		kClosestCriminal = 6,
		k_pad_MotherShipLoc = 7,
		kClosestCop = 8,
		kAvatarClose = 9,
		kClosestAmbulance = 10,
		kClosestCopCar = 11,
		kClosestFiretruck = 12,
		kClosestCriminalCar = 13,
		kClosestAmbient = 14,
	};
public:
	short * GetLocalVar(short);
	// calltype: NearC
	static void StartScurkPeople(short, short);
	// calltype: NearC
	static void StartScurkPeopleNearAvatar();
	// calltype: NearC
	static void BeamRemainingAmbients();
	// calltype: NearC
	static void StartForScurkID(enum PersonType, enum MissionType, short, short, short, /*unpacked*/ struct _DYOBJ_INST*, int32_t, int32_t);
	// calltype: NearC
	static void StartForScurkID(enum PersonType, enum MissionType, short, short, short, /*unpacked*/ struct _DYOBJ_INST*);
	unsigned short GetNearbyFire(short, short *, short *);
	unsigned short StartMission(enum PersonType, enum MissionType, short, short, long, /*unpacked*/ struct _DYOBJ_INST*, /*unpacked*/ struct Point3d*);
	unsigned short StartScurkAmbientMission(short, short, enum PersonType, short, short, /*unpacked*/ struct _DYOBJ_INST*, int32_t, int32_t);
	unsigned short StartScurkAmbientMission(short, short, enum PersonType, short, short, /*unpacked*/ struct _DYOBJ_INST*, /*unpacked*/ struct Point3d*);
	void ResetToAmbient();
	long JoinRiot();
	// calltype: NearC
	static short StartPerson(enum PersonType, enum MissionType);
	unsigned short AddToHeli();
	void RemoveFromHeli();
	void SetPersonData(enum PersonType, enum MissionType, long);
	static short sInitBhav[14];
	static short sHitRxnTree[20];
	// calltype: NearC
	static void SetRxnTree(short, short);
	static long sSimTicks;
	/*+0x18*/  long fLastInterrupt;
	enum LocationType {
		kOutOfCity = -1,
		kLocNoInfo = 0,
		kLocUnknown = 1,
		kNothing = 2,
		kForest = 3,
		kRubble = 4,
		kSmallPark = 5,
		kWireStuff = 6,
		kCarRoad = 7,
		kCarBridge = 8,
		kTrainTrack = 9,
		kDomestic = 10,
		kCommercial = 11,
		kWhiteCollarBusiness = 12,
		kBlueCollarBusiness = 13,
		kNumLocTypes = 14,
	};
public:
	static enum cYObject::LocationType sLocType[256];
	enum SearchType {
		kSearchEdgeGround = 0,
		kSearchAnywhereGround = 1,
		kSearchRoof = 2,
		kSearchAnywhereAtAll = 3,
	};
	struct cYObject::LocationInfo{ // not packed(0x8 bytes) TI: 0x425a
		/*+0x0*/   enum cYObject::SearchType searchType;
		/*+0x4*/   short maxNormalLoiterers; // 0x2 bytes
	};
public:
	static /*unpacked*/ struct cYObject::LocationInfo sLocInfo[14];
	/*unpacked*/ struct _DYOBJ_INST* SearchForDynObj(short, short, /*unpacked*/ struct _DYOBJ_INST*);
	short GetDirectionTo(/*unpacked*/ struct _DYOBJ_INST*);
	short GetDirectionTo(short, short);
	unsigned short SearchForPersonSpot(/*unpacked*/ struct _CELL_INFO*, /*unpacked*/ struct Point3d*, enum cYObject::SearchType);
	unsigned short SearchForPersonSpot(/*unpacked*/ struct _CELL_INFO*, int32_t *, int32_t *, enum cYObject::SearchType);
	unsigned short SearchForPersonSpot(/*unpacked*/ struct _DYOBJ_INST*, /*unpacked*/ struct Point3d*);
	static short sBeamed;
	static short sDebugNumBeamed;
	// calltype: NearC
	static unsigned short LikelyToBeamSuccessfully();
	// calltype: NearC
	static short GetScurkID(short, short);
	// calltype: NearC
	static unsigned short IsSuitableForMission(enum MissionType, short, short);
	// calltype: NearC
	static unsigned short IsNeutralForPerson(enum PersonType, enum cYObject::LocationType);
	unsigned short IsNeutralAndSparse(/*unpacked*/ struct _CELL_INFO*, enum cYObject::LocationType);
	// calltype: NearC
	static /*unpacked*/ struct Point3d GetPos(unsigned char, unsigned char, int32_t, int32_t);
	// calltype: NearC
	static /*unpacked*/ struct Point3d GetPos(/*unpacked*/ struct _CELL_INFO*, int32_t, int32_t);
	unsigned short AdjoinsRoad(/*unpacked*/ struct Point3d);
	unsigned short RoadTile(int32_t, int32_t);
	unsigned short GetNeutralLoc(int32_t *, int32_t *, int32_t *, int32_t *);
	void UpdateMission(enum cYObject::MissionUpdates, long);
	void ResetTree();
	void ResetTree(short);
	struct cYObject::MoveInfo{ // not packed(0x10 bytes) TI: 0x3748
		/*+0x0*/   enum cYObject::LocationType *locType;
		/*+0x4*/   signed char * roadDir;
		/*+0x8*/   /*unpacked*/ struct _DYOBJ_INST *dyBlock;
		/*+0xc*/   /*unpacked*/ struct _STOBJ_INST *stBlock;
	};
	struct cYObject::_ControlInput{ // not packed(0x18 bytes) TI: 0x3745
		/*+0x0*/   /*unpacked*/ struct Point3d vector; // 0xc bytes
		/*+0xc*/   int32_t fwdSpeed;
		/*+0x10*/  int32_t rotateRate;
		/*+0x14*/  int32_t yaw;
	};
	struct cYObject::_ControlInput{ // not packed(0x18 bytes) TI: 0x3745
		/*+0x0*/   /*unpacked*/ struct Point3d vector; // 0xc bytes
		/*+0xc*/   int32_t fwdSpeed;
		/*+0x10*/  int32_t rotateRate;
		/*+0x14*/  int32_t yaw;
	};
private:
	static unsigned short sInited;
	static /*unpacked*/ class cYObject *sObjects[100];
	static enum cYObject::LocationType sNeutralPersonLocs[18][10];
	static enum cYObject::LocationType sNeutralMissionLocs[14][10];
	static /*unpacked*/ class cYObject *sList;
	static /*unpacked*/ class NResFile sFile;
	static /*unpacked*/ class ResFile sErrorFile;
public:
	static /*unpacked*/ class YObjLang *sLanguage;
	static /*unpacked*/ class Behavior *sBehavior;
	static /*unpacked*/ struct Point3d sMoveTable[8];
	static /*unpacked*/ struct Point3d sUnitVectorTable[8];
	// calltype: NearC
	static void InitObjects(char *);
	// calltype: NearC
	static void DestroyObjects();
	// calltype: NearC
	static short MakeNewObject(short, /*unpacked*/ struct Point3d, /*unpacked*/ class Behavior*);
	// calltype: NearC
	static void KillObject(short);
	// calltype: NearC
	static void MakePlebes();
	void InitForEngine(short);
	void TellLocToEngine();
	/*unpacked*/ class cYObject* GetClosest(enum MissionSupertype, enum MissionType, unsigned short, short *);
	// calltype: NearC
	static /*unpacked*/ class cYObject* GetObjectA(short);
	// calltype: NearC
	static /*unpacked*/ class cYObject* GetObjectA(/*unpacked*/ struct _DYOBJ_INST*);
	/*unpacked*/ class cYObject* GetPersonWithMaster(/*unpacked*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static /*unpacked*/ class cYObject* GetSleepingPerson();
	// calltype: NearC
	static void DrawOnePerson(/*unpacked*/ struct VRBlit*);
	void SetCell(unsigned char, unsigned char);
	void UnsetCell(unsigned char, unsigned char);
	void Link();
	void Link(unsigned char, unsigned char);
	/*+0x1c*/  long fMissionID;
	void PutOnGround();
	void Unlink();
	unsigned short CellIsSet();
	/*+0x20*/  unsigned short fbLinked; // 0x2 bytes
	unsigned short Linked();
	/*+0x22*/  unsigned short fInited; // 0x2 bytes
	// calltype: NearC
	static unsigned short ConvertObjDef(void * __ptr32);
	// calltype: NearC
	static short GetAvailRouteMask();
	// calltype: NearC
	static void ClearRouteMask(short);
	// calltype: NearC
	static void MaskTile(short, short, short);
	// calltype: NearC
	static void IntegrityCheck(unsigned char *);
	static short sNumMissionAwake;
	static short sNumAmbientAwake;
	static unsigned short sAllAmbientStarted;
	static short sAmbientTopOff;
	static short sAmbientAbsoluteMax;
	static short sScurkRectRad;
	/*+0x24*/  /*unpacked*/ struct _DYOBJ_INST fDyn; // 0x64 bytes
	/*+0x88*/  unsigned char fCellX; // 0x1 bytes
	/*+0x89*/  unsigned char fCellY; // 0x1 bytes
	/*+0x8c*/  unsigned long fBodyName;
	/*+0x90*/  /*unpacked*/ class cCopterBody *fBody;
	/*+0x94*/  unsigned long fAnimName;
	/*+0x98*/  /*unpacked*/ class cCopterAnim *fAnim;
	/*+0x9c*/  short fFace; // 0x2 bytes
	void SetFace(short);
	/*+0xa0*/  /*unpacked*/ struct Point3d fLastMasterLoc; // 0xc bytes
	unsigned short SetMaster(/*unpacked*/ struct _DYOBJ_INST*);
	/*unpacked*/ struct _DYOBJ_INST* GetMaster();
	void FollowMaster();
	/*+0xac*/  enum cYObject::LocationType fCurLocType;
	// calltype: NearC
	static unsigned short GetOutOfHeli(long);
	// calltype: NearC
	static /*unpacked*/ struct Point2d GetRiotCenter(short, short);
	// calltype: NearC
	static /*unpacked*/ struct Point2d GetRiotCenter(long);
	void SimAnim();
	void Simulate();
	// calltype: NearC
	static void SimulateAll();
	// calltype: NearC
	static void TryStartAllAmbient();
	unsigned long GetBody();
	void SetBody(unsigned long);
	void IncAndCheckAnimFrame();
	void CheckAnimFrame();
	// calltype: NearC
	static /*unpacked*/ class cYObject* GetOnePersonForScurkID(short, short);
	// calltype: NearC
	static /*unpacked*/ struct _DYOBJ_INST* GetFirstDynObj(/*unpacked*/ struct _CELL_INFO*, long);
	// calltype: NearC
	static short CountDynObjs(/*unpacked*/ struct _CELL_INFO*, long);
	void SetMissionType(enum MissionType);
	void SetMissionID(long);
	void SetPersonType(enum PersonType);
	void ChangeMission(enum MissionType, long);
	void IncrementMissionStats(enum MissionType, short);
	void ClickHeels();
	void VisitOz();
	unsigned long GetAnim();
	void SetAnim(unsigned long);
	/*+0xb0*/  unsigned short fSimulate; // 0x2 bytes
	/*+0xb4*/  /*unpacked*/ class Behavior *fBehavior;
	/*+0xb8*/  /*unpacked*/ class cYObject *fNext;
	/*+0xbc*/  short fID; // 0x2 bytes
	/*+0xbe*/  short _pad; // 0x2 bytes
	/*+0xc0*/  short fTemp[8]; // 0x10 bytes
	/*+0xd0*/  short fData[48]; // 0x60 bytes
	/*+0x130*/ unsigned char * fPointers[4]; // 0x10 bytes
	/*+0x140*/ short fIterations; // 0x2 bytes
	/*+0x142*/ short _pad2; // 0x2 bytes
	/*+0x144*/ short fDirInc; // 0x2 bytes
	/*+0x148*/ /*unpacked*/ struct cYObject::ObjDefHeader fDefinition; // 0x1c bytes
	enum /* __unnamed */ {
		kMasterObject = 0,
		kLastHitterObject = 1,
	};
	enum /* __unnamed */ {
		kDirection = 0,
		kAwake = 1,
		kHeightCanJump = 2,
		kPersonType = 3,
		kMissionType = 4,
		kMissionSupertype = 5,
		kAnimFrame = 6,
		kObjectID = 7,
		kRiotVal = 8,
		kVisible = 9,
		kLastRiotVal = 10,
		kNearMedFar = 11,
		kLastHitterMsg = 12,
		kMegaphoneMessage = 13,
		kInRxnTree = 14,
		kDead = 15,
		kColorIndexShift = 16,
		kDynAnim = 17,
		kSpeed = 18,
		kOnlyOnRoad = 19,
		kMoveOnlyNeutrally = 20,
		kMoveNoMatterWhat = 21,
		kSpecificToScurkID = 22,
		kCaptured = 23,
		kStartingObject = 24,
		kSoundChannel = 25,
		kCurrentSound = 26,
		kDynSound = 27,
		kSoundFrequencyAdj = 28,
		kInitBhav = 29,
		kLastRxnTree = 30,
	};
protected:
	virtual enum TreeSim::ReturnCode TryElement(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*) /* override */;
	virtual void HandleOverflow(); // vtable+0x10
	virtual short InterpValue(short, short, short **); // vtable+0x14
	enum TreeSim::ReturnCode TryExpression(/*unpacked*/ struct YObjLang::AttrParam*);
public:
	enum cYObject::MoveErrorCode TryVectorMove(/*unpacked*/ struct Point3d, int32_t, /*unpacked*/ struct cYObject::MoveInfo*);
	enum cYObject::MoveErrorCode TryTableMove(short, unsigned short, /*unpacked*/ struct cYObject::MoveInfo*);
	enum cYObject::MoveErrorCode TryMove(unsigned short, /*unpacked*/ struct cYObject::MoveInfo*, int32_t, int32_t, int32_t, unsigned short);
	enum cYObject::LocationType GetLocType();
	// calltype: NearC
	static enum cYObject::LocationType GetLocType(short, short);
	// calltype: NearC
	static unsigned short IsWater(short, short);
	unsigned short IsWalkable(short, short, enum cYObject::LocationType);
	unsigned short CanJumpOffHere();
	// calltype: NearC
	static signed char GetRoadDir(/*unpacked*/ struct Point3d);
	enum SoundNum {
		kSNone = -1,
		kSAssertion = 1,
		kSDunno = 2,
		kSHoHum = 3,
		kSQuery = 4,
		kSSad = 5,
		kSTitter = 6,
		kSYouGoGirl = 7,
		kSGrunt = 8,
		kSWhoa = 9,
		kSHey = 10,
		kSHiThere = 11,
		kSAaah = 12,
		kSAck = 13,
		kSFeet = 14,
		kSYrUnderArrest = 15,
		kSGimmeYrCash = 16,
		kSSinisterChuckle = 17,
		kSSayYrKindaHot = 18,
	};
public:
	// calltype: NearC
	static short DistributeSoundChannels(short, short);
	unsigned short PlaySoundA(enum cYObject::SoundNum, unsigned short);
	// calltype: NearC
	static void PhaseAndBeamSoundChannels();
	static short sSoundChannels[15];
	// calltype: NearC
	static short ExtraSoundChannelForSure();
	// calltype: NearC
	static short RegSoundChannel();
	// calltype: NearC
	static void StopAllSounds();
	void StopSound();
	void ClearSoundChannel();
	short GetActualSoundChannel();
	// calltype: NearC
	static short GetActualSoundChannel(short);
	void SetSoundChannel(short);
	// calltype: NearC
	static short GetSRadius(/*unpacked*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static int32_t GetRadius(/*unpacked*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static /*unpacked*/ struct _DYOBJ_INST* GetDynObj(/*unpacked*/ struct _DYOBJ_INST*, /*unpacked*/ struct Point3d, int32_t, /*unpacked*/ struct _DYOBJ_INST*, /*unpacked*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static /*unpacked*/ struct _STOBJ_INST* GetStaticObj(/*unpacked*/ struct Point3d, int32_t);
	// calltype: NearC
	static unsigned short InBoundingRect(/*unpacked*/ struct Point3d, int32_t, /*unpacked*/ struct Point3d, int32_t);
	unsigned short MasterSlowerThan(short);
	short GetHeightOverGround();
	unsigned short GetFakeDistTo(/*unpacked*/ struct _DYOBJ_INST*);
	unsigned short CloseTo(/*unpacked*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static /*unpacked*/ class cYObject* GetFirst();
	// calltype: NearC
	static /*unpacked*/ class cYObject* GetFirst(short, short);
	// calltype: NearC
	static /*unpacked*/ class cYObject* GetFirstInvisible(short);
	/*unpacked*/ class cYObject* PutTotedMedVicOnHeli();
	/*unpacked*/ class cYObject* PutTotedMedVicOn(/*unpacked*/ struct _DYOBJ_INST*);
	unsigned short SetStartingObject(/*unpacked*/ struct _DYOBJ_INST*);
	/*unpacked*/ class cYObject* DropToted();
	/*unpacked*/ class cYObject* GetToted();
	unsigned short GetOffMasterObject();
	// calltype: NearC
	static unsigned short IsHigherThan(/*unpacked*/ struct Point3d, short);
	// calltype: NearC
	static unsigned short IsFlattenedTerrain(/*unpacked*/ struct _CELL_INFO*);
	// calltype: NearC
	static void RandomEdgeOffset(short, int32_t *, int32_t *);
	// calltype: NearC
	static void RandomOffset(short, int32_t *, int32_t *);
	virtual void Reset(); // vtable+0x18
	virtual void ~cYObject() /* override */;
protected:
	virtual void Error(short) /* override */;
	void cYObject(short, /*unpacked*/ class Behavior*, /*unpacked*/ struct Point3d, short);
public:
	/*unpacked*/ struct cYObject::ObjDefHeader* GetDef();
	void GetTypeName(char *);
	// calltype: NearC
	static /*unpacked*/ class ResFile* GetGlobalFile();
	// calltype: NearC
	static /*unpacked*/ class YObjLang* GetLanguage();
	// calltype: NearC
	static /*unpacked*/ class ResFile* GetErrorFile();
	short GetID();
	/*unpacked*/ struct Point3d GetLocation();
	/*unpacked*/ class Behavior* GetBehavior();
	void Draw(/*unpacked*/ struct VRBlit*);
	/*+0x164*/ float fScale;
	void DefaultDrawStr(short, short, unsigned char, unsigned char *, int32_t);
	void SetCellAndLoc(/*unpacked*/ struct Point3d, unsigned char, unsigned char);
	void SetCellAndLoc(unsigned char, unsigned char, int32_t, int32_t);
	void Start(int32_t, int32_t, int32_t, int32_t);
	unsigned short BeamIntoCameraRange();
	unsigned short OutOfCameraRange();
	unsigned short CanPlace(/*unpacked*/ struct Point3d);
	void AdjustRadiusForRiotVal();
	unsigned short HasRiotValChanged();
	void IncrementRiotVal(short);
	void GetSurroundingRiotInfo(short, short *, short *, short *);
	void Turn(short);
	/*unpacked*/ class cYObject* GetNext();
	void DynEffects(short, enum cYObject::MoveErrorCode, /*unpacked*/ struct cYObject::MoveInfo*);
	void DynEffectsFixed(int32_t, enum cYObject::MoveErrorCode, /*unpacked*/ struct cYObject::MoveInfo*);
	using PrimProc = enum TreeSim::ReturnCode (*)(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
public:
	static enum TreeSim::ReturnCode (*PrimProcs[64])(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sIdle(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iIdle(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sSetAnim(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iSetAnim(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sAttr(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iAttr(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sWalk(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iWalk(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sSetBody(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iSetBody(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sRandom(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iRandom(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sWalkToAndGrabOntoStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iWalkToAndGrabOntoStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sUpdateMyMission(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iUpdateMyMission(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sCheckForTrue(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iCheckForTrue(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sCompareMyLocWith(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iCompareMyLocWith(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sSelfDecommission(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iSelfDecommission(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGetOffMasterObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGetOffMasterObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sTurnTowardsStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iTurnTowardsStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sIsThisLocType(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iIsThisLocType(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sIsThisLocTypeNeutral(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iIsThisLocTypeNeutral(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sCanJumpOffHere(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iCanJumpOffHere(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sCheckForSpotlightInMyCell(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iCheckForSpotlightInMyCell(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sIncrementRiotVal(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iIncrementRiotVal(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGetSurroundingRiotVal(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGetSurroundingRiotVal(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sIsThisScurkID(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iIsThisScurkID(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGosubToInitbhav(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGosubToInitbhav(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sAdjustRadiusForRiotVal(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iAdjustRadiusForRiotVal(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sJoinRiot(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iJoinRiot(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sSetDirection(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iSetDirection(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sThrowProjectile(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iThrowProjectile(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sTurnFromStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iTurnFromStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sTurnFromLastHitter(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iTurnFromLastHitter(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sTurnTowardsLastHitter(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iTurnTowardsLastHitter(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGetOutOfRoadEtc(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGetOutOfRoadEtc(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGenerateMedevacAndSetSelfAsVictim(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGenerateMedevacAndSetSelfAsVictim(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sTurnToNearbyFire(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iTurnToNearbyFire(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sDie(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iDie(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sWalkToStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iWalkToStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sPutObjIntoTreeNum(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iPutObjIntoTreeNum(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sVisitOz(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iVisitOz(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sMakeMyMedevacVictimVisible(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iMakeMyMedevacVictimVisible(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sMakeMyMedevacVictimInvisible(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iMakeMyMedevacVictimInvisible(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sMakeMeMasterOfStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iMakeMeMasterOfStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sMakeMyStackObjectVisitOz(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iMakeMyStackObjectVisitOz(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sPutTotedMedVicOnStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iPutTotedMedVicOnStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sTakeAnyMedVicOffStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iTakeAnyMedVicOffStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGetOnStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGetOnStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sUpdateStackVictimToted(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iUpdateStackVictimToted(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGetNumSpacesOnStackObject(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGetNumSpacesOnStackObject(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sDropToted(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iDropToted(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sUpdateStackVictimPickedUp(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iUpdateStackVictimPickedUp(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sCloseToHeli(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iCloseToHeli(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sSetMyExpression(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iSetMyExpression(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGetHeliSpeedPlusDamage(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGetHeliSpeedPlusDamage(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sIsThisCellSafe(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iIsThisCellSafe(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sPlaySound(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iPlaySound(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sGetOnHeliIfHarnessRaised(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iGetOnHeliIfHarnessRaised(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sAmIOnHeli(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iAmIOnHeli(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sThrowFieryProjectile(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iThrowFieryProjectile(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sTellStartingObjectTrueOrFalse(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iTellStartingObjectTrueOrFalse(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sPutMyCarInStack(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iPutMyCarInStack(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	// calltype: NearC
	static enum TreeSim::ReturnCode sDoIHaveAMaster(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
	enum TreeSim::ReturnCode iDoIHaveAMaster(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);
};

// Type: long;

// Type: /*unpacked*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // not packed(0x64 bytes) TI: 0x3681
	/*+0x0*/   /*unpacked*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*unpacked*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*unpacked*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: float;

// Type: char;

// Type: short;

// Type: void;

// Type: /*unpacked*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // not packed(0x18 bytes) TI: 0x3671
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*unpacked*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*unpacked*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*unpacked*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*unpacked*/ struct Point2d;
struct Point2d{ // not packed(0x8 bytes) TI: 0x363e
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*unpacked*/ struct _STOBJ_INST (forward reference);
struct _STOBJ_INST{ // not packed(0x10 bytes) TI: 0x365f
	/*+0x0*/   /*unpacked*/ struct _STOBJ_INST *next;
	/*+0x4*/   void * __ptr32 mesh;
	/*+0x8*/   long user1;
	/*+0xc*/   long user2;
};

// Type: enum cYObject::LocationType;
enum LocationType {
	kOutOfCity = -1,
	kLocNoInfo = 0,
	kLocUnknown = 1,
	kNothing = 2,
	kForest = 3,
	kRubble = 4,
	kSmallPark = 5,
	kWireStuff = 6,
	kCarRoad = 7,
	kCarBridge = 8,
	kTrainTrack = 9,
	kDomestic = 10,
	kCommercial = 11,
	kWhiteCollarBusiness = 12,
	kBlueCollarBusiness = 13,
	kNumLocTypes = 14,
};

// Type: signed char;

// Type: /*unpacked*/ struct cYObject::MoveInfo (forward reference);
struct cYObject::MoveInfo{ // not packed(0x10 bytes) TI: 0x3748
	/*+0x0*/   enum cYObject::LocationType *locType;
	/*+0x4*/   signed char * roadDir;
	/*+0x8*/   /*unpacked*/ struct _DYOBJ_INST *dyBlock;
	/*+0xc*/   /*unpacked*/ struct _STOBJ_INST *stBlock;
};

// Type: enum cYObject::MoveErrorCode;
enum MoveErrorCode {
	kMoveError = -1,
	kMoveSuccess = 0,
	kMoveFailTooHigh = 1,
	kMoveFailTooLow = 2,
	kMoveFailNonNeutralTerritory = 3,
	kMoveFailDynObjGeneric = 4,
	kMoveFailDynObjPerson = 5,
	kMoveFailOutOfDynObjRect = 6,
	kMoveFailNoSpeed = 7,
	kMoveFailFinishedMoving = 8,
	kMoveFailStaticObj = 9,
	kMoveFailStackObject = 10,
	kMoveFailUnwalkableLoctype = 11,
	kMoveFailOutOfRoad = 12,
};

// Type: unsigned char;

// Type: /*unpacked*/ struct TreeSim::StackElem (forward reference);
struct TreeSim::StackElem{ // not packed(0x14 bytes) TI: 0x3614
	/*+0x0*/   short treeID; // 0x2 bytes
	/*+0x2*/   short nodeNum; // 0x2 bytes
	/*+0x4*/   short objectID; // 0x2 bytes
	/*+0x4*/   short _pad; // 0x2 bytes
	/*+0x4*/   unsigned char * objectPtr;
	/*+0x8*/   short locals[4]; // 0x8 bytes
	/*+0x10*/  /*unpacked*/ class Behavior *pBehavior;
	void GetTreeName(unsigned char *);
};

// Type: /*unpacked*/ struct Point2d (forward reference);
struct Point2d{ // not packed(0x8 bytes) TI: 0x363e
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: short *;

// Type: double;

// Type: enum MissionSupertype;
enum MissionSupertype {
	kMissionSupertypeError = -2,
	kCriminal = 0,
	kCop = 1,
	kAmbient = 2,
};

// Type: enum MissionType;
enum MissionType {
	kMissionTypeError = -2,
	kAmbientNoMission = 0,
	kOnCapsizedBoat = 1,
	kOnBurningBuilding = 2,
	kRioting = 3,
	kTransport = 4,
	kMedevacParamedic = 5,
	kMedevacVictim = 6,
	kCopAerial = 7,
	kCopFoot = 8,
	kFireman = 9,
	kCrimRobber = 10,
	kCrimArsonist = 11,
	kCrimMugger = 12,
	kCrimCar = 13,
	kNumMissionTypes = 14,
};

// Type: /*unpacked*/ struct _MISSION_PARMS;
struct _MISSION_PARMS{ // not packed(0x18 bytes) TI: 0x38f9
	/*+0x0*/   long op;
	/*+0x4*/   long id;
	/*+0x8*/   /*unpacked*/ struct Point2d maploc; // 0x8 bytes
	/*+0x10*/  long i2num;
	/*+0x14*/  long flags;
};

// Type: /*unpacked*/ struct Behavior::Node (forward reference);
struct Behavior::Node{ // not packed(0xc bytes) TI: 0x35e3
	/*+0x0*/   short treeID; // 0x2 bytes
	/*+0x0*/   short primCode; // 0x2 bytes
	/*+0x2*/   signed char trueTrans; // 0x1 bytes
	/*+0x3*/   signed char falseTrans; // 0x1 bytes
	/*+0x4*/   /*unpacked*/ struct Behavior::NodeParameter param; // 0x8 bytes
};

// Type: enum TreeSim::ReturnCode;
enum ReturnCode {
	kTrueComplete = 1,
	kFalseComplete = 0,
	kEngaged = 2,
	kError = -1,
	kStackLoaded = 3,
};

// Type: /*unpacked*/ struct YObjLang::IdleParam;
struct YObjLang::IdleParam{ // not packed(0x2 bytes) TI: 0x3578
	/*+0x0*/   short decTemp; // 0x2 bytes
};

// Type: /*unpacked*/ union YObjLang::Param (forward reference);

// Type: /*unpacked*/ struct YObjLang::SetAnimParam;
struct YObjLang::SetAnimParam{ // not packed(0x4 bytes) TI: 0x3576
	/*+0x0*/   unsigned long animname;
};

// Type: /*unpacked*/ struct cYObject::MoveInfo;
struct cYObject::MoveInfo{ // not packed(0x10 bytes) TI: 0x3748
	/*+0x0*/   enum cYObject::LocationType *locType;
	/*+0x4*/   signed char * roadDir;
	/*+0x8*/   /*unpacked*/ struct _DYOBJ_INST *dyBlock;
	/*+0xc*/   /*unpacked*/ struct _STOBJ_INST *stBlock;
};

// Type: /*unpacked*/ struct YObjLang::SetBodyParam;
struct YObjLang::SetBodyParam{ // not packed(0x4 bytes) TI: 0x3574
	/*+0x0*/   unsigned long bodyname;
};

// Type: /*unpacked*/ struct YObjLang::RandomParam;
struct YObjLang::RandomParam{ // not packed(0x6 bytes) TI: 0x3570
	/*+0x0*/   short destTemp; // 0x2 bytes
	/*+0x2*/   short rangeData; // 0x2 bytes
	/*+0x4*/   short rangeOwner; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::WalkAndGrabParam;
struct YObjLang::WalkAndGrabParam{ // not packed(0x4 bytes) TI: 0x357c
	/*+0x0*/   short decTemp; // 0x2 bytes
	/*+0x2*/   short dynAnimBoolean; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::UpdateMyMissionParam;
struct YObjLang::UpdateMyMissionParam{ // not packed(0x2 bytes) TI: 0x3582
	/*+0x0*/   short updateLiteral; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::CheckForTrueParam;
struct YObjLang::CheckForTrueParam{ // not packed(0x2 bytes) TI: 0x3580
	/*+0x0*/   short whatLiteral; // 0x2 bytes
};

// Type: /*unpacked*/ struct _HELI_DATA (forward reference);
struct _HELI_DATA{ // not packed(0x32c bytes) TI: 0x390f
	/*+0x0*/   int32_t type;
	/*+0x4*/   int32_t state;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   int32_t altdelta;
	/*+0x10*/  /*unpacked*/ struct Point2d lastpos; // 0x8 bytes
	/*+0x18*/  /*unpacked*/ struct Point2d currpos; // 0x8 bytes
	/*+0x20*/  int32_t rotor_mat[4][4]; // 0x40 bytes
	/*+0x60*/  int32_t rotortl_mat[4][4]; // 0x40 bytes
	/*+0xa0*/  /*unpacked*/ struct _DYOBJ_INST *dycannon;
	/*+0xa4*/  /*unpacked*/ struct _DYOBJ_INST *dyheli;
	/*+0xa8*/  /*unpacked*/ struct _DYOBJ_INST *dyshadow;
	/*+0xac*/  /*unpacked*/ struct _DYOBJ_INST *dyrotor;
	/*+0xb0*/  /*unpacked*/ struct _DYOBJ_INST *dyrotortl;
	/*+0xb4*/  /*unpacked*/ struct _DYOBJ_INST *dyrotshadow;
	/*+0xb8*/  /*unpacked*/ struct _DYOBJ_INST *dyrope;
	/*+0xbc*/  /*unpacked*/ struct _DYOBJ_INST *dybucket;
	/*+0xc0*/  /*unpacked*/ struct _DYOBJ_INST *dyspot;
	/*+0xc4*/  /*unpacked*/ struct _DYOBJ_INST *dybracket;
	/*+0xc8*/  void * __ptr32 bucketmesh;
	/*+0xcc*/  void * __ptr32 harnessmesh;
	/*+0xd0*/  int32_t damage;
	/*+0xd4*/  int32_t smokeseq;
	/*+0xd8*/  /*unpacked*/ struct mv heli_p; // 0x14 bytes
	/*+0xec*/  /*unpacked*/ struct mv heli_r; // 0x14 bytes
	/*+0x100*/ /*unpacked*/ struct Point3d vector; // 0xc bytes
	/*+0x10c*/ int32_t yaw;
	/*+0x110*/ int32_t collide_delay;
	/*+0x114*/ int32_t roll;
	/*+0x118*/ int32_t slide;
	/*+0x11c*/ int32_t pitch;
	/*+0x120*/ int32_t yawrate;
	/*+0x124*/ int32_t yspeed;
	/*+0x128*/ int32_t fwd_speed;
	/*+0x12c*/ int32_t delta_fwd_speed;
	/*+0x130*/ int32_t movex;
	/*+0x134*/ int32_t movez;
	/*+0x138*/ int32_t hover_ht;
	/*+0x13c*/ int32_t can_land;
	/*+0x140*/ long spotlevel;
	/*+0x144*/ int32_t rotstate;
	/*+0x148*/ int32_t rotspeed;
	/*+0x14c*/ int32_t fireprojectile;
	/*+0x150*/ int32_t terralt;
	/*+0x154*/ int32_t buildalt;
	/*+0x158*/ /*unpacked*/ struct Point3d collisvec; // 0xc bytes
	/*+0x164*/ int32_t shad_color;
	/*+0x168*/ /*unpacked*/ struct _MISSILE_DATA *crash_traj;
	/*+0x16c*/ int32_t crash_timer;
	/*+0x170*/ long crash_seq;
	/*+0x174*/ int32_t over_water;
	/*+0x178*/ /*unpacked*/ struct _ROPE_DATA rinfo; // 0x44 bytes
	/*+0x1bc*/ /*unpacked*/ struct _WATER_DATA winfo; // 0x8 bytes
	/*+0x1c4*/ /*unpacked*/ struct tagHeliPassengerData passengerData; // 0x15c bytes
	/*+0x320*/ int32_t fuel;
	/*+0x324*/ int32_t flight_time;
	/*+0x328*/ int32_t pct_load;
};

// Type: /*unpacked*/ struct YObjLang::CompareMyLocWithParam;
struct YObjLang::CompareMyLocWithParam{ // not packed(0x6 bytes) TI: 0x357e
	/*+0x0*/   short withWhatLiteral; // 0x2 bytes
	/*+0x2*/   short distData; // 0x2 bytes
	/*+0x4*/   short distOwner; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::IsThisLocTypeParam;
struct YObjLang::IsThisLocTypeParam{ // not packed(0x2 bytes) TI: 0x3584
	/*+0x0*/   short locTypeLiteral; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::CheckForSpotParam;
struct YObjLang::CheckForSpotParam{ // not packed(0x4 bytes) TI: 0x358c
	/*+0x0*/   short brightnessTemp; // 0x2 bytes
	/*+0x2*/   short dirToHeliTemp; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::IncrementRiotValParam;
struct YObjLang::IncrementRiotValParam{ // not packed(0x2 bytes) TI: 0x3588
	/*+0x0*/   short riotValLiteral; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::GetSurroundingRiotValParam;
struct YObjLang::GetSurroundingRiotValParam{ // not packed(0x8 bytes) TI: 0x358a
	/*+0x0*/   short distTemp; // 0x2 bytes
	/*+0x2*/   short dirToConcTemp; // 0x2 bytes
	/*+0x4*/   short riotValTemp; // 0x2 bytes
	/*+0x6*/   short numPeopleCountedTemp; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::IsThisScurkIDParam;
struct YObjLang::IsThisScurkIDParam{ // not packed(0x2 bytes) TI: 0x3586
	/*+0x0*/   short scurkIDLiteral; // 0x2 bytes
};

// Type: /*unpacked*/ struct tagLogString;
struct tagLogString{ // not packed(0x14 bytes) TI: 0x38f4
	/*+0x0*/   unsigned long nType;
	/*+0x4*/   unsigned long nTime;
	/*+0x8*/   unsigned long nMissionID;
	/*+0xc*/   char * szLogString;
	/*+0x10*/  char szData[4];
};

// Type: /*unpacked*/ struct YObjLang::SetDirectionParam;
struct YObjLang::SetDirectionParam{ // not packed(0x2 bytes) TI: 0x358e
	/*+0x0*/   short dirTemp; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::GetOutOfRoadParam;
struct YObjLang::GetOutOfRoadParam{ // not packed(0x2 bytes) TI: 0x358f
	/*+0x0*/   short decTemp; // 0x2 bytes
};

// Type: /*unpacked*/ struct YObjLang::TurnToFireParam;
struct YObjLang::TurnToFireParam{ // not packed(0x4 bytes) TI: 0x3591
	/*+0x0*/   short xdistloc; // 0x2 bytes
	/*+0x2*/   short ydistloc; // 0x2 bytes
};

// Type: enum cYObject::MissionUpdates;
enum MissionUpdates {
	kPickedUp = 0,
	kOuttaHere = 1,
	kReportNewPickupLocation = 2,
	kJoinedRiot = 3,
	kDrivenFromRiot = 4,
	kLeftRiotOfOwnVolition = 5,
	kReportNewLocation = 6,
	kMedVicToted = 7,
	kMedVicPickedUp = 8,
	kPersonCaught = 9,
};

// Type: /*unpacked*/ struct YObjLang::AttrParam (forward reference);
struct YObjLang::AttrParam{ // not packed(0x8 bytes) TI: 0x3568
	/*+0x0*/   short lhsData; // 0x2 bytes
	/*+0x2*/   short rhsData; // 0x2 bytes
	/*+0x4*/   LfBitfield @ 0x5d5b4:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
	[90m   LB.[95mTI[m = 0x3565
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 isSigned; // 0x8 bytes
	/*+0x4*/   LfBitfield @ 0x5d5bc:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
	[90m   LB.[95mTI[m = 0x3566
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x8
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 opType; // 0x8 bytes
	/*+0x6*/   LfBitfield @ 0x5d5b4:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
	[90m   LB.[95mTI[m = 0x3565
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 lhsOwner; // 0x8 bytes
	/*+0x6*/   LfBitfield @ 0x5d5bc:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
	[90m   LB.[95mTI[m = 0x3566
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x8
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 rhsOwner; // 0x8 bytes
};

// Type: /*unpacked*/ class TreeSim;
// VTABLE: COPTER_D 0x00593630
class TreeSim{ // not packed(0x14 bytes) TI: 0x3610
	enum /* __unnamed */ {
		kNumLocals = 4,
		kMaxIterations = 128,
	};
	struct TreeSim::StackElem{ // not packed(0x14 bytes) TI: 0x3614
		/*+0x0*/   short treeID; // 0x2 bytes
		/*+0x2*/   short nodeNum; // 0x2 bytes
		/*+0x4*/   short objectID; // 0x2 bytes
		/*+0x4*/   short _pad; // 0x2 bytes
		/*+0x4*/   unsigned char * objectPtr;
		/*+0x8*/   short locals[4]; // 0x8 bytes
		/*+0x10*/  /*unpacked*/ class Behavior *pBehavior;
		void GetTreeName(unsigned char *);
	};
private:
	/*+0x4*/   /*unpacked*/ struct TreeSim::StackElem *fStack;
	/*+0x8*/   short fStackSize; // 0x2 bytes
	/*+0xa*/   short fMaxStackSize; // 0x2 bytes
	/*+0xc*/   short fIterations; // 0x2 bytes
	/*+0xe*/   short _pad; // 0x2 bytes
	/*+0x10*/  short * fAutoStackArea;
	enum ReturnCode {
		kTrueComplete = 1,
		kFalseComplete = 0,
		kEngaged = 2,
		kError = -1,
		kStackLoaded = 3,
	};
	enum /* __unnamed */ {
		kStackErrorBase = 1000,
		kStackOverflow = 1000,
		kUndefinedTransition = 1001,
		kTooManyIterations = 1002,
		kStackUnderflow = 1003,
		kStackErrorMax = 1004,
	};
protected:
	virtual enum TreeSim::ReturnCode TryElement(/*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*); // vtable+0x0
	virtual void Error(short); // vtable+0x4
	void GetCurrentNode(short *, short *);
	void Reset(/*unpacked*/ class Behavior*, short);
	signed char NodeComplete(unsigned short);
	unsigned short Gosub(/*unpacked*/ class Behavior*, short *, short);
public:
	void TreeSim(short, short *);
	void TreeSim(short, short, /*unpacked*/ class Behavior*, short *);
	virtual void ~TreeSim(); // vtable+0x8
	virtual unsigned short Simulate(long, unsigned short); // vtable+0xc
	/*unpacked*/ struct TreeSim::StackElem* GetHighLevelAction();
	/*unpacked*/ struct TreeSim::StackElem* GetCurElem();
	/*unpacked*/ struct TreeSim::StackElem* GetNthElem(short);
	short GetStackSize();
	short GetMaxStackSize();
};

// Type: /*unpacked*/ class YObjLang;
// VTABLE: COPTER_D 0x005936e8
class YObjLang : public Language
{ // not packed(0x4 bytes) TI: 0x484d
public:
	void YObjLang(/*unpacked*/ class YObjLang&);
	void YObjLang(unsigned char *);
	void ~YObjLang();
	virtual void GetNodeText(/*unpacked*/ class Behavior*, /*unpacked*/ struct Behavior::Node*, unsigned char *) /* override */;
	virtual void GetPrimName(short, unsigned char *) /* override */;
	virtual unsigned short IsSingleExit(/*unpacked*/ struct Behavior::Node*) /* override */;
	// calltype: NearC
	static void SwizzleTreeParam(short, /*unpacked*/ struct Behavior::NodeParameter*);
	// calltype: NearC
	static void SwizzleTree(void * __ptr32, long);
	virtual void (*)(void * __ptr32, long) GetSwizzler() /* override */;
	enum /* __unnamed */ {
		kIdle = 0,
		kSetAnim = 1,
		kAttr = 2,
		_kWhatsAhead = 3,
		kWalk = 4,
		_kRunPad = 5,
		kSetBody = 6,
		kRandom = 7,
		_kGetDirDistToFirst = 8,
		_kGetDirDistToPerson = 9,
		_kRoadDir = 10,
		_kSearchForDyn = 11,
		kWalkToAndGrabOntoStackObject = 12,
		kUpdateMyMission = 13,
		kCheckForTrue = 14,
		kCompareMyLocWith = 15,
		kSelfDecommission = 16,
		kGetOffMasterObject = 17,
		kTurnTowardsStackObject = 18,
		kIsThisLocType = 19,
		kIsThisLocTypeNeutral = 20,
		kCanJumpOffHere = 21,
		kCheckForSpotlightInMyCell = 22,
		kIncrementRiotVal = 23,
		kGetSurroundingRiotVal = 24,
		kIsThisScurkID = 25,
		kGosubToInitbhav = 26,
		kAdjustRadiusForRiotVal = 27,
		kJoinRiot = 28,
		kSetDirection = 29,
		kThrowProjectile = 30,
		kTurnFromStackObject = 31,
		kTurnFromLastHitter = 32,
		kTurnTowardsLastHitter = 33,
		kGetOutOfRoadEtc = 34,
		kGenerateMedevacAndSetSelfAsVictim = 35,
		kTurnToNearbyFire = 36,
		kDie = 37,
		kWalkToStackObject = 38,
		kPutObjIntoTreeNum = 39,
		kVisitOz = 40,
		_kNotUsed = 41,
		kMakeMyMedevacVictimVisible = 42,
		kMakeMyMedevacVictimInvisible = 43,
		kMakeMeMasterOfStackObject = 44,
		kMakeMyStackObjectVisitOz = 45,
		kPutTotedMedVicOnStackObject = 46,
		kTakeAnyMedVicOffStackObject = 47,
		kGetOnStackObject = 48,
		kUpdateStackVictimToted = 49,
		kGetNumSpacesOnStackObject = 50,
		kDropToted = 51,
		kUpdateStackVictimPickedUp = 52,
		kCloseToHeli = 53,
		kSetMyExpression = 54,
		kGetHeliSpeedPlusDamage = 55,
		kIsThisCellSafe = 56,
		kPlaySound = 57,
		kGetOnHeliIfHarnessRaised = 58,
		kAmIOnHeli = 59,
		kThrowFieryProjectile = 60,
		kTellStartingObjectTrueOrFalse = 61,
		kPutMyCarInStack = 62,
		kDoIHaveAMaster = 63,
		kNumPrimitives = 64,
	};
public:
	virtual short CountPrimitives() /* override */;
	enum /* __unnamed */ {
		kMyself = 0,
		kTreeParam = 1,
		kTargetObj = 2,
		kMyData = 3,
		kTreeParamData = 4,
		kTargetObjData = 5,
		kSimGlobals = 6,
		kImmediate = 7,
		kTempVars = 8,
		kStackVars = 9,
		kStackObject = 10,
		kTempTempVars = 11,
		kTreeTableValue = 12,
		kNumOwners = 13,
	};
	struct YObjLang::OwnerDataParam{ // not packed(0x8 bytes) TI: 0x3593
		/*+0x0*/   short owner1; // 0x2 bytes
		/*+0x2*/   short data1; // 0x2 bytes
		/*+0x4*/   short owner2; // 0x2 bytes
		/*+0x6*/   short data2; // 0x2 bytes
	};
	struct YObjLang::TurnToFireParam{ // not packed(0x4 bytes) TI: 0x3591
		/*+0x0*/   short xdistloc; // 0x2 bytes
		/*+0x2*/   short ydistloc; // 0x2 bytes
	};
	struct YObjLang::GetOutOfRoadParam{ // not packed(0x2 bytes) TI: 0x358f
		/*+0x0*/   short decTemp; // 0x2 bytes
	};
	struct YObjLang::SetDirectionParam{ // not packed(0x2 bytes) TI: 0x358e
		/*+0x0*/   short dirTemp; // 0x2 bytes
	};
	struct YObjLang::CheckForSpotParam{ // not packed(0x4 bytes) TI: 0x358c
		/*+0x0*/   short brightnessTemp; // 0x2 bytes
		/*+0x2*/   short dirToHeliTemp; // 0x2 bytes
	};
	struct YObjLang::GetSurroundingRiotValParam{ // not packed(0x8 bytes) TI: 0x358a
		/*+0x0*/   short distTemp; // 0x2 bytes
		/*+0x2*/   short dirToConcTemp; // 0x2 bytes
		/*+0x4*/   short riotValTemp; // 0x2 bytes
		/*+0x6*/   short numPeopleCountedTemp; // 0x2 bytes
	};
	struct YObjLang::IncrementRiotValParam{ // not packed(0x2 bytes) TI: 0x3588
		/*+0x0*/   short riotValLiteral; // 0x2 bytes
	};
	struct YObjLang::IsThisScurkIDParam{ // not packed(0x2 bytes) TI: 0x3586
		/*+0x0*/   short scurkIDLiteral; // 0x2 bytes
	};
	struct YObjLang::IsThisLocTypeParam{ // not packed(0x2 bytes) TI: 0x3584
		/*+0x0*/   short locTypeLiteral; // 0x2 bytes
	};
	struct YObjLang::UpdateMyMissionParam{ // not packed(0x2 bytes) TI: 0x3582
		/*+0x0*/   short updateLiteral; // 0x2 bytes
	};
	struct YObjLang::CheckForTrueParam{ // not packed(0x2 bytes) TI: 0x3580
		/*+0x0*/   short whatLiteral; // 0x2 bytes
	};
	struct YObjLang::CompareMyLocWithParam{ // not packed(0x6 bytes) TI: 0x357e
		/*+0x0*/   short withWhatLiteral; // 0x2 bytes
		/*+0x2*/   short distData; // 0x2 bytes
		/*+0x4*/   short distOwner; // 0x2 bytes
	};
	struct YObjLang::WalkAndGrabParam{ // not packed(0x4 bytes) TI: 0x357c
		/*+0x0*/   short decTemp; // 0x2 bytes
		/*+0x2*/   short dynAnimBoolean; // 0x2 bytes
	};
	struct YObjLang::SearchForDynParam{ // not packed(0x6 bytes) TI: 0x357a
		/*+0x0*/   short searchdynobjtypetemp; // 0x2 bytes
		/*+0x2*/   short onlyonmasterboolean; // 0x2 bytes
		/*+0x4*/   short numcellstospiral; // 0x2 bytes
	};
	struct YObjLang::IdleParam{ // not packed(0x2 bytes) TI: 0x3578
		/*+0x0*/   short decTemp; // 0x2 bytes
	};
	struct YObjLang::SetAnimParam{ // not packed(0x4 bytes) TI: 0x3576
		/*+0x0*/   unsigned long animname;
	};
	struct YObjLang::SetBodyParam{ // not packed(0x4 bytes) TI: 0x3574
		/*+0x0*/   unsigned long bodyname;
	};
	struct YObjLang::WalkRunParam{ // not packed(0x7 bytes) TI: 0x3572
		/*+0x0*/   signed char decTemp; // 0x1 bytes
		/*+0x1*/   signed char onlyNeutralBoolean; // 0x1 bytes
		/*+0x2*/   signed char moveFailTemp; // 0x1 bytes
		/*+0x3*/   signed char newLocTemp; // 0x1 bytes
		/*+0x4*/   signed char roadDirTemp; // 0x1 bytes
		/*+0x5*/   signed char dynAnimBoolean; // 0x1 bytes
		/*+0x6*/   signed char speedTemp; // 0x1 bytes
	};
	struct YObjLang::RandomParam{ // not packed(0x6 bytes) TI: 0x3570
		/*+0x0*/   short destTemp; // 0x2 bytes
		/*+0x2*/   short rangeData; // 0x2 bytes
		/*+0x4*/   short rangeOwner; // 0x2 bytes
	};
	struct YObjLang::RoadDirParam{ // not packed(0x6 bytes) TI: 0x356e
		/*+0x0*/   short dirTemp; // 0x2 bytes
		/*+0x2*/   short distAheadData; // 0x2 bytes
		/*+0x4*/   short distAheadOwner; // 0x2 bytes
	};
	struct YObjLang::DirDistFirstParam{ // not packed(0x8 bytes) TI: 0x356c
		/*+0x0*/   short dirToTemp; // 0x2 bytes
		/*+0x2*/   short distToTemp; // 0x2 bytes
		/*+0x4*/   short whatData; // 0x2 bytes
		/*+0x6*/   short whatOwner; // 0x2 bytes
	};
	struct YObjLang::DirDistPersonParam{ // not packed(0x8 bytes) TI: 0x356a
		/*+0x0*/   short dirToTemp; // 0x2 bytes
		/*+0x2*/   short distToTemp; // 0x2 bytes
		/*+0x4*/   short whoData; // 0x2 bytes
		/*+0x6*/   short whoOwner; // 0x2 bytes
	};
	struct YObjLang::AttrParam{ // not packed(0x8 bytes) TI: 0x3568
		/*+0x0*/   short lhsData; // 0x2 bytes
		/*+0x2*/   short rhsData; // 0x2 bytes
		/*+0x4*/   LfBitfield @ 0x5d5b4:
		[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
		[90m   LB.[95mTI[m = 0x3565
		[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
		[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
		 isSigned; // 0x8 bytes
		/*+0x4*/   LfBitfield @ 0x5d5bc:
		[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
		[90m   LB.[95mTI[m = 0x3566
		[90m   LB.[32m[  1.  1][m [95mposition[m = 0x8
		[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
		 opType; // 0x8 bytes
		/*+0x6*/   LfBitfield @ 0x5d5b4:
		[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
		[90m   LB.[95mTI[m = 0x3565
		[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
		[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
		 lhsOwner; // 0x8 bytes
		/*+0x6*/   LfBitfield @ 0x5d5bc:
		[90m   LB.[32m[  0.  1][m [95mlength[m = 0x8
		[90m   LB.[95mTI[m = 0x3566
		[90m   LB.[32m[  1.  1][m [95mposition[m = 0x8
		[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
		 rhsOwner; // 0x8 bytes
	};
	enum /* __unnamed */ {
		kGreaterThan = 0,
		kLessThan = 1,
		kEquals = 2,
		kIncrement = 3,
		kDecrement = 4,
		kSetValue = 5,
		kTimesEq = 6,
		kDivideEq = 7,
		kIsFlagSet = 8,
		kSetFlag = 9,
		kClearFlag = 10,
		kNumOps = 11,
	};
	struct YObjLang::MiscParam{ // not packed(0x8 bytes) TI: 0x3564
		/*+0x0*/   short m1; // 0x2 bytes
		/*+0x2*/   short m2; // 0x2 bytes
		/*+0x4*/   short m3; // 0x2 bytes
		/*+0x6*/   short m4; // 0x2 bytes
	};
	// TODO: Unknown nested type: <class 'tpi.LfUnion'>
	// /*unpacked*/ union YObjLang::Param Param
	enum TreeNum {
		kNoTree = -1,
		kSpotlightTree = 900,
		kMegaphoneTree = 901,
		kOuchTree = 902,
		kDieTree = 903,
		kRunTree = 904,
		kRunOrSwoonTree = 905,
		kSwoonTree = 906,
	};
	enum /* __unnamed */ {
		kWeightStringsID = 140,
		kPrimitiveStringsID = 139,
		kDataLabelsID = 129,
		kDataBase = 1,
		kGlobalBase = 33,
		kOwnerStringsID = 132,
		kNewOwnerBase = 1,
		kMacroDescriptionStrings = 133,
		kPrimMacroBase = 1,
		kMotiveStringsID = 134,
		kMiscStringsID = 135,
		kDontCare = 1,
		kSaveChanges = 2,
		kMaxEntryLabel = 3,
		kBehStringsID = 128,
		kPrimBase = 1,
		kOwnerBase = 33,
		kGosubStr = 65,
		kOpenParen = 66,
		kForType = 67,
		kRadius = 68,
		kFromZeroTo = 69,
		kInto = 70,
		kDistance = 71,
		kStack = 72,
		kUseTempVars = 73,
		kCloseParen = 74,
		kTreetemp = 75,
		kObjtemp = 76,
		kThisObj = 77,
		kAlertType = 78,
		kCheckTreeID = 79,
		kActionTreeID = 80,
		kForAction = 81,
		kEqualStr = 82,
		kTree = 83,
		kRate = 84,
		kTo = 85,
		kForNeed = 86,
		kSel = 87,
		kPairAction = 88,
		kToCheck = 89,
		kSet = 90,
		kToNeed = 91,
		kUpdateNeed = 92,
		kToIndex = 93,
		kCheck = 94,
		kAct = 95,
		kUntil = 96,
		kNot = 97,
		kClear = 98,
		kFor = 99,
		kByAmount = 100,
		kOpBase = 117,
		kTypeBase = 143,
		kBaseTreeBase = 164,
	};
};

// Type: /*unpacked*/ class Language (forward reference);
// Language Class implementation not found



// Contribution: 1:00153ff0-0015b264 Module: 196, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00554ff0
unsigned short cYObject::InBoundingRect(/*unpacked*/ struct Point3d queryloc, int32_t queryRad, /*unpacked*/ struct Point3d objLoc, int32_t objRad) {
// LINE 60:
	__asm        mov    eax, objLoc.x;
	__asm        sub    eax, objRad;
	__asm        mov    ecx, queryloc.x;
	__asm        add    ecx, queryRad;
	__asm        cmp    eax, ecx;
	__asm        jle    _T22;
// LINE 61:
	return 0x0;
// LINE 62:
_T22:
	__asm        mov    eax, objLoc.x;
	__asm        add    eax, objRad;
	__asm        mov    ecx, queryloc.x;
	__asm        sub    ecx, queryRad;
	__asm        cmp    eax, ecx;
	__asm        jge    _T3e;
// LINE 63:
	return 0x0;
// LINE 64:
_T3e:
	__asm        mov    eax, objLoc.y;
	__asm        sub    eax, objRad;
	__asm        mov    ecx, queryloc.y;
	__asm        add    ecx, queryRad;
	__asm        cmp    eax, ecx;
	__asm        jle    _T5a;
// LINE 65:
	return 0x0;
// LINE 66:
_T5a:
	__asm        mov    eax, queryloc.y;
	__asm        sub    eax, queryRad;
	__asm        mov    ecx, objLoc.y;
	__asm        add    ecx, objRad;
	__asm        cmp    eax, ecx;
	__asm        jle    _T76;
// LINE 67:
	return 0x0;
// LINE 68:
_T76:
	__asm        mov    eax, objLoc.z;
	__asm        sub    eax, objRad;
	__asm        mov    ecx, queryloc.z;
	__asm        add    ecx, queryRad;
	__asm        cmp    eax, ecx;
	__asm        jle    _T92;
// LINE 69:
	return 0x0;
// LINE 70:
_T92:
	__asm        mov    eax, objLoc.z;
	__asm        add    eax, objRad;
	__asm        mov    ecx, queryloc.z;
	__asm        sub    ecx, queryRad;
	__asm        cmp    eax, ecx;
	__asm        jge    _Tae;
// LINE 71:
	return 0x0;
// LINE 72:
_Tae:
	return 0x1;
// LINE 73:
}

// FUNCTION: COPTER_D 0x005550ac
void PersonHitDispatch(long hitter_type, /*unpacked*/ struct _DYOBJ_INST *dyhitter, /*unpacked*/ struct _DYOBJ_INST *dyhittee, long mission_id, long xtra_msg) {
	/*bp-0x4*/   /*unpacked*/ class cYObject *person;
	/*bp-0x8*/   short tree;
	/*bp-0x6c*/  char text[100]; // 0x64 bytes
	/*bp-0x70*/  float fps;

// LINE 78:
	__asm        cmp    hitter_type, 0;
	__asm        jl     _T1d;

	__asm        cmp    hitter_type, 0x14;
	__asm        jl     _T36;
_T1d:
	doAssert(0x8c085, 0x5bc638, 0x4e, 0x5bc668);
// LINE 79:
_T36:
	__asm        mov    eax, hitter_type;
	__asm        mov    ax, cYObject::sHitRxnTree[eax*2];
	__asm        mov    tree, ax;
// LINE 81:
	__asm        movsx  eax, tree;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T57;
// LINE 82:
	return;
// LINE 84:
_T57:
	__asm        mov    eax, dyhittee;
	__asm        mov    ax, [eax+0xE];
	__asm        mov    [ebp-0x78], ax;
	__asm        movsx  eax, word ptr [ebp-0x78];
	__asm        cmp    eax, 0x7D00;
	__asm        jne    _T7e;

	person = gAvatar;
	__asm        jmp    _Tfa;
_T7e:
	__asm        movsx  eax, word ptr [ebp-0x78];
	__asm        test   eax, eax;
	__asm        jl     _T97;

	__asm        movsx  eax, word ptr [ebp-0x78];
	__asm        cmp    eax, 0x64;
	__asm        jl     _Tb3;
_T97:
	doAssert(0x8c085, 0x5bb9f4, 0x204, 0x5bba14);
_Tb3:
	__asm        movsx  eax, word ptr [ebp-0x78];
	__asm        cmp    cYObject::sObjects[0][eax*4], 0;
	__asm        jne    _Te1;

	doAssert(0x8c085, 0x5bb9d0, 0x205, 0x5bba14);
_Te1:
	__asm        movsx  eax, word ptr [ebp-0x78];
	__asm        mov    eax, cYObject::sObjects[0][eax*4];
	__asm        mov    person, eax;
	__asm        jmp    _Tfa;

	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    person, eax;
// LINE 85:
_Tfa:
	__asm        cmp    person, 0;
	__asm        jne    _T11d;

	doAssert(0x8c085, 0x5bc68c, 0x55, 0x5bc6b0);
// LINE 88:
_T11d:
	__asm        mov    eax, person;
	__asm        movsx  eax, word ptr [eax+0xEC];
	__asm        test   eax, eax;
	__asm        jle    _T16c;
// LINE 89:
// Block start:
	/*bp-0x74*/  short currxn;
	__asm        mov    eax, person;
	__asm        mov    ax, [eax+0x10C];
	__asm        mov    currxn, ax;
// LINE 90:
	__asm        movsx  eax, currxn;
	__asm        test   eax, eax;
	__asm        je     _T158;

	__asm        movsx  eax, currxn;
	__asm        cmp    eax, 0x384;
	__asm        jne    _T167;
_T158:
	__asm        movsx  eax, tree;
	__asm        cmp    eax, 0x384;
	__asm        jne    _T16c;
// LINE 91:
_T167:
	return;
// LINE 94:
// Block end:
_T16c:
	__asm        movsx  eax, tree;
	__asm        cmp    eax, 0x384;
	__asm        jne    _T194;

	__asm        mov    eax, cYObject::sSimTicks;
	__asm        mov    ecx, person;
	__asm        sub    eax, [ecx+0x18];
	__asm        cmp    eax, 4;
	__asm        jge    _T194;
// LINE 95:
	return;
// LINE 101:
_T194:
	__asm        mov    eax, person;
	__asm        movsx  eax, word ptr [eax+0xBC];
	__asm        cmp    eax, 0x7D00;
	__asm        jne    _T1ae;
// LINE 102:
	return;
// LINE 107:
_T1ae:
	person->fLastInterrupt = cYObject::sSimTicks;
// LINE 108:
	person->fPointers[1] = dyhitter;
// LINE 109:
	__asm        mov    eax, xtra_msg;
	__asm        mov    ecx, person;
	__asm        mov    [ecx+0xE8], ax;
// LINE 112:
	fps = gGameApp-><CGameApp+0x4344:4>;
	__asm        jmp    _T1e5;
// LINE 113:
_T1e5:
	__asm        fld    fps;
	__asm        fcomp  qword ptr ds:[0x593600];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T218;
// LINE 114:
	__asm        fld    fps;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        movsx  eax, tree;
	__asm        push   eax;
	__asm        push   0x5BC6D4;
	__asm        lea    eax, text[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x14;
// LINE 119:
_T218:
	__asm        mov    ax, tree;
	__asm        mov    ecx, person;
	__asm        mov    [ecx+0x10C], ax;
// LINE 120:
	__asm        jmp    _T22b;
_T22b:
	__asm        jmp    _T230;
_T230:
	__asm        mov    eax, person;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, person;
	__asm        mov    ecx, [ecx+4];
	__asm        movsx  eax, word ptr [eax+ecx];
	__asm        movsx  ecx, tree;
	__asm        cmp    eax, ecx;
	__asm        je     _T2ae;

	__asm        jmp    _T25c;
_T25c:
	__asm        jmp    _T261;
_T261:
	__asm        mov    eax, person;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        dec    eax;
	__asm        mov    ecx, person;
	__asm        movsx  ecx, word ptr [ecx+8];
	__asm        cmp    eax, ecx;
	__asm        jg     _T294;

	doAssert(0x8c085, 0x5bbd3c, 0xce, 0x5bba14);
_T294:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tree);
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    ecx, person;
	__asm        call   TreeSim::Gosub;
	__asm        jmp    _T2b3;

	__asm        jmp    _T2b3;
_T2ae:
	__asm        jmp    _T2b3;
// LINE 122:
_T2b3:
	return;
}

// FUNCTION: COPTER_D 0x00555369
/*unpacked*/ struct _DYOBJ_INST* cYObject::GetDynObj(/*unpacked*/ struct _DYOBJ_INST *donotignore, /*unpacked*/ struct Point3d location, int32_t radius, /*unpacked*/ struct _DYOBJ_INST *ignore1, /*unpacked*/ struct _DYOBJ_INST *ignore2) {
	/*bp-0x4*/   /*unpacked*/ struct _DYOBJ_INST *dyobj;
	/*bp-0x8*/   /*unpacked*/ struct _DYOBJ_INST *founddyobj;
	/*bp-0xc*/   short helipartcount;
	/*bp-0x14*/  /*unpacked*/ struct Point2d celloc; // 0x8 bytes
	/*bp-0x18*/  /*unpacked*/ struct _CELL_INFO *cptr;
	/*bp-0x1c*/  int32_t halfradius;

// LINE 174:
	founddyobj = 0x0;
// LINE 181:
	celloc.x = ((location.x + 0x20000000) >> 0x16);
// LINE 182:
	celloc.y = ((0x20000000 - location.z) >> 0x16);
// LINE 185:
	__asm        mov    eax, celloc.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, celloc.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 189:
	dyobj = cptr->dyptr;
// LINE 190:
	helipartcount = 0xffff;
// LINE 191:
	__asm        mov    eax, radiusReduction;
	__asm        push   eax;
	__asm        mov    eax, radius;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    halfradius, eax;
// LINE 193:
__WHILE_6e:
	while ((dyobj != 0x0)) {
		// LINE 196:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 4;
			__asm        jne    __WHILE_a0;

			__asm        movsx  eax, helipartcount;
			__asm        test   eax, eax;
			__asm        jl     _Tef;

			__asm        movsx  eax, helipartcount;
			__asm        cmp    eax, 9;
			__asm        jge    _Tef;
		// LINE 198:
		__WHILE_a0:
			__asm        inc    helipartcount;
			__asm        movsx  eax, helipartcount;
			__asm        cmp    eax, 0xA;
			__asm        jge    _Td4;

			__asm        cmp    dyobj, 0;
			__asm        je     _Td4;

			__asm        mov    eax, donotignore;
			__asm        cmp    dyobj, eax;
			__asm        je     _Td4;
		// LINE 200:
			dyobj = dyobj->next;
		// LINE 202:
			__asm        jmp    __WHILE_a0;
		// LINE 203:
		_Td4:
			__asm        cmp    dyobj, 0;
			__asm        je     _Tea;

			__asm        mov    eax, donotignore;
			__asm        cmp    dyobj, eax;
			__asm        je     _Tef;
		// LINE 204:
		_Tea:
			__asm        jmp    __WHILE_6e;
		// LINE 209:
		_Tef:
			__asm        mov    eax, donotignore;
			__asm        cmp    dyobj, eax;
			__asm        je     _T117;

			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x20;
			__asm        je     _T117;
		// LINE 211:
			dyobj = dyobj->next;
		// LINE 212:
			__asm        jmp    __WHILE_6e;
		// LINE 216:
		_T117:
			__asm        mov    eax, ignore1;
			__asm        cmp    dyobj, eax;
			__asm        je     _T12f;

			__asm        mov    eax, ignore2;
			__asm        cmp    dyobj, eax;
			__asm        jne    _T164;
		// LINE 218:
		_T12f:
			__asm        mov    eax, donotignore;
			__asm        cmp    dyobj, eax;
			__asm        jne    _T157;

			doAssert(0x8c085, 0x5bc6ec, 0xda, 0x5bc714);
		// LINE 219:
		_T157:
			dyobj = dyobj->next;
		// LINE 220:
			__asm        jmp    __WHILE_6e;
		// LINE 224:
		_T164:
			__asm        mov    eax, radiusReduction;
			__asm        push   eax;
			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x10];
			__asm        push   eax;
			__asm        call   0x004D19DF;
			__asm        add    esp, 8;
			__asm        push   eax;
			__asm        mov    eax, dyobj;
			__asm        add    eax, 0x18;
			__asm        mov    ecx, [eax+8];
			__asm        push   ecx;
			__asm        mov    ecx, [eax+4];
			__asm        push   ecx;
			__asm        mov    eax, [eax];
			__asm        push   eax;
			__asm        mov    eax, halfradius;
			__asm        push   eax;
			__asm        mov    eax, location.z;
			__asm        push   eax;
			__asm        mov    eax, location.y;
			__asm        push   eax;
			__asm        mov    eax, location.x;
			__asm        push   eax;
			__asm        call   cYObject::InBoundingRect;
			__asm        add    esp, 0x20;
			__asm        movzx  eax, ax;
			__asm        test   eax, eax;
			__asm        je     _T2db;
		// LINE 226:
			__asm        mov    eax, donotignore;
			__asm        cmp    dyobj, eax;
			__asm        jne    _T1c5;
		// LINE 227:
			founddyobj = dyobj;
		// LINE 228:
			__asm        jmp    _T2e8;
		// LINE 230:
		_T1c5:
			__asm        cmp    founddyobj, 0;
			__asm        jne    _T2db;
		// LINE 231:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 8;
			__asm        je     _T2c6;
		// Block start:
			/*bp-0x20*/  /*unpacked*/ class cYObject *obj;
			__asm        mov    eax, dyobj;
			__asm        mov    ax, [eax+0xE];
			__asm        mov    [ebp-0x24], ax;
		// LINE 232:
			__asm        movsx  eax, word ptr [ebp-0x24];
			__asm        cmp    eax, 0x7D00;
			__asm        jne    _T205;

			obj = gAvatar;
			__asm        jmp    _T281;
		_T205:
			__asm        movsx  eax, word ptr [ebp-0x24];
			__asm        test   eax, eax;
			__asm        jl     _T21e;

			__asm        movsx  eax, word ptr [ebp-0x24];
			__asm        cmp    eax, 0x64;
			__asm        jl     _T23a;
		_T21e:
			doAssert(0x8c085, 0x5bb9f4, 0x204, 0x5bba14);
		_T23a:
			__asm        movsx  eax, word ptr [ebp-0x24];
			__asm        cmp    cYObject::sObjects[0][eax*4], 0;
			__asm        jne    _T268;

			doAssert(0x8c085, 0x5bb9d0, 0x205, 0x5bba14);
		_T268:
			__asm        movsx  eax, word ptr [ebp-0x24];
			__asm        mov    eax, cYObject::sObjects[0][eax*4];
			__asm        mov    obj, eax;
			__asm        jmp    _T281;

			__asm        mov    eax, [ebp-0x28];
			__asm        mov    obj, eax;
		// LINE 233:
		_T281:
			__asm        cmp    obj, 0;
			__asm        jne    _T2a7;

			doAssert(0x8c085, 0x5bc738, 0xe9, 0x5bc740);
		// LINE 234:
		_T2a7:
			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xE2];
			__asm        test   eax, eax;
			__asm        jne    _T2c6;
		// LINE 235:
			dyobj = dyobj->next;
		// LINE 236:
			__asm        jmp    __WHILE_6e;
		// LINE 239:
		// Block end:
		_T2c6:
			founddyobj = dyobj;
		// LINE 240:
			__asm        cmp    donotignore, 0;
			__asm        jne    _T2db;
		// LINE 241:
			__asm        jmp    _T2e8;
		// LINE 245:
		_T2db:
			dyobj = dyobj->next;
	}
// LINE 249:
_T2e8:
	return founddyobj;
// LINE 250:
}

// FUNCTION: COPTER_D 0x0055565e
/*unpacked*/ struct _STOBJ_INST* cYObject::GetStaticObj(/*unpacked*/ struct Point3d location, int32_t radius) {
	/*bp-0x4*/   int32_t normz;
	/*bp-0x8*/   int32_t flags;
	/*bp-0xc*/   /*unpacked*/ struct _STOBJ_INST *stobj;
	/*bp-0x14*/  /*unpacked*/ struct Point2d celloc; // 0x8 bytes
	/*bp-0x18*/  int32_t objy;
	/*bp-0x1c*/  /*unpacked*/ struct _CELL_INFO *cptr;
	/*bp-0x20*/  int32_t normx;
	/*bp-0x24*/  int32_t normy;

// LINE 276:
	celloc.x = ((location.x + 0x20000000) >> 0x16);
// LINE 277:
	celloc.y = ((0x20000000 - location.z) >> 0x16);
// LINE 280:
	__asm        mov    eax, celloc.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, celloc.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 283:
	__asm        mov    eax, location.x;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normx, eax;
// LINE 284:
	__asm        mov    eax, location.z;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normz, eax;
// LINE 285:
	__asm        mov    eax, location.y;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normy, eax;
// LINE 288:
	stobj = cptr->stptr;
// LINE 289:
__WHILE_82:
	while ((stobj != 0x0)) {
		// LINE 292:
			flags = 0x200;
		// LINE 301:
			objy = VRGetObjAlt(0x0, 0x0, radius, flags, normz, normy, normx, stobj->mesh);
		// LINE 304:
			__asm        cmp    objy, 0;
			__asm        jle    _Tcf;
		// LINE 306:
			return stobj;
		// LINE 310:
		_Tcf:
			stobj = stobj->next;
	}
// LINE 314:
_Tdc:
	return 0x0;
// LINE 315:
}

// FUNCTION: COPTER_D 0x00555746
enum cYObject::LocationType cYObject::GetLocType(short cellx, short celly) {
	/*bp-0x4*/   short scurkID;

// LINE 321:
	__asm        movsx  eax, cellx;
	__asm        cmp    eax, 0x7F;
	__asm        jg     _T3b;

	__asm        movsx  eax, celly;
	__asm        cmp    eax, 0x7F;
	__asm        jg     _T3b;

	__asm        movsx  eax, cellx;
	__asm        test   eax, eax;
	__asm        jl     _T3b;

	__asm        movsx  eax, celly;
	__asm        test   eax, eax;
	__asm        jge    _T46;
_T3b:
	scurkID = 0xffff;
	__asm        jmp    _Ta2;
_T46:
	__asm        movsx  eax, cellx;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        movsx  ecx, celly;
	__asm        movzx  ax, byte ptr [eax+ecx];
	__asm        mov    [ebp-8], ax;
	__asm        movsx  eax, word ptr [ebp-8];
	__asm        test   eax, eax;
	__asm        jl     _T79;

	__asm        movsx  eax, word ptr [ebp-8];
	__asm        cmp    eax, 0x100;
	__asm        jl     _T95;
_T79:
	doAssert(0x8c085, 0x5bba34, 0x18a, 0x5bba14);
_T95:
	__asm        mov    ax, [ebp-8];
	__asm        mov    scurkID, ax;
	__asm        jmp    _Ta2;
// LINE 322:
_Ta2:
	__asm        movsx  eax, scurkID;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _Tbe;
// LINE 323:
	return 0xffffffff;
// LINE 324:
	__asm        jmp    __RETURN;
// LINE 325:
_Tbe:
	__asm        movsx  eax, scurkID;
	__asm        mov    eax, cYObject::sLocType[0][eax*4];
	__asm        jmp    __RETURN;
// LINE 326:
__RETURN:
}

// FUNCTION: COPTER_D 0x00555819
unsigned short cYObject::IsWater(short cellx, short celly) {
	/*bp-0x4*/   int32_t j;

// LINE 330:
	__asm        movsx  eax, celly;
	__asm        and    eax, 0xFF;
	__asm        movsx  ecx, cellx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        mov    j, edx;
// LINE 331:
	__asm        cmp    j, 0;
	__asm        jl     _T4d;

	__asm        cmp    j, 0xF;
	__asm        jge    _T4d;
// LINE 332:
	return 0x1;
// LINE 333:
	__asm        jmp    __RETURN;
// LINE 334:
_T4d:
	return 0x0;
// LINE 335:
__RETURN:
}

// FUNCTION: COPTER_D 0x00555873
signed char cYObject::GetRoadDir(/*unpacked*/ struct Point3d location) {
// LINE 345:
	return 0x3;
// LINE 346:
}

// FUNCTION: COPTER_D 0x00555885
enum cYObject::MoveErrorCode cYObject::TryTableMove(short speed, unsigned short moveOnlyNeutrally, /*unpacked*/ struct cYObject::MoveInfo *moveinfo) {
	/*bp-0x4*/   int32_t dz;
	/*bp-0x8*/   enum cYObject::MoveErrorCode movecode;
	/*bp-0xc*/   short attempts;
	/*bp-0x10*/  short dir;
	/*bp-0x14*/  int32_t dx;

// LINE 350:
	attempts = 0x0;
// LINE 354:
_LOOP_12:
	for (;;) {
		// LINE 354:
		_LOOP_12:
			__asm        mov    eax, this;
			__asm        movsx  eax, word ptr [eax+0xD0];
			__asm        add    eax, 2;
			__asm        mov    dir, ax;
		// LINE 355:
			__asm        movsx  eax, dir;
			__asm        and    eax, 7;
			__asm        mov    dir, ax;
		// LINE 356:
			__asm        movsx  eax, dir;
			__asm        lea    eax, [eax+eax*2];
			__asm        mov    eax, cYObject::sMoveTable[0].x[eax*4];
			__asm        mov    dx, eax;
		// LINE 357:
			__asm        movsx  eax, dir;
			__asm        lea    eax, [eax+eax*2];
			__asm        mov    eax, cYObject::sMoveTable[0].z[eax*4];
			__asm        mov    dz, eax;
		// LINE 358:
			__asm        movsx  eax, speed;
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        mov    eax, dx;
			__asm        push   eax;
			__asm        call   0x004D19BD;
			__asm        add    esp, 8;
			__asm        mov    dx, eax;
		// LINE 359:
			__asm        movsx  eax, speed;
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        mov    eax, dz;
			__asm        push   eax;
			__asm        call   0x004D19BD;
			__asm        add    esp, 8;
			__asm        mov    dz, eax;
		// LINE 360:
			__asm        push   0;
			__asm        push   0;
			__asm        mov    eax, dz;
			__asm        push   eax;
			__asm        mov    eax, dx;
			__asm        push   eax;
			__asm        mov    eax, moveinfo;
			__asm        push   eax;
			__asm        mov    eax, reinterpret_cast<uint32_t>(moveOnlyNeutrally);
			__asm        push   eax;
			__asm        mov    ecx, this;
			__asm        call   cYObject::TryMove;
			__asm        mov    movecode, eax;
		// LINE 362:
			__asm        mov    eax, this;
			__asm        movsx  eax, word ptr [eax+0xFA];
			__asm        test   eax, eax;
			__asm        jne    _Tb7;
		// LINE 363:
			return movecode;
		// LINE 368:
		_Tb7:
			__asm        cmp    movecode, 0;
			__asm        je     _Tdf;

			__asm        cmp    movecode, 0xA;
			__asm        je     _Tdf;

			__asm        cmp    movecode, 8;
			__asm        je     _Tdf;

			__asm        cmp    movecode, 7;
			__asm        jne    _Te7;
		// LINE 369:
		_Tdf:
			return movecode;
		// LINE 371:
		_Te7:
			attempts++;
		// LINE 372:
			__asm        movsx  eax, attempts;
			__asm        cmp    eax, 8;
			__asm        jle    _T100;
		// LINE 373:
			return movecode;
		// LINE 374:
		_T100:
			this->fData[0]++;
		// LINE 375:
			__asm        mov    eax, this;
			__asm        movsx  eax, word ptr [eax+0xD0];
			__asm        and    eax, 7;
			__asm        mov    ecx, this;
			__asm        mov    [ecx+0xD0], ax;
		// LINE 376:
			__asm        jmp    _LOOP_12;
	}
// LINE 377:
}

// FUNCTION: COPTER_D 0x005559b2
enum cYObject::MoveErrorCode cYObject::TryVectorMove(/*unpacked*/ struct Point3d vector, int32_t fwdspeed, /*unpacked*/ struct cYObject::MoveInfo *moveinfo) {
	/*bp-0x4*/   int32_t dz;
	/*bp-0x8*/   int32_t Vx;
	/*bp-0xc*/   int32_t Vz;
	/*bp-0x10*/  int32_t dx;

// LINE 382:
	__asm        cmp    fwdspeed, 0;
	__asm        jne    _T20;

	return 0x7;
// LINE 384:
_T20:
	__asm        mov    eax, this;
	__asm        add    eax, 0x48;
	__asm        push   eax;
	__asm        lea    eax, vector.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 385:
	__asm        mov    eax, fwdspeed;
	__asm        push   eax;
	__asm        mov    eax, vector.x;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    Vx, eax;
// LINE 386:
	__asm        mov    eax, fwdspeed;
	__asm        push   eax;
	__asm        mov    eax, vector.z;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    Vz, eax;
// LINE 388:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, Vx;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dx, eax;
// LINE 389:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, Vz;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dz, eax;
// LINE 392:
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, dz;
	__asm        push   eax;
	__asm        mov    eax, dx;
	__asm        push   eax;
	__asm        mov    eax, moveinfo;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   cYObject::TryMove;
	__asm        jmp    __RETURN;
// LINE 393:
__RETURN:
}

// FUNCTION: COPTER_D 0x00555a60
enum cYObject::MoveErrorCode cYObject::TryMove(unsigned short moveOnlyNeutrally, /*unpacked*/ struct cYObject::MoveInfo *moveinfo, int32_t dx, int32_t dz, int32_t masterdy, unsigned short mastermove) {
	/*bp-0x4*/   enum cYObject::MoveErrorCode retcode;
	/*bp-0x8*/   unsigned char ncelly;
	/*bp-0x14*/  /*unpacked*/ struct Point3d newloc; // 0xc bytes
	/*bp-0x18*/  unsigned char ncellx;
	/*bp-0x1c*/  /*unpacked*/ struct _DYOBJ_INST *dyn;
	/*bp-0x20*/  int32_t masterheight;

// LINE 402:
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        lea    ecx, newloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 403:
	newloc.x += dx;
	newloc.z += dz;
// LINE 404:
	__asm        test   reinterpret_cast<uint32_t>(mastermove), 0xFFFF;
	__asm        je     _T4d;
// LINE 405:
	newloc.y += masterdy;
// LINE 406:
_T4d:
	retcode = 0x0;
// LINE 407:
	dyn = 0x0;
// LINE 409:
	__asm        test   reinterpret_cast<uint32_t>(mastermove), 0xFFFF;
	__asm        jne    _T465;
// LINE 410:
// Block start:
	/*bp-0x24*/  /*unpacked*/ struct TreeSim::StackElem *elem;
	/*bp-0x28*/  int32_t ht;
	/*bp-0x2c*/  int32_t dy;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x130], 0;
	__asm        je     _Tfa;
// LINE 413:
// Block start:
	/*bp-0x30*/  /*unpacked*/ struct _DYOBJ_INST *master;
	/*bp-0x34*/  int32_t groundheight;
	/*bp-0x40*/  /*unpacked*/ struct Point3d offset; // 0xc bytes
	master = this->fPointers[0];
// LINE 414:
	offset.x = (newloc.x - master->loc.x);
	offset.y = 0x0;
	offset.z = (newloc.z - master->loc.z);
// LINE 419:
	masterheight = VRGetDyObjAlt(this->fDyn.radius, offset.x, (master + 0x24), master->mesh);
// LINE 420:
	groundheight = S3PUtilsGetAlt(newloc.z, newloc.y, newloc.x);
// LINE 421:
	newloc.y = ((groundheight + masterheight) + 0x30000);
// LINE 423:
// Block end:
	__asm        jmp    _T116;
// LINE 424:
_Tfa:
	newloc.y = (S3PUtilsGetAlt(newloc.z, newloc.y, newloc.x) + 0x30000);
// LINE 426:
_T116:
	dy = (newloc.y - this->fDyn.loc.y);
// LINE 427:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD4];
	__asm        shl    eax, 0x10;
	__asm        mov    ht, eax;
// LINE 428:
	__asm        cmp    G_CheatCodes[0], 0;
	__asm        je     _T183;

	__asm        push   1;
	__asm        call   IsModifierSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T183;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xBC];
	__asm        cmp    eax, 0x7D00;
	__asm        jne    _T183;
// LINE 429:
	__asm        push   0x140000;
	__asm        mov    eax, ht;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ht, eax;
// LINE 430:
_T183:
	__asm        mov    eax, dy;
	__asm        cmp    ht, eax;
	__asm        jge    _T196;
// LINE 431:
	retcode = 0x1;
// LINE 432:
_T196:
	__asm        mov    eax, ht;
	__asm        neg    eax;
	__asm        cmp    eax, dy;
	__asm        jle    _T1ab;
// LINE 433:
	retcode = 0x2;
// LINE 434:
_T1ab:
	__asm        cmp    retcode, 0;
	__asm        je     _T1f4;
// LINE 435:
	__asm        cmp    moveinfo, 0;
	__asm        je     _T1ec;
// LINE 436:
// Block start:
	/*bp-0x44*/  /*unpacked*/ struct _STOBJ_INST *st;
	st = cYObject::GetStaticObj((this->fDyn.radius >> 0x1), newloc.z, newloc.y, newloc.x);
// LINE 437:
	moveinfo->stBlock = st;
// LINE 439:
// Block end:
_T1ec:
	return retcode;
// LINE 442:
_T1f4:
	__asm        jmp    _T1f9;
_T1f9:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        mov    elem, eax;
// LINE 444:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x130];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, newloc.z;
	__asm        push   eax;
	__asm        mov    eax, newloc.y;
	__asm        push   eax;
	__asm        mov    eax, newloc.x;
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   cYObject::GetDynObj;
	__asm        add    esp, 0x1C;
	__asm        mov    dyn, eax;
// LINE 446:
	__asm        cmp    moveinfo, 0;
	__asm        je     _T26b;
// LINE 447:
	moveinfo->dyBlock = dyn;
// LINE 449:
_T26b:
	__asm        cmp    dyn, 0;
	__asm        je     _T28e;

	__asm        mov    eax, elem;
	__asm        mov    ecx, dyn;
	__asm        cmp    [eax+4], ecx;
	__asm        jne    _T28e;
// LINE 450:
	return 0xa;
// LINE 451:
_T28e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x130], 0;
	__asm        je     _T3dc;
// LINE 452:
// Block start:
	/*bp-0x50*/  /*unpacked*/ struct Point3d masterloc; // 0xc bytes
	/*bp-0x54*/  int32_t myrad;
	/*bp-0x58*/  int32_t masterrad;
	__asm        mov    eax, radiusReduction;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    myrad, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x130];
	__asm        mov    [ebp-0x84], eax;
// LINE 453:
	__asm        mov    eax, [ebp-0x84];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x80;
	__asm        jne    _T305;

	__asm        mov    eax, radiusReduction;
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    masterrad, eax;
	__asm        jmp    _T311;

	__asm        jmp    _T311;
_T305:
	masterrad = 0x80000;
	__asm        jmp    _T311;
// LINE 454:
_T311:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x130];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, masterloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 455:
	masterloc.y += masterheight;
// LINE 457:
	__asm        mov    eax, masterrad;
	__asm        push   eax;
	__asm        mov    eax, masterloc.z;
	__asm        push   eax;
	__asm        mov    eax, masterloc.y;
	__asm        push   eax;
	__asm        mov    eax, masterloc.x;
	__asm        push   eax;
	__asm        mov    eax, myrad;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        mov    ecx, [eax+8];
	__asm        push   ecx;
	__asm        mov    ecx, [eax+4];
	__asm        push   ecx;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   cYObject::InBoundingRect;
	__asm        add    esp, 0x20;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T39f;
// LINE 458:
// Block start:
	/*bp-0x5c*/  /*unpacked*/ struct _DYOBJ_INST *master;
	master = this->fPointers[0];
// LINE 459:
	doAssert(0x8c085, 0x5bc764, 0x1cb, 0x5bc7a0);
// LINE 463:
// Block end:
_T39f:
	__asm        mov    eax, masterrad;
	__asm        push   eax;
	__asm        mov    eax, masterloc.z;
	__asm        push   eax;
	__asm        mov    eax, masterloc.y;
	__asm        push   eax;
	__asm        mov    eax, masterloc.x;
	__asm        push   eax;
	__asm        mov    eax, myrad;
	__asm        push   eax;
	__asm        mov    eax, newloc.z;
	__asm        push   eax;
	__asm        mov    eax, newloc.y;
	__asm        push   eax;
	__asm        mov    eax, newloc.x;
	__asm        push   eax;
	__asm        call   cYObject::InBoundingRect;
	__asm        add    esp, 0x20;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T3dc;
// LINE 464:
	return 0x6;
// LINE 466:
// Block end:
_T3dc:
	__asm        cmp    dyn, 0;
	__asm        je     _T465;
// LINE 467:
// Block start:
	/*bp-0x60*/  /*unpacked*/ struct _DYOBJ_INST *myspacedyn;
	/*bp-0x64*/  /*unpacked*/ struct _DYOBJ_INST *dontignore;
	dontignore = 0x0;
// LINE 468:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x130];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        mov    ecx, [eax+8];
	__asm        push   ecx;
	__asm        mov    ecx, [eax+4];
	__asm        push   ecx;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, dontignore;
	__asm        push   eax;
	__asm        call   cYObject::GetDynObj;
	__asm        add    esp, 0x1C;
	__asm        mov    myspacedyn, eax;
// LINE 469:
	__asm        mov    eax, myspacedyn;
	__asm        cmp    dyn, eax;
	__asm        je     _T465;
// LINE 470:
	__asm        mov    eax, dyn;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _T45b;
// LINE 471:
	return 0x5;
// LINE 472:
	__asm        jmp    _T465;
// LINE 473:
_T45b:
	return 0x4;
// LINE 502:
// Block end:
// Block end:
_T465:
	__asm        mov    eax, newloc.x;
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    ncellx, al;
// LINE 503:
	__asm        mov    eax, 0x20000000;
	__asm        sub    eax, newloc.z;
	__asm        sar    eax, 0x16;
	__asm        mov    ncelly, al;
// LINE 509:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        xor    eax, eax;
	__asm        mov    al, ncellx;
	__asm        cmp    ecx, eax;
	__asm        jne    _T4b7;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        xor    eax, eax;
	__asm        mov    al, ncelly;
	__asm        cmp    ecx, eax;
	__asm        je     _T9e6;
// LINE 511:
// Block start:
	/*bp-0x68*/  enum cYObject::LocationType newloctype;
_T4b7:
	__asm        movzx  ax, ncelly;
	__asm        push   eax;
	__asm        movzx  ax, ncellx;
	__asm        push   eax;
	__asm        call   cYObject::GetLocType;
	__asm        add    esp, 8;
	__asm        mov    newloctype, eax;
// LINE 512:
	__asm        test   reinterpret_cast<uint32_t>(mastermove), 0xFFFF;
	__asm        jne    _T964;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x130], 0;
	__asm        jne    _T964;
// LINE 516:
// Block start:
	/*bp-0x6c*/  enum cYObject::LocationType thisloctype;
	/*bp-0x70*/  short thiscelly;
	/*bp-0x74*/  short thiscellx;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    thiscellx, ax;
// LINE 517:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x44];
	__asm        sar    eax, 0x16;
	__asm        mov    thiscelly, ax;
// LINE 518:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        xor    eax, eax;
	__asm        mov    al, reinterpret_cast<uint8_t>(thiscellx);
	__asm        cmp    ecx, eax;
	__asm        jne    _T54e;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        xor    eax, eax;
	__asm        mov    al, reinterpret_cast<uint8_t>(thiscelly);
	__asm        cmp    ecx, eax;
	__asm        je     _T56a;
_T54e:
	doAssert(0x8c085, 0x5bc7c4, 0x206, 0x5bc7d8);
// LINE 519:
_T56a:
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        call   cYObject::GetLocType;
	__asm        add    esp, 8;
	__asm        mov    thisloctype, eax;
// LINE 520:
	__asm        mov    eax, this;
	__asm        mov    ecx, thisloctype;
	__asm        cmp    [eax+0xAC], ecx;
	__asm        je     _T5fa;
// LINE 521:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        test   eax, eax;
	__asm        jne    _T5de;
// LINE 522:
	doAssert(0x8c085, 0x5bc7fc, 0x20a, 0x5bc82c);
// LINE 524:
	__asm        jmp    _T5fa;
// LINE 525:
_T5de:
	doAssert(0x8c085, 0x5bc850, 0x20d, 0x5bc880);
// LINE 529:
_T5fa:
	__asm        mov    eax, this;
	__asm        mov    ecx, newloctype;
	__asm        cmp    [eax+0xAC], ecx;
	__asm        je     _T92d;
// LINE 530:
// Block start:
	/*bp-0x78*/  unsigned short thisneutralforme;
	/*bp-0x7c*/  unsigned short failnonneutral;
	/*bp-0x80*/  unsigned short newneutralandsparse;
	__asm        cmp    moveinfo, 0;
	__asm        je     _T662;

	__asm        mov    eax, moveinfo;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T662;
// LINE 532:
	moveinfo->locType-> = newloctype;
// LINE 533:
	__asm        cmp    newloctype, 7;
	__asm        jne    _T662;

	__asm        mov    eax, moveinfo;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T662;
// LINE 534:
	moveinfo->roadDir[0] = cYObject::GetRoadDir(newloc.z, newloc.y, newloc.x);
// LINE 547:
_T662:
	failnonneutral = 0x0;
// LINE 548:
	__asm        mov    eax, newloctype;
	__asm        push   eax;
	__asm        movzx  ax, ncelly;
	__asm        push   eax;
	__asm        movzx  ax, ncellx;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::IsWalkable;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T69d;
// LINE 549:
	return 0xb;
// LINE 550:
	__asm        jmp    _T911;
_T69d:
	__asm        test   reinterpret_cast<uint32_t>(moveOnlyNeutrally), 0xFFFF;
	__asm        je     _T8b9;
// LINE 551:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xF6];
	__asm        test   eax, eax;
	__asm        je     _FOR_6e9;

	doAssert(0x8c085, 0x5bc8a4, 0x227, 0x5bc8d4);
// LINE 552:
_FOR_6e9:
	__asm        mov    word ptr [ebp-0x94], 0;
	__asm        jmp    _FOR_COND_6e9;
_FOR_NEXT_6e9:
	__asm        inc    word ptr [ebp-0x94];
_FOR_COND_6e9:
	__asm        movsx  eax, word ptr [ebp-0x94];
	__asm        cmp    eax, 0xA;
	__asm        jge    _T73d;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD6];
	__asm        lea    eax, [eax+eax*4];
	__asm        movsx  ecx, word ptr [ebp-0x94];
	__asm        shl    ecx, 2;
	__asm        mov    edx, newloctype;
	__asm        cmp    cYObject::sNeutralPersonLocs[0][0][ecx+eax*8], edx;
	__asm        jne    _T738;

	__asm        mov    word ptr [ebp-0x90], 1;
	__asm        jmp    _T74b;
_T738:
	__asm        jmp    _FOR_NEXT_6e9;
_T73d:
	__asm        mov    word ptr [ebp-0x90], 0;
	__asm        jmp    _T74b;
_T74b:
	__asm        xor    eax, eax;
	__asm        mov    al, ncelly;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, ncellx;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    word ptr [ebp-0x9C], 0;
__WHILE_771:
	__asm        cmp    dword ptr [ebp-0x98], 0;
	__asm        je     _T7aa;

	__asm        mov    eax, [ebp-0x98];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _T797;

	__asm        inc    word ptr [ebp-0x9C];
_T797:
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x98], eax;
	__asm        jmp    __WHILE_771;
_T797:
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x98], eax;
	__asm        jmp    __WHILE_771;
_T7aa:
	__asm        jmp    _T7af;
_T7af:
	__asm        mov    eax, newloctype;
	__asm        movsx  eax, cYObject::sLocInfo[0].maxNormalLoiterers[eax*8];
	__asm        movsx  ecx, word ptr [ebp-0x9C];
	__asm        cmp    eax, ecx;
	__asm        jle    _T7d7;

	__asm        mov    word ptr [ebp-0x8C], 1;
	__asm        jmp    _T7e0;
_T7d7:
	__asm        mov    word ptr [ebp-0x8C], 0;
_T7e0:
	__asm        test   dword ptr [ebp-0x90], 0xFFFF;
	__asm        je     _T810;

	__asm        test   dword ptr [ebp-0x8C], 0xFFFF;
	__asm        je     _T810;

	newneutralandsparse = 0x1;
	__asm        jmp    _T81b;

	__asm        jmp    _T81b;
_T810:
	newneutralandsparse = 0x0;
	__asm        jmp    _T81b;
// LINE 553:
_T81b:
	__asm        test   reinterpret_cast<uint32_t>(newneutralandsparse), 0xFFFF;
	__asm        jne    _T8b4;
// LINE 554:
	failnonneutral = 0x1;
// LINE 555:
_FOR_83c:
	__asm        mov    word ptr [ebp-0x88], 0;
	__asm        jmp    _FOR_COND_83c;
_FOR_NEXT_83c:
	__asm        inc    word ptr [ebp-0x88];
_FOR_COND_83c:
	__asm        movsx  eax, word ptr [ebp-0x88];
	__asm        cmp    eax, 0xA;
	__asm        jge    _T896;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD6];
	__asm        lea    eax, [eax+eax*4];
	__asm        movsx  ecx, word ptr [ebp-0x88];
	__asm        shl    ecx, 2;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0xAC];
	__asm        cmp    cYObject::sNeutralPersonLocs[0][0][ecx+eax*8], edx;
	__asm        jne    _T891;

	thisneutralforme = 0x1;
	__asm        jmp    _T8a1;
_T891:
	__asm        jmp    _FOR_NEXT_83c;
_T896:
	thisneutralforme = 0x0;
	__asm        jmp    _T8a1;
// LINE 556:
_T8a1:
	__asm        test   reinterpret_cast<uint32_t>(thisneutralforme), 0xFFFF;
	__asm        jne    _T8b4;
// LINE 557:
	failnonneutral = 0x0;
// LINE 563:
_T8b4:
	__asm        jmp    _T911;
_T8b9:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xF6];
	__asm        test   eax, eax;
	__asm        je     _T911;
// LINE 564:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xAC], 7;
	__asm        je     _T8fd;

	doAssert(0x8c085, 0x5bc8f8, 0x234, 0x5bc930);
// LINE 565:
_T8fd:
	__asm        cmp    newloctype, 7;
	__asm        je     _T911;
// LINE 566:
	return 0xc;
// LINE 569:
_T911:
	__asm        test   reinterpret_cast<uint32_t>(failnonneutral), 0xFFFF;
	__asm        je     _T928;
// LINE 570:
	return 0x3;
// LINE 582:
// Block end:
_T928:
	__asm        jmp    _T964;
_T92d:
	__asm        cmp    moveinfo, 0;
	__asm        je     _T964;

	__asm        mov    eax, moveinfo;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T964;

	__asm        mov    eax, moveinfo;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T964;
// LINE 583:
	moveinfo->locType-> = 0x0;
// LINE 584:
	moveinfo->roadDir[0] = 0xff;
// LINE 587:
// Block end:
_T964:
	this->fCurLocType = newloctype;
// LINE 588:
	this->cYObject::Unlink();
// LINE 589:
	__asm        jmp    _T983;
_T983:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+0x20];
	__asm        test   ecx, ecx;
	__asm        je     _T9b3;

	doAssert(0x8c085, 0x5bbbb8, 0x210, 0x5bba14);
_T9b3:
	__asm        mov    al, ncellx;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x88], al;
	__asm        mov    al, ncelly;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x89], al;
	__asm        jmp    _T9d6;
_T9d6:
	this->cYObject::Link();
	__asm        jmp    _T9e6;
// LINE 591:
// Block end:
_T9e6:
	__asm        lea    eax, newloc.x;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x3C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 595:
	return 0x0;
// LINE 596:
}

// FUNCTION: COPTER_D 0x00556470
unsigned short cYObject::CanJumpOffHere() {
// LINE 606:
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        call   cYObject::GetLocType;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::IsWalkable;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _T60;
// LINE 607:
	return 0x0;
// LINE 608:
_T60:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x130];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T92;

	doAssert(0x8c085, 0x5bdd88, 0x3da, 0x5bba14);
_T92:
	__asm        jmp    _T97;
_T97:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    ecx, [ebp-8];
	__asm        sub    eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0xA8];
	__asm        mov    ecx, [ebp-8];
	__asm        sub    eax, [ecx+0x20];
	__asm        sar    eax, 0x10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cmp    eax, 2;
	__asm        jge    _Tdb;

	__asm        jmp    _Tf5;

	__asm        jmp    _Ted;

	__asm        jmp    _Te0;
_Tdb:
	__asm        jmp    _Ted;
_Te0:
	__asm        test   dword ptr [ebp-0xC], 0xFFFF;
	__asm        jne    _Tf5;
// LINE 609:
_Ted:
	return 0x0;
// LINE 610:
_Tf5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetAlt;
	__asm        add    esp, 0xC;
	__asm        mov    [ebp-4], eax;
	__asm        jmp    _T11a;
_T11a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        sub    eax, [ebp-4];
	__asm        sar    eax, 0x10;
	__asm        movsx  eax, ax;
	__asm        cmp    eax, 5;
	__asm        jle    _T13a;
// LINE 611:
	return 0x0;
// LINE 628:
_T13a:
	return 0x1;
// LINE 630:
}

// FUNCTION: COPTER_D 0x005565b8
unsigned short cYObject::IsWalkable(short cellx, short celly, enum cYObject::LocationType loctype) {
// LINE 634:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xBC];
	__asm        cmp    eax, 0x7D00;
	__asm        jne    _T49;

	__asm        cmp    G_CheatCodes[0], 0;
	__asm        je     _T49;

	__asm        push   1;
	__asm        call   IsModifierSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T49;
// LINE 635:
	return 0x1;
// LINE 636:
_T49:
	__asm        mov    eax, reinterpret_cast<uint32_t>(celly);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(cellx);
	__asm        push   eax;
	__asm        call   cYObject::IsWater;
	__asm        add    esp, 8;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T6c;
// LINE 637:
	return 0x0;
// LINE 638:
_T6c:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xBC];
	__asm        cmp    eax, 0x7D00;
	__asm        je     _Te7;
// LINE 639:
	__asm        cmp    loctype, 0xFFFFFFFF;
	__asm        jne    _T93;
// LINE 640:
	return 0x0;
// LINE 641:
_T93:
	__asm        cmp    loctype, 0;
	__asm        jne    _Ta5;
// LINE 642:
	return 0x0;
// LINE 643:
_Ta5:
	__asm        cmp    loctype, 1;
	__asm        jne    _Tb7;
// LINE 644:
	return 0x0;
// LINE 647:
_Tb7:
	__asm        movsx  eax, celly;
	__asm        and    eax, 0xFF;
	__asm        movsx  ecx, cellx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _Te7;
// LINE 648:
	return 0x0;
// LINE 650:
_Te7:
	return 0x1;
// LINE 651:
}

// FUNCTION: COPTER_D 0x005566af
/*unpacked*/ struct Point2d GetRiotCenter(long riotid) {
// LINE 657:
	__asm        mov    eax, riotid;
	__asm        push   eax;
	__asm        call   cYObject::GetRiotCenter;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        mov    [ebp-4], edx;
	__asm        mov    eax, [ebp-8];
	__asm        mov    edx, [ebp-4];
	__asm        jmp    __RETURN;
// LINE 658:
__RETURN:
}

// FUNCTION: COPTER_D 0x005566da
/*unpacked*/ struct Point2d cYObject::GetRiotCenter(long riotid) {
	/*bp-0x4*/   long overallcelly;
	/*bp-0x8*/   long overallcellx;
	/*bp-0xc*/   short count;
	/*bp-0x10*/  /*unpacked*/ class cYObject *obj;
	/*bp-0x18*/  /*unpacked*/ struct Point2d cent; // 0x8 bytes
	/*bp-0x1c*/  short numcounted;

// LINE 662:
	numcounted = 0x0;
// LINE 663:
	overallcellx = 0x0;
	overallcelly = 0x0;
// LINE 666:
_FOR_28:
	for (count = 0x0; (reinterpret_cast<int16_t>(count) < 0x64); count++) {
		// LINE 667:
			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x7D00;
			__asm        jne    _T55;

			obj = gAvatar;
			__asm        jmp    _Td1;
		_T55:
			__asm        movsx  eax, count;
			__asm        test   eax, eax;
			__asm        jl     _T6e;

			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x64;
			__asm        jl     _T8a;
		_T6e:
			doAssert(0x8c085, 0x5bb9f4, 0x204, 0x5bba14);
		_T8a:
			__asm        movsx  eax, count;
			__asm        cmp    cYObject::sObjects[0][eax*4], 0;
			__asm        jne    _Tb8;

			doAssert(0x8c085, 0x5bb9d0, 0x205, 0x5bba14);
		_Tb8:
			__asm        movsx  eax, count;
			__asm        mov    eax, cYObject::sObjects[0][eax*4];
			__asm        mov    obj, eax;
			__asm        jmp    _Td1;

			__asm        mov    eax, [ebp-0x20];
			__asm        mov    obj, eax;
		// LINE 668:
		_Td1:
			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xD2];
			__asm        test   eax, eax;
			__asm        jne    _Te8;

			__asm        jmp    _FOR_NEXT_28;
		// LINE 669:
		_Te8:
			__asm        mov    eax, obj;
			__asm        mov    ecx, riotid;
			__asm        cmp    [eax+0x1C], ecx;
			__asm        jne    _T117;
		// LINE 670:
			__asm        mov    eax, obj;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+0x88];
			__asm        add    overallcellx, ecx;
		// LINE 671:
			__asm        mov    eax, obj;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+0x89];
			__asm        add    overallcelly, ecx;
		// LINE 672:
			numcounted++;
		// LINE 674:
		_T117:
	}
// LINE 675:
_T11c:
	__asm        movsx  eax, numcounted;
	__asm        test   eax, eax;
	__asm        jne    _T144;

	doAssert(0x8c085, 0x5bc954, 0x2a3, 0x5bc990);
// LINE 676:
_T144:
	__asm        movsx  ecx, numcounted;
	__asm        mov    eax, overallcellx;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    cent.x, eax;
// LINE 677:
	__asm        movsx  ecx, numcounted;
	__asm        mov    eax, overallcelly;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    cent.y, eax;
// LINE 678:
	__asm        mov    eax, cent.x;
	__asm        mov    edx, cent.y;
	__asm        jmp    __RETURN;
// LINE 679:
__RETURN:
}

// FUNCTION: COPTER_D 0x00556848
void cYObject::GetSurroundingRiotInfo(short todist, short * avgriotval, short * counted, short * dirtogreatestconcentration) {
	/*bp-0x4*/   short startcelly;
	/*bp-0xc*/   double overallxloc; // 0x8 bytes
	/*bp-0x10*/  short cellx;
	/*bp-0x14*/  short celly;
	/*bp-0x18*/  /*unpacked*/ struct _CELL_INFO *cptr;
	/*bp-0x1c*/  long riotval;
	/*bp-0x20*/  short startcellx;
	/*bp-0x28*/  double overallzloc; // 0x8 bytes
	/*bp-0x2c*/  short numcounted;

// LINE 683:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    startcellx, cx;
// LINE 684:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    startcelly, cx;
// LINE 687:
	riotval = 0x0;
// LINE 688:
	numcounted = 0x0;
// LINE 689:
	reinterpret_cast<uint32_t>(overallxloc) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&overallxloc) + 4) = 0x0;
// LINE 690:
	reinterpret_cast<uint32_t>(overallzloc) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&overallzloc) + 4) = 0x0;
// LINE 692:
_FOR_79:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    cellx, cx;
	__asm        jmp    _FOR_COND_79;
_FOR_NEXT_79:
	cellx++;
_FOR_COND_79:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, cellx;
	__asm        cmp    ecx, eax;
	__asm        jl     _FOR_152;
// LINE 693:
_FOR_b4:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    celly, cx;
	__asm        jmp    _FOR_COND_b4;
_FOR_NEXT_b4:
	celly++;
_FOR_COND_b4:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, celly;
	__asm        cmp    ecx, eax;
	__asm        jl     _T133;
// LINE 694:
	__asm        movsx  eax, cellx;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        movsx  ecx, celly;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    cptr, eax;
// LINE 695:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        and    eax, 0xFFFFFFFB;
	__asm        mov    ecx, cptr;
	__asm        mov    [ecx], ax;
// LINE 696:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 4;
	__asm        je     _T12e;

	doAssert(0x8c085, 0x5bc9b4, 0x2b8, 0x5bc9cc);
// LINE 697:
_T12e:
	__asm        jmp    _FOR_NEXT_b4;
// LINE 698:
_T133:
	__asm        jmp    _FOR_NEXT_79;
// LINE 700:
_FOR_152:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    cellx, cx;
	__asm        jmp    _FOR_COND_152;
_FOR_NEXT_152:
	cellx++;
_FOR_COND_152:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, cellx;
	__asm        cmp    ecx, eax;
	__asm        jl     _T3bc;
// LINE 701:
_FOR_18d:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    celly, cx;
	__asm        jmp    _FOR_COND_18d;
_FOR_NEXT_18d:
	celly++;
_FOR_COND_18d:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, celly;
	__asm        cmp    ecx, eax;
	__asm        jl     _T3b7;
// LINE 702:
// Block start:
	/*bp-0x30*/  /*unpacked*/ struct _DYOBJ_INST *dyobj;
	__asm        movsx  eax, cellx;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        movsx  ecx, celly;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    cptr, eax;
// LINE 703:
	__asm        cmp    cptr, 0;
	__asm        jne    _T1f4;

	doAssert(0x8c085, 0x5bc9f0, 0x2bf, 0x5bc9f8);
// LINE 704:
_T1f4:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 4;
	__asm        je     _T207;
// LINE 705:
	__asm        jmp    _FOR_NEXT_18d;
// LINE 706:
_T207:
	dyobj = cptr->dyptr;
// LINE 707:
__WHILE_210:
	while ((dyobj != 0x0)) {
		// LINE 708:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 8;
			__asm        je     _T396;

			__asm        mov    eax, this;
			__asm        add    eax, 0x24;
			__asm        cmp    eax, dyobj;
			__asm        je     _T396;
		// Block start:
			/*bp-0x34*/  short xloc;
			/*bp-0x38*/  short zloc;
			/*bp-0x3c*/  short thisriotval;
			/*bp-0x40*/  /*unpacked*/ class cYObject *obj;
			__asm        mov    eax, dyobj;
			__asm        mov    ax, [eax+0xE];
			__asm        mov    [ebp-0x4C], ax;
		// LINE 709:
			__asm        movsx  eax, word ptr [ebp-0x4C];
			__asm        cmp    eax, 0x7D00;
			__asm        jne    _T25f;

			obj = gAvatar;
			__asm        jmp    _T2db;
		_T25f:
			__asm        movsx  eax, word ptr [ebp-0x4C];
			__asm        test   eax, eax;
			__asm        jl     _T278;

			__asm        movsx  eax, word ptr [ebp-0x4C];
			__asm        cmp    eax, 0x64;
			__asm        jl     _T294;
		_T278:
			doAssert(0x8c085, 0x5bb9f4, 0x204, 0x5bba14);
		_T294:
			__asm        movsx  eax, word ptr [ebp-0x4C];
			__asm        cmp    cYObject::sObjects[0][eax*4], 0;
			__asm        jne    _T2c2;

			doAssert(0x8c085, 0x5bb9d0, 0x205, 0x5bba14);
		_T2c2:
			__asm        movsx  eax, word ptr [ebp-0x4C];
			__asm        mov    eax, cYObject::sObjects[0][eax*4];
			__asm        mov    obj, eax;
			__asm        jmp    _T2db;

			__asm        mov    eax, [ebp-0x50];
			__asm        mov    obj, eax;
		// LINE 710:
		_T2db:
			__asm        cmp    obj, 0;
			__asm        jne    _T301;

			doAssert(0x8c085, 0x5bca1c, 0x2c6, 0x5bca24);
		// LINE 711:
		_T301:
			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xD2];
			__asm        test   eax, eax;
			__asm        jne    _T32f;

			doAssert(0x8c085, 0x5bca48, 0x2c7, 0x5bca84);
		// LINE 712:
		_T32f:
			__asm        mov    eax, obj;
			__asm        mov    ax, [eax+0xE0];
			__asm        mov    thisriotval, ax;
		// LINE 713:
			__asm        mov    eax, obj;
			__asm        mov    eax, [eax+0x3C];
			__asm        sar    eax, 0x10;
			__asm        mov    xloc, ax;
		// LINE 714:
			__asm        mov    eax, obj;
			__asm        mov    eax, [eax+0x44];
			__asm        sar    eax, 0x10;
			__asm        mov    zloc, ax;
		// LINE 715:
			__asm        movsx  eax, xloc;
			__asm        mov    [ebp-0x58], eax;
			__asm        fild   dword ptr [ebp-0x58];
			__asm        movsx  eax, thisriotval;
			__asm        mov    [ebp-0x5C], eax;
			__asm        fimul  dword ptr [ebp-0x5C];
			__asm        fadd   overallxloc;
			__asm        fstp   overallxloc;
		// LINE 716:
			__asm        movsx  eax, zloc;
			__asm        mov    [ebp-0x60], eax;
			__asm        fild   dword ptr [ebp-0x60];
			__asm        movsx  eax, thisriotval;
			__asm        mov    [ebp-0x64], eax;
			__asm        fimul  dword ptr [ebp-0x64];
			__asm        fadd   overallzloc;
			__asm        fstp   overallzloc;
		// LINE 717:
			riotval += reinterpret_cast<int16_t>(thisriotval);
		// LINE 718:
			numcounted++;
		// LINE 720:
		// Block end:
		_T396:
			dyobj = dyobj->next;
	}
// LINE 722:
_T3a3:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        or     eax, 4;
	__asm        mov    ecx, cptr;
	__asm        mov    [ecx], ax;
// LINE 723:
// Block end:
	__asm        jmp    _FOR_NEXT_18d;
// LINE 724:
_T3b7:
	__asm        jmp    _FOR_NEXT_152;
// LINE 725:
_T3bc:
	__asm        movsx  eax, numcounted;
	__asm        test   eax, eax;
	__asm        je     _T44b;

	__asm        cmp    riotval, 0;
	__asm        je     _T44b;
// LINE 726:
// Block start:
	/*bp-0x44*/  int32_t overx;
	/*bp-0x48*/  int32_t overz;
	__asm        fld    overallxloc;
	__asm        mov    eax, riotval;
	__asm        mov    [ebp-0x68], eax;
	__asm        fidiv  dword ptr [ebp-0x68];
	__asm        fstp   overallxloc;
// LINE 727:
	__asm        fld    overallzloc;
	__asm        mov    eax, riotval;
	__asm        mov    [ebp-0x6C], eax;
	__asm        fidiv  dword ptr [ebp-0x6C];
	__asm        fstp   overallzloc;
// LINE 728:
	__asm        fld    overallxloc;
	__asm        call   0x0056EBE8;
	__asm        shl    eax, 0x10;
	__asm        mov    overx, eax;
// LINE 729:
	__asm        fld    overallzloc;
	__asm        call   0x0056EBE8;
	__asm        shl    eax, 0x10;
	__asm        mov    overz, eax;
// LINE 731:
	__asm        mov    eax, overz;
	__asm        push   eax;
	__asm        mov    eax, overx;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        sub    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, dirtogreatestconcentration;
	__asm        mov    [ecx], ax;
// LINE 732:
	__asm        movsx  ecx, numcounted;
	__asm        mov    eax, riotval;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, avgriotval;
	__asm        mov    [ecx], ax;
// LINE 734:
// Block end:
	__asm        jmp    _T45b;
// LINE 735:
_T44b:
	dirtogreatestconcentration[0] = 0xffff;
// LINE 736:
	avgriotval[0] = 0x0;
// LINE 738:
_T45b:
	__asm        mov    ax, numcounted;
	__asm        mov    ecx, counted;
	__asm        mov    [ecx], ax;
// LINE 739:
	return;
}

// FUNCTION: COPTER_D 0x00556cb9
unsigned short cYObject::GetNearbyFire(short todist, short * firecellx, short * firecelly) {
	/*bp-0x4*/   short cellx;
	/*bp-0x8*/   short celly;
	/*bp-0xc*/   /*unpacked*/ struct _CELL_INFO *cptr;

// LINE 748:
_FOR_26:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    cellx, cx;
	__asm        jmp    _FOR_COND_26;
_FOR_NEXT_26:
	cellx++;
_FOR_COND_26:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, cellx;
	__asm        cmp    ecx, eax;
	__asm        jl     _FOR_ff;
// LINE 749:
_FOR_61:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    celly, cx;
	__asm        jmp    _FOR_COND_61;
_FOR_NEXT_61:
	celly++;
_FOR_COND_61:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, celly;
	__asm        cmp    ecx, eax;
	__asm        jl     _Te0;
// LINE 750:
	__asm        movsx  eax, celly;
	__asm        and    eax, 0xFF;
	__asm        movsx  ecx, cellx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 751:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        and    eax, 0xFFFFFFFB;
	__asm        mov    ecx, cptr;
	__asm        mov    [ecx], ax;
// LINE 752:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 4;
	__asm        je     _Tdb;

	doAssert(0x8c085, 0x5bcaa8, 0x2f0, 0x5bcac0);
// LINE 753:
_Tdb:
	__asm        jmp    _FOR_NEXT_61;
// LINE 754:
_Te0:
	__asm        jmp    _FOR_NEXT_26;
// LINE 756:
_FOR_ff:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    cellx, cx;
	__asm        jmp    _FOR_COND_ff;
_FOR_NEXT_ff:
	cellx++;
_FOR_COND_ff:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, cellx;
	__asm        cmp    ecx, eax;
	__asm        jl     _T1f8;
// LINE 757:
_FOR_13a:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        sub    ecx, eax;
	__asm        mov    celly, cx;
	__asm        jmp    _FOR_COND_13a;
_FOR_NEXT_13a:
	celly++;
_FOR_COND_13a:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        movsx  eax, todist;
	__asm        add    ecx, eax;
	__asm        movsx  eax, celly;
	__asm        cmp    ecx, eax;
	__asm        jl     _T1f3;
// LINE 758:
	__asm        movsx  eax, celly;
	__asm        and    eax, 0xFF;
	__asm        movsx  ecx, cellx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 759:
	__asm        cmp    cptr, 0;
	__asm        jne    _T1a1;

	doAssert(0x8c085, 0x5bcae4, 0x2f7, 0x5bcaec);
// LINE 760:
_T1a1:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 4;
	__asm        je     _T1b4;
// LINE 761:
	__asm        jmp    _FOR_NEXT_13a;
// LINE 762:
_T1b4:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _T1df;
// LINE 763:
	__asm        mov    ax, cellx;
	__asm        mov    ecx, firecellx;
	__asm        mov    [ecx], ax;
// LINE 764:
	__asm        mov    ax, celly;
	__asm        mov    ecx, firecelly;
	__asm        mov    [ecx], ax;
// LINE 765:
	return 0x1;
// LINE 767:
_T1df:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        or     eax, 4;
	__asm        mov    ecx, cptr;
	__asm        mov    [ecx], ax;
// LINE 768:
	__asm        jmp    _FOR_NEXT_13a;
// LINE 769:
_T1f3:
	__asm        jmp    _FOR_NEXT_ff;
// LINE 770:
_T1f8:
	return 0x0;
// LINE 771:
}

// FUNCTION: COPTER_D 0x00556ec0
/*unpacked*/ class cYObject* cYObject::GetClosest(enum MissionSupertype missionsupertype, enum MissionType missiontype, unsigned short onlyvisible, short * dist) {
	/*bp-0x4*/   short count;
	/*bp-0x8*/   /*unpacked*/ struct _DYOBJ_INST *closestdyn;
	/*bp-0xc*/   unsigned short closestdist;
	/*bp-0x10*/  /*unpacked*/ class cYObject *closestobj;

// LINE 775:
	closestdyn = 0x0;
// LINE 776:
	closestobj = 0x0;
// LINE 777:
	closestdist = 0xffff;
// LINE 778:
_FOR_2b:
	for (count = 0x0; (reinterpret_cast<int16_t>(count) < 0x64); count++) {
		// LINE 779:
		// Block start:
			/*bp-0x14*/  unsigned short dist;
			/*bp-0x18*/  /*unpacked*/ struct _DYOBJ_INST *dyn;
			/*bp-0x1c*/  /*unpacked*/ class cYObject *obj;
			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x7D00;
			__asm        jne    _T58;

			obj = gAvatar;
			__asm        jmp    _Td4;
		_T58:
			__asm        movsx  eax, count;
			__asm        test   eax, eax;
			__asm        jl     _T71;

			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x64;
			__asm        jl     _T8d;
		_T71:
			doAssert(0x8c085, 0x5bb9f4, 0x204, 0x5bba14);
		_T8d:
			__asm        movsx  eax, count;
			__asm        cmp    cYObject::sObjects[0][eax*4], 0;
			__asm        jne    _Tbb;

			doAssert(0x8c085, 0x5bb9d0, 0x205, 0x5bba14);
		_Tbb:
			__asm        movsx  eax, count;
			__asm        mov    eax, cYObject::sObjects[0][eax*4];
			__asm        mov    obj, eax;
			__asm        jmp    _Td4;

			__asm        mov    eax, [ebp-0x20];
			__asm        mov    obj, eax;
		// LINE 780:
		_Td4:
			__asm        cmp    obj, 0;
			__asm        jne    _Tfa;

			doAssert(0x8c085, 0x5bcb10, 0x30c, 0x5bcb18);
		// LINE 781:
		_Tfa:
			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xD2];
			__asm        test   eax, eax;
			__asm        jne    _T111;

			__asm        jmp    _FOR_NEXT_2b;
		// LINE 782:
		_T111:
			__asm        mov    eax, obj;
			__asm        cmp    this, eax;
			__asm        jne    _T122;

			__asm        jmp    _FOR_NEXT_2b;
		// LINE 783:
		_T122:
			__asm        cmp    missionsupertype, 0xFFFFFFFE;
			__asm        je     _T144;

			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xDA];
			__asm        cmp    eax, missionsupertype;
			__asm        je     _T144;

			__asm        jmp    _FOR_NEXT_2b;
		// LINE 784:
		_T144:
			__asm        cmp    missiontype, 0xFFFFFFFE;
			__asm        je     _T166;

			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xD8];
			__asm        cmp    eax, missiontype;
			__asm        je     _T166;

			__asm        jmp    _FOR_NEXT_2b;
		// LINE 786:
		_T166:
			__asm        cmp    missionsupertype, 0xFFFFFFFE;
			__asm        jne    _T196;

			__asm        cmp    missiontype, 0xFFFFFFFE;
			__asm        jne    _T196;

			doAssert(0x8c085, 0x5bcb3c, 0x312, 0x5bcb64);
		// LINE 787:
		_T196:
			__asm        cmp    missionsupertype, 0;
			__asm        jne    _T1b7;

			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xFE];
			__asm        test   eax, eax;
			__asm        je     _T1b7;

			__asm        jmp    _FOR_NEXT_2b;
		// LINE 788:
		_T1b7:
			__asm        test   reinterpret_cast<uint32_t>(onlyvisible), 0xFFFF;
			__asm        je     _T1db;

			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xE2];
			__asm        test   eax, eax;
			__asm        jne    _T1db;

			__asm        jmp    _FOR_NEXT_2b;
		// LINE 789:
		_T1db:
			dyn = (obj + 0x24);
		// LINE 790:
			__asm        cmp    dyn, 0;
			__asm        jne    _T20a;

			doAssert(0x8c085, 0x5bbebc, 0x3e6, 0x5bba14);
		_T20a:
			__asm        jmp    _T20f;
		_T20f:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+0x3C];
			__asm        mov    ecx, dyn;
			__asm        sub    eax, [ecx+0x18];
			__asm        mov    ecx, this;
			__asm        add    eax, [ecx+0x44];
			__asm        mov    ecx, dyn;
			__asm        sub    eax, [ecx+0x20];
			__asm        mov    ecx, this;
			__asm        add    eax, [ecx+0x40];
			__asm        mov    ecx, dyn;
			__asm        sub    eax, [ecx+0x1C];
			__asm        sar    eax, 0x10;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    [ebp-0x24], ax;
			__asm        mov    ax, [ebp-0x24];
			__asm        mov    dist, ax;
			__asm        jmp    _T24f;
		// LINE 791:
		_T24f:
			__asm        mov    eax, reinterpret_cast<uint32_t>(dist);
			__asm        and    eax, 0xFFFF;
			__asm        mov    ecx, reinterpret_cast<uint32_t>(closestdist);
			__asm        and    ecx, 0xFFFF;
			__asm        cmp    eax, ecx;
			__asm        jge    _T27c;
		// LINE 792:
			__asm        mov    ax, dist;
			__asm        mov    closestdist, ax;
		// LINE 793:
			closestdyn = dyn;
		// LINE 794:
			closestobj = obj;
		// LINE 796:
		// Block end:
		_T27c:
	}
// LINE 797:
_T281:
	__asm        cmp    dist, 0;
	__asm        je     _T29f;

	__asm        cmp    closestobj, 0;
	__asm        je     _T29f;
// LINE 798:
	__asm        mov    ax, closestdist;
	__asm        mov    ecx, dist;
	__asm        mov    [ecx], ax;
// LINE 799:
_T29f:
	return closestobj;
// LINE 800:
}

// FUNCTION: COPTER_D 0x0055716e
void cYObject::Die() {
	/*bp-0x18*/  /*unpacked*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 805:
	mp.op = 0x17;
// LINE 806:
	mp.i2num = 0x1;
// LINE 807:
	mp.id = this->fMissionID;
// LINE 808:
	mp.flags = 0x0;
// LINE 809:
	S3MissionUpdate(mp.op);
// LINE 810:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        test   eax, eax;
	__asm        je     _T55;
// LINE 811:
	this->cYObject::ResetToAmbient();
// LINE 813:
	__asm        jmp    _T77;
// LINE 814:
_T55:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x10A];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xB4];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::Reset;
	__asm        jmp    _T77;
// LINE 816:
_T77:
	this->fData[15] = 0x1;
// LINE 817:
	return;
}

// FUNCTION: COPTER_D 0x005571fb
/*unpacked*/ class cYObject* cYObject::GetFirst(short whichtype, short visible) {
	/*bp-0x4*/   short count;
	/*bp-0x8*/   /*unpacked*/ class cYObject *found;

// LINE 822:
	found = 0x0;
// LINE 823:
_FOR_1b:
	for (count = 0x0; (reinterpret_cast<int16_t>(count) < 0x64); count++) {
		// LINE 824:
		// Block start:
			/*bp-0xc*/   /*unpacked*/ class cYObject *obj;
			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x7D00;
			__asm        jne    _T48;

			obj = gAvatar;
			__asm        jmp    _Tc4;
		_T48:
			__asm        movsx  eax, count;
			__asm        test   eax, eax;
			__asm        jl     _T61;

			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x64;
			__asm        jl     _T7d;
		_T61:
			doAssert(0x8c085, 0x5bb9f4, 0x204, 0x5bba14);
		_T7d:
			__asm        movsx  eax, count;
			__asm        cmp    cYObject::sObjects[0][eax*4], 0;
			__asm        jne    _Tab;

			doAssert(0x8c085, 0x5bb9d0, 0x205, 0x5bba14);
		_Tab:
			__asm        movsx  eax, count;
			__asm        mov    eax, cYObject::sObjects[0][eax*4];
			__asm        mov    obj, eax;
			__asm        jmp    _Tc4;

			__asm        mov    eax, [ebp-0x10];
			__asm        mov    obj, eax;
		// LINE 825:
		_Tc4:
			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xD2];
			__asm        test   eax, eax;
			__asm        jne    _Tdb;

			__asm        jmp    _FOR_NEXT_1b;
		// LINE 826:
		_Tdb:
			__asm        movsx  eax, visible;
			__asm        cmp    eax, 1;
			__asm        jne    _Tff;

			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xE2];
			__asm        test   eax, eax;
			__asm        jne    _Tff;

			__asm        jmp    _FOR_NEXT_1b;
		// LINE 827:
		_Tff:
			__asm        movsx  eax, visible;
			__asm        test   eax, eax;
			__asm        jne    _T122;

			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xE2];
			__asm        test   eax, eax;
			__asm        je     _T122;

			__asm        jmp    _FOR_NEXT_1b;
		// LINE 829:
		_T122:
			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xD8];
			__asm        movsx  ecx, whichtype;
			__asm        cmp    eax, ecx;
			__asm        jne    _T140;
		// LINE 830:
			return obj;
		// LINE 831:
		// Block end:
		_T140:
	}
// LINE 832:
_T145:
	return 0x0;
// LINE 833:
}

// FUNCTION: COPTER_D 0x0055734c
/*unpacked*/ class cYObject* cYObject::DropToted() {
	/*bp-0x4*/   /*unpacked*/ class cYObject *obj;

// LINE 837:
	obj = this->cYObject::GetToted();
// LINE 838:
	__asm        cmp    obj, 0;
	__asm        je     _T9d;
// LINE 839:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        cmp    eax, 6;
	__asm        je     _T50;

	doAssert(0x8c085, 0x5bcb88, 0x347, 0x5bcba8);
// LINE 840:
_T50:
	__asm        jmp    _T55;
_T55:
	__asm        mov    eax, obj;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x24;
	__asm        cmp    [eax+0x130], ecx;
	__asm        je     _T86;

	doAssert(0x8c085, 0x5bcbcc, 0x348, 0x5bcbf8);
// LINE 841:
_T86:
	__asm        push   0;
	__asm        mov    ecx, obj;
	__asm        call   cYObject::SetMaster;
// LINE 842:
	return obj;
// LINE 844:
	__asm        jmp    __RETURN;
// LINE 845:
_T9d:
	return 0x0;
// LINE 846:
__RETURN:
}

// FUNCTION: COPTER_D 0x005573f5
/*unpacked*/ class cYObject* cYObject::GetToted() {
	/*bp-0x4*/   short count;
	/*bp-0x8*/   /*unpacked*/ class cYObject *found;

// LINE 850:
	found = 0x0;
// LINE 851:
_FOR_1e:
	for (count = 0x0; (reinterpret_cast<int16_t>(count) < 0x64); count++) {
		// LINE 852:
		// Block start:
			/*bp-0xc*/   /*unpacked*/ class cYObject *obj;
			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x7D00;
			__asm        jne    _T4b;

			obj = gAvatar;
			__asm        jmp    _Tc7;
		_T4b:
			__asm        movsx  eax, count;
			__asm        test   eax, eax;
			__asm        jl     _T64;

			__asm        movsx  eax, count;
			__asm        cmp    eax, 0x64;
			__asm        jl     _T80;
		_T64:
			doAssert(0x8c085, 0x5bb9f4, 0x204, 0x5bba14);
		_T80:
			__asm        movsx  eax, count;
			__asm        cmp    cYObject::sObjects[0][eax*4], 0;
			__asm        jne    _Tae;

			doAssert(0x8c085, 0x5bb9d0, 0x205, 0x5bba14);
		_Tae:
			__asm        movsx  eax, count;
			__asm        mov    eax, cYObject::sObjects[0][eax*4];
			__asm        mov    obj, eax;
			__asm        jmp    _Tc7;

			__asm        mov    eax, [ebp-0x10];
			__asm        mov    obj, eax;
		// LINE 853:
		_Tc7:
			__asm        mov    eax, obj;
			__asm        movsx  eax, word ptr [eax+0xD2];
			__asm        test   eax, eax;
			__asm        jne    _Tde;

			__asm        jmp    _FOR_NEXT_1e;
		// LINE 854:
		_Tde:
			__asm        jmp    _Te3;
		_Te3:
			__asm        mov    eax, obj;
			__asm        mov    ecx, this;
			__asm        add    ecx, 0x24;
			__asm        cmp    [eax+0x130], ecx;
			__asm        jne    _T124;
		// LINE 855:
			__asm        cmp    found, 0;
			__asm        je     _T11e;

			doAssert(0x8c085, 0x5bcc1c, 0x357, 0x5bcc44);
		// LINE 856:
		_T11e:
			found = obj;
		// LINE 858:
		// Block end:
		_T124:
	}
// LINE 860:
_T129:
	return found;
// LINE 861:
}

// FUNCTION: COPTER_D 0x0055752b
enum TreeSim::ReturnCode cYObject::iDoIHaveAMaster(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 876:
	result = 0xffffffff;
// LINE 877:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x130], 0;
	__asm        je     _T2f;
// LINE 878:
	result = 0x1;
// LINE 879:
	__asm        jmp    _T36;
// LINE 880:
_T2f:
	result = 0x0;
// LINE 881:
_T36:
	return result;
// LINE 882:
}

// FUNCTION: COPTER_D 0x00557570
enum TreeSim::ReturnCode cYObject::iPutMyCarInStack(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 886:
	result = 0xffffffff;
// LINE 887:
	result = 0x0;
// LINE 888:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x100];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T5d;
// LINE 889:
// Block start:
	/*bp-0x8*/   /*unpacked*/ struct _DYOBJ_INST *car;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x100];
	__asm        push   eax;
	__asm        call   EmergencyVehicleClass::S3GetCar;
	__asm        add    esp, 4;
	__asm        mov    car, eax;
// LINE 890:
	__asm        cmp    car, 0;
	__asm        je     _T5d;
// LINE 891:
	__asm        mov    eax, car;
	__asm        mov    ecx, elem;
	__asm        mov    [ecx+4], eax;
// LINE 892:
	result = 0x1;
// LINE 895:
// Block end:
_T5d:
	return result;
// LINE 896:
}

// FUNCTION: COPTER_D 0x005575dc
enum TreeSim::ReturnCode cYObject::iIdle(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   /*unpacked*/ struct YObjLang::IdleParam param;

// LINE 900:
	nparam = (node + 0x4);
	result = 0xffffffff;
// LINE 901:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    param.decTemp, ax;
// LINE 902:
	__asm        movsx  eax, param.decTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T40;

	__asm        movsx  eax, param.decTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T5c;
_T40:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T5c:
	__asm        jmp    _T61;
_T61:
	__asm        jmp    _T66;
_T66:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.decTemp;
	__asm        movsx  eax, word ptr [eax+ecx*2+8];
	__asm        test   eax, eax;
	__asm        jne    _T9a;

	result = 0x1;
// LINE 903:
	__asm        jmp    _T10b;
// LINE 904:
_T9a:
	__asm        movsx  eax, param.decTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _Tb4;

	__asm        movsx  eax, param.decTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _Td0;
_Tb4:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_Td0:
	__asm        jmp    _Td5;
_Td5:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.decTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _Tfe;
_Tfe:
	__asm        mov    eax, [ebp-0x10];
	__asm        dec    word ptr [eax];
// LINE 905:
	result = 0x2;
// LINE 907:
_T10b:
	return result;
// LINE 908:
}

// FUNCTION: COPTER_D 0x005576f6
enum TreeSim::ReturnCode cYObject::iSetAnim(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   /*unpacked*/ struct YObjLang::SetAnimParam param;

// LINE 912:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 913:
	param.animname = nparam-><YObjLang::Param+0x00:4>;
// LINE 914:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x90], 0;
	__asm        jne    _T50;

	doAssert(0x8c085, 0x5bbb9c, 0x2f8, 0x5bba14);
_T50:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        je     _T75;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    ecx, param.animname;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        je     _Tbc;
_T75:
	__asm        mov    eax, param.animname;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x90];
	__asm        call   cCopterBody::GetPrivateAnim;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x98], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        jne    _Tbc;

	doAssert(0x8c085, 0x5bbb74, 0x2fb, 0x5bba14);
_Tbc:
	__asm        jmp    _Tc1;
// LINE 915:
_Tc1:
	result = 0x1;
// LINE 916:
	return result;
// LINE 917:
}

// FUNCTION: COPTER_D 0x005577cd
enum TreeSim::ReturnCode cYObject::iAttr(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;

// LINE 921:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 922:
	__asm        mov    eax, nparam;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::TryExpression;
	__asm        mov    result, eax;
// LINE 923:
	return result;
// LINE 924:
}

// FUNCTION: COPTER_D 0x00557807
enum TreeSim::ReturnCode cYObject::iWalk(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x14*/  /*unpacked*/ struct cYObject::MoveInfo moveinfo; // 0x10 bytes
	/*bp-0x18*/  enum cYObject::MoveErrorCode movecode;
	/*bp-0x1c*/  unsigned short onlyNeutral;
	/*bp-0x20*/  /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x24*/  short * walkloc;
	/*bp-0x28*/  short dectemp;
	/*bp-0x2c*/  short movespeed;

// LINE 928:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 929:
	movecode = 0xffffffff;
// LINE 930:
	movespeed = 0x0;
// LINE 932:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    dectemp, ax;
// LINE 933:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xF8];
	__asm        mov    onlyNeutral, ax;
// LINE 934:
	Memory::BlockFill(0x10, 0x0, moveinfo.locType);
// LINE 935:
	__asm        movsx  eax, dectemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T6b;

	__asm        movsx  eax, dectemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T87;
_T6b:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        jmp    _T91;
_T91:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, dectemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    walkloc, eax;
// LINE 937:
	__asm        mov    eax, walkloc;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   eax, eax;
	__asm        jne    _Td6;
// LINE 938:
	movecode = 0x8;
// LINE 939:
	result = 0x1;
// LINE 941:
	__asm        jmp    _T11e;
// LINE 942:
_Td6:
	walkloc[0]--;
// LINE 944:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xF4];
	__asm        mov    movespeed, ax;
// LINE 956:
	__asm        lea    eax, moveinfo.locType;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(onlyNeutral);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(movespeed);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::TryTableMove;
	__asm        mov    movecode, eax;
	__asm        cmp    movecode, 0;
	__asm        jne    _T117;
// LINE 957:
	result = 0x2;
// LINE 958:
	__asm        jmp    _T11e;
// LINE 959:
_T117:
	result = 0x0;
// LINE 961:
_T11e:
	__asm        lea    eax, moveinfo.locType;
	__asm        push   eax;
	__asm        mov    eax, movecode;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(movespeed);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::DynEffects;
// LINE 962:
	return result;
// LINE 963:
}

// FUNCTION: COPTER_D 0x00557948
enum TreeSim::ReturnCode cYObject::iSetBody(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   /*unpacked*/ struct YObjLang::SetBodyParam param;

// LINE 967:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 968:
	param.bodyname = nparam-><YObjLang::Param+0x00:4>;
// LINE 969:
	__asm        mov    eax, cCopterBody::fsList;
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    dword ptr [ebp-0x10], 0;
	__asm        cmp    dword ptr [ebp-0x10], 0;
	__asm        jl     _T47;

	__asm        cmp    dword ptr [ebp-0x10], 0x20;
	__asm        jb     _T60;
_T47:
	doAssert(0x8c085, 0x5bbd7c, 0x6d, 0x5bbda4);
_T60:
	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        je     _T78;

	__asm        mov    eax, [ebp-0x30];
	__asm        add    eax, 4;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T7f;
_T78:
	__asm        mov    dword ptr [ebp-0x1C], 0;
_T7f:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x18], eax;
	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        je     _T9c;

	__asm        mov    eax, [ebp-0x18];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _Ta3;
_T9c:
	__asm        mov    dword ptr [ebp-0x14], 0;
_Ta3:
	__asm        jmp    _Ta8;
_Ta8:
	__asm        jmp    _Tad;
_Tad:
	__asm        jmp    _Tca;
_LOOP_b2:
	for (;;) {
		_LOOP_b2:
			__asm        cmp    dword ptr [ebp-0x14], 0;
			__asm        je     _Tc5;

			__asm        mov    eax, [ebp-0x14];
			__asm        mov    eax, [eax+4];
			__asm        mov    [ebp-0x14], eax;
		_Tc5:
			__asm        jmp    _Tca;
		_Tca:
			__asm        cmp    dword ptr [ebp-0x14], 0;
			__asm        je     _Tea;

			__asm        mov    eax, [ebp-0x14];
			__asm        cmp    dword ptr [eax], 0;
			__asm        je     _T17e;

			__asm        jmp    _Tfe;

			__asm        jmp    _Tf4;
		_Tea:
			__asm        jmp    _T17e;

			__asm        jmp    _Tfe;
		_Tf4:
			__asm        cmp    dword ptr [ebp-0x24], 0;
			__asm        je     _T17e;
		_Tfe:
			__asm        cmp    dword ptr [ebp-0x14], 0;
			__asm        je     _T11a;

			__asm        mov    eax, [ebp-0x14];
			__asm        mov    eax, [eax];
			__asm        mov    [ebp-0x20], eax;
			__asm        jmp    _T126;

			__asm        jmp    _T126;
		_T11a:
			__asm        mov    dword ptr [ebp-0x20], 0;
			__asm        jmp    _T126;
		_T126:
			__asm        jmp    _T12b;
		_T12b:
			__asm        mov    eax, [ebp-0x20];
			__asm        mov    eax, [eax+0x1C];
			__asm        mov    cl, [ebp-0x10];
			__asm        shr    eax, cl;
			__asm        mov    edx, param.bodyname;
			__asm        mov    cl, [ebp-0x10];
			__asm        shr    edx, cl;
			__asm        cmp    eax, edx;
			__asm        jne    _T179;

			__asm        cmp    dword ptr [ebp-0x14], 0;
			__asm        je     _T162;

			__asm        mov    eax, [ebp-0x14];
			__asm        mov    eax, [eax];
			__asm        mov    [ebp-0x2C], eax;
			__asm        jmp    _T174;

			__asm        jmp    _T16e;
		_T162:
			__asm        mov    dword ptr [ebp-0x2C], 0;
			__asm        jmp    _T174;
		_T16e:
			__asm        mov    eax, [ebp-0x28];
			__asm        mov    [ebp-0x2C], eax;
		_T174:
			__asm        jmp    _T18a;
		_T179:
			__asm        jmp    _LOOP_b2;
	}
_T17e:
	__asm        mov    dword ptr [ebp-0x2C], 0;
	__asm        jmp    _T18a;
_T18a:
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x90], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x90], 0;
	__asm        jne    _T1c2;

	doAssert(0x8c085, 0x5bbd68, 0x27a, 0x5bba14);
_T1c2:
	__asm        jmp    _T1c7;
// LINE 970:
_T1c7:
	result = 0x1;
// LINE 972:
	return result;
// LINE 973:
}

// FUNCTION: COPTER_D 0x00557b25
enum TreeSim::ReturnCode cYObject::iRandom(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   short range;
	/*bp-0x14*/  /*unpacked*/ struct YObjLang::RandomParam rand; // 0x6 bytes

// LINE 977:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 978:
	__asm        mov    eax, nparam;
	__asm        lea    ecx, rand.destTemp;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    ax, [eax+4];
	__asm        mov    [ecx+4], ax;
// LINE 980:
	__asm        push   0;
	__asm        mov    eax, reinterpret_cast<uint32_t>(rand.rangeData);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(rand.rangeOwner);
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    range, ax;
// LINE 981:
	__asm        movsx  eax, range;
	__asm        test   eax, eax;
	__asm        jg     _T6f;

	doAssert(0x8c085, 0x5bcc68, 0x3d5, 0x5bcc88);
// LINE 982:
_T6f:
	__asm        movsx  eax, rand.destTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T89;

	__asm        movsx  eax, rand.destTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _Ta5;
_T89:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_Ta5:
	__asm        jmp    _Taa;
_Taa:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, rand.destTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _Td3;
_Td3:
	__asm        mov    eax, reinterpret_cast<uint32_t>(range);
	__asm        push   eax;
	__asm        call   SRand;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x18];
	__asm        mov    [ecx], ax;
// LINE 983:
	result = 0x1;
// LINE 985:
	return result;
// LINE 986:
}

// FUNCTION: COPTER_D 0x00557c20
enum TreeSim::ReturnCode cYObject::iWalkToAndGrabOntoStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   short speed;
	/*bp-0x18*/  /*unpacked*/ struct cYObject::MoveInfo moveinfo; // 0x10 bytes
	/*bp-0x1c*/  enum cYObject::MoveErrorCode movecode;
	/*bp-0x20*/  /*unpacked*/ struct YObjLang::WalkAndGrabParam walkgrab;
	/*bp-0x24*/  /*unpacked*/ union YObjLang::Param *nparam;

// LINE 990:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 991:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T45;

	doAssert(0x8c085, 0x5bccac, 0x3df, 0x5bccc8);
// LINE 992:
_T45:
	reinterpret_cast<uint32_t>(walkgrab.decTemp) = nparam-><YObjLang::Param+0x00:4>;
// LINE 995:
	speed = 0x0;
// LINE 996:
	__asm        movsx  eax, walkgrab.decTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T6d;

	__asm        movsx  eax, walkgrab.decTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T89;
_T6d:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T89:
	__asm        jmp    _T8e;
_T8e:
	__asm        jmp    _T93;
_T93:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, walkgrab.decTemp;
	__asm        movsx  eax, word ptr [eax+ecx*2+8];
	__asm        test   eax, eax;
	__asm        jne    _Tce;
// LINE 997:
	movecode = 0x8;
// LINE 998:
	result = 0x0;
// LINE 1000:
	__asm        jmp    _T2fd;
// LINE 1001:
// Block start:
	/*bp-0x28*/  /*unpacked*/ struct _DYOBJ_INST *goal;
_Tce:
	__asm        movsx  eax, walkgrab.decTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _Te8;

	__asm        movsx  eax, walkgrab.decTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T104;
_Te8:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T104:
	__asm        jmp    _T109;
_T109:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, walkgrab.decTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T132;
_T132:
	__asm        mov    eax, [ebp-0x2C];
	__asm        dec    word ptr [eax];
// LINE 1002:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    goal, eax;
// LINE 1003:
	__asm        jmp    _T146;
_T146:
	__asm        mov    eax, goal;
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, goal;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        movsx  eax, ax;
	__asm        sub    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1004:
	Memory::BlockFill(0x10, 0x0, moveinfo.locType);
// LINE 1005:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xF4];
	__asm        mov    speed, ax;
// LINE 1006:
	__asm        lea    eax, moveinfo.locType;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, reinterpret_cast<uint32_t>(speed);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::TryTableMove;
	__asm        mov    movecode, eax;
// LINE 1007:
	__asm        cmp    movecode, 0xA;
	__asm        jne    _T2e0;

	__asm        mov    eax, goal;
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x40];
	__asm        and    eax, 0xFFFF0000;
	__asm        mov    ecx, 0x50000;
	__asm        and    ecx, 0xFFFF0000;
	__asm        cmp    eax, ecx;
	__asm        jge    _T2e0;
// LINE 1008:
	__asm        mov    eax, node;
	__asm        movsx  eax, word ptr [eax];
	__asm        cmp    eax, 0xC;
	__asm        jne    _T2d4;
// LINE 1009:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::SetMaster;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T2c8;

	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x38], eax;
// LINE 1010:
	__asm        mov    eax, [ebp-0x38];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x3C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::Unlink;
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x44];
	__asm        sar    eax, 0x16;
	__asm        mov    [ebp-0x30], al;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    [ebp-0x34], al;
	__asm        jmp    _T25b;
_T25b:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+0x20];
	__asm        test   ecx, ecx;
	__asm        je     _T288;

	doAssert(0x8c085, 0x5bbbb8, 0x210, 0x5bba14);
_T288:
	__asm        mov    al, [ebp-0x34];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x88], al;
	__asm        mov    al, [ebp-0x30];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x89], al;
	__asm        jmp    _T2a5;
_T2a5:
	this->cYObject::Link();
	__asm        jmp    _T2b2;
// LINE 1013:
_T2b2:
	__asm        mov    eax, elem;
	__asm        mov    dword ptr [eax+4], 0;
// LINE 1014:
	result = 0x1;
// LINE 1016:
	__asm        jmp    _T2cf;
// LINE 1017:
_T2c8:
	result = 0x0;
// LINE 1019:
_T2cf:
	__asm        jmp    _T2db;
// LINE 1020:
_T2d4:
	result = 0x1;
// LINE 1022:
_T2db:
	__asm        jmp    _T2fd;
_T2e0:
	__asm        cmp    movecode, 0;
	__asm        jne    _T2f6;
// LINE 1023:
	result = 0x2;
// LINE 1024:
	__asm        jmp    _T2fd;
// LINE 1025:
_T2f6:
	result = 0x0;
// LINE 1027:
// Block end:
_T2fd:
	__asm        lea    eax, moveinfo.locType;
	__asm        push   eax;
	__asm        mov    eax, movecode;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(speed);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::DynEffects;
// LINE 1029:
	return result;
// LINE 1030:
}

// FUNCTION: COPTER_D 0x00557f40
enum TreeSim::ReturnCode cYObject::iUpdateMyMission(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   /*unpacked*/ struct YObjLang::UpdateMyMissionParam param;

// LINE 1034:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1035:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    param.updateLiteral, ax;
// LINE 1036:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        movsx  eax, param.updateLiteral;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::UpdateMission;
// LINE 1037:
	result = 0x1;
// LINE 1039:
	return result;
// LINE 1040:
}

// FUNCTION: COPTER_D 0x00557f90
enum TreeSim::ReturnCode cYObject::iCheckForTrue(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   /*unpacked*/ struct YObjLang::CheckForTrueParam param;

// LINE 1044:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1045:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    param.whatLiteral, ax;
// LINE 1046:
	__asm        movsx  eax, param.whatLiteral;
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T2a8;
// LINE 1050:
_T32:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T4d;
// LINE 1051:
	result = 0x1;
// LINE 1052:
	__asm        jmp    _T54;
// LINE 1053:
_T4d:
	result = 0x0;
// LINE 1054:
_T54:
	__asm        jmp    _T2d0;
// LINE 1057:
// Block start:
	/*bp-0x10*/  short copterheight;
	/*bp-0x14*/  /*unpacked*/ struct _HELI_DATA *hd;
_T59:
	hd = S3HeliGetDataByDyObj(G_uheli->dyheli);
// LINE 1058:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x154];
	__asm        sar    eax, 0x10;
	__asm        mov    copterheight, ax;
// LINE 1060:
	__asm        jmp    _T93;
_T93:
	__asm        movsx  eax, copterheight;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cmp    eax, 5;
	__asm        jge    _Tb4;
// LINE 1061:
	result = 0x1;
// LINE 1062:
	__asm        jmp    _Tbb;
// LINE 1063:
_Tb4:
	result = 0x0;
// LINE 1064:
_Tbb:
	__asm        jmp    _T2d0;
// LINE 1067:
// Block end:
// Block start:
	/*bp-0x18*/  short delta_y;
	/*bp-0x1c*/  int32_t y;
	/*bp-0x20*/  /*unpacked*/ struct _DYOBJ_INST *obj;
_Tc0:
	obj = this->fPointers[0];
// LINE 1068:
	__asm        cmp    obj, 0;
	__asm        jne    _Tf2;

	doAssert(0x8c085, 0x5bccec, 0x42c, 0x5bcd20);
// LINE 1069:
_Tf2:
	y = S3PUtilsGetAlt(obj->loc.z, obj->loc.y, obj->loc.x);
// LINE 1070:
	__asm        mov    eax, obj;
	__asm        mov    eax, [eax+0x1C];
	__asm        sub    eax, y;
	__asm        sar    eax, 0x10;
	__asm        mov    delta_y, ax;
// LINE 1071:
	__asm        movsx  eax, delta_y;
	__asm        cmp    eax, 5;
	__asm        jge    _T13b;
// LINE 1072:
	result = 0x1;
// LINE 1073:
	__asm        jmp    _T142;
// LINE 1074:
_T13b:
	result = 0x0;
// LINE 1075:
_T142:
	__asm        jmp    _T2d0;
// LINE 1078:
// Block end:
_T147:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x130];
	__asm        mov    [ebp-0x28], eax;
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        jne    _T179;

	doAssert(0x8c085, 0x5bdd88, 0x3da, 0x5bba14);
_T179:
	__asm        jmp    _T17e;
_T17e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    ecx, [ebp-0x28];
	__asm        sub    eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0xA8];
	__asm        mov    ecx, [ebp-0x28];
	__asm        sub    eax, [ecx+0x20];
	__asm        sar    eax, 0x10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cmp    eax, 2;
	__asm        jge    _T1bd;

	__asm        jmp    _T1d4;

	__asm        jmp    _T1c7;
_T1bd:
	__asm        jmp    _T1e0;

	__asm        jmp    _T1d4;
_T1c7:
	__asm        test   dword ptr [ebp-0x2C], 0xFFFF;
	__asm        je     _T1e0;
// LINE 1079:
_T1d4:
	result = 0x1;
// LINE 1080:
	__asm        jmp    _T1e7;
// LINE 1081:
_T1e0:
	result = 0x0;
// LINE 1082:
_T1e7:
	__asm        jmp    _T2d0;
// LINE 1085:
_T1ec:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T215;

	doAssert(0x8c085, 0x5bcd44, 0x43d, 0x5bcd78);
// LINE 1087:
_T215:
	__asm        mov    eax, elem;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        cmp    [eax+4], ecx;
	__asm        jne    _T27b;
// LINE 1090:
// Block start:
	/*bp-0x24*/  short copterheight;
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, G_uheli;
	__asm        sub    eax, [ecx+0x154];
	__asm        sar    eax, 0x10;
	__asm        mov    copterheight, ax;
// LINE 1092:
	__asm        jmp    _T24e;
_T24e:
	__asm        movsx  eax, copterheight;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cmp    eax, 5;
	__asm        jge    _T26f;
// LINE 1093:
	result = 0x1;
// LINE 1094:
	__asm        jmp    _T276;
// LINE 1095:
_T26f:
	result = 0x0;
// LINE 1097:
// Block end:
_T276:
	__asm        jmp    _T282;
// LINE 1098:
_T27b:
	result = 0x1;
// LINE 1100:
_T282:
	__asm        jmp    _T2d0;
// LINE 1103:
_T287:
	doAssert(0x8c085, 0x5bcd9c, 0x44f, 0x5bcdb8);
// LINE 1104:
	__asm        jmp    _T2d0;
_T2a8:
	__asm        cmp    dword ptr [ebp-0x34], 4;
	__asm        ja     _T287;

	__asm        mov    eax, [ebp-0x34];
	__asm        jmp    _Switch_2bc[0][eax*4];
// Switch pointers:
//   _T32
//   _T59
//   _Tc0
//   _T147
//   _T1ec
// LINE 1105:
_T2d0:
	return result;
// LINE 1106:
}

// FUNCTION: COPTER_D 0x0055826f
enum TreeSim::ReturnCode cYObject::iCompareMyLocWith(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   /*unpacked*/ struct _DYOBJ_INST *destobj;
	/*bp-0x8*/   enum TreeSim::ReturnCode result;
	/*bp-0xc*/   short distance;
	/*bp-0x10*/  /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x18*/  /*unpacked*/ struct YObjLang::CompareMyLocWithParam param; // 0x6 bytes
	/*bp-0x20*/  /*unpacked*/ struct Point2d destloc; // 0x8 bytes

// LINE 1110:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1111:
	__asm        mov    eax, nparam;
	__asm        lea    ecx, param.withWhatLiteral;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    ax, [eax+4];
	__asm        mov    [ecx+4], ax;
// LINE 1113:
	__asm        push   0;
	__asm        mov    eax, reinterpret_cast<uint32_t>(param.distData);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(param.distOwner);
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    distance, ax;
// LINE 1115:
	destobj = 0x0;
// LINE 1116:
	__asm        movsx  eax, param.withWhatLiteral;
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    _T433;
// LINE 1118:
_T5a:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        test   eax, eax;
	__asm        jne    _T88;

	doAssert(0x8c085, 0x5bcddc, 0x45e, 0x5bce14);
// LINE 1119:
_T88:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1C], 0xFFFFFFFF;
	__asm        jne    _Tb1;

	doAssert(0x8c085, 0x5bce38, 0x45f, 0x5bce64);
// LINE 1120:
_Tb1:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   S3MissionGetDestMapLoc;
	__asm        add    esp, 4;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    destloc.x, ecx;
	__asm        mov    destloc.y, eax;
// LINE 1121:
	__asm        jmp    _T483;
// LINE 1123:
_Td0:
	destobj = reinterpret_cast<uint32_t>(this->fIterations);
// LINE 1124:
	__asm        cmp    destobj, 0;
	__asm        jne    _T102;

	doAssert(0x8c085, 0x5bce88, 0x464, 0x5bcec0);
// LINE 1125:
_T102:
	__asm        jmp    _T483;
// LINE 1127:
_T107:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    destobj, eax;
// LINE 1128:
	__asm        cmp    destobj, 0;
	__asm        jne    _T136;

	doAssert(0x8c085, 0x5bcee4, 0x468, 0x5bcf20);
// LINE 1129:
_T136:
	__asm        jmp    _T483;
// LINE 1131:
_T13b:
	destobj = G_uheli->dybucket;
// LINE 1133:
	__asm        jmp    _T483;
// LINE 1136:
_T14e:
	destobj = G_uheli->dyheli;
// LINE 1138:
	__asm        jmp    _T483;
// LINE 1141:
_T161:
	doAssert(0x8c085, 0x5bcf44, 0x475, 0x5bcf60);
// LINE 1144:
	__asm        jmp    _T483;
// LINE 1147:
// Block start:
	/*bp-0x24*/  /*unpacked*/ class cYObject *obj;
_T182:
	__asm        push   0;
	__asm        push   1;
	__asm        push   0xFFFFFFFE;
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   cYObject::GetClosest;
	__asm        mov    obj, eax;
// LINE 1148:
	__asm        cmp    obj, 0;
	__asm        je     _T1ad;
// LINE 1149:
	destobj = (obj + 0x24);
// LINE 1150:
	__asm        jmp    _T1b4;
// LINE 1151:
_T1ad:
	result = 0x0;
// LINE 1153:
_T1b4:
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        cmp    eax, destobj;
	__asm        jne    _T1df;

	doAssert(0x8c085, 0x5bcf84, 0x481, 0x5bcf8c);
// LINE 1154:
_T1df:
	__asm        jmp    _T483;
// LINE 1157:
// Block end:
_T1e4:
	destobj = (gAvatar + 0x24);
// LINE 1158:
	result = 0x1;
// LINE 1159:
	__asm        jmp    _T483;
// LINE 1162:
// Block start:
	/*bp-0x28*/  /*unpacked*/ class cYObject *obj;
_T1fb:
	__asm        push   0;
	__asm        push   1;
	__asm        push   0xFFFFFFFE;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   cYObject::GetClosest;
	__asm        mov    obj, eax;
// LINE 1163:
	__asm        cmp    obj, 0;
	__asm        je     _T226;
// LINE 1164:
	destobj = (obj + 0x24);
// LINE 1165:
	__asm        jmp    _T22d;
// LINE 1166:
_T226:
	result = 0x0;
// LINE 1168:
_T22d:
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        cmp    eax, destobj;
	__asm        jne    _T258;

	doAssert(0x8c085, 0x5bcfb0, 0x490, 0x5bcfb8);
// LINE 1169:
_T258:
	__asm        jmp    _T483;
// LINE 1172:
// Block end:
// Block start:
	/*bp-0x2c*/  /*unpacked*/ class cYObject *obj;
_T25d:
	__asm        push   0;
	__asm        push   1;
	__asm        push   6;
	__asm        push   0xFFFFFFFE;
	__asm        mov    ecx, this;
	__asm        call   cYObject::GetClosest;
	__asm        mov    obj, eax;
// LINE 1173:
	__asm        cmp    obj, 0;
	__asm        je     _T288;
// LINE 1174:
	destobj = (obj + 0x24);
// LINE 1175:
	__asm        jmp    _T28f;
// LINE 1176:
_T288:
	result = 0x0;
// LINE 1178:
_T28f:
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        cmp    eax, destobj;
	__asm        jne    _T2ba;

	doAssert(0x8c085, 0x5bcfdc, 0x49a, 0x5bcfe4);
// LINE 1179:
_T2ba:
	__asm        jmp    _T483;
// LINE 1182:
// Block end:
_T2bf:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        push   ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        push   ecx;
	__asm        push   0;
	__asm        call   AutomobileClass::GetClosestCar;
	__asm        add    esp, 0xC;
	__asm        mov    destobj, eax;
// LINE 1183:
	__asm        cmp    destobj, 0;
	__asm        je     _T2fa;
// LINE 1184:
	result = 0x1;
// LINE 1185:
	__asm        jmp    _T301;
// LINE 1186:
_T2fa:
	result = 0x0;
// LINE 1187:
_T301:
	__asm        jmp    _T483;
// LINE 1190:
_T306:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        push   ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        push   ecx;
	__asm        push   3;
	__asm        call   AutomobileClass::GetClosestCar;
	__asm        add    esp, 0xC;
	__asm        mov    destobj, eax;
// LINE 1191:
	__asm        cmp    destobj, 0;
	__asm        je     _T341;
// LINE 1192:
	result = 0x1;
// LINE 1193:
	__asm        jmp    _T348;
// LINE 1194:
_T341:
	result = 0x0;
// LINE 1195:
_T348:
	__asm        jmp    _T483;
// LINE 1199:
_T34d:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        push   ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        push   ecx;
	__asm        push   1;
	__asm        call   AutomobileClass::GetClosestCar;
	__asm        add    esp, 0xC;
	__asm        mov    destobj, eax;
// LINE 1200:
	__asm        cmp    destobj, 0;
	__asm        je     _T388;
// LINE 1201:
	result = 0x1;
// LINE 1202:
	__asm        jmp    _T38f;
// LINE 1203:
_T388:
	result = 0x0;
// LINE 1204:
_T38f:
	__asm        jmp    _T483;
// LINE 1207:
_T394:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        push   ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        push   ecx;
	__asm        push   2;
	__asm        call   AutomobileClass::GetClosestCar;
	__asm        add    esp, 0xC;
	__asm        mov    destobj, eax;
// LINE 1208:
	__asm        cmp    destobj, 0;
	__asm        je     _T3cf;
// LINE 1209:
	result = 0x1;
// LINE 1210:
	__asm        jmp    _T3d6;
// LINE 1211:
_T3cf:
	result = 0x0;
// LINE 1212:
_T3d6:
	__asm        jmp    _T483;
// LINE 1215:
// Block start:
	/*bp-0x30*/  /*unpacked*/ class cYObject *obj;
_T3db:
	__asm        push   0;
	__asm        push   1;
	__asm        push   0;
	__asm        push   0xFFFFFFFE;
	__asm        mov    ecx, this;
	__asm        call   cYObject::GetClosest;
	__asm        mov    obj, eax;
// LINE 1216:
	__asm        cmp    obj, 0;
	__asm        je     _T406;
// LINE 1217:
	destobj = (obj + 0x24);
// LINE 1218:
	__asm        jmp    _T40d;
// LINE 1219:
_T406:
	result = 0x0;
// LINE 1221:
_T40d:
	__asm        jmp    _T483;
// LINE 1224:
// Block end:
_T412:
	doAssert(0x8c085, 0x5bd008, 0x4c8, 0x5bd028);
// LINE 1225:
	__asm        jmp    _T483;
_T433:
	__asm        cmp    dword ptr [ebp-0x3C], 0xE;
	__asm        ja     _T412;

	__asm        mov    eax, [ebp-0x3C];
	__asm        jmp    _Switch_447[0][eax*4];
// Switch pointers:
//   _T5a
//   _T107
//   _T14e
//   _T13b
//   _Td0
//   _T25d
//   _T1fb
//   _T161
//   _T182
//   _T1e4
//   _T2bf
//   _T34d
//   _T394
//   _T306
//   _T3db
// LINE 1226:
_T483:
	__asm        cmp    result, 0;
	__asm        je     _T54a;
// LINE 1227:
// Block start:
	/*bp-0x34*/  short dist;
	__asm        cmp    destobj, 0;
	__asm        je     _T4b9;
// LINE 1228:
	destloc.x = ((destobj->loc.x + 0x20000000) >> 0x16);
// LINE 1229:
	destloc.y = ((0x20000000 - destobj->loc.z) >> 0x16);
// LINE 1232:
_T4b9:
	__asm        jmp    _T4be;
_T4be:
	__asm        jmp    _T4c3;
_T4c3:
	__asm        jmp    _T4c8;
_T4c8:
	__asm        mov    eax, destloc.y;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x89];
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        movsx  ecx, ax;
	__asm        mov    eax, destloc.x;
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0x88];
	__asm        sub    eax, ebx;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cmp    ecx, eax;
	__asm        jg     _T508;

	__asm        mov    ecx, eax;
_T508:
	__asm        movsx  eax, cx;
	__asm        and    eax, 0xFF;
	__asm        mov    dist, ax;
// LINE 1233:
	__asm        movsx  eax, dist;
	__asm        movsx  ecx, distance;
	__asm        cmp    eax, ecx;
	__asm        jl     _T530;
// LINE 1234:
	result = 0x0;
// LINE 1235:
	__asm        jmp    _T54a;
// LINE 1236:
_T530:
	__asm        cmp    destobj, 0;
	__asm        je     _T543;
// LINE 1237:
	__asm        mov    eax, destobj;
	__asm        mov    ecx, elem;
	__asm        mov    [ecx+4], eax;
// LINE 1238:
_T543:
	result = 0x1;
// LINE 1241:
// Block end:
_T54a:
	return result;
// LINE 1242:
}

// FUNCTION: COPTER_D 0x005587c8
enum TreeSim::ReturnCode cYObject::iSelfDecommission(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1246:
	result = 0xffffffff;
// LINE 1247:
	this->cYObject::ResetToAmbient();
// LINE 1248:
	result = 0x3;
// LINE 1250:
	return result;
// LINE 1251:
}

// FUNCTION: COPTER_D 0x005587f9
enum TreeSim::ReturnCode cYObject::iGetOffMasterObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1255:
	result = 0xffffffff;
// LINE 1256:
	__asm        mov    ecx, this;
	__asm        call   cYObject::CanJumpOffHere;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _Tc1;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x130], 0;
	__asm        jne    _T52;

	doAssert(0x8c085, 0x5bb998, 0x41e, 0x5bba14);
_T52:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   cYObject::SetMaster;
	__asm        mov    [ebp-8], ax;
	__asm        test   dword ptr [ebp-8], 0xFFFF;
	__asm        jne    _T89;

	doAssert(0x8c085, 0x5bb978, 0x420, 0x5bba14);
_T89:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetAlt;
	__asm        add    esp, 0xC;
	__asm        lea    eax, [eax+0x30000];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x40], eax;
	__asm        jmp    _Tb7;
_Tb7:
	__asm        jmp    _Td8;

	__asm        jmp    _Tcb;
_Tc1:
	__asm        jmp    _Te4;

	__asm        jmp    _Td8;
_Tcb:
	__asm        test   dword ptr [ebp-0xC], 0xFFFF;
	__asm        je     _Te4;
// LINE 1257:
_Td8:
	result = 0x1;
// LINE 1258:
	__asm        jmp    _Teb;
// LINE 1259:
_Te4:
	result = 0x0;
// LINE 1261:
_Teb:
	return result;
// LINE 1262:
}

// FUNCTION: COPTER_D 0x005588f3
enum TreeSim::ReturnCode cYObject::iTurnTowardsStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1266:
	result = 0xffffffff;
// LINE 1267:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T3c;

	doAssert(0x8c085, 0x5bd04c, 0x4f3, 0x5bd064);
_T3c:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
// LINE 1268:
	__asm        jmp    _T4a;
_T4a:
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        movsx  eax, ax;
	__asm        sub    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1269:
	result = 0x1;
// LINE 1271:
	return result;
// LINE 1272:
}

// FUNCTION: COPTER_D 0x0055898a
enum TreeSim::ReturnCode cYObject::iIsThisLocType(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   enum cYObject::LocationType loctype;
	/*bp-0xc*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x10*/  /*unpacked*/ struct YObjLang::IsThisLocTypeParam param;

// LINE 1276:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1277:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    param.locTypeLiteral, ax;
// LINE 1278:
	loctype = reinterpret_cast<int16_t>(param.locTypeLiteral);
// LINE 1279:
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        call   cYObject::GetLocType;
	__asm        add    esp, 8;
	__asm        cmp    eax, loctype;
	__asm        jne    _T62;
// LINE 1280:
	result = 0x1;
// LINE 1281:
	__asm        jmp    _T69;
// LINE 1282:
_T62:
	result = 0x0;
// LINE 1284:
_T69:
	return result;
// LINE 1285:
}

// FUNCTION: COPTER_D 0x00558a02
enum TreeSim::ReturnCode cYObject::iIsThisLocTypeNeutral(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   enum cYObject::LocationType loctype;

// LINE 1289:
	result = 0xffffffff;
// LINE 1290:
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        call   cYObject::GetLocType;
	__asm        add    esp, 8;
	__asm        mov    loctype, eax;
// LINE 1291:
_FOR_41:
	__asm        mov    word ptr [ebp-0xC], 0;
	__asm        jmp    _FOR_COND_41;
_FOR_NEXT_41:
	__asm        inc    word ptr [ebp-0xC];
_FOR_COND_41:
	__asm        movsx  eax, word ptr [ebp-0xC];
	__asm        cmp    eax, 0xA;
	__asm        jge    _T80;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD6];
	__asm        lea    eax, [eax+eax*4];
	__asm        movsx  ecx, word ptr [ebp-0xC];
	__asm        shl    ecx, 2;
	__asm        mov    edx, loctype;
	__asm        cmp    cYObject::sNeutralPersonLocs[0][0][ecx+eax*8], edx;
	__asm        jne    _T7b;

	__asm        jmp    _T97;
_T7b:
	__asm        jmp    _FOR_NEXT_41;
_T80:
	__asm        jmp    _Ta3;

	__asm        jmp    _T97;

	__asm        test   dword ptr [ebp-0x10], 0xFFFF;
	__asm        je     _Ta3;
// LINE 1292:
_T97:
	result = 0x1;
// LINE 1293:
	__asm        jmp    _Taa;
// LINE 1294:
_Ta3:
	result = 0x0;
// LINE 1296:
_Taa:
	return result;
// LINE 1297:
}

// FUNCTION: COPTER_D 0x00558abb
enum TreeSim::ReturnCode cYObject::iCanJumpOffHere(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1301:
	result = 0xffffffff;
// LINE 1302:
	__asm        mov    ecx, this;
	__asm        call   cYObject::CanJumpOffHere;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T32;
// LINE 1303:
	result = 0x1;
// LINE 1304:
	__asm        jmp    _T39;
// LINE 1305:
_T32:
	result = 0x0;
// LINE 1307:
_T39:
	return result;
// LINE 1308:
}

// FUNCTION: COPTER_D 0x00558b03
enum TreeSim::ReturnCode cYObject::iCheckForSpotlightInMyCell(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x10*/  /*unpacked*/ struct Point2d loc; // 0x8 bytes
	/*bp-0x14*/  /*unpacked*/ struct YObjLang::CheckForSpotParam param;

// LINE 1312:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1313:
	reinterpret_cast<uint32_t>(param.brightnessTemp) = nparam-><YObjLang::Param+0x00:4>;
// LINE 1315:
	S3HeliGetSpotLoc(loc.x);
// LINE 1316:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, loc.x;
	__asm        jne    _T183;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, loc.y;
	__asm        jne    _T183;
// LINE 1317:
	__asm        movsx  eax, param.brightnessTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T72;

	__asm        movsx  eax, param.brightnessTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T8e;
_T72:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T8e:
	__asm        jmp    _T93;
_T93:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.brightnessTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _Tbc;
_Tbc:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x140];
	__asm        mov    ecx, [ebp-0x18];
	__asm        mov    [ecx], ax;
// LINE 1318:
	__asm        movsx  eax, param.dirToHeliTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _Te7;

	__asm        movsx  eax, param.dirToHeliTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T103;
_Te7:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T103:
	__asm        jmp    _T108;
_T108:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.dirToHeliTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T131;
_T131:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T144;
_T144:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        movsx  eax, ax;
	__asm        sub    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, [ebp-0x1C];
	__asm        mov    [ecx], ax;
// LINE 1319:
	result = 0x1;
// LINE 1321:
	__asm        jmp    _T18a;
// LINE 1322:
_T183:
	result = 0x0;
// LINE 1324:
_T18a:
	return result;
// LINE 1325:
}

// FUNCTION: COPTER_D 0x00558c9c
enum TreeSim::ReturnCode cYObject::iIncrementRiotVal(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   /*unpacked*/ struct YObjLang::IncrementRiotValParam param;

// LINE 1329:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1330:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    param.riotValLiteral, ax;
// LINE 1331:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xE0];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE4], ax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xE0];
	__asm        movsx  ecx, param.riotValLiteral;
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE0], ax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xE0];
	__asm        cmp    eax, 0xA;
	__asm        jle    _T78;

	this->fData[8] = 0xa;
	__asm        jmp    _T96;
_T78:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xE0];
	__asm        test   eax, eax;
	__asm        jge    _T96;

	this->fData[8] = 0x0;
_T96:
	__asm        jmp    _T9b;
// LINE 1332:
_T9b:
	result = 0x1;
// LINE 1334:
	return result;
// LINE 1335:
}

// FUNCTION: COPTER_D 0x00558d4d
enum TreeSim::ReturnCode cYObject::iGetSurroundingRiotVal(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   short actualriotval;
	/*bp-0xc*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x14*/  /*unpacked*/ struct YObjLang::GetSurroundingRiotValParam param; // 0x8 bytes
	/*bp-0x18*/  short dirtoconc;
	/*bp-0x1c*/  short todist;
	/*bp-0x20*/  short numcounted;

// LINE 1339:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1340:
	__asm        mov    eax, nparam;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    reinterpret_cast<uint32_t>(param.distTemp), ecx;
	__asm        mov    reinterpret_cast<uint32_t>(param.riotValTemp), eax;
// LINE 1341:
	__asm        movsx  eax, param.distTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T53;

	doAssert(0x8c085, 0x5bd088, 0x53d, 0x5bd09c);
// LINE 1342:
_T53:
	__asm        movsx  eax, param.distTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T6d;

	__asm        movsx  eax, param.distTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T89;
_T6d:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T89:
	__asm        jmp    _T8e;
_T8e:
	__asm        jmp    _T93;
_T93:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.distTemp;
	__asm        mov    ax, [eax+ecx*2+8];
	__asm        mov    todist, ax;
// LINE 1344:
	__asm        lea    eax, dirtoconc;
	__asm        push   eax;
	__asm        lea    eax, numcounted;
	__asm        push   eax;
	__asm        lea    eax, actualriotval;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(todist);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::GetSurroundingRiotInfo;
// LINE 1345:
	__asm        movsx  eax, param.dirToConcTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _Te9;

	__asm        movsx  eax, param.dirToConcTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T105;
_Te9:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T105:
	__asm        jmp    _T10a;
_T10a:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.dirToConcTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T133;
_T133:
	__asm        mov    ax, dirtoconc;
	__asm        mov    ecx, [ebp-0x24];
	__asm        mov    [ecx], ax;
// LINE 1346:
	__asm        movsx  eax, param.riotValTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T157;

	__asm        movsx  eax, param.riotValTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T173;
_T157:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T173:
	__asm        jmp    _T178;
_T178:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.riotValTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _T1a1;
_T1a1:
	__asm        mov    ax, actualriotval;
	__asm        mov    ecx, [ebp-0x28];
	__asm        mov    [ecx], ax;
// LINE 1347:
	__asm        movsx  eax, param.numPeopleCountedTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T1c5;

	__asm        movsx  eax, param.numPeopleCountedTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T1e1;
_T1c5:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T1e1:
	__asm        jmp    _T1e6;
_T1e6:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.numPeopleCountedTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T20f;
_T20f:
	__asm        mov    ax, numcounted;
	__asm        mov    ecx, [ebp-0x2C];
	__asm        mov    [ecx], ax;
// LINE 1348:
	result = 0x1;
// LINE 1350:
	return result;
// LINE 1351:
}

// FUNCTION: COPTER_D 0x00558f7c
enum TreeSim::ReturnCode cYObject::iIsThisScurkID(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   /*unpacked*/ struct YObjLang::IsThisScurkIDParam param;
	/*bp-0x10*/  short scurkID;

// LINE 1355:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1356:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    param.scurkIDLiteral, ax;
// LINE 1357:
	__asm        mov    ax, param.scurkIDLiteral;
	__asm        mov    scurkID, ax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        mov    [ebp-0x18], ax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        mov    [ebp-0x1C], ax;
// LINE 1358:
	__asm        movsx  eax, word ptr [ebp-0x1C];
	__asm        cmp    eax, 0x7F;
	__asm        jg     _T7e;

	__asm        movsx  eax, word ptr [ebp-0x18];
	__asm        cmp    eax, 0x7F;
	__asm        jg     _T7e;

	__asm        movsx  eax, word ptr [ebp-0x1C];
	__asm        test   eax, eax;
	__asm        jl     _T7e;

	__asm        movsx  eax, word ptr [ebp-0x18];
	__asm        test   eax, eax;
	__asm        jge    _T90;
_T7e:
	__asm        movsx  eax, scurkID;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T110;

	__asm        jmp    _T104;
_T90:
	__asm        movsx  eax, word ptr [ebp-0x1C];
	__asm        mov    eax, BuildMap[eax*4];
	__asm        movsx  ecx, word ptr [ebp-0x18];
	__asm        movzx  ax, byte ptr [eax+ecx];
	__asm        mov    [ebp-0x14], ax;
	__asm        movsx  eax, word ptr [ebp-0x14];
	__asm        test   eax, eax;
	__asm        jl     _Tc3;

	__asm        movsx  eax, word ptr [ebp-0x14];
	__asm        cmp    eax, 0x100;
	__asm        jl     _Tdf;
_Tc3:
	doAssert(0x8c085, 0x5bba34, 0x18a, 0x5bba14);
_Tdf:
	__asm        movsx  eax, word ptr [ebp-0x14];
	__asm        movsx  ecx, scurkID;
	__asm        cmp    eax, ecx;
	__asm        jne    _T110;

	__asm        jmp    _T104;

	__asm        movsx  eax, word ptr [ebp-0x20];
	__asm        movsx  ecx, scurkID;
	__asm        cmp    eax, ecx;
	__asm        jne    _T110;
// LINE 1359:
_T104:
	result = 0x1;
// LINE 1360:
	__asm        jmp    _T117;
// LINE 1361:
_T110:
	result = 0x0;
// LINE 1363:
_T117:
	return result;
// LINE 1364:
}

// FUNCTION: COPTER_D 0x005590a2
enum TreeSim::ReturnCode cYObject::iGosubToInitbhav(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   short id;

// LINE 1368:
	result = 0xffffffff;
// LINE 1370:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x10A];
	__asm        mov    id, ax;
// LINE 1371:
	__asm        jmp    _T26;
_T26:
	__asm        jmp    _T2b;
_T2b:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+4];
	__asm        movsx  eax, word ptr [eax+ecx];
	__asm        movsx  ecx, id;
	__asm        cmp    eax, ecx;
	__asm        je     _Tb4;

	__asm        jmp    _T57;
_T57:
	__asm        jmp    _T5c;
_T5c:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        movsx  ecx, word ptr [ecx+8];
	__asm        cmp    eax, ecx;
	__asm        jg     _T8f;

	doAssert(0x8c085, 0x5bbd3c, 0xce, 0x5bba14);
_T8f:
	__asm        mov    eax, reinterpret_cast<uint32_t>(id);
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::Gosub;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _Te2;

	__asm        jmp    _Tc6;

	__asm        jmp    _Tb9;
_Tb4:
	__asm        jmp    _Tc6;
_Tb9:
	__asm        test   dword ptr [ebp-0xC], 0xFFFF;
	__asm        jne    _Te2;
// LINE 1372:
_Tc6:
	doAssert(0x8c085, 0x5bd0c0, 0x55c, 0x5bd0d0);
// LINE 1374:
_Te2:
	result = 0x1;
// LINE 1376:
	return result;
// LINE 1377:
}

// FUNCTION: COPTER_D 0x0055919a
enum TreeSim::ReturnCode cYObject::iAdjustRadiusForRiotVal(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1381:
	result = 0xffffffff;
// LINE 1382:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xE0];
	__asm        cmp    eax, 5;
	__asm        jle    _T43;

	__asm        push   0x20000;
	__asm        push   0x50000;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x34], eax;
	__asm        jmp    _T4d;
_T43:
	this->fDyn.radius = 0x50000;
_T4d:
	__asm        jmp    _T52;
// LINE 1383:
_T52:
	result = 0x1;
// LINE 1385:
	return result;
// LINE 1386:
}

// FUNCTION: COPTER_D 0x00559202
enum TreeSim::ReturnCode cYObject::iJoinRiot(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x18*/  /*unpacked*/ struct tagLogString lstr; // 0x14 bytes

// LINE 1390:
	result = 0xffffffff;
	lstr.nType = 0x1;
	lstr.nMissionID = this->fMissionID;
// LINE 1391:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD2];
	__asm        test   eax, eax;
	__asm        jne    _T5d;

	doAssert(0x8c085, 0x5bbc88, 0x2e4, 0x5bba14);
_T5d:
	__asm        jmp    _T62;
_T62:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+0x20];
	__asm        test   ecx, ecx;
	__asm        jne    _T92;

	doAssert(0x8c085, 0x5bbc5c, 0x2e5, 0x5bba14);
_T92:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _Te1;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _Tdc;

	doAssert(0x8c085, 0x5bbad4, 0x22e, 0x5bba14);
_Tdc:
	__asm        jmp    _T114;
_Te1:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _T114;

	doAssert(0x8c085, 0x5bbabc, 0x231, 0x5bba14);
_T114:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _T135;

	__asm        jmp    _T166;

	__asm        jmp    _T135;
_T135:
	__asm        jmp    _T14a;

	__asm        test   dword ptr [ebp-0x88], 0xFFFF;
	__asm        jne    _T166;
_T14a:
	doAssert(0x8c085, 0x5bbc3c, 0x2e6, 0x5bba14);
_T166:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T228;

	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x104], 0xFFFF;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T1fd;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T1d5;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        add    eax, 0x62;
	__asm        mov    [ebp-0x80], ax;
	__asm        jmp    _T1eb;

	__asm        jmp    _T1e0;
_T1d5:
	__asm        mov    word ptr [ebp-0x80], 0xFFFF;
	__asm        jmp    _T1eb;
_T1e0:
	__asm        mov    ax, [ebp-0x84];
	__asm        mov    [ebp-0x80], ax;
_T1eb:
	__asm        jmp    _T1f0;
_T1f0:
	__asm        movsx  eax, word ptr [ebp-0x80];
	__asm        push   eax;
	__asm        call   S3DSStopPlay;
	__asm        add    esp, 4;
_T1fd:
	__asm        jmp    _T202;
_T202:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        mov    cYObject::sSoundChannels[eax*2], 0;
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x102], 0xFFFF;
_T228:
	__asm        jmp    _T22d;
_T22d:
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0xD2], 0;
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0xF0], 0xFFFF;
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x9C], 0xFFFF;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        mov    [ebp-0x7C], eax;
	__asm        cmp    dword ptr [ebp-0x7C], 0;
	__asm        jne    _T287;

	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        dec    eax;
	__asm        mov    cYObject::sNumAmbientAwake, ax;
	__asm        jmp    _T295;
_T287:
	__asm        movsx  eax, cYObject::sNumMissionAwake;
	__asm        dec    eax;
	__asm        mov    cYObject::sNumMissionAwake, ax;
_T295:
	__asm        jmp    _T29a;
_T29a:
	__asm        movsx  eax, cYObject::sNumMissionAwake;
	__asm        test   eax, eax;
	__asm        jl     _T2b8;

	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        test   eax, eax;
	__asm        jge    _T2d4;
_T2b8:
	doAssert(0x8c085, 0x5bbc24, 0x2ec, 0x5bba14);
_T2d4:
	this->cYObject::Unlink();
	__asm        jmp    _T2e4;
// LINE 1392:
_T2e4:
	__asm        mov    ecx, this;
	__asm        call   cYObject::JoinRiot;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T319;
// LINE 1393:
	lstr.szLogString = 0x5bd0f4;
	S3AddLogEntry(0x1, lstr.nType);
// LINE 1395:
	result = 0x3;
// LINE 1397:
	__asm        jmp    _T320;
// LINE 1398:
_T319:
	result = 0x0;
// LINE 1399:
_T320:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD2];
	__asm        test   eax, eax;
	__asm        je     _T351;

	doAssert(0x8c085, 0x5bba9c, 0x2d3, 0x5bba14);
_T351:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x10A];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xB4];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TreeSim::Reset;
	__asm        jmp    _T37c;
_T37c:
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0xD2], 1;
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0xE2], 1;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        mov    [ebp-0x1C], eax;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        jne    _T3c7;

	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        inc    eax;
	__asm        mov    cYObject::sNumAmbientAwake, ax;
	__asm        jmp    _T3d5;
_T3c7:
	__asm        movsx  eax, cYObject::sNumMissionAwake;
	__asm        inc    eax;
	__asm        mov    cYObject::sNumMissionAwake, ax;
_T3d5:
	__asm        jmp    _T3da;
_T3da:
	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        movsx  ecx, cYObject::sNumMissionAwake;
	__asm        add    eax, ecx;
	__asm        cmp    eax, 0x64;
	__asm        jle    _T40f;

	doAssert(0x8c085, 0x5bba7c, 0x2d9, 0x5bba14);
_T40f:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _T45e;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _T459;

	doAssert(0x8c085, 0x5bbad4, 0x22e, 0x5bba14);
_T459:
	__asm        jmp    _T491;
_T45e:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _T491;

	doAssert(0x8c085, 0x5bbabc, 0x231, 0x5bba14);
_T491:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _T4b2;

	__asm        jmp    _T4e0;

	__asm        jmp    _T4b2;
_T4b2:
	__asm        jmp    _T4c4;

	__asm        test   dword ptr [ebp-0x78], 0xFFFF;
	__asm        jne    _T4e0;
_T4c4:
	doAssert(0x8c085, 0x5bba54, 0x2da, 0x5bba14);
_T4e0:
	this->cYObject::Link();
	__asm        jmp    _T4f0;
_T4f0:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+0x20];
	__asm        test   ecx, ecx;
	__asm        jne    _T520;

	doAssert(0x8c085, 0x5bbaec, 0x1f8, 0x5bba14);
_T520:
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        lea    ecx, [ebp-0x74];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        push   0x40;
	__asm        mov    eax, this;
	__asm        add    eax, 0x48;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x5C];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        push   3;
	__asm        lea    eax, [ebp-0x74];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x2C];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
	__asm        jmp    _T571;
_T571:
	__asm        jmp    _T576;
// LINE 1401:
_T576:
	return result;
// LINE 1402:
}

// FUNCTION: COPTER_D 0x00559787
enum TreeSim::ReturnCode cYObject::iSetDirection(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   short count;
	/*bp-0xc*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x10*/  /*unpacked*/ struct YObjLang::SetDirectionParam param;

// LINE 1406:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1407:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    param.dirTemp, ax;
// LINE 1408:
	__asm        movsx  eax, param.dirTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T40;

	__asm        movsx  eax, param.dirTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T5c;
_T40:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T5c:
	__asm        jmp    _T61;
_T61:
	__asm        jmp    _T66;
_T66:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.dirTemp;
	__asm        mov    ax, [eax+ecx*2+8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1409:
	count = 0x0;
// LINE 1410:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD0];
	__asm        cmp    eax, 0xFFFFFFE2;
	__asm        jle    _Tbc;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD0];
	__asm        cmp    eax, 0x1E;
	__asm        jl     __WHILE_d8;
_Tbc:
	doAssert(0x8c085, 0x5bd100, 0x582, 0x5bd11c);
// LINE 1411:
__WHILE_d8:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD0];
	__asm        test   eax, eax;
	__asm        jge    _T106;
// LINE 1412:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD0];
	__asm        add    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
	__asm        jmp    __WHILE_d8;
// LINE 1413:
_T106:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD0];
	__asm        and    eax, 7;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1414:
	result = 0x1;
// LINE 1416:
	return result;
// LINE 1417:
}

// FUNCTION: COPTER_D 0x005598ba
enum TreeSim::ReturnCode cYObject::iThrowProjectile(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   long scale;
	/*bp-0x8*/   enum TreeSim::ReturnCode result;
	/*bp-0xc*/   int32_t speed;
	/*bp-0x4c*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x50*/  long what;
	/*bp-0x5c*/  /*unpacked*/ struct Point3d loc; // 0xc bytes
	/*bp-0x64*/  /*unpacked*/ struct Point2d celloc; // 0x8 bytes
	/*bp-0x70*/  /*unpacked*/ struct Point3d debrisunitvect; // 0xc bytes
	/*bp-0x7c*/  /*unpacked*/ struct Point3d personunitvect; // 0xc bytes

// LINE 1421:
	result = 0xffffffff;
// LINE 1422:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x90], 0;
	__asm        jne    _T42;

	doAssert(0x8c085, 0x5bbb9c, 0x2f8, 0x5bba14);
_T42:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        je     _T68;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        cmp    dword ptr [eax+0x1C], 0x5468726F;
	__asm        je     _Tb0;
_T68:
	__asm        push   0x5468726F;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x90];
	__asm        call   cCopterBody::GetPrivateAnim;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x98], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        jne    _Tb0;

	doAssert(0x8c085, 0x5bbb74, 0x2fb, 0x5bba14);
_Tb0:
	__asm        jmp    _Tb5;
// LINE 1423:
_Tb5:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        mov    celloc.x, ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        mov    celloc.y, ecx;
// LINE 1424:
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1425:
	scale = 0x1;
// LINE 1427:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD0];
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, cYObject::sMoveTable[0].x[eax*4];
	__asm        lea    ecx, personunitvect.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1429:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 1431:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xC8;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+0x2EE];
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 1432:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, debrisunitvect.x;
	__asm        push   eax;
	__asm        lea    eax, personunitvect.x;
	__asm        push   eax;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 1433:
	__asm        call   rand;
	__asm        mov    ecx, 0x32;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+0x32];
	__asm        shl    eax, 0x10;
	__asm        mov    speed, eax;
// LINE 1434:
	what = 0xa;
// LINE 1435:
	__asm        mov    eax, node;
	__asm        movsx  eax, word ptr [eax];
	__asm        cmp    eax, 0x3C;
	__asm        jne    _T194;
// LINE 1436:
	what = 0x4;
// LINE 1437:
_T194:
	S3MissileStart(this->fMissionID, speed, (this + 0x24), scale, debrisunitvect.x, loc.x, celloc.x, what);
// LINE 1438:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x90], 0;
	__asm        jne    _T1ee;

	doAssert(0x8c085, 0x5bbb9c, 0x2f8, 0x5bba14);
_T1ee:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        je     _T214;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        cmp    dword ptr [eax+0x1C], 0x4E6F4D6F;
	__asm        je     _T25c;
_T214:
	__asm        push   0x4E6F4D6F;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x90];
	__asm        call   cCopterBody::GetPrivateAnim;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x98], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        jne    _T25c;

	doAssert(0x8c085, 0x5bbb74, 0x2fb, 0x5bba14);
_T25c:
	__asm        jmp    _T261;
// LINE 1439:
_T261:
	result = 0x1;
// LINE 1441:
	return result;
// LINE 1442:
}

// FUNCTION: COPTER_D 0x00559b31
enum TreeSim::ReturnCode cYObject::iTurnFromStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1446:
	result = 0xffffffff;
// LINE 1447:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T3c;

	doAssert(0x8c085, 0x5bd140, 0x5a7, 0x5bd15c);
_T3c:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
// LINE 1448:
	__asm        jmp    _T4a;
_T4a:
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        movsx  eax, ax;
	__asm        add    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1449:
	result = 0x1;
// LINE 1451:
	return result;
// LINE 1452:
}

// FUNCTION: COPTER_D 0x00559bc8
enum TreeSim::ReturnCode cYObject::iTurnFromLastHitter(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1456:
	result = 0xffffffff;
// LINE 1457:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x140], 0;
	__asm        jne    _T3f;

	doAssert(0x8c085, 0x5bd180, 0x5b1, 0x5bd190);
_T3f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x140];
	__asm        mov    [ebp-8], eax;
// LINE 1458:
	__asm        jmp    _T50;
_T50:
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        movsx  eax, ax;
	__asm        add    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1459:
	result = 0x1;
// LINE 1461:
	return result;
// LINE 1462:
}

// FUNCTION: COPTER_D 0x00559c65
enum TreeSim::ReturnCode cYObject::iTurnTowardsLastHitter(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1466:
	result = 0xffffffff;
// LINE 1467:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x140], 0;
	__asm        jne    _T3f;

	doAssert(0x8c085, 0x5bd1b4, 0x5bb, 0x5bd1c4);
_T3f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x140];
	__asm        mov    [ebp-8], eax;
// LINE 1468:
	__asm        jmp    _T50;
_T50:
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        movsx  eax, ax;
	__asm        sub    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1469:
	result = 0x1;
// LINE 1471:
	return result;
// LINE 1472:
}

// FUNCTION: COPTER_D 0x00559d02
enum TreeSim::ReturnCode cYObject::iGetOutOfRoadEtc(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   enum cYObject::MoveErrorCode movecode;
	/*bp-0xc*/   enum cYObject::LocationType loctype;
	/*bp-0x10*/  /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x14*/  /*unpacked*/ struct YObjLang::GetOutOfRoadParam getoutofroad;

// LINE 1476:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1477:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    getoutofroad.decTemp, ax;
// LINE 1479:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xF6];
	__asm        test   eax, eax;
	__asm        je     _T54;

	doAssert(0x8c085, 0x5bd1e8, 0x5c7, 0x5bd220);
// LINE 1480:
_T54:
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        call   cYObject::GetLocType;
	__asm        add    esp, 8;
	__asm        mov    loctype, eax;
	__asm        jmp    _T7c;
// LINE 1486:
_T7c:
	__asm        cmp    loctype, 7;
	__asm        je     _Tc4;

	__asm        cmp    loctype, 8;
	__asm        je     _Tc4;

	__asm        cmp    loctype, 6;
	__asm        je     _Tc4;

	__asm        cmp    loctype, 9;
	__asm        je     _Tc4;

	__asm        cmp    loctype, 0xFFFFFFFF;
	__asm        je     _Tc4;

	__asm        cmp    loctype, 1;
	__asm        je     _Tc4;
// LINE 1487:
	result = 0x1;
// LINE 1489:
	__asm        jmp    _T20d;
_Tc4:
	__asm        movsx  eax, getoutofroad.decTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _Tde;

	__asm        movsx  eax, getoutofroad.decTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _Tfa;
_Tde:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_Tfa:
	__asm        jmp    _Tff;
_Tff:
	__asm        jmp    _T104;
_T104:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, getoutofroad.decTemp;
	__asm        movsx  eax, word ptr [eax+ecx*2+8];
	__asm        test   eax, eax;
	__asm        jne    _T13f;
// LINE 1490:
	movecode = 0x8;
// LINE 1491:
	result = 0x0;
// LINE 1493:
	__asm        jmp    _T20d;
// LINE 1495:
// Block start:
	/*bp-0x18*/  short speed;
	/*bp-0x28*/  /*unpacked*/ struct cYObject::MoveInfo moveinfo; // 0x10 bytes
_T13f:
	__asm        movsx  eax, getoutofroad.decTemp;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T159;

	__asm        movsx  eax, getoutofroad.decTemp;
	__asm        cmp    eax, 4;
	__asm        jl     _T175;
_T159:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T175:
	__asm        jmp    _T17a;
_T17a:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, getoutofroad.decTemp;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T1a3;
_T1a3:
	__asm        mov    eax, [ebp-0x2C];
	__asm        dec    word ptr [eax];
// LINE 1499:
	Memory::BlockFill(0x10, 0x0, moveinfo.locType);
// LINE 1500:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xF4];
	__asm        mov    speed, ax;
// LINE 1501:
	__asm        lea    eax, moveinfo.locType;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, reinterpret_cast<uint32_t>(speed);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::TryTableMove;
	__asm        mov    movecode, eax;
// LINE 1518:
	__asm        cmp    movecode, 0;
	__asm        jne    _T1f2;
// LINE 1519:
	result = 0x2;
// LINE 1520:
	__asm        jmp    _T1f9;
// LINE 1521:
_T1f2:
	result = 0x0;
// LINE 1522:
_T1f9:
	__asm        lea    eax, moveinfo.locType;
	__asm        push   eax;
	__asm        mov    eax, movecode;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(speed);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::DynEffects;
// LINE 1526:
// Block end:
_T20d:
	return result;
// LINE 1527:
}

// FUNCTION: COPTER_D 0x00559f1e
enum TreeSim::ReturnCode cYObject::iGenerateMedevacAndSetSelfAsVictim(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x18*/  /*unpacked*/ struct tagLogString lstr; // 0x14 bytes

// LINE 1531:
	result = 0xffffffff;
	lstr.nType = 0x1;
	lstr.nMissionID = this->fMissionID;
// LINE 1533:
	lstr.szLogString = 0x5bd244;
	S3AddLogEntry(0x1, lstr.nType);
// LINE 1536:
	this->cYObject::Die();
// LINE 1537:
	result = 0x3;
// LINE 1539:
	return result;
// LINE 1540:
}

// FUNCTION: COPTER_D 0x00559f74
enum TreeSim::ReturnCode cYObject::iTurnToNearbyFire(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   short firecelly;
	/*bp-0xc*/   short firecellx;
	/*bp-0x10*/  /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x14*/  /*unpacked*/ struct YObjLang::TurnToFireParam param;

// LINE 1544:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1545:
	reinterpret_cast<uint32_t>(param.xdistloc) = nparam-><YObjLang::Param+0x00:4>;
// LINE 1547:
	__asm        lea    eax, firecelly;
	__asm        push   eax;
	__asm        lea    eax, firecellx;
	__asm        push   eax;
	__asm        push   3;
	__asm        mov    ecx, this;
	__asm        call   cYObject::GetNearbyFire;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T1d1;

	__asm        mov    ax, firecelly;
	__asm        mov    [ebp-0x24], ax;
	__asm        mov    ax, firecellx;
	__asm        mov    [ebp-0x28], ax;
// LINE 1548:
	__asm        movsx  eax, word ptr [ebp-0x24];
	__asm        and    eax, 0xFF;
	__asm        movsx  ecx, word ptr [ebp-0x28];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T76;
_T76:
	__asm        mov    eax, [ebp-0x20];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        push   eax;
	__asm        call   S3PUtilsGetDir;
	__asm        add    esp, 0x10;
	__asm        movsx  eax, ax;
	__asm        sub    eax, 2;
	__asm        and    eax, 7;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD0], ax;
// LINE 1549:
	__asm        movsx  eax, param.xdistloc;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _Tcf;

	__asm        movsx  eax, param.xdistloc;
	__asm        cmp    eax, 4;
	__asm        jl     _Teb;
_Tcf:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_Teb:
	__asm        jmp    _Tf0;
_Tf0:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.xdistloc;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T119;
_T119:
	__asm        movsx  eax, firecellx;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x88];
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, [ebp-0x18];
	__asm        mov    [ecx], ax;
	__asm        jmp    _T13d;
// LINE 1550:
_T13d:
	__asm        movsx  eax, param.ydistloc;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T157;

	__asm        movsx  eax, param.ydistloc;
	__asm        cmp    eax, 4;
	__asm        jl     _T173;
_T157:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T173:
	__asm        jmp    _T178;
_T178:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, param.ydistloc;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T1a1;
_T1a1:
	__asm        movsx  eax, firecelly;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x89];
	__asm        sub    eax, edx;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, [ebp-0x1C];
	__asm        mov    [ecx], ax;
	__asm        jmp    _T1c5;
// LINE 1551:
_T1c5:
	result = 0x1;
// LINE 1553:
	__asm        jmp    _T1d8;
// LINE 1554:
_T1d1:
	result = 0x0;
// LINE 1556:
_T1d8:
	return result;
// LINE 1557:
}

// FUNCTION: COPTER_D 0x0055a15b
enum TreeSim::ReturnCode cYObject::iDie(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x18*/  /*unpacked*/ struct tagLogString lstr; // 0x14 bytes

// LINE 1561:
	result = 0xffffffff;
	lstr.nType = 0x1;
	lstr.nMissionID = this->fMissionID;
// LINE 1562:
	lstr.szLogString = 0x5bd250;
	S3AddLogEntry(0x1, lstr.nType);
// LINE 1564:
	this->cYObject::Die();
// LINE 1565:
	result = 0x3;
// LINE 1567:
	return result;
// LINE 1568:
}

// FUNCTION: COPTER_D 0x0055a1b1
enum TreeSim::ReturnCode cYObject::iWalkToStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
// LINE 1572:
	__asm        mov    eax, node;
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::iWalkToAndGrabOntoStackObject;
	__asm        jmp    __RETURN;
// LINE 1573:
__RETURN:
}

// FUNCTION: COPTER_D 0x0055a1d9
enum TreeSim::ReturnCode cYObject::iPutObjIntoTreeNum(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   short treenum;
	/*bp-0x10*/  /*unpacked*/ class cYObject *obj;

// LINE 1577:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1578:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   cYObject::GetObjectA;
	__asm        add    esp, 4;
	__asm        mov    obj, eax;
// LINE 1579:
	__asm        cmp    obj, 0;
	__asm        jne    _T54;

	doAssert(0x8c085, 0x5bd264, 0x62b, 0x5bd26c);
// LINE 1580:
_T54:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    treenum, ax;
// LINE 1582:
	__asm        jmp    _T63;
_T63:
	__asm        jmp    _T68;
_T68:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, obj;
	__asm        mov    ecx, [ecx+4];
	__asm        movsx  eax, word ptr [eax+ecx];
	__asm        movsx  ecx, treenum;
	__asm        cmp    eax, ecx;
	__asm        je     _Te6;

	__asm        jmp    _T94;
_T94:
	__asm        jmp    _T99;
_T99:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xA];
	__asm        dec    eax;
	__asm        mov    ecx, obj;
	__asm        movsx  ecx, word ptr [ecx+8];
	__asm        cmp    eax, ecx;
	__asm        jg     _Tcc;

	doAssert(0x8c085, 0x5bbd3c, 0xce, 0x5bba14);
_Tcc:
	__asm        mov    eax, reinterpret_cast<uint32_t>(treenum);
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    ecx, obj;
	__asm        call   TreeSim::Gosub;
	__asm        jmp    _Teb;

	__asm        jmp    _Teb;
_Te6:
	__asm        jmp    _Teb;
// LINE 1583:
_Teb:
	result = 0x1;
// LINE 1585:
	return result;
// LINE 1586:
}

// FUNCTION: COPTER_D 0x0055a2da
enum TreeSim::ReturnCode cYObject::iVisitOz(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1590:
	result = 0xffffffff;
// LINE 1591:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD2];
	__asm        test   eax, eax;
	__asm        jne    _T41;

	doAssert(0x8c085, 0x5bbc88, 0x2e4, 0x5bba14);
_T41:
	__asm        jmp    _T46;
_T46:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+0x20];
	__asm        test   ecx, ecx;
	__asm        jne    _T73;

	doAssert(0x8c085, 0x5bbc5c, 0x2e5, 0x5bba14);
_T73:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _Tbc;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _Tb7;

	doAssert(0x8c085, 0x5bbad4, 0x22e, 0x5bba14);
_Tb7:
	__asm        jmp    _Tec;
_Tbc:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _Tec;

	doAssert(0x8c085, 0x5bbabc, 0x231, 0x5bba14);
_Tec:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _T10a;

	__asm        jmp    _T138;

	__asm        jmp    _T10a;
_T10a:
	__asm        jmp    _T11c;

	__asm        test   dword ptr [ebp-0x14], 0xFFFF;
	__asm        jne    _T138;
_T11c:
	doAssert(0x8c085, 0x5bbc3c, 0x2e6, 0x5bba14);
_T138:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T1e2;

	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x104], 0xFFFF;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T1bd;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T198;

	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        add    eax, 0x62;
	__asm        mov    [ebp-0xC], ax;
	__asm        jmp    _T1ab;

	__asm        jmp    _T1a3;
_T198:
	__asm        mov    word ptr [ebp-0xC], 0xFFFF;
	__asm        jmp    _T1ab;
_T1a3:
	__asm        mov    ax, [ebp-0x10];
	__asm        mov    [ebp-0xC], ax;
_T1ab:
	__asm        jmp    _T1b0;
_T1b0:
	__asm        movsx  eax, word ptr [ebp-0xC];
	__asm        push   eax;
	__asm        call   S3DSStopPlay;
	__asm        add    esp, 4;
_T1bd:
	__asm        jmp    _T1c2;
_T1c2:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        mov    cYObject::sSoundChannels[eax*2], 0;
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x102], 0xFFFF;
_T1e2:
	__asm        jmp    _T1e7;
_T1e7:
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0xD2], 0;
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0xF0], 0xFFFF;
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x9C], 0xFFFF;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T235;

	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        dec    eax;
	__asm        mov    cYObject::sNumAmbientAwake, ax;
	__asm        jmp    _T243;
_T235:
	__asm        movsx  eax, cYObject::sNumMissionAwake;
	__asm        dec    eax;
	__asm        mov    cYObject::sNumMissionAwake, ax;
_T243:
	__asm        jmp    _T248;
_T248:
	__asm        movsx  eax, cYObject::sNumMissionAwake;
	__asm        test   eax, eax;
	__asm        jl     _T266;

	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        test   eax, eax;
	__asm        jge    _T282;
_T266:
	doAssert(0x8c085, 0x5bbc24, 0x2ec, 0x5bba14);
_T282:
	this->cYObject::Unlink();
	__asm        jmp    _T28f;
// LINE 1592:
_T28f:
	result = 0x2;
// LINE 1594:
	return result;
// LINE 1595:
}

// FUNCTION: COPTER_D 0x0055a57f
enum TreeSim::ReturnCode cYObject::iMakeMyMedevacVictimVisible(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1599:
	result = 0xffffffff;
// LINE 1600:
	obj = this->cYObject::GetToted();
// LINE 1601:
	__asm        cmp    obj, 0;
	__asm        jne    _T44;

	doAssert(0x8c085, 0x5bd290, 0x641, 0x5bd2a4);
// LINE 1602:
_T44:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        cmp    eax, 6;
	__asm        je     _T73;

	doAssert(0x8c085, 0x5bd2c8, 0x642, 0x5bd2e8);
// LINE 1603:
_T73:
	__asm        jmp    _T78;
_T78:
	__asm        mov    eax, obj;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x24;
	__asm        cmp    [eax+0x130], ecx;
	__asm        je     _Ta9;

	doAssert(0x8c085, 0x5bd30c, 0x643, 0x5bd338);
// LINE 1604:
_Ta9:
	obj->fData[9] = 0x1;
// LINE 1605:
	result = 0x1;
// LINE 1607:
	return result;
// LINE 1608:
}

// FUNCTION: COPTER_D 0x0055a64a
enum TreeSim::ReturnCode cYObject::iMakeMyMedevacVictimInvisible(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1612:
	result = 0xffffffff;
// LINE 1613:
	doAssert(0x8c085, 0x5bd35c, 0x64d, 0x5bd378);
// LINE 1615:
	result = 0x1;
// LINE 1617:
	return result;
// LINE 1618:
}

// FUNCTION: COPTER_D 0x0055a68f
enum TreeSim::ReturnCode cYObject::iMakeMeMasterOfStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1622:
	result = 0xffffffff;
// LINE 1623:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T3c;

	doAssert(0x8c085, 0x5bd39c, 0x657, 0x5bd3d0);
// LINE 1624:
_T3c:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   cYObject::GetObjectA;
	__asm        add    esp, 4;
	__asm        mov    obj, eax;
// LINE 1625:
	__asm        cmp    obj, 0;
	__asm        jne    _T74;

	doAssert(0x8c085, 0x5bd3f4, 0x659, 0x5bd3fc);
// LINE 1626:
_T74:
	__asm        mov    eax, this;
	__asm        add    eax, 0x3C;
	__asm        mov    ecx, obj;
	__asm        add    ecx, 0x3C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        mov    ecx, obj;
	__asm        call   cYObject::Unlink;
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, obj;
	__asm        sub    eax, [ecx+0x44];
	__asm        sar    eax, 0x16;
	__asm        mov    [ebp-0xC], al;
	__asm        mov    eax, obj;
	__asm        mov    eax, [eax+0x3C];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    [ebp-0x10], al;
	__asm        jmp    _Tbf;
_Tbf:
	__asm        mov    eax, obj;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+0x20];
	__asm        test   ecx, ecx;
	__asm        je     _Tec;

	doAssert(0x8c085, 0x5bbbb8, 0x210, 0x5bba14);
_Tec:
	__asm        mov    al, [ebp-0x10];
	__asm        mov    ecx, obj;
	__asm        mov    [ecx+0x88], al;
	__asm        mov    al, [ebp-0xC];
	__asm        mov    ecx, obj;
	__asm        mov    [ecx+0x89], al;
	__asm        jmp    _T109;
_T109:
	obj->cYObject::Link();
	__asm        jmp    _T116;
// LINE 1627:
_T116:
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    ecx, obj;
	__asm        call   cYObject::SetMaster;
// LINE 1628:
	result = 0x1;
// LINE 1630:
	return result;
// LINE 1631:
}

// FUNCTION: COPTER_D 0x0055a7ca
enum TreeSim::ReturnCode cYObject::iMakeMyStackObjectVisitOz(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1635:
	result = 0xffffffff;
// LINE 1636:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T3c;

	doAssert(0x8c085, 0x5bd420, 0x664, 0x5bd43c);
// LINE 1637:
_T3c:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   cYObject::GetObjectA;
	__asm        add    esp, 4;
	__asm        mov    obj, eax;
// LINE 1638:
	__asm        cmp    obj, 0;
	__asm        jne    _T74;

	doAssert(0x8c085, 0x5bd460, 0x666, 0x5bd468);
// LINE 1639:
_T74:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xD2];
	__asm        test   eax, eax;
	__asm        jne    _Ta2;

	doAssert(0x8c085, 0x5bbc88, 0x2e4, 0x5bba14);
_Ta2:
	__asm        jmp    _Ta7;
_Ta7:
	__asm        mov    eax, obj;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+0x20];
	__asm        test   ecx, ecx;
	__asm        jne    _Td4;

	doAssert(0x8c085, 0x5bbc5c, 0x2e5, 0x5bba14);
_Td4:
	__asm        mov    eax, obj;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _T11d;

	__asm        mov    eax, obj;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _T118;

	doAssert(0x8c085, 0x5bbad4, 0x22e, 0x5bba14);
_T118:
	__asm        jmp    _T14d;
_T11d:
	__asm        mov    eax, obj;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        jne    _T14d;

	doAssert(0x8c085, 0x5bbabc, 0x231, 0x5bba14);
_T14d:
	__asm        mov    eax, obj;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        cmp    ecx, 0xFFFFFFFF;
	__asm        je     _T16b;

	__asm        jmp    _T199;

	__asm        jmp    _T16b;
_T16b:
	__asm        jmp    _T17d;

	__asm        test   dword ptr [ebp-0x18], 0xFFFF;
	__asm        jne    _T199;
_T17d:
	doAssert(0x8c085, 0x5bbc3c, 0x2e6, 0x5bba14);
_T199:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T243;

	__asm        mov    eax, obj;
	__asm        mov    word ptr [eax+0x104], 0xFFFF;
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T21e;

	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T1f9;

	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        add    eax, 0x62;
	__asm        mov    [ebp-0x10], ax;
	__asm        jmp    _T20c;

	__asm        jmp    _T204;
_T1f9:
	__asm        mov    word ptr [ebp-0x10], 0xFFFF;
	__asm        jmp    _T20c;
_T204:
	__asm        mov    ax, [ebp-0x14];
	__asm        mov    [ebp-0x10], ax;
_T20c:
	__asm        jmp    _T211;
_T211:
	__asm        movsx  eax, word ptr [ebp-0x10];
	__asm        push   eax;
	__asm        call   S3DSStopPlay;
	__asm        add    esp, 4;
_T21e:
	__asm        jmp    _T223;
_T223:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0x102];
	__asm        mov    cYObject::sSoundChannels[eax*2], 0;
	__asm        mov    eax, obj;
	__asm        mov    word ptr [eax+0x102], 0xFFFF;
_T243:
	__asm        jmp    _T248;
_T248:
	__asm        mov    eax, obj;
	__asm        mov    word ptr [eax+0xD2], 0;
	__asm        mov    eax, obj;
	__asm        mov    word ptr [eax+0xF0], 0xFFFF;
	__asm        mov    eax, obj;
	__asm        mov    word ptr [eax+0x9C], 0xFFFF;
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T296;

	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        dec    eax;
	__asm        mov    cYObject::sNumAmbientAwake, ax;
	__asm        jmp    _T2a4;
_T296:
	__asm        movsx  eax, cYObject::sNumMissionAwake;
	__asm        dec    eax;
	__asm        mov    cYObject::sNumMissionAwake, ax;
_T2a4:
	__asm        jmp    _T2a9;
_T2a9:
	__asm        movsx  eax, cYObject::sNumMissionAwake;
	__asm        test   eax, eax;
	__asm        jl     _T2c7;

	__asm        movsx  eax, cYObject::sNumAmbientAwake;
	__asm        test   eax, eax;
	__asm        jge    _T2e3;
_T2c7:
	doAssert(0x8c085, 0x5bbc24, 0x2ec, 0x5bba14);
_T2e3:
	obj->cYObject::Unlink();
	__asm        jmp    _T2f0;
// LINE 1640:
_T2f0:
	result = 0x1;
// LINE 1642:
	return result;
// LINE 1643:
}

// FUNCTION: COPTER_D 0x0055aad0
enum TreeSim::ReturnCode cYObject::iPutTotedMedVicOnStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1647:
	__asm        mov    result, 0xFFFFFFFF;
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1C], eax;
// LINE 1648:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        jne    _T42;

	doAssert(0x8c085, 0x5bbe90, 0x3ff, 0x5bba14);
_T42:
	__asm        mov    ecx, this;
	__asm        call   cYObject::GetToted;
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T1df;

	__asm        mov    eax, [ebp-0xC];
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        cmp    eax, 6;
	__asm        je     _T86;

	doAssert(0x8c085, 0x5bbe70, 0x402, 0x5bba14);
_T86:
	__asm        jmp    _T8b;
_T8b:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x24;
	__asm        cmp    [eax+0x130], ecx;
	__asm        je     _Tbc;

	doAssert(0x8c085, 0x5bbe44, 0x403, 0x5bba14);
_Tbc:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        jne    _Te2;

	doAssert(0x8c085, 0x5bbebc, 0x3e6, 0x5bba14);
_Te2:
	__asm        jmp    _Te7;
_Te7:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax+0x3C];
	__asm        mov    ecx, [ebp-0x1C];
	__asm        sub    eax, [ecx+0x18];
	__asm        mov    ecx, [ebp-0xC];
	__asm        add    eax, [ecx+0x44];
	__asm        mov    ecx, [ebp-0x1C];
	__asm        sub    eax, [ecx+0x20];
	__asm        mov    ecx, [ebp-0xC];
	__asm        add    eax, [ecx+0x40];
	__asm        mov    ecx, [ebp-0x1C];
	__asm        sub    eax, [ecx+0x1C];
	__asm        sar    eax, 0x10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-0x14], ax;
	__asm        jmp    _T11f;
_T11f:
	__asm        mov    eax, [ebp-0x14];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1E;
	__asm        jle    _T135;

	__asm        jmp    _T14c;
_T135:
	__asm        jmp    _T168;

	__asm        jmp    _T14c;

	__asm        test   dword ptr [ebp-0x18], 0xFFFF;
	__asm        jne    _T168;
_T14c:
	doAssert(0x8c085, 0x5bbe24, 0x405, 0x5bba14);
_T168:
	__asm        mov    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   cYObject::SetMaster;
	__asm        mov    [ebp-0x10], ax;
	__asm        test   dword ptr [ebp-0x10], 0xFFFF;
	__asm        jne    _T1a1;

	doAssert(0x8c085, 0x5bbde4, 0x407, 0x5bba14);
_T1a1:
	__asm        mov    eax, [ebp-0xC];
	__asm        movsx  eax, word ptr [eax+0xE2];
	__asm        test   eax, eax;
	__asm        je     _T1cf;

	doAssert(0x8c085, 0x5bbdc8, 0x408, 0x5bba14);
_T1cf:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    obj, eax;
	__asm        jmp    _T1f1;

	__asm        jmp    _T1eb;
_T1df:
	obj = 0x0;
	__asm        jmp    _T1f1;
_T1eb:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    obj, eax;
// LINE 1649:
_T1f1:
	__asm        cmp    obj, 0;
	__asm        je     _T213;
// LINE 1650:
	__asm        mov    eax, obj;
	__asm        add    eax, 0x24;
	__asm        mov    ecx, elem;
	__asm        mov    [ecx+4], eax;
// LINE 1651:
	result = 0x1;
// LINE 1653:
	__asm        jmp    _T21a;
// LINE 1654:
_T213:
	result = 0x0;
// LINE 1656:
_T21a:
	return result;
// LINE 1657:
}

// FUNCTION: COPTER_D 0x0055acf9
enum TreeSim::ReturnCode cYObject::iTakeAnyMedVicOffStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1661:
	result = 0xffffffff;
// LINE 1662:
	__asm        jmp    _T18;
_T18:
	obj = cYObject::GetFirst(0x0, 0x6);
// LINE 1663:
	__asm        cmp    obj, 0;
	__asm        je     _Te1;
// LINE 1664:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xE2];
	__asm        test   eax, eax;
	__asm        je     _T5f;

	doAssert(0x8c085, 0x5bd48c, 0x680, 0x5bd494);
// LINE 1665:
_T5f:
	__asm        jmp    _T64;
_T64:
	__asm        mov    eax, obj;
	__asm        cmp    dword ptr [eax+0x130], 0;
	__asm        jne    _T90;

	doAssert(0x8c085, 0x5bd4b8, 0x681, 0x5bd4c0);
// LINE 1666:
_T90:
	__asm        push   0;
	__asm        mov    ecx, obj;
	__asm        call   cYObject::SetMaster;
// LINE 1667:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xE2];
	__asm        cmp    eax, 1;
	__asm        je     _Tc9;

	doAssert(0x8c085, 0x5bd4e4, 0x683, 0x5bd4ec);
// LINE 1668:
_Tc9:
	__asm        mov    eax, obj;
	__asm        add    eax, 0x24;
	__asm        mov    ecx, elem;
	__asm        mov    [ecx+4], eax;
// LINE 1669:
	result = 0x1;
// LINE 1671:
	__asm        jmp    _Te8;
// LINE 1672:
_Te1:
	result = 0x0;
// LINE 1674:
_Te8:
	return result;
// LINE 1675:
}

// FUNCTION: COPTER_D 0x0055adf0
enum TreeSim::ReturnCode cYObject::iGetOnStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1679:
	result = 0xffffffff;
// LINE 1680:
	doAssert(0x8c085, 0x5bd510, 0x690, 0x5bd524);
// LINE 1681:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T58;

	doAssert(0x8c085, 0x5bd548, 0x691, 0x5bd578);
_T58:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xC], eax;
// LINE 1682:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T87;

	doAssert(0x8c085, 0x5bbebc, 0x3e6, 0x5bba14);
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        mov    ecx, [ebp-0xC];
	__asm        sub    eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x44];
	__asm        mov    ecx, [ebp-0xC];
	__asm        sub    eax, [ecx+0x20];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x40];
	__asm        mov    ecx, [ebp-0xC];
	__asm        sub    eax, [ecx+0x1C];
	__asm        sar    eax, 0x10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-8], ax;
	__asm        jmp    _Tc4;
_Tc4:
	__asm        mov    eax, [ebp-8];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1E;
	__asm        jle    _Tda;

	__asm        jmp    _Tf1;
_Tda:
	__asm        jmp    _T10d;

	__asm        jmp    _Tf1;

	__asm        test   dword ptr [ebp-0x10], 0xFFFF;
	__asm        jne    _T10d;
_Tf1:
	doAssert(0x8c085, 0x5bd59c, 0x692, 0x5bd5c0);
// LINE 1683:
_T10d:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::SetMaster;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T133;
// LINE 1684:
	result = 0x1;
// LINE 1685:
	__asm        jmp    _T13a;
// LINE 1686:
_T133:
	result = 0x0;
// LINE 1688:
_T13a:
	return result;
// LINE 1689:
}

// FUNCTION: COPTER_D 0x0055af39
enum TreeSim::ReturnCode cYObject::iUpdateStackVictimToted(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1693:
	result = 0xffffffff;
// LINE 1694:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T3c;

	doAssert(0x8c085, 0x5bd5e4, 0x69e, 0x5bd5f4);
// LINE 1695:
_T3c:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   cYObject::GetObjectA;
	__asm        add    esp, 4;
	__asm        mov    obj, eax;
// LINE 1696:
	__asm        cmp    obj, 0;
	__asm        jne    _T74;

	doAssert(0x8c085, 0x5bd618, 0x6a0, 0x5bd65c);
// LINE 1697:
_T74:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        cmp    eax, 6;
	__asm        je     _Ta3;

	doAssert(0x8c085, 0x5bd680, 0x6a1, 0x5bd6a4);
// LINE 1698:
_Ta3:
	__asm        mov    eax, obj;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        push   7;
	__asm        mov    ecx, this;
	__asm        call   cYObject::UpdateMission;
// LINE 1699:
	result = 0x1;
// LINE 1701:
	return result;
// LINE 1702:
}

// FUNCTION: COPTER_D 0x0055b003
enum TreeSim::ReturnCode cYObject::iGetNumSpacesOnStackObject(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   short localnum;

// LINE 1706:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1707:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T45;

	doAssert(0x8c085, 0x5bd6c8, 0x6ab, 0x5bd6fc);
// LINE 1709:
_T45:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    localnum, ax;
// LINE 1710:
	__asm        mov    eax, elem;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        cmp    [eax+4], ecx;
	__asm        jne    _Te9;
// LINE 1711:
	__asm        movsx  eax, localnum;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T81;

	__asm        movsx  eax, localnum;
	__asm        cmp    eax, 4;
	__asm        jl     _T9d;
_T81:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T9d:
	__asm        jmp    _Ta2;
_Ta2:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, localnum;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _Tcb;
_Tcb:
	__asm        mov    eax, G_uheli;
	__asm        add    eax, 0x1C4;
	__asm        push   eax;
	__asm        call   HeliPassengerCountFreeSeats;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x10];
	__asm        mov    [ecx], ax;
// LINE 1712:
	__asm        jmp    _T188;
_Te9:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x10;
	__asm        je     _T16c;
// LINE 1713:
	__asm        movsx  eax, localnum;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T115;

	__asm        movsx  eax, localnum;
	__asm        cmp    eax, 4;
	__asm        jl     _T131;
_T115:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_T131:
	__asm        jmp    _T136;
_T136:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, localnum;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T15f;
_T15f:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    word ptr [eax], 0x1721;
// LINE 1714:
	__asm        jmp    _T188;
// LINE 1715:
_T16c:
	doAssert(0x8c085, 0x5bd720, 0x6b3, 0x5bd740);
// LINE 1716:
_T188:
	result = 0x1;
// LINE 1718:
	return result;
// LINE 1719:
}

// FUNCTION: COPTER_D 0x0055b1a1
enum TreeSim::ReturnCode cYObject::iDropToted(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1723:
	result = 0xffffffff;
// LINE 1724:
	obj = this->cYObject::DropToted();
// LINE 1725:
	__asm        cmp    obj, 0;
	__asm        je     _T40;
// LINE 1726:
	__asm        mov    eax, obj;
	__asm        add    eax, 0x24;
	__asm        mov    ecx, elem;
	__asm        mov    [ecx+4], eax;
// LINE 1727:
	result = 0x1;
// LINE 1729:
	__asm        jmp    _T47;
// LINE 1730:
_T40:
	result = 0x0;
// LINE 1732:
_T47:
	return result;
// LINE 1733:
}

// FUNCTION: COPTER_D 0x0055b1f7
enum TreeSim::ReturnCode cYObject::iUpdateStackVictimPickedUp(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ class cYObject *obj;

// LINE 1737:
	result = 0xffffffff;
// LINE 1738:
	__asm        mov    eax, elem;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T3c;

	doAssert(0x8c085, 0x5bd764, 0x6ca, 0x5bd774);
// LINE 1739:
_T3c:
	__asm        mov    eax, elem;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   cYObject::GetObjectA;
	__asm        add    esp, 4;
	__asm        mov    obj, eax;
// LINE 1740:
	__asm        cmp    obj, 0;
	__asm        jne    _T74;

	doAssert(0x8c085, 0x5bd798, 0x6cc, 0x5bd7dc);
// LINE 1741:
_T74:
	__asm        mov    eax, obj;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        cmp    eax, 6;
	__asm        je     _Ta3;

	doAssert(0x8c085, 0x5bd800, 0x6cd, 0x5bd824);
// LINE 1742:
_Ta3:
	__asm        mov    eax, obj;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        push   8;
	__asm        mov    ecx, this;
	__asm        call   cYObject::UpdateMission;
// LINE 1743:
	result = 0x1;
// LINE 1745:
	return result;
// LINE 1746:
}

// FUNCTION: COPTER_D 0x0055b2c1
enum TreeSim::ReturnCode cYObject::iCloseToHeli(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1750:
	__asm        mov    result, 0xFFFFFFFF;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    [ebp-0xC], eax;
// LINE 1751:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T47;

	doAssert(0x8c085, 0x5bbebc, 0x3e6, 0x5bba14);
_T47:
	__asm        jmp    _T4c;
_T4c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3C];
	__asm        mov    ecx, [ebp-0xC];
	__asm        sub    eax, [ecx+0x18];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x44];
	__asm        mov    ecx, [ebp-0xC];
	__asm        sub    eax, [ecx+0x20];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x40];
	__asm        mov    ecx, [ebp-0xC];
	__asm        sub    eax, [ecx+0x1C];
	__asm        sar    eax, 0x10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-8], ax;
	__asm        jmp    _T84;
_T84:
	__asm        mov    eax, [ebp-8];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1E;
	__asm        jle    _T9a;

	__asm        jmp    _Tb1;
_T9a:
	__asm        jmp    _Tbd;

	__asm        jmp    _Tb1;

	__asm        test   dword ptr [ebp-0x10], 0xFFFF;
	__asm        jne    _Tbd;
// LINE 1752:
_Tb1:
	result = 0x0;
// LINE 1753:
	__asm        jmp    _Td5;
// LINE 1754:
_Tbd:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, elem;
	__asm        mov    [ecx+4], eax;
// LINE 1755:
	result = 0x1;
// LINE 1758:
_Td5:
	return result;
// LINE 1759:
}

// FUNCTION: COPTER_D 0x0055b3a5
enum TreeSim::ReturnCode cYObject::iSetMyExpression(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   short expressionnum;

// LINE 1763:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1765:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    expressionnum, ax;
// LINE 1767:
	__asm        movsx  eax, expressionnum;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xBC];
	__asm        push   eax;
	__asm        mov    eax, G_uheli;
	__asm        add    eax, 0x1C4;
	__asm        push   eax;
	__asm        call   HeliPassengerSetExpression;
	__asm        add    esp, 0xC;
// LINE 1768:
	HeliPassengerSetChanged((G_uheli + 0x1c4));
// LINE 1769:
	result = 0x1;
// LINE 1771:
	return result;
// LINE 1772:
}

// FUNCTION: COPTER_D 0x0055b417
enum TreeSim::ReturnCode cYObject::iGetHeliSpeedPlusDamage(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   float speed;
	/*bp-0xc*/   float maxdamage;
	/*bp-0x10*/  float res;
	/*bp-0x14*/  /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0x18*/  float damage;

// LINE 1776:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1778:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x128];
	__asm        sar    eax, 0x10;
	__asm        mov    [ebp-0x28], eax;
	__asm        fild   dword ptr [ebp-0x28];
	__asm        fstp   speed;
// LINE 1779:
	__asm        mov    eax, G_uheli;
	__asm        push   eax;
	__asm        call   S3HeliGetCurrentDamage;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x2C], eax;
	__asm        fild   dword ptr [ebp-0x2C];
	__asm        fstp   damage;
// LINE 1780:
	__asm        mov    eax, G_uheli;
	__asm        push   eax;
	__asm        call   S3HeliGetMaximumDamage;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x30], eax;
	__asm        fild   dword ptr [ebp-0x30];
	__asm        fstp   maxdamage;
// LINE 1781:
	__asm        fld    damage;
	__asm        fcomp  dword ptr ds:[0x593610];
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T7c;

	damage = 0x3f800000;
// LINE 1782:
_T7c:
	__asm        fld    maxdamage;
	__asm        fmul   speed;
	__asm        fdiv   damage;
// LINE 1783:
	__asm        fcom   dword ptr ds:[0x593618];
	__asm        fstp   res;
	__asm        fnstsw ax;
	__asm        test   ah, 0x41;
	__asm        jne    _Ta0;
// LINE 1784:
	res = 0x477fff00;
// LINE 1785:
_Ta0:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    [ebp-0x20], ax;
	__asm        movsx  eax, word ptr [ebp-0x20];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _Tc4;

	__asm        movsx  eax, word ptr [ebp-0x20];
	__asm        cmp    eax, 4;
	__asm        jl     _Te0;
_Tc4:
	doAssert(0x8c085, 0x5bddbc, 0x106, 0x5bba14);
_Te0:
	__asm        jmp    _Te5;
_Te5:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, word ptr [ebp-0x20];
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T10e;
_T10e:
	__asm        fld    res;
	__asm        call   0x0056EBE8;
	__asm        mov    ecx, [ebp-0x1C];
	__asm        mov    [ecx], ax;
// LINE 1786:
	result = 0x1;
// LINE 1788:
	return result;
// LINE 1789:
}

// FUNCTION: COPTER_D 0x0055b549
enum TreeSim::ReturnCode cYObject::iIsThisCellSafe(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1793:
	result = 0xffffffff;
// LINE 1794:
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        call   cYObject::GetLocType;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x89];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movzx  ax, byte ptr [eax+0x88];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::IsWalkable;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T6b;
// LINE 1797:
	result = 0x1;
// LINE 1798:
	__asm        jmp    _T72;
// LINE 1799:
_T6b:
	result = 0x0;
// LINE 1801:
_T72:
	return result;
// LINE 1802:
}

// FUNCTION: COPTER_D 0x0055b5ca
enum TreeSim::ReturnCode cYObject::iPlaySound(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   unsigned short playforsure;

// LINE 1806:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1807:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax+2];
	__asm        mov    playforsure, ax;
// LINE 1808:
	__asm        mov    eax, reinterpret_cast<uint32_t>(playforsure);
	__asm        push   eax;
	__asm        mov    eax, nparam;
	__asm        movsx  eax, word ptr [eax];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::PlaySoundA;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T51;
// LINE 1809:
	result = 0x1;
// LINE 1810:
	__asm        jmp    _T58;
// LINE 1811:
_T51:
	result = 0x0;
// LINE 1826:
_T58:
	return result;
// LINE 1827:
}

// FUNCTION: COPTER_D 0x0055b631
enum TreeSim::ReturnCode cYObject::iGetOnHeliIfHarnessRaised(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1831:
	result = 0xffffffff;
// LINE 1832:
	__asm        jmp    _T18;
_T18:
	__asm        mov    eax, this;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xBC];
	__asm        cmp    [eax+0x130], ecx;
	__asm        je     _T7b;
// LINE 1833:
	__asm        jmp    _T38;
_T38:
	__asm        mov    eax, this;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        cmp    [eax+0x130], ecx;
	__asm        je     _T6f;

	doAssert(0x8c085, 0x5bd848, 0x729, 0x5bd888);
// LINE 1834:
_T6f:
	result = 0x1;
// LINE 1836:
	__asm        jmp    _Tf9;
_T7b:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+0x1B4], 0;
	__asm        je     _Tc4;
// LINE 1837:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::SetMaster;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        jne    _Tb8;
// LINE 1838:
	result = 0x0;
// LINE 1839:
	__asm        jmp    _Tbf;
// LINE 1840:
_Tb8:
	result = 0x1;
// LINE 1842:
_Tbf:
	__asm        jmp    _Tf9;
// LINE 1843:
_Tc4:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _Tf2;

	doAssert(0x8c085, 0x5bd8ac, 0x733, 0x5bd8c0);
// LINE 1844:
_Tf2:
	result = 0x0;
// LINE 1847:
_Tf9:
	return result;
// LINE 1848:
}

// FUNCTION: COPTER_D 0x0055b739
enum TreeSim::ReturnCode cYObject::iAmIOnHeli(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;

// LINE 1852:
	result = 0xffffffff;
// LINE 1853:
	__asm        mov    eax, this;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        cmp    [eax+0x130], ecx;
	__asm        jne    _T3a;
// LINE 1854:
	result = 0x1;
// LINE 1855:
	__asm        jmp    _T41;
// LINE 1856:
_T3a:
	result = 0x0;
// LINE 1858:
_T41:
	return result;
// LINE 1859:
}

// FUNCTION: COPTER_D 0x0055b789
enum TreeSim::ReturnCode cYObject::iThrowFieryProjectile(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
// LINE 1863:
	__asm        mov    eax, node;
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   cYObject::iThrowProjectile;
	__asm        jmp    __RETURN;
// LINE 1864:
__RETURN:
}

// FUNCTION: COPTER_D 0x0055b7b1
enum TreeSim::ReturnCode cYObject::iTellStartingObjectTrueOrFalse(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   /*unpacked*/ union YObjLang::Param *nparam;
	/*bp-0xc*/   short truefalse;

// LINE 1868:
	result = 0xffffffff;
	nparam = (node + 0x4);
// LINE 1869:
	__asm        mov    eax, nparam;
	__asm        mov    ax, [eax];
	__asm        mov    truefalse, ax;
// LINE 1870:
	__asm        movsx  eax, truefalse;
	__asm        test   eax, eax;
	__asm        je     _T5b;

	__asm        movsx  eax, truefalse;
	__asm        cmp    eax, 1;
	__asm        je     _T5b;

	doAssert(0x8c085, 0x5bd8e4, 0x74e, 0x5bd908);
// LINE 1871:
_T5b:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x100];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T86;
// LINE 1872:
	__asm        movsx  eax, truefalse;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x100];
	__asm        push   eax;
	__asm        call   EmergencyVehicleClass::S3UpdateCar;
	__asm        add    esp, 8;
// LINE 1873:
_T86:
	result = 0x1;
// LINE 1875:
	return result;
// LINE 1876:
}

// FUNCTION: COPTER_D 0x0055b84d
enum TreeSim::ReturnCode cYObject::TryElement(/*unpacked*/ struct TreeSim::StackElem *elem, /*unpacked*/ struct Behavior::Node *node) {
	/*bp-0x4*/   enum TreeSim::ReturnCode res;

// LINE 1881:
	__asm        mov    eax, node;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   eax, eax;
	__asm        jl     _T29;

	__asm        mov    eax, node;
	__asm        movsx  eax, word ptr [eax];
	__asm        cmp    eax, 0x40;
	__asm        jl     _T45;
_T29:
	doAssert(0x8c085, 0x5bd92c, 0x759, 0x5bd950);
// LINE 1882:
_T45:
	__asm        mov    eax, node;
	__asm        movsx  eax, word ptr [eax];
	__asm        cmp    cYObject::PrimProcs[0][eax*4], 0;
	__asm        jne    _T75;

	doAssert(0x8c085, 0x5bd974, 0x75a, 0x5bd99c);
// LINE 1884:
_T75:
	this->fIterations++;
// LINE 1885:
	__asm        mov    eax, node;
	__asm        push   eax;
	__asm        mov    eax, elem;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, node;
	__asm        movsx  eax, word ptr [eax];
	__asm        call   cYObject::PrimProcs[0][eax*4];
	__asm        add    esp, 0xC;
	__asm        mov    res, eax;
// LINE 1887:
	__asm        cmp    res, 0xFFFFFFFF;
	__asm        jne    _Tc4;

	doAssert(0x8c085, 0x5bd9c0, 0x75f, 0x5bd9e8);
// LINE 1888:
_Tc4:
	return res;
// LINE 1889:
}

// FUNCTION: COPTER_D 0x0055b920
void cYObject::UpdateMission(enum cYObject::MissionUpdates missup, long missionid) {
	/*bp-0x18*/  /*unpacked*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 1901:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD2];
	__asm        test   eax, eax;
	__asm        jne    _T3a;

	doAssert(0x8c085, 0x5bda0c, 0x76d, 0x5bda34);
// LINE 1902:
_T3a:
	__asm        cmp    missionid, 0xFFFFFFFF;
	__asm        jne    _T60;

	doAssert(0x8c085, 0x5bda58, 0x76e, 0x5bda7c);
// LINE 1903:
_T60:
	mp.id = missionid;
// LINE 1904:
	__asm        mov    eax, missup;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T1ec;
// LINE 1906:
_T71:
	mp.op = 0x14;
// LINE 1907:
	mp.i2num = 0x1;
// LINE 1908:
	__asm        jmp    _T228;
// LINE 1911:
_T84:
	mp.op = 0x15;
// LINE 1912:
	mp.i2num = 0x1;
// LINE 1913:
	__asm        jmp    _T228;
// LINE 1916:
_T97:
	mp.op = 0x12;
// LINE 1917:
	mp.i2num = 0x1;
// LINE 1918:
	__asm        jmp    _T228;
// LINE 1920:
_Taa:
	mp.op = 0x13;
// LINE 1921:
	mp.i2num = 0x1;
// LINE 1922:
	__asm        jmp    _T228;
// LINE 1924:
_Tbd:
	mp.op = 0x13;
// LINE 1925:
	mp.i2num = 0x1;
// LINE 1926:
	__asm        jmp    _T228;
// LINE 1928:
_Td0:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0xD8];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T13c;
// LINE 1930:
_Te2:
	mp.op = 0x15;
// LINE 1931:
	mp.i2num = 0x1;
// LINE 1932:
	__asm        jmp    _T163;
// LINE 1934:
_Tf5:
	mp.op = 0x11;
// LINE 1935:
	mp.i2num = 0x1;
// LINE 1936:
	__asm        jmp    _T163;
// LINE 1939:
_T108:
	mp.op = 0x10;
// LINE 1940:
	mp.i2num = 0x1;
// LINE 1941:
	__asm        jmp    _T163;
// LINE 1943:
_T11b:
	doAssert(0x8c085, 0x5bdaa0, 0x797, 0x5bdacc);
// LINE 1944:
	__asm        jmp    _T163;
_T13c:
	__asm        dec    dword ptr [ebp-0x24];
	__asm        cmp    dword ptr [ebp-0x24], 3;
	__asm        ja     _T11b;

	__asm        mov    eax, [ebp-0x24];
	__asm        jmp    _Switch_153[0][eax*4];
// Switch pointers:
//   _T108
//   _T108
//   _Te2
//   _Tf5
// LINE 1945:
_T163:
	__asm        jmp    _T228;
// LINE 1947:
_T168:
	mp.op = 0x1e;
// LINE 1948:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        mov    mp.maploc.x, ecx;
// LINE 1949:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        mov    mp.maploc.y, ecx;
// LINE 1950:
	__asm        jmp    _T228;
// LINE 1952:
_T190:
	mp.op = 0x0;
// LINE 1953:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x88];
	__asm        mov    mp.maploc.x, ecx;
// LINE 1954:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x89];
	__asm        mov    mp.maploc.y, ecx;
// LINE 1955:
	__asm        jmp    _T228;
// LINE 1957:
_T1b8:
	mp.op = 0x25;
// LINE 1958:
	mp.i2num = 0x1;
// LINE 1959:
	__asm        jmp    _T228;
// LINE 1961:
_T1cb:
	doAssert(0x8c085, 0x5bdaf0, 0x7a9, 0x5bdb10);
// LINE 1962:
	__asm        jmp    _T228;
_T1ec:
	__asm        cmp    dword ptr [ebp-0x20], 9;
	__asm        ja     _T1cb;

	__asm        mov    eax, [ebp-0x20];
	__asm        jmp    _Switch_200[0][eax*4];
// Switch pointers:
//   _Tbd
//   _Td0
//   _T168
//   _T1cb
//   _T71
//   _T84
//   _T190
//   _T97
//   _Taa
//   _T1b8
// LINE 1963:
_T228:
	S3MissionUpdate(mp.op);
// LINE 1964:
	return;
}

// FUNCTION: COPTER_D 0x0055bb60
enum TreeSim::ReturnCode cYObject::TryExpression(/*unpacked*/ struct YObjLang::AttrParam *attr) {
	/*bp-0x4*/   enum TreeSim::ReturnCode result;
	/*bp-0x8*/   short rhs;
	/*bp-0xc*/   short * plhs;
	/*bp-0x10*/  short lhs;

// LINE 1992:
	result = 0xffffffff;
// LINE 1996:
	__asm        push   0;
	__asm        mov    eax, attr;
	__asm        mov    ax, [eax+2];
	__asm        push   eax;
	__asm        mov    eax, attr;
	__asm        mov    ax, [eax+6];
	__asm        sar    ax, 8;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    rhs, ax;
// LINE 1997:
	__asm        lea    eax, plhs;
	__asm        push   eax;
	__asm        mov    eax, attr;
	__asm        mov    ax, [eax];
	__asm        push   eax;
	__asm        mov    eax, attr;
	__asm        mov    ax, [eax+6];
	__asm        shl    ax, 8;
	__asm        sar    ax, 8;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    lhs, ax;
// LINE 1999:
	__asm        mov    eax, attr;
	__asm        mov    ax, [eax+4];
	__asm        sar    ax, 8;
	__asm        movsx  eax, ax;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T395;
// LINE 2001:
_T78:
	__asm        movsx  eax, rhs;
	__asm        movsx  ecx, lhs;
	__asm        cmp    eax, ecx;
	__asm        jle    _T94;

	result = 0x1;
// LINE 2002:
	__asm        jmp    _T9b;
_T94:
	result = 0x0;
// LINE 2003:
_T9b:
	__asm        jmp    _T3d5;
// LINE 2005:
_Ta0:
	__asm        movsx  eax, rhs;
	__asm        movsx  ecx, lhs;
	__asm        cmp    eax, ecx;
	__asm        jge    _Tbc;

	result = 0x1;
// LINE 2006:
	__asm        jmp    _Tc3;
_Tbc:
	result = 0x0;
// LINE 2007:
_Tc3:
	__asm        jmp    _T3d5;
// LINE 2009:
_Tc8:
	__asm        movsx  eax, rhs;
	__asm        movsx  ecx, lhs;
	__asm        cmp    eax, ecx;
	__asm        jne    _Te4;

	result = 0x1;
// LINE 2010:
	__asm        jmp    _Teb;
_Te4:
	result = 0x0;
// LINE 2011:
_Teb:
	__asm        jmp    _T3d5;
// LINE 2013:
_Tf0:
	__asm        cmp    plhs, 0;
	__asm        je     _T109;
// LINE 2014:
	__asm        mov    ax, rhs;
	__asm        mov    ecx, plhs;
	__asm        mov    [ecx], ax;
// LINE 2015:
	__asm        jmp    _T120;
// LINE 2016:
_T109:
	__asm        push   0x12;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T483;

	__asm        jmp    tree_error;
// LINE 2018:
_T120:
	result = 0x1;
// LINE 2019:
	__asm        jmp    _T3d5;
// LINE 2021:
_T12c:
	__asm        cmp    plhs, 0;
	__asm        je     _T14d;
// LINE 2022:
	__asm        mov    eax, plhs;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, rhs;
	__asm        add    eax, ecx;
	__asm        mov    ecx, plhs;
	__asm        mov    [ecx], ax;
// LINE 2023:
	__asm        jmp    _T164;
// LINE 2024:
_T14d:
	__asm        push   0x12;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T47e;

	__asm        jmp    tree_error;
// LINE 2026:
_T164:
	result = 0x1;
// LINE 2027:
	__asm        jmp    _T3d5;
// LINE 2029:
_T170:
	__asm        cmp    plhs, 0;
	__asm        je     _T191;
// LINE 2030:
	__asm        mov    eax, plhs;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, rhs;
	__asm        sub    eax, ecx;
	__asm        mov    ecx, plhs;
	__asm        mov    [ecx], ax;
// LINE 2031:
	__asm        jmp    _T1a8;
// LINE 2032:
_T191:
	__asm        push   0x12;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T479;

	__asm        jmp    tree_error;
// LINE 2034:
_T1a8:
	result = 0x1;
// LINE 2035:
	__asm        jmp    _T3d5;
// LINE 2037:
_T1b4:
	__asm        cmp    plhs, 0;
	__asm        je     _T1d6;
// LINE 2038:
	__asm        mov    eax, plhs;
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, rhs;
	__asm        imul   eax, ecx;
	__asm        mov    ecx, plhs;
	__asm        mov    [ecx], ax;
// LINE 2039:
	__asm        jmp    _T1ed;
// LINE 2040:
_T1d6:
	__asm        push   0x12;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T474;

	__asm        jmp    tree_error;
// LINE 2042:
_T1ed:
	result = 0x1;
// LINE 2043:
	__asm        jmp    _T3d5;
// LINE 2045:
_T1f9:
	__asm        cmp    plhs, 0;
	__asm        je     _T21b;
// LINE 2046:
	__asm        mov    eax, plhs;
	__asm        movsx  ecx, rhs;
	__asm        movsx  eax, word ptr [eax];
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, plhs;
	__asm        mov    [ecx], ax;
// LINE 2047:
	__asm        jmp    _T232;
// LINE 2048:
_T21b:
	__asm        push   0x12;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T46f;

	__asm        jmp    tree_error;
// LINE 2050:
_T232:
	result = 0x1;
// LINE 2051:
	__asm        jmp    _T3d5;
// LINE 2053:
_T23e:
	__asm        movsx  eax, rhs;
	__asm        cmp    eax, 0xE;
	__asm        jle    _T262;

	__asm        push   0xC;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T46a;

	__asm        jmp    tree_error;
// LINE 2054:
_T262:
	__asm        cmp    plhs, 0;
	__asm        je     _T28b;

	__asm        mov    eax, 1;
	__asm        movsx  ecx, rhs;
	__asm        dec    ecx;
	__asm        shl    eax, cl;
	__asm        mov    ecx, plhs;
	__asm        movsx  ecx, word ptr [ecx];
	__asm        or     eax, ecx;
	__asm        mov    ecx, plhs;
	__asm        mov    [ecx], ax;
// LINE 2055:
	__asm        jmp    _T2a2;
// LINE 2056:
_T28b:
	__asm        push   0x12;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T465;

	__asm        jmp    tree_error;
// LINE 2058:
_T2a2:
	result = 0x1;
// LINE 2059:
	__asm        jmp    _T3d5;
// LINE 2061:
_T2ae:
	__asm        movsx  eax, rhs;
	__asm        cmp    eax, 0xE;
	__asm        jle    _T2d2;

	__asm        push   0xC;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T460;

	__asm        jmp    tree_error;
// LINE 2062:
_T2d2:
	__asm        cmp    plhs, 0;
	__asm        je     _T2fd;

	__asm        mov    eax, 1;
	__asm        movsx  ecx, rhs;
	__asm        dec    ecx;
	__asm        shl    eax, cl;
	__asm        not    eax;
	__asm        mov    ecx, plhs;
	__asm        movsx  ecx, word ptr [ecx];
	__asm        and    eax, ecx;
	__asm        mov    ecx, plhs;
	__asm        mov    [ecx], ax;
// LINE 2063:
	__asm        jmp    _T314;
// LINE 2064:
_T2fd:
	__asm        push   0x12;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T45b;

	__asm        jmp    tree_error;
// LINE 2066:
_T314:
	result = 0x1;
// LINE 2067:
	__asm        jmp    _T3d5;
// LINE 2069:
_T320:
	__asm        movsx  eax, rhs;
	__asm        cmp    eax, 0xE;
	__asm        jle    _T344;

	__asm        push   0xC;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T456;

	__asm        jmp    tree_error;
// LINE 2070:
_T344:
	__asm        mov    eax, 1;
	__asm        movsx  ecx, rhs;
	__asm        dec    ecx;
	__asm        shl    eax, cl;
	__asm        movsx  ecx, lhs;
	__asm        test   ecx, eax;
	__asm        je     _T368;

	result = 0x1;
// LINE 2071:
	__asm        jmp    _T36f;
_T368:
	result = 0x0;
// LINE 2072:
_T36f:
	__asm        jmp    _T3d5;
// LINE 2075:
_T374:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T451;

	__asm        jmp    tree_error;
// LINE 2076:
	__asm        jmp    _T3d5;
// LINE 2077:
	__asm        jmp    _T3d5;
_T395:
	__asm        cmp    dword ptr [ebp-0x18], 0xA;
	__asm        ja     _T374;

	__asm        mov    eax, [ebp-0x18];
	__asm        jmp    _Switch_3a9[0][eax*4];
// Switch pointers:
//   _Ta0
//   _T78
//   _Tc8
//   _T12c
//   _T170
//   _Tf0
//   _T1b4
//   _T1f9
//   _T320
//   _T23e
//   _T2ae
// LINE 2080:
_T3d5:
	__asm        cmp    plhs, 0;
	__asm        je     tree_error;
// LINE 2081:
	__asm        mov    eax, plhs;
	__asm        movsx  eax, word ptr [eax];
	__asm        cmp    eax, 0x61A8;
	__asm        jle    _T414;
// LINE 2082:
	doAssert(0x8c085, 0x5bdb34, 0x822, 0x5bdb60);
// LINE 2083:
	plhs[0] = 0x61a8;
// LINE 2086:
_T414:
	__asm        mov    eax, plhs;
	__asm        movsx  eax, word ptr [eax];
	__asm        cmp    eax, 0xFFFF9E58;
	__asm        jge    tree_error;
// LINE 2087:
	doAssert(0x8c085, 0x5bdb84, 0x827, 0x5bdbb0);
// LINE 2088:
	plhs[0] = 0x9e58;
// LINE 2098:
tree_error:
	return result;
// LINE 2099:
_T451:
	__asm        jmp    tree_error;
_T456:
	__asm        jmp    tree_error;
_T45b:
	__asm        jmp    tree_error;
_T460:
	__asm        jmp    tree_error;
_T465:
	__asm        jmp    tree_error;
_T46a:
	__asm        jmp    tree_error;
_T46f:
	__asm        jmp    tree_error;
_T474:
	__asm        jmp    tree_error;
_T479:
	__asm        jmp    tree_error;
_T47e:
	__asm        jmp    tree_error;
_T483:
	__asm        jmp    tree_error;
}

// FUNCTION: COPTER_D 0x0055bfef
void cYObject::HandleOverflow() {
// LINE 2104:
	doAssert(0x8c085, 0x5bdbd4, 0x838, 0x5bdbec);
// LINE 2105:
	return;
}

// FUNCTION: COPTER_D 0x0055c021
short cYObject::InterpValue(short ownerField, short dataField, short * *dataRef) {
	/*bp-0x4*/   short data;
	/*bp-0x8*/   short temp;
	/*bp-0xc*/   short * ptemp;

// LINE 2113:
	__asm        cmp    dataRef, 0;
	__asm        jne    _T22;
// LINE 2114:
	dataRef = ptemp;
// LINE 2115:
	ptemp = temp;
// LINE 2117:
_T22:
	dataRef-> = 0x0;
// LINE 2118:
	data = 0x0;
// LINE 2119:
	__asm        movsx  eax, ownerField;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T1d9;
// LINE 2121:
_T3d:
	doAssert(0x8c085, 0x5bdc10, 0x849, 0x5bdc20);
// LINE 2124:
	__asm        jmp    _T21d;
// LINE 2126:
_T5e:
	doAssert(0x8c085, 0x5bdc44, 0x84e, 0x5bdc58);
// LINE 2130:
	__asm        jmp    _T21d;
// LINE 2132:
_T7f:
	doAssert(0x8c085, 0x5bdc7c, 0x854, 0x5bdca4);
// LINE 2133:
	__asm        jmp    _T21d;
// LINE 2135:
_Ta0:
	__asm        movsx  eax, dataField;
	__asm        cmp    eax, 0x30;
	__asm        jl     _Tc4;

	__asm        push   6;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T238;

	__asm        jmp    tree_error;
// LINE 2136:
_Tc4:
	__asm        movsx  eax, dataField;
	__asm        add    eax, eax;
	__asm        add    eax, this;
	__asm        add    eax, 0xD0;
	__asm        mov    ecx, dataRef;
	__asm        mov    [ecx], eax;
	__asm        mov    eax, dataRef;
	__asm        mov    eax, [eax];
	__asm        mov    ax, [eax];
	__asm        mov    data, ax;
// LINE 2137:
	__asm        jmp    _T21d;
// LINE 2139:
_Te8:
	doAssert(0x8c085, 0x5bdcc8, 0x85b, 0x5bdce0);
// LINE 2140:
	__asm        jmp    _T21d;
// LINE 2142:
_T109:
	__asm        mov    ax, dataField;
	__asm        mov    data, ax;
// LINE 2143:
	__asm        jmp    _T21d;
// LINE 2145:
_T116:
	doAssert(0x8c085, 0x5bdd04, 0x861, 0x5bdd20);
// LINE 2146:
	__asm        jmp    _T21d;
// LINE 2148:
_T137:
	doAssert(0x8c085, 0x5bdd44, 0x864, 0x5bdd64);
// LINE 2149:
	__asm        jmp    _T21d;
// LINE 2151:
_T158:
	__asm        movsx  eax, dataField;
	__asm        cmp    eax, 4;
	__asm        jl     _T17c;

	__asm        push   7;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T233;

	__asm        jmp    tree_error;
// LINE 2152:
_T17c:
	__asm        jmp    _T181;
_T181:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        lea    eax, [eax*4-4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+4];
	__asm        movsx  ecx, dataField;
	__asm        lea    eax, [eax+ecx*2];
	__asm        add    eax, 8;
	__asm        mov    ecx, dataRef;
	__asm        mov    [ecx], eax;
	__asm        mov    eax, dataRef;
	__asm        mov    eax, [eax];
	__asm        mov    ax, [eax];
	__asm        mov    data, ax;
// LINE 2153:
	__asm        jmp    _T21d;
// LINE 2155:
_T1b8:
	__asm        push   8;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        jmp    _T22e;

	__asm        jmp    tree_error;
// LINE 2156:
	__asm        jmp    _T21d;
// LINE 2157:
	__asm        jmp    _T21d;
_T1d9:
	__asm        cmp    dword ptr [ebp-0x14], 0xB;
	__asm        ja     _T1b8;

	__asm        mov    eax, [ebp-0x14];
	__asm        jmp    _Switch_1ed[0][eax*4];
// Switch pointers:
//   _T3d
//   _T7f
//   _T1b8
//   _Ta0
//   _Te8
//   _T1b8
//   _T1b8
//   _T109
//   _T116
//   _T158
//   _T5e
//   _T137
// LINE 2158:
_T21d:
	return data;
// LINE 2161:
tree_error:
	return 0x0;
// LINE 2162:
_T22e:
	__asm        jmp    tree_error;
_T233:
	__asm        jmp    tree_error;
_T238:
	__asm        jmp    tree_error;
}



// Contribution: 2:00004600-0000461b Module: 196, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00025634-00026d84 Module: 196, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005bc634
int32_t radiusReduction = 131072;



// Contribution: 3:00026d88-00026dba Module: 196, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "must have master object to test its speed, for now"


// Contribution: 3:00026dbc-00026dd5 Module: 196, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "local number out of range"


// Contribution: 3:000a05a8-000a06a7 Module: 196, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x006375a8
enum TreeSim::ReturnCode (*cYObject::PrimProcs[64])(/*unpacked*/ class cYObject*, /*unpacked*/ struct TreeSim::StackElem*, /*unpacked*/ struct Behavior::Node*);



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.
// GLOBAL: COPTER_D 0x0067ed30
/*packed*/ struct _CELL_INFO *G_omap[256][256]; // Contrib missing

