// Module: S3emrvcl.obj
// Source: C:\Copter\source\game\S3emrvcl.cpp
// autogenerated by simcopter_tool from PDB file

// Type: const enum TurnIndex[4][4];

// Type: int32_t;

// Type: class EmergencyVehicleClass (forward reference);
class EmergencyVehicleClass : public AutomobileClass
{
		enum EmergencyVehicleClass::__unnamed {
			MAXIMUM_DISTANCE_FROM_BASE = 7,
			MAXIMUM_TIME_TO_EMERGENCY = 3932160,
			AMBULANCE_CAPACITY = 2,
		};
protected:
	struct _GridCoordinates baseLocation;
	struct _GridCoordinates emergencyLocation;
	enum EmergencyType emergencyType;
	long timeOfArrival;
	struct _DYOBJ_INST dispatchIcon;
	int32_t timeToEmergency;
	class AutomobileClass* dispatchTarget;
	unsigned char dispatchPath[256];
	unsigned char dispatchPathIndex;
	unsigned char dispatchPathLength;
	enum EmergencyLevel emergencyState;
	int32_t stationID;
	int32_t numberOfSeats;
public:
	void EmergencyVehicleClass(const class EmergencyVehicleClass&);
	void EmergencyVehicleClass();
	virtual void ~EmergencyVehicleClass();
	enum EmergencyLevel GetEmergencyState();
	void InitializePlacedVehicleForDispatch(struct Goal, struct Goal, struct Goal, struct Goal, struct _GridCoordinates, struct Goal, enum EmergencyType, enum EmergencyLevel);
	void InitializeStationVehicleForDispatch(int32_t, struct Goal, struct Goal, struct _GridCoordinates, struct Goal, struct Goal, struct _GridCoordinates, int32_t, struct Goal, enum EmergencyType, enum EmergencyLevel);
	// calltype: NearC
	static int32_t AreThereMoreSeats(struct _DYOBJ_INST*);
	// calltype: NearC
	static void FillSeat(struct _DYOBJ_INST*);
	// calltype: NearC
	static int32_t S3UpdateCar(int32_t, int32_t);
	// calltype: NearC
	static struct _DYOBJ_INST* S3GetCar(int32_t);
	void CancelEmergencyDispatch();
protected:
	// vtable: 36
	intro void Reset();
	virtual void AdjustSpeed();
	virtual enum TurnIndex PickTurnDir(struct Goal*);
	virtual void SetSaveData(struct _AUTO_LOAD_SAVE*);
	virtual void LoadSaveData(struct _AUTO_LOAD_SAVE*);
	void ArriveOnScene();
	void UnLinkIconFromCell(const struct _GridCoordinates);
	void LinkIconToCell(const struct _GridCoordinates);
	void PositionIcon();
	void GoBackToStation();
	void BuildPath(struct _RGIndex, struct _RGIndex);
	void TurnOnStrobe();
	void TurnOffStrobe();
	int32_t UpdateCar(int32_t);
	virtual void BeamToWithinCameraRange();
public:
	class EmergencyVehicleClass operator=(const class EmergencyVehicleClass&);
};

// Type: struct _DYOBJ_INST (forward reference);
// _DYOBJ_INST Class implementation not found

// Type: void;

// Type: struct Goal;
struct Goal{
	struct RGVertex* pRGV;
	int32_t elementIndex;
	int32_t gridIndex;
	struct _GridCoordinates gridLoc;
	enum DirIndex2 edgeIndex;
	enum DirIndex2 direction;
	int32_t distance;
	int32_t turnFlags;
	int32_t deadEndFlags;
	int32_t fElevated;
	enum SlopeIndex slope;
};

// Type: struct _GridCoordinates;
struct _GridCoordinates{
	unsigned char x;
	unsigned char y;
};

// Type: enum EmergencyType;
	enum EmergencyType {
		NO_EMERGENCY = 0,
		FIRE_TRUCK = 1,
		AMBULANCE_CAR = 2,
		POLICE_CHASING_CAR = 3,
		POLICE_ON_PATROL = 4,
	};

// Type: enum EmergencyLevel;
	enum EmergencyLevel {
		ES_UNDEFINED = 0,
		ES_STAKEOUT = 1,
		ES_RETURN = 2,
		ES_PURSUIT = 3,
		ES_DISPATCHED = 4,
		ES_AT_SCENE = 5,
		ES_COP_CHASE = 6,
	};

// Type: struct _RGIndex;
struct _RGIndex{
	unsigned char x;
	unsigned char yindex;
};

// Type: struct Edge (forward reference);
// Edge Class implementation not found

// Type: unsigned char;

// Type: struct VRview;
struct VRview{
	struct Point3d loc;
	struct Point3d scale;
	int32_t matrix[4][4];
};

// Type: struct Goal (forward reference);
// Goal Class implementation not found

// Type: enum TurnIndex;
	enum TurnIndex {
		iTS = 0,
		iTR = 1,
		iTL = 2,
		iTU = 3,
	};

// Type: struct _CELL_INFO (forward reference);
// _CELL_INFO Class implementation not found

// Type: long;

// Type: struct RGVertex (forward reference);
// RGVertex Class implementation not found

// Type: struct VRFaceInfo;
struct VRFaceInfo{
	int32_t Face;
	int32_t Verts;
	int32_t Attribute;
	int32_t Plotter;
	struct VRBmpHdr* Bitmap;
	int32_t * VertList;
	struct MapVert* MapVList;
	struct MapVert* BarryPtr;
};

// Type: struct VRObjInfo;
struct VRObjInfo{
	int32_t Faces;
	int32_t Verts;
	int32_t Attribute;
	int32_t Radius;
	struct Point3d* ObjCenter;
	struct Point3d* VertsPtr;
	struct Xform3d* VertsXfm;
	struct Point3d* OrgVerts;
	int32_t[4][4]* Matrix;
};

// Type: struct _AUTO_LOAD_SAVE (forward reference);
// _AUTO_LOAD_SAVE Class implementation not found

// Type: uint32_t;

// Type: class AutomobileClass;
class AutomobileClass{
		enum AutomobileClass::__unnamed {
			CAR_TYPES = 7,
			PERCENTAGE_OF_AUTO1 = 10,
			PERCENTAGE_OF_AUTO2 = 20,
			PERCENTAGE_OF_AUTO3 = 20,
			PERCENTAGE_OF_AUTO4 = 10,
			PERCENTAGE_OF_AUTO5 = 10,
			PERCENTAGE_OF_AUTO6 = 20,
			PERCENTAGE_OF_AUTO7 = 20,
			TOTAL_PERCENTAGE = 110,
		};
		enum AutomobileClass::__unnamed {
			NO_X_POSITION = -1,
			STARTING_X = 3,
			ENDING_X = 125,
			NO_Y_POSITION = -1,
			STARTING_Y = 3,
			ENDING_Y = 125,
		};
		enum AutomobileClass::IntersectionTypes {
			DEAD_END = 0,
			STRAIGHT_AHEAD = 1,
			LEFT_ONLY = 2,
			RIGHT_ONLY = 4,
			LEFT_OR_STRAIGHT = 3,
			LEFT_OR_RIGHT = 6,
			RIGHT_OR_STRAIGHT = 5,
			LEFT_STRAIGHT_OR_RIGHT = 7,
			DEAD_END_HIWAY = 16,
		};
		enum AutomobileClass::StoppedReasons {
			NO_REASON = 0,
			TRAFFIC = 1,
			STOPPED_TRAFFIC = 2,
			PERSON_IN_WAY = 3,
			AUTO_IN_WAY = 4,
			DEBRIS_IN_WAY = 5,
			UNIDENTIFIED_IN_WAY = 6,
			HELI_IN_WAY = 7,
			END_OF_ROAD = 8,
			END_OF_HIWAY = 9,
			INTERSECTION_FULL = 10,
			BEEN_PULLED_OVER = 11,
		};
		enum AutomobileClass::RoadTileOffsets {
			RD_CENTOFF = 851968,
			RD_EDGEOFF = 131072,
		};
		enum AutomobileClass::HiwayOffsets {
			HW_CENTOFF_LANE1 = 851968,
			HW_EDGEOFF_LANE1 = 131072,
			HW_CENTOFF_LANE2 = 851968,
			HW_EDGEOFF_LANE2 = 131072,
			HW_HEIGHT = 2031616,
		};
		enum AutomobileClass::PersonState {
			PS_IN_VEHICLE = 0,
			PS_OUT_OF_VEHICLE = 1,
			PS_BACK_IN_VEHICLE = 2,
			PS_GOT_AWAY = 3,
			PS_MISSION_OVER = 4,
		};
		enum AutomobileClass::__unnamed {
			CAR_RADIUS = 327680,
			COLLISION_SPACE = 655360,
			ROAD_SPEED = 2621440,
			ROAD_SLOWDOWN_FACTOR = 131072,
			HIWAY_SPEED = 6225920,
			HIWAY_SLOWDOWN_FACTOR = 327680,
			SPEED_VARIANCE = 262144,
			HIWAY_VARIANCE = 655360,
			MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
			MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
			MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
		};
		enum AutomobileClass::Flags {
			AUTO_INITIALIZED = 1,
			AUTO_PLACED = 2,
			AUTO_TURNING = 4,
			AUTO_MAKING_UTURN = 8,
			AUTO_PULL_OVER = 16,
			AUTO_PULLING_OVER = 32,
			AUTO_PULLED_OVER = 64,
			AUTO_AT_DEAD_END = 128,
			AUTO_IN_INTERSECTION = 256,
			AUTO_ON_FIRE = 512,
			AUTO_JAMMED = 1024,
			AUTO_PULLING_OUT = 2048,
			AUTO_RIGHT_OF_WAY = 4096,
			AUTO_ON_HIWAY = 8192,
		};
public:
	int32_t flags;
	struct _DYOBJ_INST autoDynomitor;
	struct Goal goal;
private:
	static struct Point2d lastScannedLocation;
	int32_t DeltaFromCenter;
	int32_t stalledTimer;
	struct Point3d directionVector;
	int32_t remainingTime;
	int32_t desiredSpeed;
	int32_t desiredHiwaySpeed;
	int32_t beamDelay;
	int32_t beamTimer;
	int32_t m_cellBaseY;
	int32_t timePulledOver;
	enum DirectionTypes hiwaydir;
	struct _GridCoordinates currentLocation;
	struct _GridCoordinates nextLocation;
	struct _GridCoordinates northCell;
	struct _GridCoordinates southCell;
	struct _GridCoordinates eastCell;
	struct _GridCoordinates westCell;
protected:
	long carModel;
	int32_t speed;
	enum DirIndex2 prevDir;
	enum TurnIndex turnIndex;
	int32_t currDist;
	int32_t legOfTurn;
	struct Point3d* pDirVector;
	int32_t timeToLive;
	int32_t fireTime;
	long fireSeq;
	long missionId;
	struct _CELL_INFO* cptr;
	enum AutomobileClass::PersonState personState;
	int32_t spotlightHitCounter;
	int32_t IsCarPersistant();
	int32_t CanCarBeamToHiwayTile(unsigned short);
public:
	void AutomobileClass(const class AutomobileClass&);
	void AutomobileClass();
	// vtable: 0
	intro void ~AutomobileClass();
	// calltype: NearC
	static class AutomobileClass* CreateInstance(int32_t);
	// calltype: NearC
	static class AutomobileClass* GetAutoPointer(long);
	// calltype: NearC
	static void DestroyInstance(class AutomobileClass*);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t MissionStartFire(long, struct Point2d*);
	// calltype: NearC
	static int32_t MissionStartJam(long, struct Point2d*);
	// calltype: NearC
	static void MissionCancel(long);
	// calltype: NearC
	static void SetAllHeadlights(int32_t);
	void HitDispatch(long, struct _DYOBJ_INST*, long, long);
	int32_t AmIABadGuy();
	int32_t Initialize(int32_t);
	void WaterDouse(struct _DYOBJ_INST*);
	void IveBeenMegaphoned(long);
	void StartFire(long);
	void StartJam(long);
	void PullOver();
	void PullOut();
	int32_t CanIPullOut();
protected:
	void Itterate();
	// vtable: 4
	intro void AdjustSpeed();
	void Reset();
	// vtable: 8
	intro enum TurnIndex PickTurnDir(struct Goal*);
	void UnPlaceCar();
	void PullOverCiviliansInWay();
	// vtable: 12
	intro void ItterateFSM();
	int32_t InitializeInstance(int32_t);
	void LinkToCell(const struct _GridCoordinates&);
	int32_t AreCarsHeadOn(struct Point3d*);
	enum AutomobileClass::StoppedReasons CollisionCheck(int32_t, struct _DYOBJ_INST**);
	int32_t IsCarOutOfCameraRange();
	void TurnOffHeadlight();
	void TurnOnHeadlight();
	void SetHiwayDirection(unsigned short);
	int32_t DoHiwayTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void AdjustCurrentHiwayPosition();
	void AdjustNextHiwayPosition();
	enum AutomobileClass::IntersectionTypes PickHiwayDir(struct _GridCoordinates&);
	void MakeAHiwayTurn(enum AutomobileClass::IntersectionTypes);
	void GoStraight();
	void TurnLeft();
	void TurnRight();
	void MoveForwardOnHiway();
	void DoDiagonalRoadFixup();
	// vtable: 16
	intro void BeamToWithinCameraRange();
	// vtable: 20
	intro int32_t BeamToLocation(const struct _GridCoordinates&);
	void MoveAuto(int32_t);
private:
	void UnlinkFromCell(const struct _GridCoordinates&);
	void TransitionBetweenGoals();
	void RunFireState();
	void RunJamState();
	void IveBeenSpotlighted(struct _DYOBJ_INST*);
	int32_t IsThisAnEmergencyVehicle();
public:
	class AutomobileClass operator=(const class AutomobileClass&);
};



// Contribution: 1:00140530-00141d79 Module: 154, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00541530
int32_t EmergencyVehicleClass::S3UpdateCar(int32_t id, int32_t status) {
// LINE 71:
	__asm        mov    eax, status;
	__asm        push   eax;
	__asm        mov    eax, id;
	__asm        mov    ecx, cars[0][eax*4];
	__asm        call   EmergencyVehicleClass::UpdateCar;
	__asm        jmp    near ptr 0x0054154E;
// LINE 72:
}

// FUNCTION: COPTER_D 0x00541553
int32_t EmergencyVehicleClass::UpdateCar(int32_t status) {
// LINE 77:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T3c;
// LINE 79:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xF6], 1;
// LINE 80:
	__asm        mov    eax, status;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xFA], eax;
// LINE 81:
	__asm        mov    eax, 1;
	__asm        jmp    _T43;
// LINE 84:
_T3c:
	__asm        xor    eax, eax;
	__asm        jmp    _T43;
// LINE 85:
_T43:
}

// FUNCTION: COPTER_D 0x0054159d
struct _DYOBJ_INST* EmergencyVehicleClass::S3GetCar(int32_t id) {
// LINE 90:
	__asm        mov    eax, id;
	__asm        mov    eax, cars[0][eax*4];
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T2c;
// LINE 92:
	__asm        mov    eax, id;
	__asm        mov    eax, cars[0][eax*4];
	__asm        add    eax, 0xC;
	__asm        jmp    _T33;
// LINE 95:
_T2c:
	__asm        xor    eax, eax;
	__asm        jmp    _T33;
// LINE 96:
_T33:
}

// FUNCTION: COPTER_D 0x005415d5
void EmergencyVehicleClass::EmergencyVehicleClass() {

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::AutomobileClass;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11E], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x122], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x294], 1;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5934C0;
// LINE 103:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x11C], 0;
// LINE 104:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x11D], 0;
// LINE 105:
	__asm        jmp    near ptr 0x00541632;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0054163a
void EmergencyVehicleClass::~EmergencyVehicleClass() {

	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5934C0;
	__asm        jmp    near ptr 0x00541654;

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::~AutomobileClass;
}

// FUNCTION: COPTER_D 0x00541661
void EmergencyVehicleClass::InitializePlacedVehicleForDispatch(struct Goal startGoal1, struct Goal startGoal2, struct Goal destGoal1, struct Goal destGoal2, struct _GridCoordinates destLoc, struct Goal result, enum EmergencyType responceType, enum EmergencyLevel eState) {
	struct _RGIndex destIndex;
	struct _RGIndex startIndex;

// LINE 261:
	__asm        cmp    responceType, 0xFFFFFFFF;
	__asm        je     _T28;
// LINE 262:
	__asm        mov    eax, responceType;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11E], eax;
// LINE 264:
_T28:
	__asm        mov    eax, eState;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x294], eax;
// LINE 266:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T20e;
// LINE 271:
// Block start:
	struct Edge* pEdge;
	__asm        mov    eax, startGoal1.pRGV;
	__asm        mov    al, [eax];
	__asm        mov    startIndex.x, al;
// LINE 272:
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, startIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    startIndex.yindex, al;
// LINE 273:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        mov    al, [eax];
	__asm        mov    destIndex.x, al;
// LINE 274:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, destIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destIndex.yindex, al;
// LINE 275:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destIndex.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(startIndex.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::BuildPath;
// LINE 282:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x192];
	__asm        lea    eax, [ecx+ecx*4];
	__asm        add    eax, eax;
	__asm        add    eax, startGoal1.pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 283:
	__asm        cmp    startGoal2.pRGV, 0;
	__asm        je     _T14a;
// LINE 285:
// Block start:
	unsigned char yindex;
	__asm        mov    eax, startGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, startGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    yindex, al;
// LINE 286:
	__asm        mov    eax, startGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+1];
	__asm        cmp    ecx, edx;
	__asm        jne    _T129;

	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        xor    eax, eax;
	__asm        mov    al, yindex;
	__asm        cmp    ecx, eax;
	__asm        jne    _T129;
// LINE 288:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 1;
// LINE 289:
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 291:
	__asm        jmp    _T145;
// LINE 293:
_T129:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 0;
// LINE 294:
	__asm        lea    esi, startGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 297:
// Block end:
_T145:
	__asm        jmp    _T166;
// LINE 299:
_T14a:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 1;
// LINE 300:
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 305:
_T166:
	__asm        cmp    destGoal2.pRGV, 0;
	__asm        je     _T1f1;
// LINE 307:
// Block start:
	int32_t yindex;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    yindex, ecx;
// LINE 308:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2D];
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax];
	__asm        cmp    ecx, edx;
	__asm        jne    _T1d4;

	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2C];
	__asm        cmp    ecx, yindex;
	__asm        jne    _T1d4;
// LINE 310:
	__asm        mov    eax, this;
	__asm        dec    byte ptr [eax+0x293];
// LINE 312:
	__asm        jmp    _T1ec;
// LINE 314:
_T1d4:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 317:
// Block end:
_T1ec:
	__asm        jmp    _T209;
// LINE 319:
_T1f1:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 322:
// Block end:
_T209:
	__asm        jmp    _T2b0;
// LINE 325:
_T20e:
	__asm        cmp    startGoal1.pRGV, 0;
	__asm        jne    _T23e;

	__asm        cmp    startGoal2.pRGV, 0;
	__asm        jne    _T23e;

	__asm        push   0x145;
	__asm        push   0x5B8268;
	__asm        push   0x5B828C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T243;
_T23e:
	__asm        jmp    _T243;
// LINE 326:
_T243:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    startGoal1.pRGV, eax;
	__asm        jne    _T269;
// LINE 328:
	__asm        lea    esi, startGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 330:
	__asm        jmp    _T2b0;
_T269:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    startGoal2.pRGV, eax;
	__asm        jne    _T28f;
// LINE 332:
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 334:
	__asm        jmp    _T2b0;
// LINE 336:
_T28f:
	__asm        push   0x150;
	__asm        push   0x5B82B0;
	__asm        push   0x5B82D4;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T2b0;

	__asm        jmp    _T2b0;
// LINE 343:
_T2b0:
	__asm        mov    ax, reinterpret_cast<uint16_t>(destLoc.x);
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11C], ax;
// LINE 345:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xEA], 0;
// LINE 346:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xEE], 0;
// LINE 347:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TILUT[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 348:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE6];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][1][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 349:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 350:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::MoveAuto;
// LINE 351:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 0;
// LINE 352:
	__asm        jmp    near ptr 0x005419B3;
}

// FUNCTION: COPTER_D 0x005419ba
void EmergencyVehicleClass::InitializeStationVehicleForDispatch(int32_t sID, struct Goal stationGoal1, struct Goal stationGoal2, struct _GridCoordinates stationLoc, struct Goal destGoal1, struct Goal destGoal2, struct _GridCoordinates destLoc, int32_t startDir, struct Goal result, enum EmergencyType responceType, enum EmergencyLevel eState) {
	struct _RGIndex destIndex;
	struct _RGIndex stationIndex;
	int32_t car_type;

// LINE 365:
	__asm        mov    eax, sID;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x298], eax;
// LINE 368:
	__asm        cmp    responceType, 0xFFFFFFFF;
	__asm        je     _T34;
// LINE 369:
	__asm        mov    eax, responceType;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11E], eax;
// LINE 371:
_T34:
	__asm        mov    eax, eState;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x294], eax;
// LINE 374:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _Ta8;
// LINE 379:
	__asm        mov    eax, stationGoal1.pRGV;
	__asm        mov    al, [eax];
	__asm        mov    stationIndex.x, al;
// LINE 380:
	__asm        mov    eax, stationGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, stationIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    stationIndex.yindex, al;
// LINE 381:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        mov    al, [eax];
	__asm        mov    destIndex.x, al;
// LINE 382:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, destIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destIndex.yindex, al;
// LINE 383:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destIndex.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(stationIndex.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::BuildPath;
// LINE 388:
_Ta8:
	__asm        mov    ax, reinterpret_cast<uint16_t>(destLoc.x);
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11C], ax;
// LINE 389:
	__asm        mov    ax, reinterpret_cast<uint16_t>(stationLoc.x);
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11A], ax;
// LINE 393:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _Tf0;

	__asm        push   0x189;
	__asm        push   0x5B82DC;
	__asm        push   0x5B8300;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tf5;
_Tf0:
	__asm        jmp    _Tf5;
// LINE 394:
_Tf5:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 1;
	__asm        jne    _T11e;

	__asm        push   0x18A;
	__asm        push   0x5B8318;
	__asm        push   0x5B833C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T123;
_T11e:
	__asm        jmp    _T123;
// LINE 395:
_T123:
	__asm        cmp    destGoal1.pRGV, 0;
	__asm        jne    _T149;

	__asm        push   0x18B;
	__asm        push   0x5B8358;
	__asm        push   0x5B837C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T14e;
_T149:
	__asm        jmp    _T14e;
// LINE 396:
_T14e:
	__asm        cmp    stationGoal1.pRGV, 0;
	__asm        jne    _T174;

	__asm        push   0x18C;
	__asm        push   0x5B838C;
	__asm        push   0x5B83B0;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T179;
_T174:
	__asm        jmp    _T179;
// LINE 397:
_T179:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 2;
// LINE 399:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T2ff;
// LINE 406:
// Block start:
	struct Edge* pEdge;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x192];
	__asm        lea    eax, [ecx+ecx*4];
	__asm        add    eax, eax;
	__asm        add    eax, stationGoal1.pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 407:
	__asm        cmp    stationGoal2.pRGV, 0;
	__asm        je     _T23b;
// LINE 409:
// Block start:
	unsigned char yindex;
	__asm        mov    eax, stationGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, stationGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    yindex, al;
// LINE 410:
	__asm        mov    eax, stationGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+1];
	__asm        cmp    ecx, edx;
	__asm        jne    _T21a;

	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        xor    eax, eax;
	__asm        mov    al, yindex;
	__asm        cmp    ecx, eax;
	__asm        jne    _T21a;
// LINE 412:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 1;
// LINE 413:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 415:
	__asm        jmp    _T236;
// LINE 417:
_T21a:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 0;
// LINE 418:
	__asm        lea    esi, stationGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 421:
// Block end:
_T236:
	__asm        jmp    _T257;
// LINE 423:
_T23b:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 1;
// LINE 424:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 429:
_T257:
	__asm        cmp    destGoal2.pRGV, 0;
	__asm        je     _T2e2;
// LINE 431:
// Block start:
	int32_t yindex;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    yindex, ecx;
// LINE 432:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2D];
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax];
	__asm        cmp    ecx, edx;
	__asm        jne    _T2c5;

	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2C];
	__asm        cmp    ecx, yindex;
	__asm        jne    _T2c5;
// LINE 434:
	__asm        mov    eax, this;
	__asm        dec    byte ptr [eax+0x293];
// LINE 436:
	__asm        jmp    _T2dd;
// LINE 438:
_T2c5:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 441:
// Block end:
_T2dd:
	__asm        jmp    _T2fa;
// LINE 443:
_T2e2:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 446:
// Block end:
_T2fa:
	__asm        jmp    _T3e3;
// LINE 451:
_T2ff:
	__asm        cmp    stationGoal1.pRGV, 0;
	__asm        jne    _T32f;

	__asm        cmp    stationGoal2.pRGV, 0;
	__asm        jne    _T32f;

	__asm        push   0x1C3;
	__asm        push   0x5B83C4;
	__asm        push   0x5B83E8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T334;
_T32f:
	__asm        jmp    _T334;
// LINE 452:
_T334:
	__asm        cmp    stationGoal1.pRGV, 0;
	__asm        jne    _T355;
// LINE 454:
	__asm        lea    esi, stationGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 456:
	__asm        jmp    _T3e3;
_T355:
	__asm        cmp    stationGoal2.pRGV, 0;
	__asm        jne    _T376;
// LINE 458:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 461:
	__asm        jmp    _T3e3;
_T376:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    stationGoal1.pRGV, eax;
	__asm        jne    _T39c;
// LINE 463:
	__asm        lea    esi, stationGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 465:
	__asm        jmp    _T3e3;
_T39c:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    stationGoal2.pRGV, eax;
	__asm        jne    _T3c2;
// LINE 467:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 469:
	__asm        jmp    _T3e3;
// LINE 471:
_T3c2:
	__asm        push   0x1D7;
	__asm        push   0x5B8410;
	__asm        push   0x5B8434;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T3e3;

	__asm        jmp    _T3e3;
// LINE 475:
_T3e3:
	__asm        mov    eax, startDir;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE2], eax;
// LINE 477:
	__asm        lea    eax, stationLoc.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 478:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xEA], 0;
// LINE 479:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xEE], 0;
// LINE 480:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TILUT[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 481:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE6];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][1][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 482:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 483:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::MoveAuto;
// LINE 484:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x292], 0;
// LINE 489:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T4e2;
// LINE 492:
_T498:
	__asm        mov    car_type, 0;
// LINE 493:
	__asm        jmp    _T50e;
// LINE 495:
_T4a4:
	__asm        mov    car_type, 1;
// LINE 496:
	__asm        jmp    _T50e;
// LINE 498:
_T4b0:
	__asm        mov    car_type, 2;
// LINE 499:
	__asm        jmp    _T50e;
// LINE 500:
_T4bc:
	__asm        push   0x1F4;
	__asm        push   0x5B843C;
	__asm        push   0x5B8460;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T4dd;

	__asm        jmp    _T4dd;
// LINE 501:
_T4dd:
	__asm        jmp    _T50e;
_T4e2:
	__asm        cmp    dword ptr [ebp-0x2C], 0x11C;
	__asm        je     _T498;

	__asm        cmp    dword ptr [ebp-0x2C], 0x11D;
	__asm        je     _T4a4;

	__asm        cmp    dword ptr [ebp-0x2C], 0x11F;
	__asm        je     _T4b0;

	__asm        jmp    _T4bc;
// LINE 503:
_T50e:
	__asm        mov    eax, this;
	__asm        add    eax, 0x11C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, car_type;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x1A];
	__asm        push   eax;
	__asm        call   S3MapAddCarInfo;
	__asm        add    esp, 0x14;
// LINE 508:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x11D];
	__asm        mov    [ebp-0x20], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x11C];
	__asm        mov    [ebp-0x24], ecx;
// LINE 509:
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x24];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x1C], eax;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        jne    _T594;

	__asm        push   0xA0;
	__asm        push   0x5B57C4;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T599;
_T594:
	__asm        jmp    _T599;
_T599:
	__asm        jmp    near ptr 0x00541F58;

	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 510:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x13E], eax;
// LINE 511:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x142], eax;
// LINE 512:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x146], eax;
// LINE 513:
	__asm        mov    eax, this;
	__asm        add    dword ptr [eax+0x142], 0xA0000;
// LINE 514:
	__asm        mov    eax, this;
	__asm        add    eax, 0x14A;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 515:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11C];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::LinkIconToCell;
// LINE 516:
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::TurnOnStrobe;
// LINE 518:
	__asm        jmp    near ptr 0x00541FED;
}

// FUNCTION: COPTER_D 0x00541ff4
void EmergencyVehicleClass::GoBackToStation() {
	struct Goal startGoal1;
	struct Goal startGoal2;
	struct Goal destGoal1;
	int32_t pathFound;
	struct Goal destGoal2;
	struct _RGIndex destVertex;
	struct _RGIndex startVertex;
	struct Goal result;

// LINE 535:
	__asm        lea    eax, startGoal2.pRGV;
	__asm        push   eax;
	__asm        lea    eax, startGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x7C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x114];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
	__asm        lea    edi, result.pRGV;
	__asm        mov    esi, eax;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 538:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T138;
// LINE 540:
	__asm        lea    eax, destGoal2.pRGV;
	__asm        push   eax;
	__asm        lea    eax, destGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x140];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
// LINE 544:
	__asm        mov    eax, startGoal1.pRGV;
	__asm        mov    al, [eax];
	__asm        mov    startVertex.x, al;
// LINE 545:
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    startVertex.yindex, al;
// LINE 546:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        mov    al, [eax];
	__asm        mov    destVertex.x, al;
// LINE 547:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destVertex.yindex, al;
// LINE 549:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destVertex.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(startVertex.x);
	__asm        push   eax;
	__asm        mov    ecx, 0x5C37F8;
	__asm        call   ShortestPath::BreadthFirstSearch;
	__asm        mov    pathFound, eax;
// LINE 550:
	__asm        cmp    pathFound, 0;
	__asm        jne    _T133;

	__asm        push   0x226;
	__asm        push   0x5B8468;
	__asm        push   0x5B848C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T138;
_T133:
	__asm        jmp    _T138;
// LINE 553:
_T138:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x294];
	__asm        push   eax;
	__asm        push   0xFFFFFFFF;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, result.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal2.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal1.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, startGoal2.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::InitializePlacedVehicleForDispatch;
// LINE 554:
	__asm        jmp    near ptr 0x005421B7;
}

// FUNCTION: COPTER_D 0x005421bc
void EmergencyVehicleClass::CancelEmergencyDispatch() {
// LINE 561:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x294], 2;
// LINE 562:
	__asm        jmp    near ptr 0x005421DA;
}

// FUNCTION: COPTER_D 0x005421df
int32_t EmergencyVehicleClass::AreThereMoreSeats(struct _DYOBJ_INST* carInst) {
// LINE 568:
	__asm        mov    eax, carInst;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        mov    eax, cars[0][eax*4];
	__asm        mov    eax, [eax+0x29C];
	__asm        jmp    near ptr 0x005421FE;
// LINE 569:
}

// FUNCTION: COPTER_D 0x00542203
void EmergencyVehicleClass::FillSeat(struct _DYOBJ_INST* carInst) {
// LINE 574:
	__asm        mov    eax, carInst;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        mov    eax, cars[0][eax*4];
	__asm        cmp    dword ptr [eax+0x29C], 2;
	__asm        jl     near ptr 0x00542224;
// LINE 576:
	__asm        jmp    near ptr 0x00542229;
}

// FUNCTION: COPTER_D 0x0054222e
void EmergencyVehicleClass::AdjustSpeed() {
// LINE 624:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::AdjustSpeed;
// LINE 626:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x294];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T8b;
// LINE 630:
	__asm        jmp    _Tb6;
// LINE 632:
	__asm        push   0x1CCCC;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDE], eax;
// LINE 633:
	__asm        jmp    _Tb6;
// LINE 635:
	__asm        push   0x14000;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDE], eax;
// LINE 636:
	__asm        jmp    _Tb6;
// LINE 638:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xDE], 0;
// LINE 639:
	__asm        jmp    _Tb6;
// LINE 640:
	__asm        jmp    _Tb6;
_T8b:
	__asm        dec    dword ptr [ebp-8];
	__asm        cmp    dword ptr [ebp-8], 4;
	__asm        ja     _Tb6;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    SwitchPointers5513936[0][eax*4];
// Switch pointers
// LINE 641:
_Tb6:
	__asm        jmp    near ptr 0x005422E9;
}

// FUNCTION: COPTER_D 0x005422ee
void EmergencyVehicleClass::PositionIcon() {
	struct VRview pos;

// LINE 666:
	__asm        mov    eax, this;
	__asm        add    eax, 0x14A;
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+edx*4+0x19];
	__asm        shl    eax, 0x11;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 667:
	__asm        mov    eax, this;
	__asm        add    eax, 0x13E;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 668:
	__asm        mov    esi, this;
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x14A;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 669:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x12E];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 670:
	__asm        jmp    near ptr 0x0054236E;
}

// FUNCTION: COPTER_D 0x00542373
enum TurnIndex EmergencyVehicleClass::PickTurnDir(struct Goal* pGoal) {
// LINE 676:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x294], 1;
	__asm        jne    _T2d;
// LINE 677:
	__asm        mov    eax, pGoal;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::PickTurnDir;
	__asm        jmp    _Ta3;
// LINE 680:
_T2d:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x292];
	__asm        cmp    ecx, 0x100;
	__asm        jl     _T60;

	__asm        push   0x2A8;
	__asm        push   0x5B8498;
	__asm        push   0x5B84BC;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T65;
_T60:
	__asm        jmp    _T65;
// LINE 683:
_T65:
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x292];
	__asm        mov    [ebp-4], al;
	__asm        mov    eax, this;
	__asm        inc    byte ptr [eax+0x292];
	__asm        xor    eax, eax;
	__asm        mov    al, [ebp-4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx+0x192];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE2];
	__asm        shl    eax, 4;
	__asm        mov    eax, TILUT[0][0][eax+edx*4];
	__asm        jmp    _Ta3;
// LINE 684:
_Ta3:
}

// FUNCTION: COPTER_D 0x0054241d
void EmergencyVehicleClass::ArriveOnScene() {
// LINE 921:
	__asm        call   clock;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x122], eax;
// LINE 922:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11C];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::UnLinkIconFromCell;
// LINE 923:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11E], 0;
// LINE 924:
	__asm        jmp    near ptr 0x0054245C;
}

// FUNCTION: COPTER_D 0x00542461
void EmergencyVehicleClass::UnLinkIconFromCell(struct _GridCoordinates point) {
	struct _CELL_INFO* cellPointer;

// LINE 945:
	__asm        xor    eax, eax;
	__asm        mov    al, point.x;
	__asm        shl    eax, 0xA;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, point.y;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T49;

	__asm        push   0xA0;
	__asm        push   0x5B57C4;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T4e;
_T49:
	__asm        jmp    _T4e;
_T4e:
	__asm        jmp    near ptr 0x005424B4;

	__asm        mov    eax, [ebp-0xC];
	__asm        mov    cellPointer, eax;
// LINE 946:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T7f;

	__asm        push   0x3B2;
	__asm        push   0x5B84E0;
	__asm        push   0x5B8504;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T84;
_T7f:
	__asm        jmp    _T84;
// LINE 948:
_T84:
	__asm        cmp    cellPointer, 0;
	__asm        je     _T103;
// LINE 950:
// Block start:
	struct _DYOBJ_INST** dyptrptr;
	__asm        mov    eax, cellPointer;
	__asm        add    eax, 0x10;
	__asm        mov    dyptrptr, eax;
// LINE 952:
_T97:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Td6;
// LINE 955:
	__asm        mov    eax, this;
	__asm        add    eax, 0x126;
	__asm        mov    ecx, dyptrptr;
	__asm        cmp    eax, [ecx];
	__asm        jne    _Tc9;
// LINE 958:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x126];
	__asm        mov    ecx, dyptrptr;
	__asm        mov    [ecx], eax;
// LINE 959:
	__asm        jmp    _T108;
// LINE 961:
_Tc9:
	__asm        mov    eax, dyptrptr;
	__asm        mov    eax, [eax];
	__asm        mov    dyptrptr, eax;
// LINE 962:
	__asm        jmp    _T97;
// LINE 963:
_Td6:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _Tfe;

	__asm        push   0x3C3;
	__asm        push   0x5B8510;
	__asm        push   0x5B8534;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T103;
_Tfe:
	__asm        jmp    _T103;
// LINE 965:
// Block end:
_T103:
	__asm        jmp    _T108;
_T108:
}

// FUNCTION: COPTER_D 0x00542570
void EmergencyVehicleClass::LinkIconToCell(struct _GridCoordinates point) {
	struct _CELL_INFO* cellPointer;

// LINE 986:
	__asm        xor    eax, eax;
	__asm        mov    al, point.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, point.x;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T49;

	__asm        push   0xA0;
	__asm        push   0x5B57C4;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T4e;
_T49:
	__asm        jmp    _T4e;
_T4e:
	__asm        jmp    near ptr 0x005425C3;

	__asm        mov    eax, [ebp-8];
	__asm        mov    cellPointer, eax;
// LINE 987:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T7f;

	__asm        push   0x3DB;
	__asm        push   0x5B8540;
	__asm        push   0x5B8564;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T84;
_T7f:
	__asm        jmp    _T84;
// LINE 989:
_T84:
	__asm        cmp    cellPointer, 0;
	__asm        je     _Tb0;
// LINE 991:
	__asm        mov    eax, cellPointer;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x126], eax;
// LINE 992:
	__asm        mov    eax, this;
	__asm        add    eax, 0x126;
	__asm        mov    ecx, cellPointer;
	__asm        mov    [ecx+0x10], eax;
// LINE 994:
	__asm        jmp    _Tb5;
// LINE 996:
_Tb0:
	__asm        jmp    _Tba;
// LINE 998:
_Tb5:
	__asm        jmp    _Tba;
_Tba:
}

// FUNCTION: COPTER_D 0x00542631
void EmergencyVehicleClass::Reset() {
// LINE 1317:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x11A], 0xFF;
// LINE 1318:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x11B], 0xFF;
// LINE 1319:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x11C], 0xFF;
// LINE 1320:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x11D], 0xFF;
// LINE 1321:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11E], 0;
// LINE 1322:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x294], 1;
// LINE 1323:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x122], 0;
// LINE 1324:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x18A], 0;
// LINE 1327:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::Reset;
// LINE 1330:
	__asm        jmp    near ptr 0x005426A6;
}

// FUNCTION: COPTER_D 0x005426ab
void DispatchEmergencyVehicle(int32_t responseType, int32_t responseLevel, long mapx, long mapy) {
	enum EmergencyLevel emergencyLevel;
	enum EmergencyType emergencyType;

// LINE 1353:
	__asm        cmp    mapx, 0x80;
	__asm        jge    _T37;

	__asm        cmp    mapx, 0;
	__asm        jl     _T37;

	__asm        cmp    mapy, 0x80;
	__asm        jge    _T37;

	__asm        cmp    mapy, 0;
	__asm        jge    _T3c;
// LINE 1354:
_T37:
	__asm        jmp    _T145;
// LINE 1356:
_T3c:
	__asm        mov    eax, responseType;
	__asm        mov    emergencyType, eax;
// LINE 1357:
	__asm        mov    eax, responseLevel;
	__asm        mov    emergencyLevel, eax;
// LINE 1359:
	__asm        mov    eax, responseType;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T118;
// LINE 1363:
	__asm        push   0x553;
	__asm        push   0x5B8570;
	__asm        push   0x5B8594;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T74;

	__asm        jmp    _T74;
// LINE 1365:
_T74:
	__asm        jmp    _T140;
// LINE 1370:
	__asm        mov    eax, mapy;
	__asm        push   eax;
	__asm        mov    eax, mapx;
	__asm        push   eax;
	__asm        mov    eax, emergencyLevel;
	__asm        push   eax;
	__asm        mov    eax, emergencyType;
	__asm        push   eax;
	__asm        call   FireEngineClass::Dispatch;
	__asm        add    esp, 0x10;
// LINE 1371:
	__asm        jmp    _T140;
// LINE 1375:
	__asm        mov    eax, mapy;
	__asm        push   eax;
	__asm        mov    eax, mapx;
	__asm        push   eax;
	__asm        mov    eax, emergencyLevel;
	__asm        push   eax;
	__asm        mov    eax, emergencyType;
	__asm        push   eax;
	__asm        call   AmbulanceClass::Dispatch;
	__asm        add    esp, 0x10;
// LINE 1376:
	__asm        jmp    _T140;
// LINE 1381:
	__asm        mov    eax, mapy;
	__asm        push   eax;
	__asm        mov    eax, mapx;
	__asm        push   eax;
	__asm        mov    eax, emergencyLevel;
	__asm        push   eax;
	__asm        mov    eax, emergencyType;
	__asm        push   eax;
	__asm        call   PoliceCarClass::Dispatch;
	__asm        add    esp, 0x10;
// LINE 1382:
	__asm        jmp    _T140;
// LINE 1386:
	__asm        mov    eax, mapy;
	__asm        push   eax;
	__asm        mov    eax, mapx;
	__asm        push   eax;
	__asm        mov    eax, emergencyLevel;
	__asm        push   eax;
	__asm        mov    eax, emergencyType;
	__asm        push   eax;
	__asm        call   PoliceCarClass::Dispatch;
	__asm        add    esp, 0x10;
// LINE 1387:
	__asm        jmp    _T140;
// LINE 1391:
_Ted:
	__asm        push   0x56F;
	__asm        push   0x5B859C;
	__asm        push   0x5B85C0;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T10e;

	__asm        jmp    _T10e;
// LINE 1393:
_T10e:
	__asm        jmp    _T140;
// LINE 1395:
	__asm        jmp    _T140;
_T118:
	__asm        cmp    dword ptr [ebp-0xC], 4;
	__asm        ja     _Ted;

	__asm        mov    eax, [ebp-0xC];
	__asm        jmp    SwitchPointers5515223[0][eax*4];
// Switch pointers
// LINE 1396:
_T140:
	__asm        jmp    _T145;
_T145:
}

// FUNCTION: COPTER_D 0x005427f5
void EmergencyVehicleClass::BuildPath(struct _RGIndex startVertex, struct _RGIndex destVertex) {
	struct _RGIndex index;
	int32_t i;
	struct RGVertex* pRGV;

// LINE 1409:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x293], 1;
// LINE 1411:
	__asm        mov    ax, reinterpret_cast<uint16_t>(destVertex.x);
	__asm        mov    reinterpret_cast<uint16_t>(index.x), ax;
// LINE 1412:
_T1e:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T42;

	__asm        xor    eax, eax;
	__asm        mov    al, index.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        je     _Tc4;
// LINE 1414:
_T42:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, index.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 1415:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+0x2D];
	__asm        mov    index.x, al;
// LINE 1416:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+0x2C];
	__asm        mov    index.yindex, al;
// LINE 1417:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        cmp    eax, 0xFF;
	__asm        je     _T95;

	__asm        xor    eax, eax;
	__asm        mov    al, index.yindex;
	__asm        cmp    eax, 0xFF;
	__asm        jne    _Tb1;
_T95:
	__asm        push   0x589;
	__asm        push   0x5B85C8;
	__asm        push   0x5B85EC;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tb6;
_Tb1:
	__asm        jmp    _Tb6;
// LINE 1418:
_Tb6:
	__asm        mov    eax, this;
	__asm        inc    byte ptr [eax+0x293];
// LINE 1424:
	__asm        jmp    _T1e;
// LINE 1432:
_Tc4:
	__asm        mov    ax, reinterpret_cast<uint16_t>(destVertex.x);
	__asm        mov    reinterpret_cast<uint16_t>(index.x), ax;
// LINE 1433:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x293];
	__asm        sub    ecx, 2;
	__asm        mov    i, ecx;
	__asm        jmp    _Te5;
_Te2:
	__asm        dec    i;
_Te5:
	__asm        cmp    i, 0;
	__asm        jl     _T13a;
// LINE 1436:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, index.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 1437:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+0x2D];
	__asm        mov    index.x, al;
// LINE 1438:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+0x2C];
	__asm        mov    index.yindex, al;
// LINE 1439:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+0x2E];
	__asm        mov    ecx, i;
	__asm        mov    edx, this;
	__asm        mov    [ecx+edx+0x192], al;
// LINE 1440:
	__asm        jmp    _Te2;
// LINE 1441:
_T13a:
	__asm        jmp    near ptr 0x00542934;
}

// FUNCTION: COPTER_D 0x0054293b
void EmergencyVehicleClass::TurnOnStrobe() {
	struct VRFaceInfo finfo;
	int32_t count;
	int32_t face;
	struct VRObjInfo oinfo;

// LINE 1461:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 1462:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1463:
	__asm        mov    count, 0;
	__asm        jmp    _T40;
_T3d:
	__asm        inc    count;
_T40:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T91;
// LINE 1465:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 1466:
	__asm        cmp    finfo.Plotter, 0x19;
	__asm        jne    _T7d;
// LINE 1468:
	__asm        and    finfo.Attribute, 0x7FFFFFFF;
// LINE 1469:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 1471:
_T7d:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1472:
	__asm        jmp    _T3d;
// LINE 1473:
_T91:
	__asm        jmp    near ptr 0x005429D1;
}

// FUNCTION: COPTER_D 0x005429d6
void EmergencyVehicleClass::TurnOffStrobe() {
	struct VRFaceInfo finfo;
	int32_t count;
	int32_t face;
	struct VRObjInfo oinfo;

// LINE 1484:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 1485:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1486:
	__asm        mov    count, 0;
	__asm        jmp    _T40;
_T3d:
	__asm        inc    count;
_T40:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T95;
// LINE 1488:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 1489:
	__asm        cmp    finfo.Plotter, 0x19;
	__asm        jne    _T81;
// LINE 1491:
	__asm        mov    eax, finfo.Attribute;
	__asm        or     eax, 0x80000000;
	__asm        mov    finfo.Attribute, eax;
// LINE 1492:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 1494:
_T81:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1495:
	__asm        jmp    _T3d;
// LINE 1496:
_T95:
	__asm        jmp    near ptr 0x00542A70;
}

// FUNCTION: COPTER_D 0x00542a75
void EmergencyVehicleClass::SetSaveData(struct _AUTO_LOAD_SAVE* sd) {
// LINE 1508:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x11E], ax;
// LINE 1509:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11C];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x120], ax;
// LINE 1510:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11E];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x122], eax;
// LINE 1511:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x122];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x126], eax;
// LINE 1512:
	__asm        mov    esi, this;
	__asm        mov    edi, sd;
	__asm        add    edi, 0x12A;
	__asm        add    esi, 0x126;
	__asm        mov    ecx, 0x19;
	__asm        rep movsd;
// LINE 1513:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18A];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x18E], eax;
// LINE 1514:
	__asm        mov    esi, this;
	__asm        mov    edi, sd;
	__asm        add    edi, 0x196;
	__asm        add    esi, 0x192;
	__asm        mov    ecx, 0x40;
	__asm        rep movsd;
// LINE 1515:
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x292];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x296], al;
// LINE 1516:
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x293];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x297], al;
// LINE 1517:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x294];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x298], eax;
// LINE 1518:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x298];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x29C], eax;
// LINE 1519:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x29C];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x2A0], eax;
// LINE 1520:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     near ptr 0x00542B78;
// LINE 1534:
	__asm        mov    eax, sd;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::SetSaveData;
// LINE 1535:
	__asm        jmp    near ptr 0x00542B89;
}

// FUNCTION: COPTER_D 0x00542b90
void EmergencyVehicleClass::LoadSaveData(struct _AUTO_LOAD_SAVE* sd) {
	int32_t car_type;

// LINE 1548:
	__asm        mov    eax, sd;
	__asm        test   byte ptr [eax], 2;
	__asm        jne    _T1d;
// LINE 1550:
	__asm        jmp    _T1e3;
// LINE 1554:
_T1d:
	__asm        mov    eax, sd;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LoadSaveData;
// LINE 1556:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0x11E];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11A], ax;
// LINE 1557:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0x120];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11C], ax;
// LINE 1558:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x122];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11E], eax;
// LINE 1559:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x126];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x122], eax;
// LINE 1560:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x18E];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x18A], eax;
// LINE 1561:
	__asm        mov    esi, sd;
	__asm        mov    edi, this;
	__asm        add    edi, 0x192;
	__asm        add    esi, 0x196;
	__asm        mov    ecx, 0x40;
	__asm        rep movsd;
// LINE 1562:
	__asm        mov    eax, sd;
	__asm        mov    al, [eax+0x296];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x292], al;
// LINE 1563:
	__asm        mov    eax, sd;
	__asm        mov    al, [eax+0x297];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x293], al;
// LINE 1564:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x298];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x294], eax;
// LINE 1565:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x29C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x298], eax;
// LINE 1566:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x2A0];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x29C], eax;
// LINE 1568:
	__asm        mov    eax, sd;
	__asm        add    eax, 0x142;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x13E;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1569:
	__asm        mov    esi, sd;
	__asm        mov    edi, this;
	__asm        add    edi, 0x14A;
	__asm        add    esi, 0x14E;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1572:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T18c;
// LINE 1575:
_T142:
	__asm        mov    car_type, 0;
// LINE 1576:
	__asm        jmp    _T1b8;
// LINE 1578:
_T14e:
	__asm        mov    car_type, 1;
// LINE 1579:
	__asm        jmp    _T1b8;
// LINE 1581:
_T15a:
	__asm        mov    car_type, 2;
// LINE 1582:
	__asm        jmp    _T1b8;
// LINE 1583:
_T166:
	__asm        push   0x62F;
	__asm        push   0x5B8618;
	__asm        push   0x5B863C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T187;

	__asm        jmp    _T187;
// LINE 1584:
_T187:
	__asm        jmp    _T1b8;
_T18c:
	__asm        cmp    dword ptr [ebp-0xC], 0x11C;
	__asm        je     _T142;

	__asm        cmp    dword ptr [ebp-0xC], 0x11D;
	__asm        je     _T14e;

	__asm        cmp    dword ptr [ebp-0xC], 0x11F;
	__asm        je     _T15a;

	__asm        jmp    _T166;
// LINE 1586:
_T1b8:
	__asm        mov    eax, this;
	__asm        add    eax, 0x11C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, car_type;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x1A];
	__asm        push   eax;
	__asm        call   S3MapAddCarInfo;
	__asm        add    esp, 0x14;
// LINE 1587:
	__asm        jmp    _T1e3;
_T1e3:
}



// Contribution: 1:00141d80-00141db8 Module: 154, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00542d80
// EmergencyVehicleClass::`scalar deleting destructor'



// Contribution: 2:00004480-000044bf Module: 154, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x00593480
const enum TurnIndex TILUT[4][4] = { /* <data@0x00593480> */ };



// Contribution: 2:000044c0-000044e7 Module: 154, 8 byte alignment, initialized_data, (comdat), read, 
// GLOBAL: COPTER_D 0x005934c0
// GLOBAL: COPTER_D 0x005934c0
// ??_7EmergencyVehicleClass@@6B@


// Contribution: 3:00021268-00021641 Module: 154, 4 byte alignment, initialized_data, read, write, 


// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.

// WARNING: this global might actually belong to: C:\Copter\Source\Game\S3rdgrph.cpp
// GLOBAL: COPTER_D 0x0067ed30
struct _CELL_INFO* G_omap[256][256] = { /* <data@0x0067ed30> */ };

