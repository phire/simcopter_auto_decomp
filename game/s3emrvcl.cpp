// Module: S3emrvcl.obj
// Source: C:\Copter\source\game\S3emrvcl.cpp
// autogenerated by simcopter_tool from PDB file

// Type: enum TurnIndex;
enum TurnIndex {
	iTS = 0,
	iTR = 1,
	iTL = 2,
	iTU = 3,
};

// Type: int32_t;

// Type: /*packed*/ class EmergencyVehicleClass (forward reference);
// VTABLE: COPTER_D 0x005934c0
class EmergencyVehicleClass : public AutomobileClass
{ // packed(0x2a0 bytes) TI: 0x47d8
	enum /* __unnamed */ {
		MAXIMUM_DISTANCE_FROM_BASE = 7,
		MAXIMUM_TIME_TO_EMERGENCY = 3932160,
		AMBULANCE_CAPACITY = 2,
	};
protected:
	/*+0x11a*/ /*packed*/ struct _GridCoordinates baseLocation; // 0x2 bytes
	/*+0x11c*/ /*packed*/ struct _GridCoordinates emergencyLocation; // 0x2 bytes
	/*+0x11e*/ enum EmergencyType emergencyType;
	/*+0x122*/ long timeOfArrival;
	/*+0x126*/ /*packed*/ struct _DYOBJ_INST dispatchIcon; // 0x64 bytes
	/*+0x18a*/ int32_t timeToEmergency;
	/*+0x18e*/ /*packed*/ class AutomobileClass *dispatchTarget;
	/*+0x192*/ unsigned char dispatchPath[256]; // 0x100 bytes
	/*+0x292*/ unsigned char dispatchPathIndex; // 0x1 bytes
	/*+0x293*/ unsigned char dispatchPathLength; // 0x1 bytes
	/*+0x294*/ enum EmergencyLevel emergencyState;
	/*+0x298*/ int32_t stationID;
	/*+0x29c*/ int32_t numberOfSeats;
public:
	void EmergencyVehicleClass(const /*packed*/ class EmergencyVehicleClass&);
	void EmergencyVehicleClass();
	virtual void ~EmergencyVehicleClass() /* override */;
	enum EmergencyLevel GetEmergencyState();
	void InitializePlacedVehicleForDispatch(/*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct _GridCoordinates, /*packed*/ struct Goal, enum EmergencyType, enum EmergencyLevel);
	void InitializeStationVehicleForDispatch(int32_t, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct _GridCoordinates, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct _GridCoordinates, int32_t, /*packed*/ struct Goal, enum EmergencyType, enum EmergencyLevel);
	// calltype: NearC
	static int32_t AreThereMoreSeats(/*packed*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static void FillSeat(/*packed*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static int32_t S3UpdateCar(int32_t, int32_t);
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* S3GetCar(int32_t);
	void CancelEmergencyDispatch();
protected:
	virtual void Reset(); // vtable+0x24
	virtual void AdjustSpeed() /* override */;
	virtual enum TurnIndex PickTurnDir(/*packed*/ struct Goal*) /* override */;
	virtual void SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*) /* override */;
	virtual void LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*) /* override */;
	void ArriveOnScene();
	void UnLinkIconFromCell(const /*packed*/ struct _GridCoordinates);
	void LinkIconToCell(const /*packed*/ struct _GridCoordinates);
	void PositionIcon();
	void GoBackToStation();
	void BuildPath(/*packed*/ struct _RGIndex, /*packed*/ struct _RGIndex);
	void TurnOnStrobe();
	void TurnOffStrobe();
	int32_t UpdateCar(int32_t);
	virtual void BeamToWithinCameraRange() /* override */;
public:
	/*packed*/ class EmergencyVehicleClass operator=(const /*packed*/ class EmergencyVehicleClass&);
};

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: void;

// Type: /*packed*/ struct Goal;
struct Goal{ // packed(0x2a bytes) TI: 0x12ce
	/*+0x0*/   /*packed*/ struct RGVertex *pRGV;
	/*+0x4*/   int32_t elementIndex;
	/*+0x8*/   int32_t gridIndex;
	/*+0xc*/   /*packed*/ struct _GridCoordinates gridLoc; // 0x2 bytes
	/*+0xe*/   enum DirIndex2 edgeIndex;
	/*+0x12*/  enum DirIndex2 direction;
	/*+0x16*/  int32_t distance;
	/*+0x1a*/  int32_t turnFlags;
	/*+0x1e*/  int32_t deadEndFlags;
	/*+0x22*/  int32_t fElevated;
	/*+0x26*/  enum SlopeIndex slope;
};

// Type: /*packed*/ struct _GridCoordinates;
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: enum EmergencyType;
enum EmergencyType {
	NO_EMERGENCY = 0,
	FIRE_TRUCK = 1,
	AMBULANCE_CAR = 2,
	POLICE_CHASING_CAR = 3,
	POLICE_ON_PATROL = 4,
};

// Type: enum EmergencyLevel;
enum EmergencyLevel {
	ES_UNDEFINED = 0,
	ES_STAKEOUT = 1,
	ES_RETURN = 2,
	ES_PURSUIT = 3,
	ES_DISPATCHED = 4,
	ES_AT_SCENE = 5,
	ES_COP_CHASE = 6,
};

// Type: /*packed*/ struct _RGIndex;
struct _RGIndex{ // packed(0x2 bytes) TI: 0x2ab2
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char yindex; // 0x1 bytes
};

// Type: /*packed*/ struct Edge (forward reference);
struct Edge{ // packed(0xa bytes) TI: 0x176b
	/*+0x0*/   unsigned char yindex; // 0x1 bytes
	/*+0x1*/   unsigned char x; // 0x1 bytes
	/*+0x2*/   unsigned short Time; // 0x2 bytes
	/*+0x4*/   unsigned short numElementsToPath; // 0x2 bytes
	/*+0x6*/   /*packed*/ struct Road *roadArray;
};

// Type: unsigned char;

// Type: /*packed*/ struct VRview;
struct VRview{ // packed(0x58 bytes) TI: 0x2ecc
	/*+0x0*/   /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0xc*/   /*packed*/ struct Point3d scale; // 0xc bytes
	/*+0x18*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct Goal (forward reference);
struct Goal{ // packed(0x2a bytes) TI: 0x12ce
	/*+0x0*/   /*packed*/ struct RGVertex *pRGV;
	/*+0x4*/   int32_t elementIndex;
	/*+0x8*/   int32_t gridIndex;
	/*+0xc*/   /*packed*/ struct _GridCoordinates gridLoc; // 0x2 bytes
	/*+0xe*/   enum DirIndex2 edgeIndex;
	/*+0x12*/  enum DirIndex2 direction;
	/*+0x16*/  int32_t distance;
	/*+0x1a*/  int32_t turnFlags;
	/*+0x1e*/  int32_t deadEndFlags;
	/*+0x22*/  int32_t fElevated;
	/*+0x26*/  enum SlopeIndex slope;
};

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: long;

// Type: /*packed*/ struct RGVertex (forward reference);
struct RGVertex{ // packed(0x33 bytes) TI: 0x1776
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
	/*+0x2*/   LfBitfield @ 0x11f58:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1771
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 turnFlags;
	/*+0x2*/   LfBitfield @ 0x11f60:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1772
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x4
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 deadEndFlags;
	/*+0x3*/   unsigned char fElevated; // 0x1 bytes
	/*+0x4*/   /*packed*/ struct Edge edge[4]; // 0x28 bytes
	/*+0x2c*/  unsigned char yindexPrev; // 0x1 bytes
	/*+0x2d*/  unsigned char xPrev; // 0x1 bytes
	/*+0x2e*/  unsigned char edgeIndexPrev; // 0x1 bytes
	/*+0x2f*/  int32_t STVisited;
};

// Type: /*packed*/ struct VRFaceInfo;
struct VRFaceInfo{ // packed(0x20 bytes) TI: 0x30c0
	/*+0x0*/   int32_t Face;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Plotter;
	/*+0x10*/  /*packed*/ struct VRBmpHdr *Bitmap;
	/*+0x14*/  int32_t * VertList;
	/*+0x18*/  /*packed*/ struct MapVert *MapVList;
	/*+0x1c*/  /*packed*/ struct MapVert *BarryPtr;
};

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: /*packed*/ struct _AUTO_LOAD_SAVE (forward reference);
struct _AUTO_LOAD_SAVE{ // packed(0x344 bytes) TI: 0x42d7
	/*+0x0*/   int32_t flags;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x68*/  /*packed*/ struct Goal goal; // 0x2a bytes
	/*+0x92*/  /*packed*/ struct _GridCoordinates goalpRGVFixup; // 0x2 bytes
	/*+0x94*/  int32_t DeltaFromCenter;
	/*+0x98*/  int32_t stalledTimer;
	/*+0x9c*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xa8*/  int32_t remainingTime;
	/*+0xac*/  int32_t desiredSpeed;
	/*+0xb0*/  int32_t desiredHiwaySpeed;
	/*+0xb4*/  int32_t beamDelay;
	/*+0xb8*/  int32_t beamTimer;
	/*+0xbc*/  int32_t m_cellBaseY;
	/*+0xc0*/  int32_t timePulledOver;
	/*+0xc4*/  enum DirectionTypes hiwaydir;
	/*+0xc8*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xca*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xcc*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xce*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xd0*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xd2*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
	/*+0xd4*/  int32_t speed;
	/*+0xd8*/  long prevDir;
	/*+0xdc*/  long turnIndex;
	/*+0xe0*/  int32_t currDist;
	/*+0xe4*/  int32_t legOfTurn;
	/*+0xe8*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xec*/  int32_t personDone;
	/*+0xf0*/  int32_t personState;
	/*+0xf4*/  int32_t personTimer;
	/*+0xf8*/  int32_t timeToLive;
	/*+0xfc*/  int32_t fireTime;
	/*+0x100*/ long fireSeq;
	/*+0x104*/ long missionId;
	/*+0x108*/ /*packed*/ struct _GridCoordinates cptrfixup; // 0x2 bytes
	/*+0x10a*/ int32_t spotlightHitCounter;
	struct _AUTO_LOAD_SAVE::_CRIMINAL{ // packed(0x10 bytes) TI: 0x42df
		/*+0x0*/   long missionState;
		/*+0x4*/   long criminalType;
		/*+0x8*/   int32_t timeToLeaveCar;
		/*+0xc*/   int32_t timeToBeOnTheRun;
	};
public:
	/*+0x10e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_CRIMINAL c; // 0x10 bytes
	struct _AUTO_LOAD_SAVE::_EMERGENCY{ // packed(0x186 bytes) TI: 0x42dd
		/*+0x0*/   /*packed*/ struct _GridCoordinates baseLocation; // 0x2 bytes
		/*+0x2*/   /*packed*/ struct _GridCoordinates emergencyLocation; // 0x2 bytes
		/*+0x4*/   long emergencyType;
		/*+0x8*/   long timeOfArrival;
		/*+0xc*/   /*packed*/ struct _DYOBJ_INST dispatchIcon; // 0x64 bytes
		/*+0x70*/  int32_t timeToEmergency;
		/*+0x74*/  long targetfixup;
		/*+0x78*/  unsigned char dispatchPath[256]; // 0x100 bytes
		/*+0x178*/ unsigned char dispatchPathIndex; // 0x1 bytes
		/*+0x179*/ unsigned char dispatchPathLength; // 0x1 bytes
		/*+0x17a*/ long emergencyState;
		/*+0x17e*/ int32_t stationID;
		/*+0x182*/ int32_t numberOfSeats;
	};
public:
	/*+0x11e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_EMERGENCY e; // 0x186 bytes
	struct _AUTO_LOAD_SAVE::_FIRE{ // packed(0x18 bytes) TI: 0x42db
		/*+0x0*/   int32_t dousingFire;
		/*+0x4*/   int32_t distToFire;
		/*+0x8*/   /*packed*/ struct Point3d firevec; // 0xc bytes
		/*+0x14*/  int32_t pathID;
	};
public:
	/*+0x2a4*/ /*packed*/ struct _AUTO_LOAD_SAVE::_FIRE f; // 0x18 bytes
	struct _AUTO_LOAD_SAVE::_POLICE{ // packed(0x88 bytes) TI: 0x42d9
		/*+0x0*/   /*packed*/ struct Goal currDestGoal; // 0x2a bytes
		/*+0x2a*/  /*packed*/ struct _GridCoordinates currpRGVFixup; // 0x2 bytes
		/*+0x2c*/  /*packed*/ struct Goal destGoal1; // 0x2a bytes
		/*+0x56*/  /*packed*/ struct _GridCoordinates dest1pRGVFixup; // 0x2 bytes
		/*+0x58*/  /*packed*/ struct Goal destGoal2; // 0x2a bytes
		/*+0x82*/  /*packed*/ struct _GridCoordinates dest2pRGVFixup; // 0x2 bytes
		/*+0x84*/  int32_t foundRoad;
	};
public:
	/*+0x2bc*/ /*packed*/ struct _AUTO_LOAD_SAVE::_POLICE p; // 0x88 bytes
};

// Type: uint32_t;

// Type: /*packed*/ class AutomobileClass;
// VTABLE: COPTER_D 0x00592d98
class AutomobileClass{ // packed(0x11a bytes) TI: 0x4880
	enum CarType {
		kCarAmbulance = 0,
		kCarCop = 1,
		kCarFiretruck = 2,
		kCarCriminal = 3,
	};
	enum AutoMessageID {
		AM_NO_MESSAGE = 0,
		AM_CANCEL_AUTO_MISSION = 1,
	};
	enum /* __unnamed */ {
		CAR_TYPES = 7,
		PERCENTAGE_OF_AUTO1 = 10,
		PERCENTAGE_OF_AUTO2 = 20,
		PERCENTAGE_OF_AUTO3 = 20,
		PERCENTAGE_OF_AUTO4 = 10,
		PERCENTAGE_OF_AUTO5 = 10,
		PERCENTAGE_OF_AUTO6 = 20,
		PERCENTAGE_OF_AUTO7 = 20,
		TOTAL_PERCENTAGE = 110,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
		DEAD_END_HIWAY = 16,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		AUTO_IN_WAY = 4,
		DEBRIS_IN_WAY = 5,
		UNIDENTIFIED_IN_WAY = 6,
		HELI_IN_WAY = 7,
		END_OF_ROAD = 8,
		END_OF_HIWAY = 9,
		INTERSECTION_FULL = 10,
		BEEN_PULLED_OVER = 11,
	};
	enum RoadTileOffsets {
		RD_CENTOFF = 851968,
		RD_EDGEOFF = 131072,
	};
	enum HiwayOffsets {
		HW_CENTOFF_LANE1 = 851968,
		HW_EDGEOFF_LANE1 = 131072,
		HW_CENTOFF_LANE2 = 851968,
		HW_EDGEOFF_LANE2 = 131072,
		HW_HEIGHT = 2031616,
	};
public:
	static int32_t fireSirenDist;
	static int32_t policeSirenDist;
	static int32_t ambSirenDist;
	static int32_t fireHoseDist;
	enum /* __unnamed */ {
		CAR_RADIUS = 327680,
		COLLISION_SPACE = 655360,
		ROAD_SPEED = 2621440,
		ROAD_SLOWDOWN_FACTOR = 131072,
		HIWAY_SPEED = 6225920,
		HIWAY_SLOWDOWN_FACTOR = 327680,
		SPEED_VARIANCE = 262144,
		HIWAY_VARIANCE = 655360,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
	};
	enum Flags {
		AUTO_INITIALIZED = 1,
		AUTO_PLACED = 2,
		AUTO_NEEDS_TO_PULL_OVER = 4,
		AUTO_PULL_OVER = 8,
		AUTO_PULLING_OVER = 16,
		AUTO_PULLED_OVER = 32,
		AUTO_PULLING_OUT = 64,
		AUTO_IN_INTERSECTION = 128,
		AUTO_ON_FIRE = 256,
		AUTO_JAMMED = 512,
		AUTO_RIGHT_OF_WAY = 1024,
		AUTO_ON_HIWAY = 2048,
		AUTO_SPEEDER = 4096,
		AUTO_SPEEDER_DONE = 8192,
		AUTO_UTURN = 16384,
	};
public:
	/*+0x4*/   long carModel;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x70*/  /*packed*/ struct Goal goal; // 0x2a bytes
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	/*+0x9a*/  int32_t DeltaFromCenter;
	/*+0x9e*/  int32_t stalledTimer;
	/*+0xa2*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xae*/  int32_t remainingTime;
	/*+0xb2*/  int32_t desiredSpeed;
	/*+0xb6*/  int32_t desiredHiwaySpeed;
	/*+0xba*/  int32_t beamDelay;
	/*+0xbe*/  int32_t beamTimer;
	/*+0xc2*/  int32_t m_cellBaseY;
	/*+0xc6*/  int32_t timePulledOver;
	/*+0xca*/  int32_t hornSoundId;
	/*+0xce*/  enum DirectionTypes hiwaydir;
	/*+0xd2*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xd4*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xd6*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xd8*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xda*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xdc*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
protected:
	/*+0xde*/  int32_t speed;
	/*+0xe2*/  enum DirIndex2 prevDir;
	/*+0xe6*/  enum TurnIndex turnIndex;
	/*+0xea*/  int32_t currDist;
	/*+0xee*/  int32_t legOfTurn;
	/*+0xf2*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xf6*/  int32_t personDone;
	/*+0xfa*/  int32_t personState;
	/*+0xfe*/  int32_t personTimer;
	/*+0x102*/ int32_t timeToLive;
	/*+0x106*/ int32_t fireTime;
	/*+0x10a*/ long fireSeq;
	/*+0x10e*/ long missionId;
	/*+0x112*/ /*packed*/ struct _CELL_INFO *cptr;
	/*+0x116*/ int32_t spotlightHitCounter;
	int32_t IsCarPersistant();
	int32_t CanCarBeamToHiwayTile(unsigned short);
public:
	void AutomobileClass(const /*packed*/ class AutomobileClass&);
	void AutomobileClass();
	virtual void ~AutomobileClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class AutomobileClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class AutomobileClass* GetAutoPointer(long);
	// calltype: NearC
	static void DestroyInstance(/*packed*/ class AutomobileClass*);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t MissionStartFire(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static int32_t MissionStartJam(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static void MissionCancel(long);
	// calltype: NearC
	static void SetAllHeadlights(int32_t);
	// calltype: NearC
	static int32_t S3AutoMessage(short, short);
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
	void HitDispatch(long, /*packed*/ struct _DYOBJ_INST*, long, long);
	int32_t AmIABadGuy();
	int32_t Initialize(int32_t);
	void WaterDouse(/*packed*/ struct _DYOBJ_INST*);
	void IveBeenMegaphoned(long);
	void StartFire(long);
	void StartJam(long);
	virtual void PullOver(short); // vtable+0x4
	void PullOut();
	int32_t CanIPullOut();
	int32_t CanIPullOver();
	void DoAUTurn();
	long GetCarModel();
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* GetClosestCar(int32_t, int32_t, int32_t);
protected:
	void Itterate();
	virtual void AdjustSpeed(); // vtable+0x8
	void Reset();
	virtual enum TurnIndex PickTurnDir(/*packed*/ struct Goal*); // vtable+0xc
	void UnPlaceCar();
	void PullOverCiviliansInWay();
	virtual void ItterateFSM(); // vtable+0x10
	int32_t InitializeInstance(int32_t);
	void LinkToCell(const /*packed*/ struct _GridCoordinates&);
	int32_t AreCarsHeadOn(/*packed*/ struct Point3d*);
	enum AutomobileClass::StoppedReasons CollisionCheck(int32_t, /*packed*/ struct _DYOBJ_INST**);
	int32_t IsCarOutOfCameraRange();
	void TurnOffHeadlight();
	void TurnOnHeadlight();
	int32_t AutoMessage(short);
	int32_t PlacePerson(int32_t, int32_t);
	virtual void SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x14
	virtual void LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x18
	void HonkHorn();
	void SetHiwayDirection(unsigned short);
	int32_t DoHiwayTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void AdjustCurrentHiwayPosition();
	void AdjustNextHiwayPosition();
	enum AutomobileClass::IntersectionTypes PickHiwayDir(/*packed*/ struct _GridCoordinates&);
	void MakeAHiwayTurn(enum AutomobileClass::IntersectionTypes);
	void GoStraight();
	void TurnLeft();
	void TurnRight();
	void MoveForwardOnHiway();
	void DoDiagonalRoadFixup();
	virtual void BeamToWithinCameraRange(); // vtable+0x1c
	virtual int32_t BeamToLocation(const /*packed*/ struct _GridCoordinates&); // vtable+0x20
	void MoveAuto(int32_t);
	void ChangeAutoColor();
private:
	void UnlinkFromCell(const /*packed*/ struct _GridCoordinates&);
	void TransitionBetweenGoals();
	void RunFireState();
	void RunJamState();
	void IveBeenSpotlighted(/*packed*/ struct _DYOBJ_INST*);
	int32_t IsThisAnEmergencyVehicle();
	void DoPullOverStuff(int32_t);
	int32_t CanIDoAUTurn();
public:
	/*packed*/ class AutomobileClass operator=(const /*packed*/ class AutomobileClass&);
};



// Contribution: 1:00140530-00141d79 Module: 154, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00541530
int32_t EmergencyVehicleClass::S3UpdateCar(int32_t id, int32_t status) {
// LINE 71:
	__asm        mov    eax, status;
	__asm        push   eax;
	__asm        mov    eax, id;
	__asm        mov    ecx, cars[0][eax*4];
	__asm        call   EmergencyVehicleClass::UpdateCar;
	__asm        jmp    __RETURN;
// LINE 72:
__RETURN:
}

// FUNCTION: COPTER_D 0x00541553
int32_t EmergencyVehicleClass::UpdateCar(int32_t status) {
// LINE 77:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T3c;
// LINE 79:
	this->personDone = 0x1;
// LINE 80:
	this->personState = status;
// LINE 81:
	return 0x1;
// LINE 84:
_T3c:
	return 0x0;
// LINE 85:
}

// FUNCTION: COPTER_D 0x0054159d
/*packed*/ struct _DYOBJ_INST* EmergencyVehicleClass::S3GetCar(int32_t id) {
// LINE 90:
	__asm        mov    eax, id;
	__asm        mov    eax, cars[0][eax*4];
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T2c;
// LINE 92:
	__asm        mov    eax, id;
	__asm        mov    eax, cars[0][eax*4];
	__asm        add    eax, 0xC;
	__asm        jmp    __RETURN;
// LINE 95:
_T2c:
	return 0x0;
// LINE 96:
__RETURN:
}

// FUNCTION: COPTER_D 0x005415d5
void EmergencyVehicleClass::EmergencyVehicleClass() {

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::AutomobileClass;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11E], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x122], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x294], 1;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5934C0;
// LINE 103:
	this->emergencyLocation.x = 0x0;
// LINE 104:
	this->emergencyLocation.y = 0x0;
// LINE 105:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0054163a
void EmergencyVehicleClass::~EmergencyVehicleClass() {

	this-><EmergencyVehicleClass+0x00> = 0x5934c0;
	__asm        jmp    __RETURN;
__RETURN:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::~AutomobileClass;
}

// FUNCTION: COPTER_D 0x00541661
void EmergencyVehicleClass::InitializePlacedVehicleForDispatch(/*packed*/ struct Goal startGoal1, /*packed*/ struct Goal startGoal2, /*packed*/ struct Goal destGoal1, /*packed*/ struct Goal destGoal2, /*packed*/ struct _GridCoordinates destLoc, /*packed*/ struct Goal result, enum EmergencyType responceType, enum EmergencyLevel eState) {
	/*bp-0x4*/   /*packed*/ struct _RGIndex startIndex;
	/*bp-0x8*/   /*packed*/ struct _RGIndex destIndex;

// LINE 261:
	__asm        cmp    responceType, 0xFFFFFFFF;
	__asm        je     _T28;
// LINE 262:
	this->emergencyType = responceType;
// LINE 264:
_T28:
	this->emergencyState = eState;
// LINE 266:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T20e;
// LINE 271:
// Block start:
	/*bp-0xc*/   /*packed*/ struct Edge *pEdge;
	startIndex.x = startGoal1.pRGV->x;
// LINE 272:
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, startIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    startIndex.yindex, al;
// LINE 273:
	destIndex.x = destGoal1.pRGV->x;
// LINE 274:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, destIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destIndex.yindex, al;
// LINE 275:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destIndex.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(startIndex.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::BuildPath;
// LINE 282:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x192];
	__asm        lea    eax, [ecx+ecx*4];
	__asm        add    eax, eax;
	__asm        add    eax, startGoal1.pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 283:
	__asm        cmp    startGoal2.pRGV, 0;
	__asm        je     _T14a;
// LINE 285:
// Block start:
	/*bp-0x10*/  unsigned char yindex;
	__asm        mov    eax, startGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, startGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    yindex, al;
// LINE 286:
	__asm        mov    eax, startGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+1];
	__asm        cmp    ecx, edx;
	__asm        jne    _T129;

	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        xor    eax, eax;
	__asm        mov    al, yindex;
	__asm        cmp    ecx, eax;
	__asm        jne    _T129;
// LINE 288:
	this->dispatchPathIndex = 0x1;
// LINE 289:
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 291:
	__asm        jmp    _T145;
// LINE 293:
_T129:
	this->dispatchPathIndex = 0x0;
// LINE 294:
	__asm        lea    esi, startGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 297:
// Block end:
_T145:
	__asm        jmp    _T166;
// LINE 299:
_T14a:
	this->dispatchPathIndex = 0x1;
// LINE 300:
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 305:
_T166:
	__asm        cmp    destGoal2.pRGV, 0;
	__asm        je     _T1f1;
// LINE 307:
// Block start:
	/*bp-0x14*/  int32_t yindex;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    yindex, ecx;
// LINE 308:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2D];
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax];
	__asm        cmp    ecx, edx;
	__asm        jne    _T1d4;

	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2C];
	__asm        cmp    ecx, yindex;
	__asm        jne    _T1d4;
// LINE 310:
	this->dispatchPathLength--;
// LINE 312:
	__asm        jmp    _T1ec;
// LINE 314:
_T1d4:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 317:
// Block end:
_T1ec:
	__asm        jmp    _T209;
// LINE 319:
_T1f1:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 322:
// Block end:
_T209:
	__asm        jmp    _T2b0;
// LINE 325:
_T20e:
	__asm        cmp    startGoal1.pRGV, 0;
	__asm        jne    _T23e;

	__asm        cmp    startGoal2.pRGV, 0;
	__asm        jne    _T23e;

	__asm        push   0x145;
	__asm        push   0x5B8268;
	__asm        push   0x5B828C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T243;
_T23e:
	__asm        jmp    _T243;
// LINE 326:
_T243:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    startGoal1.pRGV, eax;
	__asm        jne    _T269;
// LINE 328:
	__asm        lea    esi, startGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 330:
	__asm        jmp    _T2b0;
_T269:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    startGoal2.pRGV, eax;
	__asm        jne    _T28f;
// LINE 332:
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 334:
	__asm        jmp    _T2b0;
// LINE 336:
_T28f:
	__asm        push   0x150;
	__asm        push   0x5B82B0;
	__asm        push   0x5B82D4;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T2b0;

	__asm        jmp    _T2b0;
// LINE 343:
_T2b0:
	reinterpret_cast<uint16_t>(this->emergencyLocation.x) = reinterpret_cast<uint16_t>(destLoc.x);
// LINE 345:
	this->currDist = 0x0;
// LINE 346:
	this->legOfTurn = 0x0;
// LINE 347:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TILUT[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 348:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE6];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][1][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 349:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 350:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::MoveAuto;
// LINE 351:
	this->dispatchPathIndex = 0x0;
// LINE 352:
	return;
}

// FUNCTION: COPTER_D 0x005419ba
void EmergencyVehicleClass::InitializeStationVehicleForDispatch(int32_t sID, /*packed*/ struct Goal stationGoal1, /*packed*/ struct Goal stationGoal2, /*packed*/ struct _GridCoordinates stationLoc, /*packed*/ struct Goal destGoal1, /*packed*/ struct Goal destGoal2, /*packed*/ struct _GridCoordinates destLoc, int32_t startDir, /*packed*/ struct Goal result, enum EmergencyType responceType, enum EmergencyLevel eState) {
	/*bp-0x4*/   int32_t car_type;
	/*bp-0x8*/   /*packed*/ struct _RGIndex stationIndex;
	/*bp-0xc*/   /*packed*/ struct _RGIndex destIndex;

// LINE 365:
	this->stationID = sID;
// LINE 368:
	__asm        cmp    responceType, 0xFFFFFFFF;
	__asm        je     _T34;
// LINE 369:
	this->emergencyType = responceType;
// LINE 371:
_T34:
	this->emergencyState = eState;
// LINE 374:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _Ta8;
// LINE 379:
	stationIndex.x = stationGoal1.pRGV->x;
// LINE 380:
	__asm        mov    eax, stationGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, stationIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    stationIndex.yindex, al;
// LINE 381:
	destIndex.x = destGoal1.pRGV->x;
// LINE 382:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        xor    eax, eax;
	__asm        mov    al, destIndex.x;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destIndex.yindex, al;
// LINE 383:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destIndex.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(stationIndex.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::BuildPath;
// LINE 388:
_Ta8:
	reinterpret_cast<uint16_t>(this->emergencyLocation.x) = reinterpret_cast<uint16_t>(destLoc.x);
// LINE 389:
	reinterpret_cast<uint16_t>(this->baseLocation.x) = reinterpret_cast<uint16_t>(stationLoc.x);
// LINE 393:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _Tf0;

	__asm        push   0x189;
	__asm        push   0x5B82DC;
	__asm        push   0x5B8300;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tf5;
_Tf0:
	__asm        jmp    _Tf5;
// LINE 394:
_Tf5:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 1;
	__asm        jne    _T11e;

	__asm        push   0x18A;
	__asm        push   0x5B8318;
	__asm        push   0x5B833C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T123;
_T11e:
	__asm        jmp    _T123;
// LINE 395:
_T123:
	__asm        cmp    destGoal1.pRGV, 0;
	__asm        jne    _T149;

	__asm        push   0x18B;
	__asm        push   0x5B8358;
	__asm        push   0x5B837C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T14e;
_T149:
	__asm        jmp    _T14e;
// LINE 396:
_T14e:
	__asm        cmp    stationGoal1.pRGV, 0;
	__asm        jne    _T174;

	__asm        push   0x18C;
	__asm        push   0x5B838C;
	__asm        push   0x5B83B0;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T179;
_T174:
	__asm        jmp    _T179;
// LINE 397:
_T179:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 2;
// LINE 399:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T2ff;
// LINE 406:
// Block start:
	/*bp-0x10*/  /*packed*/ struct Edge *pEdge;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x192];
	__asm        lea    eax, [ecx+ecx*4];
	__asm        add    eax, eax;
	__asm        add    eax, stationGoal1.pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 407:
	__asm        cmp    stationGoal2.pRGV, 0;
	__asm        je     _T23b;
// LINE 409:
// Block start:
	/*bp-0x14*/  unsigned char yindex;
	__asm        mov    eax, stationGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, stationGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    yindex, al;
// LINE 410:
	__asm        mov    eax, stationGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+1];
	__asm        cmp    ecx, edx;
	__asm        jne    _T21a;

	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        xor    eax, eax;
	__asm        mov    al, yindex;
	__asm        cmp    ecx, eax;
	__asm        jne    _T21a;
// LINE 412:
	this->dispatchPathIndex = 0x1;
// LINE 413:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 415:
	__asm        jmp    _T236;
// LINE 417:
_T21a:
	this->dispatchPathIndex = 0x0;
// LINE 418:
	__asm        lea    esi, stationGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 421:
// Block end:
_T236:
	__asm        jmp    _T257;
// LINE 423:
_T23b:
	this->dispatchPathIndex = 0x1;
// LINE 424:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 429:
_T257:
	__asm        cmp    destGoal2.pRGV, 0;
	__asm        je     _T2e2;
// LINE 431:
// Block start:
	/*bp-0x18*/  int32_t yindex;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    yindex, ecx;
// LINE 432:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2D];
	__asm        mov    eax, destGoal2.pRGV;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax];
	__asm        cmp    ecx, edx;
	__asm        jne    _T2c5;

	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x2C];
	__asm        cmp    ecx, yindex;
	__asm        jne    _T2c5;
// LINE 434:
	this->dispatchPathLength--;
// LINE 436:
	__asm        jmp    _T2dd;
// LINE 438:
_T2c5:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 441:
// Block end:
_T2dd:
	__asm        jmp    _T2fa;
// LINE 443:
_T2e2:
	__asm        mov    al, reinterpret_cast<uint8_t>(destGoal1.edgeIndex);
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x293];
	__asm        mov    ecx, this;
	__asm        mov    [edx+ecx+0x191], al;
// LINE 446:
// Block end:
_T2fa:
	__asm        jmp    _T3e3;
// LINE 451:
_T2ff:
	__asm        cmp    stationGoal1.pRGV, 0;
	__asm        jne    _T32f;

	__asm        cmp    stationGoal2.pRGV, 0;
	__asm        jne    _T32f;

	__asm        push   0x1C3;
	__asm        push   0x5B83C4;
	__asm        push   0x5B83E8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T334;
_T32f:
	__asm        jmp    _T334;
// LINE 452:
_T334:
	__asm        cmp    stationGoal1.pRGV, 0;
	__asm        jne    _T355;
// LINE 454:
	__asm        lea    esi, stationGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 456:
	__asm        jmp    _T3e3;
_T355:
	__asm        cmp    stationGoal2.pRGV, 0;
	__asm        jne    _T376;
// LINE 458:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 461:
	__asm        jmp    _T3e3;
_T376:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    stationGoal1.pRGV, eax;
	__asm        jne    _T39c;
// LINE 463:
	__asm        lea    esi, stationGoal2.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 465:
	__asm        jmp    _T3e3;
_T39c:
	__asm        mov    eax, result.pRGV;
	__asm        cmp    stationGoal2.pRGV, eax;
	__asm        jne    _T3c2;
// LINE 467:
	__asm        lea    esi, stationGoal1.pRGV;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 469:
	__asm        jmp    _T3e3;
// LINE 471:
_T3c2:
	__asm        push   0x1D7;
	__asm        push   0x5B8410;
	__asm        push   0x5B8434;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T3e3;

	__asm        jmp    _T3e3;
// LINE 475:
_T3e3:
	this->prevDir = startDir;
// LINE 477:
	__asm        lea    eax, stationLoc.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 478:
	this->currDist = 0x0;
// LINE 479:
	this->legOfTurn = 0x0;
// LINE 480:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TILUT[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 481:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE6];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][1][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 482:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 483:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::MoveAuto;
// LINE 484:
	this->dispatchPathIndex = 0x0;
// LINE 489:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T4e2;
// LINE 492:
_T498:
	car_type = 0x0;
// LINE 493:
	__asm        jmp    _T50e;
// LINE 495:
_T4a4:
	car_type = 0x1;
// LINE 496:
	__asm        jmp    _T50e;
// LINE 498:
_T4b0:
	car_type = 0x2;
// LINE 499:
	__asm        jmp    _T50e;
// LINE 500:
_T4bc:
	__asm        push   0x1F4;
	__asm        push   0x5B843C;
	__asm        push   0x5B8460;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T4dd;

	__asm        jmp    _T4dd;
// LINE 501:
_T4dd:
	__asm        jmp    _T50e;
_T4e2:
	__asm        cmp    dword ptr [ebp-0x2C], 0x11C;
	__asm        je     _T498;

	__asm        cmp    dword ptr [ebp-0x2C], 0x11D;
	__asm        je     _T4a4;

	__asm        cmp    dword ptr [ebp-0x2C], 0x11F;
	__asm        je     _T4b0;

	__asm        jmp    _T4bc;
// LINE 503:
_T50e:
	__asm        mov    eax, this;
	__asm        add    eax, 0x11C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, car_type;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x1A];
	__asm        push   eax;
	__asm        call   S3MapAddCarInfo;
	__asm        add    esp, 0x14;
// LINE 508:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x11D];
	__asm        mov    [ebp-0x20], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x11C];
	__asm        mov    [ebp-0x24], ecx;
// LINE 509:
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x24];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x1C], eax;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        jne    _T594;

	__asm        push   0xA0;
	__asm        push   0x5B57C4;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T599;
_T594:
	__asm        jmp    _T599;
_T599:
	__asm        jmp    _T59e;
_T59e:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 510:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x13E], eax;
// LINE 511:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x142], eax;
// LINE 512:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x146], eax;
// LINE 513:
	this->dispatchIcon.loc.y += 0xa0000;
// LINE 514:
	__asm        mov    eax, this;
	__asm        add    eax, 0x14A;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 515:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11C];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::LinkIconToCell;
// LINE 516:
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::TurnOnStrobe;
// LINE 518:
	return;
}

// FUNCTION: COPTER_D 0x00541ff4
void EmergencyVehicleClass::GoBackToStation() {
	/*bp-0x2c*/  /*packed*/ struct Goal result; // 0x2a bytes
	/*bp-0x30*/  /*packed*/ struct _RGIndex startVertex;
	/*bp-0x34*/  /*packed*/ struct _RGIndex destVertex;
	/*bp-0x60*/  /*packed*/ struct Goal destGoal2; // 0x2a bytes
	/*bp-0x64*/  int32_t pathFound;
	/*bp-0x90*/  /*packed*/ struct Goal destGoal1; // 0x2a bytes
	/*bp-0xbc*/  /*packed*/ struct Goal startGoal2; // 0x2a bytes
	/*bp-0xe8*/  /*packed*/ struct Goal startGoal1; // 0x2a bytes

// LINE 535:
	__asm        lea    eax, startGoal2.pRGV;
	__asm        push   eax;
	__asm        lea    eax, startGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x7C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x114];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
	__asm        lea    edi, result.pRGV;
	__asm        mov    esi, eax;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 538:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T138;
// LINE 540:
	__asm        lea    eax, destGoal2.pRGV;
	__asm        push   eax;
	__asm        lea    eax, destGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x140];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
// LINE 544:
	startVertex.x = startGoal1.pRGV->x;
// LINE 545:
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    startVertex.yindex, al;
// LINE 546:
	destVertex.x = destGoal1.pRGV->x;
// LINE 547:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destVertex.yindex, al;
// LINE 549:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destVertex.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(startVertex.x);
	__asm        push   eax;
	__asm        mov    ecx, 0x5C37F8;
	__asm        call   ShortestPath::BreadthFirstSearch;
	__asm        mov    pathFound, eax;
// LINE 550:
	__asm        cmp    pathFound, 0;
	__asm        jne    _T133;

	__asm        push   0x226;
	__asm        push   0x5B8468;
	__asm        push   0x5B848C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T138;
_T133:
	__asm        jmp    _T138;
// LINE 553:
_T138:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x294];
	__asm        push   eax;
	__asm        push   0xFFFFFFFF;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, result.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11A];
	__asm        push   eax;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal2.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal1.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, startGoal2.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::InitializePlacedVehicleForDispatch;
// LINE 554:
	return;
}

// FUNCTION: COPTER_D 0x005421bc
void EmergencyVehicleClass::CancelEmergencyDispatch() {
// LINE 561:
	this->emergencyState = 0x2;
// LINE 562:
	return;
}

// FUNCTION: COPTER_D 0x005421df
int32_t EmergencyVehicleClass::AreThereMoreSeats(/*packed*/ struct _DYOBJ_INST *carInst) {
// LINE 568:
	__asm        mov    eax, carInst;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        mov    eax, cars[0][eax*4];
	__asm        mov    eax, [eax+0x29C];
	__asm        jmp    __RETURN;
// LINE 569:
__RETURN:
}

// FUNCTION: COPTER_D 0x00542203
void EmergencyVehicleClass::FillSeat(/*packed*/ struct _DYOBJ_INST *carInst) {
// LINE 574:
	__asm        mov    eax, carInst;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        mov    eax, cars[0][eax*4];
	__asm        cmp    dword ptr [eax+0x29C], 2;
	__asm        jl     _T21;
// LINE 576:
_T21:
	return;
}

// FUNCTION: COPTER_D 0x0054222e
void EmergencyVehicleClass::AdjustSpeed() {
// LINE 624:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::AdjustSpeed;
// LINE 626:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x294];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T8b;
// LINE 630:
_T25:
	__asm        jmp    _Tb6;
// LINE 632:
_T2a:
	__asm        push   0x1CCCC;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDE], eax;
// LINE 633:
	__asm        jmp    _Tb6;
// LINE 635:
_T4f:
	__asm        push   0x14000;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDE], eax;
// LINE 636:
	__asm        jmp    _Tb6;
// LINE 638:
_T74:
	this->speed = 0x0;
// LINE 639:
	__asm        jmp    _Tb6;
// LINE 640:
	__asm        jmp    _Tb6;
_T8b:
	__asm        dec    dword ptr [ebp-8];
	__asm        cmp    dword ptr [ebp-8], 4;
	__asm        ja     _Tb6;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    _Switch_a2[0][eax*4];
// Switch pointers:
//   _T25
//   _T25
//   _T2a
//   _T4f
//   _T74
// LINE 641:
_Tb6:
	return;
}

// FUNCTION: COPTER_D 0x005422ee
void EmergencyVehicleClass::PositionIcon() {
	/*bp-0x58*/  /*packed*/ struct VRview pos; // 0x58 bytes

// LINE 666:
	__asm        mov    eax, this;
	__asm        add    eax, 0x14A;
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+edx*4+0x19];
	__asm        shl    eax, 0x11;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 667:
	__asm        mov    eax, this;
	__asm        add    eax, 0x13E;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 668:
	__asm        mov    esi, this;
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x14A;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 669:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x12E];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 670:
	return;
}

// FUNCTION: COPTER_D 0x00542373
enum TurnIndex EmergencyVehicleClass::PickTurnDir(/*packed*/ struct Goal *pGoal) {
// LINE 676:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x294], 1;
	__asm        jne    _T2d;
// LINE 677:
	__asm        mov    eax, pGoal;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::PickTurnDir;
	__asm        jmp    __RETURN;
// LINE 680:
_T2d:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x292];
	__asm        cmp    ecx, 0x100;
	__asm        jl     _T60;

	__asm        push   0x2A8;
	__asm        push   0x5B8498;
	__asm        push   0x5B84BC;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T65;
_T60:
	__asm        jmp    _T65;
// LINE 683:
_T65:
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x292];
	__asm        mov    [ebp-4], al;
	__asm        mov    eax, this;
	__asm        inc    byte ptr [eax+0x292];
	__asm        xor    eax, eax;
	__asm        mov    al, [ebp-4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx+0x192];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE2];
	__asm        shl    eax, 4;
	__asm        mov    eax, TILUT[0][0][eax+edx*4];
	__asm        jmp    __RETURN;
// LINE 684:
__RETURN:
}

// FUNCTION: COPTER_D 0x0054241d
void EmergencyVehicleClass::ArriveOnScene() {
// LINE 921:
	this->timeOfArrival = clock();
// LINE 922:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x11C];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   EmergencyVehicleClass::UnLinkIconFromCell;
// LINE 923:
	this->emergencyType = 0x0;
// LINE 924:
	return;
}

// FUNCTION: COPTER_D 0x00542461
void EmergencyVehicleClass::UnLinkIconFromCell(/*packed*/ struct _GridCoordinates point) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 945:
	__asm        xor    eax, eax;
	__asm        mov    al, point.x;
	__asm        shl    eax, 0xA;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, point.y;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T49;

	__asm        push   0xA0;
	__asm        push   0x5B57C4;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T4e;
_T49:
	__asm        jmp    _T4e;
_T4e:
	__asm        jmp    _T53;
_T53:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    cellPointer, eax;
// LINE 946:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T7f;

	__asm        push   0x3B2;
	__asm        push   0x5B84E0;
	__asm        push   0x5B8504;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T84;
_T7f:
	__asm        jmp    _T84;
// LINE 948:
_T84:
	__asm        cmp    cellPointer, 0;
	__asm        je     _T103;
// LINE 950:
// Block start:
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST **dyptrptr;
	dyptrptr = (cellPointer + 0x10);
// LINE 952:
_T97:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Td6;
// LINE 955:
	__asm        mov    eax, this;
	__asm        add    eax, 0x126;
	__asm        mov    ecx, dyptrptr;
	__asm        cmp    eax, [ecx];
	__asm        jne    _Tc9;
// LINE 958:
	dyptrptr-> = this->dispatchIcon.next;
// LINE 959:
	return;
// LINE 961:
_Tc9:
	dyptrptr = dyptrptr->;
// LINE 962:
	__asm        jmp    _T97;
// LINE 963:
_Td6:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _Tfe;

	__asm        push   0x3C3;
	__asm        push   0x5B8510;
	__asm        push   0x5B8534;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T103;
_Tfe:
	__asm        jmp    _T103;
// LINE 965:
// Block end:
_T103:
	return;
}

// FUNCTION: COPTER_D 0x00542570
void EmergencyVehicleClass::LinkIconToCell(/*packed*/ struct _GridCoordinates point) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 986:
	__asm        xor    eax, eax;
	__asm        mov    al, point.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, point.x;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T49;

	__asm        push   0xA0;
	__asm        push   0x5B57C4;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T4e;
_T49:
	__asm        jmp    _T4e;
_T4e:
	__asm        jmp    _T53;
_T53:
	__asm        mov    eax, [ebp-8];
	__asm        mov    cellPointer, eax;
// LINE 987:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T7f;

	__asm        push   0x3DB;
	__asm        push   0x5B8540;
	__asm        push   0x5B8564;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T84;
_T7f:
	__asm        jmp    _T84;
// LINE 989:
_T84:
	__asm        cmp    cellPointer, 0;
	__asm        je     _Tb0;
// LINE 991:
	this->dispatchIcon.next = cellPointer->dyptr;
// LINE 992:
	cellPointer->dyptr = (this + 0x126);
// LINE 994:
	__asm        jmp    _Tb5;
// LINE 996:
_Tb0:
	return;
// LINE 998:
_Tb5:
	return;
}

// FUNCTION: COPTER_D 0x00542631
void EmergencyVehicleClass::Reset() {
// LINE 1317:
	this->baseLocation.x = 0xff;
// LINE 1318:
	this->baseLocation.y = 0xff;
// LINE 1319:
	this->emergencyLocation.x = 0xff;
// LINE 1320:
	this->emergencyLocation.y = 0xff;
// LINE 1321:
	this->emergencyType = 0x0;
// LINE 1322:
	this->emergencyState = 0x1;
// LINE 1323:
	this->timeOfArrival = 0x0;
// LINE 1324:
	this->timeToEmergency = 0x0;
// LINE 1327:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::Reset;
// LINE 1330:
	return;
}

// FUNCTION: COPTER_D 0x005426ab
void DispatchEmergencyVehicle(int32_t responseType, int32_t responseLevel, long mapx, long mapy) {
	/*bp-0x4*/   enum EmergencyType emergencyType;
	/*bp-0x8*/   enum EmergencyLevel emergencyLevel;

// LINE 1353:
	__asm        cmp    mapx, 0x80;
	__asm        jge    _T37;

	__asm        cmp    mapx, 0;
	__asm        jl     _T37;

	__asm        cmp    mapy, 0x80;
	__asm        jge    _T37;

	__asm        cmp    mapy, 0;
	__asm        jge    _T3c;
// LINE 1354:
_T37:
	return;
// LINE 1356:
_T3c:
	emergencyType = responseType;
// LINE 1357:
	emergencyLevel = responseLevel;
// LINE 1359:
	__asm        mov    eax, responseType;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T118;
// LINE 1363:
_T53:
	__asm        push   0x553;
	__asm        push   0x5B8570;
	__asm        push   0x5B8594;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T74;

	__asm        jmp    _T74;
// LINE 1365:
_T74:
	__asm        jmp    _T140;
// LINE 1370:
_T79:
	FireEngineClass::Dispatch(mapy, mapx, emergencyLevel, emergencyType);
// LINE 1371:
	__asm        jmp    _T140;
// LINE 1375:
_T96:
	AmbulanceClass::Dispatch(mapy, mapx, emergencyLevel, emergencyType);
// LINE 1376:
	__asm        jmp    _T140;
// LINE 1381:
_Tb3:
	PoliceCarClass::Dispatch(mapy, mapx, emergencyLevel, emergencyType);
// LINE 1382:
	__asm        jmp    _T140;
// LINE 1386:
_Td0:
	PoliceCarClass::Dispatch(mapy, mapx, emergencyLevel, emergencyType);
// LINE 1387:
	__asm        jmp    _T140;
// LINE 1391:
_Ted:
	__asm        push   0x56F;
	__asm        push   0x5B859C;
	__asm        push   0x5B85C0;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T10e;

	__asm        jmp    _T10e;
// LINE 1393:
_T10e:
	__asm        jmp    _T140;
// LINE 1395:
	__asm        jmp    _T140;
_T118:
	__asm        cmp    dword ptr [ebp-0xC], 4;
	__asm        ja     _Ted;

	__asm        mov    eax, [ebp-0xC];
	__asm        jmp    _Switch_12c[0][eax*4];
// Switch pointers:
//   _T53
//   _T79
//   _T96
//   _Td0
//   _Tb3
// LINE 1396:
_T140:
	return;
}

// FUNCTION: COPTER_D 0x005427f5
void EmergencyVehicleClass::BuildPath(/*packed*/ struct _RGIndex startVertex, /*packed*/ struct _RGIndex destVertex) {
	/*bp-0x4*/   /*packed*/ struct RGVertex *pRGV;
	/*bp-0x8*/   int32_t i;
	/*bp-0xc*/   /*packed*/ struct _RGIndex index;

// LINE 1409:
	this->dispatchPathLength = 0x1;
// LINE 1411:
	reinterpret_cast<uint16_t>(index.x) = reinterpret_cast<uint16_t>(destVertex.x);
// LINE 1412:
_T1e:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T42;

	__asm        xor    eax, eax;
	__asm        mov    al, index.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        je     _Tc4;
// LINE 1414:
_T42:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, index.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 1415:
	index.x = pRGV->xPrev;
// LINE 1416:
	index.yindex = pRGV->yindexPrev;
// LINE 1417:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        cmp    eax, 0xFF;
	__asm        je     _T95;

	__asm        xor    eax, eax;
	__asm        mov    al, index.yindex;
	__asm        cmp    eax, 0xFF;
	__asm        jne    _Tb1;
_T95:
	__asm        push   0x589;
	__asm        push   0x5B85C8;
	__asm        push   0x5B85EC;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tb6;
_Tb1:
	__asm        jmp    _Tb6;
// LINE 1418:
_Tb6:
	this->dispatchPathLength++;
// LINE 1424:
	__asm        jmp    _T1e;
// LINE 1432:
_Tc4:
	reinterpret_cast<uint16_t>(index.x) = reinterpret_cast<uint16_t>(destVertex.x);
// LINE 1433:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x293];
	__asm        sub    ecx, 2;
	__asm        mov    i, ecx;
	__asm        jmp    _Te5;
_Te2:
	i--;
_Te5:
	__asm        cmp    i, 0;
	__asm        jl     _T13a;
// LINE 1436:
	__asm        xor    eax, eax;
	__asm        mov    al, index.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, index.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 1437:
	index.x = pRGV->xPrev;
// LINE 1438:
	index.yindex = pRGV->yindexPrev;
// LINE 1439:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+0x2E];
	__asm        mov    ecx, i;
	__asm        mov    edx, this;
	__asm        mov    [ecx+edx+0x192], al;
// LINE 1440:
	__asm        jmp    _Te2;
// LINE 1441:
_T13a:
	return;
}

// FUNCTION: COPTER_D 0x0054293b
void EmergencyVehicleClass::TurnOnStrobe() {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  int32_t face;
	/*bp-0x2c*/  int32_t count;
	/*bp-0x4c*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes

// LINE 1461:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 1462:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1463:
	count = 0x0;
	__asm        jmp    _T40;
_T3d:
	count++;
_T40:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T91;
// LINE 1465:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 1466:
	__asm        cmp    finfo.Plotter, 0x19;
	__asm        jne    _T7d;
// LINE 1468:
	__asm        and    finfo.Attribute, 0x7FFFFFFF;
// LINE 1469:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 1471:
_T7d:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1472:
	__asm        jmp    _T3d;
// LINE 1473:
_T91:
	return;
}

// FUNCTION: COPTER_D 0x005429d6
void EmergencyVehicleClass::TurnOffStrobe() {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  int32_t face;
	/*bp-0x2c*/  int32_t count;
	/*bp-0x4c*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes

// LINE 1484:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 1485:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1486:
	count = 0x0;
	__asm        jmp    _T40;
_T3d:
	count++;
_T40:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T95;
// LINE 1488:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 1489:
	__asm        cmp    finfo.Plotter, 0x19;
	__asm        jne    _T81;
// LINE 1491:
	__asm        mov    eax, finfo.Attribute;
	__asm        or     eax, 0x80000000;
	__asm        mov    finfo.Attribute, eax;
// LINE 1492:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 1494:
_T81:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 1495:
	__asm        jmp    _T3d;
// LINE 1496:
_T95:
	return;
}

// FUNCTION: COPTER_D 0x00542a75
void EmergencyVehicleClass::SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE *sd) {
// LINE 1508:
	reinterpret_cast<uint16_t>(sd->e.baseLocation.x) = reinterpret_cast<uint16_t>(this->baseLocation.x);
// LINE 1509:
	reinterpret_cast<uint16_t>(sd->e.emergencyLocation.x) = reinterpret_cast<uint16_t>(this->emergencyLocation.x);
// LINE 1510:
	sd->e.emergencyType = this->emergencyType;
// LINE 1511:
	sd->e.timeOfArrival = this->timeOfArrival;
// LINE 1512:
	__asm        mov    esi, this;
	__asm        mov    edi, sd;
	__asm        add    edi, 0x12A;
	__asm        add    esi, 0x126;
	__asm        mov    ecx, 0x19;
	__asm        rep movsd;
// LINE 1513:
	sd->e.timeToEmergency = this->timeToEmergency;
// LINE 1514:
	__asm        mov    esi, this;
	__asm        mov    edi, sd;
	__asm        add    edi, 0x196;
	__asm        add    esi, 0x192;
	__asm        mov    ecx, 0x40;
	__asm        rep movsd;
// LINE 1515:
	sd->e.dispatchPathIndex = this->dispatchPathIndex;
// LINE 1516:
	sd->e.dispatchPathLength = this->dispatchPathLength;
// LINE 1517:
	sd->e.emergencyState = this->emergencyState;
// LINE 1518:
	sd->e.stationID = this->stationID;
// LINE 1519:
	sd->e.numberOfSeats = this->numberOfSeats;
// LINE 1520:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T103;
// LINE 1534:
_T103:
	__asm        mov    eax, sd;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::SetSaveData;
// LINE 1535:
	return;
}

// FUNCTION: COPTER_D 0x00542b90
void EmergencyVehicleClass::LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE *sd) {
	/*bp-0x4*/   int32_t car_type;

// LINE 1548:
	__asm        mov    eax, sd;
	__asm        test   byte ptr [eax], 2;
	__asm        jne    _T1d;
// LINE 1550:
	return;
// LINE 1554:
_T1d:
	__asm        mov    eax, sd;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LoadSaveData;
// LINE 1556:
	reinterpret_cast<uint16_t>(this->baseLocation.x) = reinterpret_cast<uint16_t>(sd->e.baseLocation.x);
// LINE 1557:
	reinterpret_cast<uint16_t>(this->emergencyLocation.x) = reinterpret_cast<uint16_t>(sd->e.emergencyLocation.x);
// LINE 1558:
	this->emergencyType = sd->e.emergencyType;
// LINE 1559:
	this->timeOfArrival = sd->e.timeOfArrival;
// LINE 1560:
	this->timeToEmergency = sd->e.timeToEmergency;
// LINE 1561:
	__asm        mov    esi, sd;
	__asm        mov    edi, this;
	__asm        add    edi, 0x192;
	__asm        add    esi, 0x196;
	__asm        mov    ecx, 0x40;
	__asm        rep movsd;
// LINE 1562:
	this->dispatchPathIndex = sd->e.dispatchPathIndex;
// LINE 1563:
	this->dispatchPathLength = sd->e.dispatchPathLength;
// LINE 1564:
	this->emergencyState = sd->e.emergencyState;
// LINE 1565:
	this->stationID = sd->e.stationID;
// LINE 1566:
	this->numberOfSeats = sd->e.numberOfSeats;
// LINE 1568:
	__asm        mov    eax, sd;
	__asm        add    eax, 0x142;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x13E;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1569:
	__asm        mov    esi, sd;
	__asm        mov    edi, this;
	__asm        add    edi, 0x14A;
	__asm        add    esi, 0x14E;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1572:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T18c;
// LINE 1575:
_T142:
	car_type = 0x0;
// LINE 1576:
	__asm        jmp    _T1b8;
// LINE 1578:
_T14e:
	car_type = 0x1;
// LINE 1579:
	__asm        jmp    _T1b8;
// LINE 1581:
_T15a:
	car_type = 0x2;
// LINE 1582:
	__asm        jmp    _T1b8;
// LINE 1583:
_T166:
	__asm        push   0x62F;
	__asm        push   0x5B8618;
	__asm        push   0x5B863C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T187;

	__asm        jmp    _T187;
// LINE 1584:
_T187:
	__asm        jmp    _T1b8;
_T18c:
	__asm        cmp    dword ptr [ebp-0xC], 0x11C;
	__asm        je     _T142;

	__asm        cmp    dword ptr [ebp-0xC], 0x11D;
	__asm        je     _T14e;

	__asm        cmp    dword ptr [ebp-0xC], 0x11F;
	__asm        je     _T15a;

	__asm        jmp    _T166;
// LINE 1586:
_T1b8:
	__asm        mov    eax, this;
	__asm        add    eax, 0x11C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, car_type;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x1A];
	__asm        push   eax;
	__asm        call   S3MapAddCarInfo;
	__asm        add    esp, 0x14;
// LINE 1587:
	return;
}



// Contribution: 1:00141d80-00141db8 Module: 154, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00542d80
// EmergencyVehicleClass::`scalar deleting destructor'



// Contribution: 2:00004480-000044bf Module: 154, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x00593480
static const enum TurnIndex TILUT[4][4] = { 0 /* todo */ };



// Contribution: 2:000044c0-000044e7 Module: 154, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for EmergencyVehicleClass @ 0x005934c0
//   00: EmergencyVehicleClass::`scalar deleting destructor' @ 0x00542d80
//   01: AutomobileClass::PullOver @ 0x005048cd
//   02: EmergencyVehicleClass::AdjustSpeed @ 0x0054222e
//   03: EmergencyVehicleClass::PickTurnDir @ 0x00542373
//   04: AutomobileClass::ItterateFSM @ 0x005022b0
//   05: EmergencyVehicleClass::SetSaveData @ 0x00542a75
//   06: EmergencyVehicleClass::LoadSaveData @ 0x00542b90
//   07: EmergencyVehicleClass::BeamToWithinCameraRange @ 0x005360a0
//   08: AutomobileClass::BeamToLocation @ 0x005030aa
//   09: EmergencyVehicleClass::Reset @ 0x00542631
//   10 entries



// Contribution: 3:00021268-00021641 Module: 154, 4 byte alignment, initialized_data, read, write, 


// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.

// WARNING: this global might actually belong to: C:\Copter\Source\Game\S3rdgrph.cpp
// GLOBAL: COPTER_D 0x0067ed30
/*packed*/ struct _CELL_INFO *G_omap[256][256]; // Contrib missing

