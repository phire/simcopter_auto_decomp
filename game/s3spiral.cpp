// Module: S3spiral.obj
// Source: C:\Copter\Source\Game\S3spiral.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class SpiralScan (forward reference);
class SpiralScan{ // packed(0x10 bytes) TI: 0x2fb5
public:
	void SpiralScan(int32_t);
	void ~SpiralScan();
	int32_t Next(/*packed*/ struct _GridCoordinates&);
	int32_t InCityGridLimits(/*packed*/ struct _GridCoordinates);
private:
	/*+0x0*/   int32_t currDist;
	/*+0x4*/   int32_t currDir;
	/*+0x8*/   int32_t currDia;
	/*+0xc*/   int32_t maxDia;
};

// Type: int32_t;

// Type: void;

// Type: /*packed*/ struct _GridCoordinates (forward reference);
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: /*packed*/ struct _GridCoordinates;
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};



// Contribution: 1:00141dc0-00141f77 Module: 153, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00542dc0
void SpiralScan::SpiralScan(int32_t radius) {
// LINE 10:
	this->currDist = 0x0;
// LINE 11:
	this->currDir = 0x0;
// LINE 12:
	this->currDia = 0x1;
// LINE 13:
	this->maxDia = (radius + radius);
// LINE 14:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00542e03
int32_t SpiralScan::Next(/*packed*/ struct _GridCoordinates& currLoc) {
// LINE 21:
_T0c:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xC];
	__asm        cmp    [eax+8], ecx;
	__asm        jle    _T25;
// LINE 23:
	return 0x0;
// LINE 27:
_T25:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+8], ecx;
	__asm        jg     _T74;
// LINE 29:
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+4];
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        mov    [ebp-4], eax;
	__asm        mov    eax, [ebp-4];
	__asm        and    dword ptr [eax], 3;
// LINE 30:
	this->currDist = 0x0;
// LINE 32:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T6e;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 2;
	__asm        jne    _T74;
// LINE 33:
_T6e:
	this->currDia++;
// LINE 37:
_T74:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Tb1;
// LINE 39:
_T82:
	__asm        mov    eax, currLoc;
	__asm        dec    byte ptr [eax+1];
	__asm        jmp    _Td5;
// LINE 40:
_T8d:
	__asm        mov    eax, currLoc;
	__asm        inc    byte ptr [eax];
	__asm        jmp    _Td5;
// LINE 41:
_T97:
	__asm        mov    eax, currLoc;
	__asm        inc    byte ptr [eax+1];
	__asm        jmp    _Td5;
// LINE 42:
_Ta2:
	__asm        mov    eax, currLoc;
	__asm        dec    byte ptr [eax];
	__asm        jmp    _Td5;
// LINE 43:
	__asm        jmp    _Td5;
_Tb1:
	__asm        cmp    dword ptr [ebp-0xC], 3;
	__asm        ja     _Td5;

	__asm        mov    eax, [ebp-0xC];
	__asm        jmp    _Switch_c5[0][eax*4];
// Switch pointers:
//   _T82
//   _T8d
//   _T97
//   _Ta2
// LINE 44:
_Td5:
	this->currDist++;
// LINE 46:
	__asm        mov    eax, currLoc;
	__asm        mov    ax, [eax];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   SpiralScan::InCityGridLimits;
	__asm        test   eax, eax;
	__asm        je     _T0c;
// LINE 48:
	return 0x1;
// LINE 49:
}

// FUNCTION: COPTER_D 0x00542f05
int32_t SpiralScan::InCityGridLimits(/*packed*/ struct _GridCoordinates currLoc) {
// LINE 53:
	__asm        xor    eax, eax;
	__asm        mov    al, currLoc.x;
	__asm        cmp    eax, 0x80;
	__asm        jl     _T23;

	return 0x0;
// LINE 54:
_T23:
	__asm        xor    eax, eax;
	__asm        mov    al, currLoc.x;
	__asm        test   eax, eax;
	__asm        jge    _T37;

	return 0x0;
// LINE 55:
_T37:
	__asm        xor    eax, eax;
	__asm        mov    al, currLoc.y;
	__asm        cmp    eax, 0x80;
	__asm        jl     _T4e;

	return 0x0;
// LINE 56:
_T4e:
	__asm        xor    eax, eax;
	__asm        mov    al, currLoc.y;
	__asm        test   eax, eax;
	__asm        jge    _T62;

	return 0x0;
// LINE 58:
_T62:
	return 0x1;
// LINE 59:
}

