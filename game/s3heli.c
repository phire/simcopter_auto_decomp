// Module: S3heli.obj
// Source: C:\Copter\source\game\S3heli.c
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ struct _HELI_DATA (forward reference);
struct _HELI_DATA{ // packed(0x32c bytes) TI: 0x2a68
	/*+0x0*/   int32_t type;
	/*+0x4*/   int32_t state;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   int32_t altdelta;
	/*+0x10*/  /*packed*/ struct Point2d lastpos; // 0x8 bytes
	/*+0x18*/  /*packed*/ struct Point2d currpos; // 0x8 bytes
	/*+0x20*/  int32_t rotor_mat[4][4]; // 0x40 bytes
	/*+0x60*/  int32_t rotortl_mat[4][4]; // 0x40 bytes
	/*+0xa0*/  /*packed*/ struct _DYOBJ_INST *dycannon;
	/*+0xa4*/  /*packed*/ struct _DYOBJ_INST *dyheli;
	/*+0xa8*/  /*packed*/ struct _DYOBJ_INST *dyshadow;
	/*+0xac*/  /*packed*/ struct _DYOBJ_INST *dyrotor;
	/*+0xb0*/  /*packed*/ struct _DYOBJ_INST *dyrotortl;
	/*+0xb4*/  /*packed*/ struct _DYOBJ_INST *dyrotshadow;
	/*+0xb8*/  /*packed*/ struct _DYOBJ_INST *dyrope;
	/*+0xbc*/  /*packed*/ struct _DYOBJ_INST *dybucket;
	/*+0xc0*/  /*packed*/ struct _DYOBJ_INST *dyspot;
	/*+0xc4*/  /*packed*/ struct _DYOBJ_INST *dybracket;
	/*+0xc8*/  void * __ptr32 bucketmesh;
	/*+0xcc*/  void * __ptr32 harnessmesh;
	/*+0xd0*/  int32_t damage;
	/*+0xd4*/  int32_t smokeseq;
	/*+0xd8*/  /*packed*/ struct mv heli_p; // 0x14 bytes
	/*+0xec*/  /*packed*/ struct mv heli_r; // 0x14 bytes
	/*+0x100*/ /*packed*/ struct Point3d vector; // 0xc bytes
	/*+0x10c*/ int32_t yaw;
	/*+0x110*/ int32_t collide_delay;
	/*+0x114*/ int32_t roll;
	/*+0x118*/ int32_t slide;
	/*+0x11c*/ int32_t pitch;
	/*+0x120*/ int32_t yawrate;
	/*+0x124*/ int32_t yspeed;
	/*+0x128*/ int32_t fwd_speed;
	/*+0x12c*/ int32_t delta_fwd_speed;
	/*+0x130*/ int32_t movex;
	/*+0x134*/ int32_t movez;
	/*+0x138*/ int32_t hover_ht;
	/*+0x13c*/ int32_t can_land;
	/*+0x140*/ long spotlevel;
	/*+0x144*/ int32_t rotstate;
	/*+0x148*/ int32_t rotspeed;
	/*+0x14c*/ int32_t fireprojectile;
	/*+0x150*/ int32_t terralt;
	/*+0x154*/ int32_t buildalt;
	/*+0x158*/ /*packed*/ struct Point3d collisvec; // 0xc bytes
	/*+0x164*/ int32_t shad_color;
	/*+0x168*/ /*packed*/ struct _MISSILE_DATA *crash_traj;
	/*+0x16c*/ int32_t crash_timer;
	/*+0x170*/ long crash_seq;
	/*+0x174*/ int32_t over_water;
	/*+0x178*/ /*packed*/ struct _ROPE_DATA rinfo; // 0x44 bytes
	/*+0x1bc*/ /*packed*/ struct _WATER_DATA winfo; // 0x8 bytes
	/*+0x1c4*/ /*packed*/ struct tagHeliPassengerData passengerData; // 0x15c bytes
	/*+0x320*/ int32_t fuel;
	/*+0x324*/ int32_t flight_time;
	/*+0x328*/ int32_t pct_load;
};

// Type: /*unpacked*/ struct _HELI_DATA (forward reference);
struct _HELI_DATA{ // not packed(0x32c bytes) TI: 0x390f
	/*+0x0*/   int32_t type;
	/*+0x4*/   int32_t state;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   int32_t altdelta;
	/*+0x10*/  /*unpacked*/ struct Point2d lastpos; // 0x8 bytes
	/*+0x18*/  /*unpacked*/ struct Point2d currpos; // 0x8 bytes
	/*+0x20*/  int32_t rotor_mat[4][4]; // 0x40 bytes
	/*+0x60*/  int32_t rotortl_mat[4][4]; // 0x40 bytes
	/*+0xa0*/  /*unpacked*/ struct _DYOBJ_INST *dycannon;
	/*+0xa4*/  /*unpacked*/ struct _DYOBJ_INST *dyheli;
	/*+0xa8*/  /*unpacked*/ struct _DYOBJ_INST *dyshadow;
	/*+0xac*/  /*unpacked*/ struct _DYOBJ_INST *dyrotor;
	/*+0xb0*/  /*unpacked*/ struct _DYOBJ_INST *dyrotortl;
	/*+0xb4*/  /*unpacked*/ struct _DYOBJ_INST *dyrotshadow;
	/*+0xb8*/  /*unpacked*/ struct _DYOBJ_INST *dyrope;
	/*+0xbc*/  /*unpacked*/ struct _DYOBJ_INST *dybucket;
	/*+0xc0*/  /*unpacked*/ struct _DYOBJ_INST *dyspot;
	/*+0xc4*/  /*unpacked*/ struct _DYOBJ_INST *dybracket;
	/*+0xc8*/  void * __ptr32 bucketmesh;
	/*+0xcc*/  void * __ptr32 harnessmesh;
	/*+0xd0*/  int32_t damage;
	/*+0xd4*/  int32_t smokeseq;
	/*+0xd8*/  /*unpacked*/ struct mv heli_p; // 0x14 bytes
	/*+0xec*/  /*unpacked*/ struct mv heli_r; // 0x14 bytes
	/*+0x100*/ /*unpacked*/ struct Point3d vector; // 0xc bytes
	/*+0x10c*/ int32_t yaw;
	/*+0x110*/ int32_t collide_delay;
	/*+0x114*/ int32_t roll;
	/*+0x118*/ int32_t slide;
	/*+0x11c*/ int32_t pitch;
	/*+0x120*/ int32_t yawrate;
	/*+0x124*/ int32_t yspeed;
	/*+0x128*/ int32_t fwd_speed;
	/*+0x12c*/ int32_t delta_fwd_speed;
	/*+0x130*/ int32_t movex;
	/*+0x134*/ int32_t movez;
	/*+0x138*/ int32_t hover_ht;
	/*+0x13c*/ int32_t can_land;
	/*+0x140*/ long spotlevel;
	/*+0x144*/ int32_t rotstate;
	/*+0x148*/ int32_t rotspeed;
	/*+0x14c*/ int32_t fireprojectile;
	/*+0x150*/ int32_t terralt;
	/*+0x154*/ int32_t buildalt;
	/*+0x158*/ /*unpacked*/ struct Point3d collisvec; // 0xc bytes
	/*+0x164*/ int32_t shad_color;
	/*+0x168*/ /*unpacked*/ struct _MISSILE_DATA *crash_traj;
	/*+0x16c*/ int32_t crash_timer;
	/*+0x170*/ long crash_seq;
	/*+0x174*/ int32_t over_water;
	/*+0x178*/ /*unpacked*/ struct _ROPE_DATA rinfo; // 0x44 bytes
	/*+0x1bc*/ /*unpacked*/ struct _WATER_DATA winfo; // 0x8 bytes
	/*+0x1c4*/ /*unpacked*/ struct tagHeliPassengerData passengerData; // 0x15c bytes
	/*+0x320*/ int32_t fuel;
	/*+0x324*/ int32_t flight_time;
	/*+0x328*/ int32_t pct_load;
};

// Type: /*packed*/ struct _HELI_TYPE_DATA (forward reference);
struct _HELI_TYPE_DATA{ // packed(0x58 bytes) TI: 0x486e
	/*+0x0*/   int32_t num_initialized;
	/*+0x4*/   int32_t max_seats;
	/*+0x8*/   int32_t max_load;
	/*+0xc*/   int32_t max_bank;
	/*+0x10*/  int32_t max_slide;
	/*+0x14*/  int32_t max_pitch;
	/*+0x18*/  int32_t max_yawrate;
	/*+0x1c*/  int32_t pitch_rate;
	/*+0x20*/  int32_t yaw_rate;
	/*+0x24*/  int32_t roll_rate;
	/*+0x28*/  int32_t slide_rate;
	/*+0x2c*/  int32_t climb_rate;
	/*+0x30*/  /*packed*/ struct Point3d tlrotor_disp; // 0xc bytes
	/*+0x3c*/  int32_t flags;
	/*+0x40*/  int32_t fuel_capacity;
	/*+0x44*/  int32_t fuel_rate;
	/*+0x48*/  int32_t cost;
	/*+0x4c*/  int32_t max_damage;
	/*+0x50*/  int32_t repair_rate;
	/*+0x54*/  int32_t fuel_purchase_rate;
};

// Type: long;

// Type: int32_t;

// Type: /*packed*/ struct _HELI_DATA;
struct _HELI_DATA{ // packed(0x32c bytes) TI: 0x2a68
	/*+0x0*/   int32_t type;
	/*+0x4*/   int32_t state;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   int32_t altdelta;
	/*+0x10*/  /*packed*/ struct Point2d lastpos; // 0x8 bytes
	/*+0x18*/  /*packed*/ struct Point2d currpos; // 0x8 bytes
	/*+0x20*/  int32_t rotor_mat[4][4]; // 0x40 bytes
	/*+0x60*/  int32_t rotortl_mat[4][4]; // 0x40 bytes
	/*+0xa0*/  /*packed*/ struct _DYOBJ_INST *dycannon;
	/*+0xa4*/  /*packed*/ struct _DYOBJ_INST *dyheli;
	/*+0xa8*/  /*packed*/ struct _DYOBJ_INST *dyshadow;
	/*+0xac*/  /*packed*/ struct _DYOBJ_INST *dyrotor;
	/*+0xb0*/  /*packed*/ struct _DYOBJ_INST *dyrotortl;
	/*+0xb4*/  /*packed*/ struct _DYOBJ_INST *dyrotshadow;
	/*+0xb8*/  /*packed*/ struct _DYOBJ_INST *dyrope;
	/*+0xbc*/  /*packed*/ struct _DYOBJ_INST *dybucket;
	/*+0xc0*/  /*packed*/ struct _DYOBJ_INST *dyspot;
	/*+0xc4*/  /*packed*/ struct _DYOBJ_INST *dybracket;
	/*+0xc8*/  void * __ptr32 bucketmesh;
	/*+0xcc*/  void * __ptr32 harnessmesh;
	/*+0xd0*/  int32_t damage;
	/*+0xd4*/  int32_t smokeseq;
	/*+0xd8*/  /*packed*/ struct mv heli_p; // 0x14 bytes
	/*+0xec*/  /*packed*/ struct mv heli_r; // 0x14 bytes
	/*+0x100*/ /*packed*/ struct Point3d vector; // 0xc bytes
	/*+0x10c*/ int32_t yaw;
	/*+0x110*/ int32_t collide_delay;
	/*+0x114*/ int32_t roll;
	/*+0x118*/ int32_t slide;
	/*+0x11c*/ int32_t pitch;
	/*+0x120*/ int32_t yawrate;
	/*+0x124*/ int32_t yspeed;
	/*+0x128*/ int32_t fwd_speed;
	/*+0x12c*/ int32_t delta_fwd_speed;
	/*+0x130*/ int32_t movex;
	/*+0x134*/ int32_t movez;
	/*+0x138*/ int32_t hover_ht;
	/*+0x13c*/ int32_t can_land;
	/*+0x140*/ long spotlevel;
	/*+0x144*/ int32_t rotstate;
	/*+0x148*/ int32_t rotspeed;
	/*+0x14c*/ int32_t fireprojectile;
	/*+0x150*/ int32_t terralt;
	/*+0x154*/ int32_t buildalt;
	/*+0x158*/ /*packed*/ struct Point3d collisvec; // 0xc bytes
	/*+0x164*/ int32_t shad_color;
	/*+0x168*/ /*packed*/ struct _MISSILE_DATA *crash_traj;
	/*+0x16c*/ int32_t crash_timer;
	/*+0x170*/ long crash_seq;
	/*+0x174*/ int32_t over_water;
	/*+0x178*/ /*packed*/ struct _ROPE_DATA rinfo; // 0x44 bytes
	/*+0x1bc*/ /*packed*/ struct _WATER_DATA winfo; // 0x8 bytes
	/*+0x1c4*/ /*packed*/ struct tagHeliPassengerData passengerData; // 0x15c bytes
	/*+0x320*/ int32_t fuel;
	/*+0x324*/ int32_t flight_time;
	/*+0x328*/ int32_t pct_load;
};

// Type: /*packed*/ struct _dPoint2d (forward reference);
struct _dPoint2d{ // packed(0x10 bytes) TI: 0x2766
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double z; // 0x8 bytes
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: char;

// Type: /*packed*/ struct VRBmpHdr (forward reference);
struct VRBmpHdr{ // packed(0x10 bytes) TI: 0x2312
	/*+0x0*/   /*packed*/ struct VRBmpInfo info; // 0xc bytes
	/*+0xc*/   int32_t ScanOffset[1];
};

// Type: char *;

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: void;

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct VRview;
struct VRview{ // packed(0x58 bytes) TI: 0x2ecc
	/*+0x0*/   /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0xc*/   /*packed*/ struct Point3d scale; // 0xc bytes
	/*+0x18*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct VRFaceInfo;
struct VRFaceInfo{ // packed(0x20 bytes) TI: 0x30c0
	/*+0x0*/   int32_t Face;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Plotter;
	/*+0x10*/  /*packed*/ struct VRBmpHdr *Bitmap;
	/*+0x14*/  int32_t * VertList;
	/*+0x18*/  /*packed*/ struct MapVert *MapVList;
	/*+0x1c*/  /*packed*/ struct MapVert *BarryPtr;
};

// Type: int32_t *;

// Type: /*packed*/ struct _STOBJ_INST (forward reference);
struct _STOBJ_INST{ // packed(0x10 bytes) TI: 0x193f
	/*+0x0*/   /*packed*/ struct _STOBJ_INST *next;
	/*+0x4*/   void * __ptr32 mesh;
	/*+0x8*/   long user1;
	/*+0xc*/   long user2;
};

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct VRBlit (forward reference);
struct VRBlit{ // packed(0x10 bytes) TI: 0x3182
	/*+0x0*/   int32_t nverts;
	/*+0x4*/   /*packed*/ struct Proj2d *verts;
	/*+0x8*/   int32_t notused;
	/*+0xc*/   int32_t user1;
};

// Type: /*packed*/ struct tagUserPersonalInfo (forward reference);
struct tagUserPersonalInfo{ // packed(0x58 bytes) TI: 0x1a2a
	/*+0x0*/   char szUserName[64]; // 0x40 bytes
	/*+0x40*/  long lMoney;
	/*+0x44*/  long lHelicopters;
	/*+0x48*/  long lEquipment;
	/*+0x4c*/  long lTrophies;
	/*+0x50*/  long lPoints;
	/*+0x54*/  long lTeargasCount;
};

// Type: void * __ptr32;



// Contribution: 1:000ee1c0-000f7aeb Module: 176, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004ef1c0
void S3HeliInitInstance(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  long size;
	/*bp-0x2c*/  int32_t rotobj;
	/*bp-0x30*/  long hdindex;
	/*bp-0x34*/  int32_t rotshadobj;
	/*bp-0x38*/  char * mem;
	/*bp-0x3c*/  int32_t obj;
	/*bp-0x40*/  int32_t heliobj;
	/*bp-0x44*/  /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0x48*/  int32_t shadobj;

// LINE 490:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 491:
	__asm        mov    eax, hd;
	__asm        sub    eax, 0x6BF1D0;
	__asm        mov    ecx, 0x32C;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    hdindex, eax;
// LINE 493:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    _T2ee;
// LINE 496:
_T40:
	__asm        push   0x76;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 497:
	__asm        push   0x117;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 498:
	__asm        push   0x159;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 499:
	__asm        push   0x160;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 500:
	__asm        jmp    _T326;
// LINE 502:
_T82:
	__asm        push   0x116;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 503:
	__asm        push   0x78;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 504:
	__asm        push   0x158;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 505:
	__asm        push   0x15F;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 506:
	__asm        jmp    _T326;
// LINE 508:
_Tc4:
	__asm        push   0x119;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 509:
	__asm        push   0x11A;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 510:
	__asm        push   0x15B;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 511:
	__asm        push   0x162;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 512:
	__asm        jmp    _T326;
// LINE 514:
_T109:
	__asm        push   0x124;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 515:
	__asm        push   0x126;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 516:
	__asm        push   0x156;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 517:
	__asm        push   0x15D;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 518:
	__asm        jmp    _T326;
// LINE 520:
_T14e:
	__asm        push   0x125;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 521:
	__asm        push   0x127;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 522:
	__asm        push   0x15A;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 523:
	__asm        push   0x161;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 524:
	__asm        jmp    _T326;
// LINE 526:
_T193:
	__asm        push   0x141;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 527:
	__asm        push   0x142;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 528:
	__asm        push   0x155;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 529:
	__asm        push   0x15C;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 530:
	__asm        jmp    _T326;
// LINE 532:
_T1d8:
	__asm        push   0x153;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 533:
	__asm        push   0x154;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 534:
	__asm        push   0x157;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 535:
	__asm        push   0x15E;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 536:
	__asm        jmp    _T326;
// LINE 538:
_T21d:
	__asm        push   0x170;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 539:
	__asm        push   0x172;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 540:
	__asm        push   0x174;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 541:
	__asm        push   0x176;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 542:
	__asm        jmp    _T326;
// LINE 544:
_T262:
	__asm        push   0x171;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 545:
	__asm        push   0x173;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 546:
	__asm        push   0x175;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 547:
	__asm        push   0x177;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 548:
	__asm        jmp    _T326;
// LINE 550:
_T2a7:
	__asm        push   0x76;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    heliobj, eax;
// LINE 551:
	__asm        push   0x117;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotobj, eax;
// LINE 552:
	__asm        push   0x159;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    shadobj, eax;
// LINE 553:
	__asm        push   0x160;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    rotshadobj, eax;
// LINE 554:
	__asm        jmp    _T326;
// LINE 555:
	__asm        jmp    _T326;
_T2ee:
	__asm        cmp    dword ptr [ebp-0x4C], 8;
	__asm        ja     _T2a7;

	__asm        mov    eax, [ebp-0x4C];
	__asm        jmp    _Switch_302[0][eax*4];
// Switch pointers:
//   _T40
//   _T82
//   _Tc4
//   _T109
//   _T14e
//   _T193
//   _T1d8
//   _T21d
//   _T262
// LINE 560:
_T326:
	hd->flags = 0x0;
// LINE 564:
	hd->dyheli = S2Alloc(0x64, G_dyobjmempool);
// LINE 566:
	hd->dybucket = S2Alloc(0x64, G_dyobjmempool);
// LINE 568:
	hd->dyshadow = S2Alloc(0x64, G_dyobjmempool);
// LINE 570:
	hd->dyspot = S2Alloc(0x64, G_dyobjmempool);
// LINE 572:
	hd->dyrotor = S2Alloc(0x64, G_dyobjmempool);
// LINE 574:
	hd->dyrotortl = S2Alloc(0x64, G_dyobjmempool);
// LINE 576:
	hd->dyrotshadow = S2Alloc(0x64, G_dyobjmempool);
// LINE 578:
	hd->dybracket = S2Alloc(0x64, G_dyobjmempool);
// LINE 580:
	hd->dyrope = S2Alloc(0x64, G_dyobjmempool);
// LINE 582:
	hd->dycannon = S2Alloc(0x64, G_dyobjmempool);
// LINE 591:
	__asm        mov    eax, htd;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jle    _T5a7;
// LINE 593:
	__asm        mov    eax, heliobj;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 594:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 595:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        mov    eax, heliobj;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+8], eax;
// LINE 596:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 598:
	__asm        mov    eax, rotobj;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 599:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 600:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        mov    eax, rotobj;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xAC];
	__asm        mov    [ecx+8], eax;
// LINE 601:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 603:
	__asm        mov    eax, shadobj;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 604:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 605:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        mov    eax, shadobj;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA8];
	__asm        mov    [ecx+8], eax;
// LINE 606:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 608:
	__asm        mov    eax, rotshadobj;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 609:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 610:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        mov    eax, rotshadobj;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB4];
	__asm        mov    [ecx+8], eax;
// LINE 611:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 613:
	__asm        jmp    _T5e3;
// LINE 615:
_T5a7:
	hd->dyheli->mesh = heliobj;
// LINE 616:
	hd->dyrotor->mesh = rotobj;
// LINE 617:
	hd->dyrotshadow->mesh = rotshadobj;
// LINE 618:
	hd->dyshadow->mesh = shadobj;
// LINE 625:
_T5e3:
	__asm        cmp    S_numhelis, 0;
	__asm        jle    _T898;
// LINE 627:
	__asm        push   0x7B;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 628:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 629:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x7B;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xBC];
	__asm        mov    [ecx+8], eax;
// LINE 630:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 631:
	hd->bucketmesh = hd->dybucket->mesh;
// LINE 633:
	__asm        push   0x16D;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 634:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 635:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x16D;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0xCC], eax;
// LINE 636:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xCC];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 638:
	__asm        push   0x118;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 639:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 640:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x118;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC0];
	__asm        mov    [ecx+8], eax;
// LINE 641:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 643:
	__asm        push   0x83;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 644:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 645:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x83;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB0];
	__asm        mov    [ecx+8], eax;
// LINE 646:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 649:
	__asm        push   0x16C;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 650:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 651:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x16C;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC4];
	__asm        mov    [ecx+8], eax;
// LINE 652:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 654:
	__asm        push   0x16E;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 655:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 656:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x16E;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx+8], eax;
// LINE 657:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 659:
	__asm        jmp    _T9c4;
// LINE 661:
_T898:
	__asm        push   0x16D;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0xCC], eax;
// LINE 662:
	__asm        push   0x7B;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0xC8], eax;
// LINE 663:
	hd->dybucket->mesh = hd->bucketmesh;
// LINE 664:
	__asm        push   0x118;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC0];
	__asm        mov    [ecx+8], eax;
// LINE 665:
	__asm        push   0x83;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB0];
	__asm        mov    [ecx+8], eax;
// LINE 666:
	__asm        push   0x16C;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC4];
	__asm        mov    [ecx+8], eax;
// LINE 667:
	__asm        push   0x16E;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx+8], eax;
// LINE 670:
	__asm        push   0x607218;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 671:
	__asm        push   0x607218;
	__asm        push   0xFE980000;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 672:
	__asm        push   0x607218;
	__asm        push   0x6071E0;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 675:
	S_spotlevels[0] = VRInt2BmpHdr(0x8, G_restex);
// LINE 676:
	S_spotlevels[1] = VRInt2BmpHdr(0x9, G_restex);
// LINE 677:
	S_spotlevels[2] = VRInt2BmpHdr(0xa, G_restex);
// LINE 678:
	S_spotlevels[3] = VRInt2BmpHdr(0xb, G_restex);
// LINE 684:
_T9c4:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+0xE], ax;
// LINE 685:
	hd->dyheli->flags = 0x5;
// LINE 686:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 687:
	hd->dyheli->radius = oinfo.Radius;
// LINE 688:
	hd->dyheli->height = VRObjGetHeight(hd->dyheli->mesh);
// LINE 693:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xBC];
	__asm        mov    [ecx+0xE], ax;
// LINE 694:
	hd->dybucket->flags = 0x21;
// LINE 695:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 696:
	hd->dybucket->radius = oinfo.Radius;
// LINE 697:
	hd->dybucket->height = VRObjGetHeight(hd->dybucket->mesh);
// LINE 702:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC0];
	__asm        mov    [ecx+0xE], ax;
// LINE 703:
	hd->dyspot->flags = 0x21;
// LINE 704:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 705:
	hd->dyspot->radius = oinfo.Radius;
// LINE 710:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA8];
	__asm        mov    [ecx+0xE], ax;
// LINE 711:
	hd->dyshadow->flags = 0x21;
// LINE 712:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 713:
	hd->dyshadow->radius = oinfo.Radius;
// LINE 718:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB4];
	__asm        mov    [ecx+0xE], ax;
// LINE 719:
	hd->dyrotshadow->flags = 0x21;
// LINE 720:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 721:
	hd->dyrotshadow->radius = oinfo.Radius;
// LINE 726:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xAC];
	__asm        mov    [ecx+0xE], ax;
// LINE 727:
	hd->dyrotor->flags = 0x21;
// LINE 728:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 729:
	hd->dyrotor->radius = oinfo.Radius;
// LINE 734:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB0];
	__asm        mov    [ecx+0xE], ax;
// LINE 735:
	hd->dyrotortl->flags = 0x21;
// LINE 736:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 737:
	hd->dyrotortl->radius = oinfo.Radius;
// LINE 742:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC4];
	__asm        mov    [ecx+0xE], ax;
// LINE 743:
	hd->dybracket->flags = 0x21;
// LINE 744:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 745:
	hd->dybracket->radius = oinfo.Radius;
// LINE 750:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx+0xE], ax;
// LINE 751:
	hd->dycannon->flags = 0x21;
// LINE 752:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 753:
	hd->dycannon->radius = oinfo.Radius;
// LINE 760:
	obj = VRObjCreateRope(RopeSeg, 0x78, 0x14);
// LINE 761:
	__asm        cmp    obj, 0;
	__asm        jne    _Tcb1;
// LINE 762:
	ERexit(0x5b4ca8);
// LINE 764:
_Tcb1:
	__asm        push   2;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 765:
	__asm        push   0;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 766:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 769:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 770:
	hd->rinfo.verts = oinfo.VertsPtr;
// LINE 777:
	hd->rinfo.last_vert = (hd->rinfo.verts + 0xe4);
// LINE 778:
	hd->rinfo.nlast_vert = (hd->rinfo.verts + 0xd8);
// LINE 781:
	hd->dyrope->mesh = obj;
// LINE 782:
	__asm        mov    eax, hdindex;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB8];
	__asm        mov    [ecx+0xE], ax;
// LINE 783:
	hd->dyrope->flags = 0x21;
// LINE 784:
	hd->dyrope->radius = 0x20000;
// LINE 789:
	hd->winfo.load = 0x0;
// LINE 795:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 796:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 797:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 800:
	S_numhelis++;
// LINE 801:
	htd->num_initialized++;
// LINE 804:
	HeliPassengerInit(hd->type, (hd + 0x1c4));
// LINE 805:
}

// FUNCTION: COPTER_D 0x004effa0
void S3HeliGenInit(/*packed*/ struct _HELI_DATA *hd, long mapx, long mapy) {
	/*bp-0x4*/   long heliidx;
	/*bp-0x8*/   int32_t alt;
	/*bp-0xc*/   /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x10*/  /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 829:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 832:
_FOR_2c:
	heliidx = 0x0;
	__asm        jmp    _FOR_COND_2c;
_FOR_NEXT_2c:
	heliidx++;
_FOR_COND_2c:
	__asm        cmp    heliidx, 0xA;
	__asm        jge    _T61;
// LINE 834:
	__asm        mov    eax, heliidx;
	__asm        cmp    G_helis[0][eax*4], 0;
	__asm        jne    _T5c;
// LINE 836:
	__asm        mov    eax, hd;
	__asm        mov    ecx, heliidx;
	__asm        mov    G_helis[0][ecx*4], eax;
// LINE 837:
	__asm        jmp    _T61;
// LINE 839:
_T5c:
	__asm        jmp    _FOR_NEXT_2c;
// LINE 842:
_T61:
	__asm        mov    eax, mapy;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, mapx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 843:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        mov    alt, eax;
// LINE 847:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+0x18], eax;
// LINE 848:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+0x1C], eax;
// LINE 849:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+0x20], eax;
// LINE 851:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 854:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx+0x18], eax;
// LINE 855:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx+0x1C], eax;
// LINE 856:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx+0x20], eax;
// LINE 857:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA0];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 862:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB8];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 863:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 868:
	hd->dybucket->loc.x = (hd->dyheli->loc.x + hd->rinfo.last_vert->x);
// LINE 869:
	hd->dybucket->loc.y = (hd->rinfo.last_vert->y + hd->dyheli->loc.y);
// LINE 870:
	hd->dybucket->loc.z = (hd->rinfo.last_vert->z + hd->dyheli->loc.z);
// LINE 871:
	hd->rinfo.buckdir.x = (hd->rinfo.nlast_vert->x - hd->rinfo.last_vert->x);
// LINE 872:
	hd->rinfo.buckdir.y = (hd->rinfo.nlast_vert->y - hd->rinfo.last_vert->y);
// LINE 873:
	hd->rinfo.buckdir.z = (hd->rinfo.nlast_vert->z - hd->rinfo.last_vert->z);
// LINE 874:
	MTNormalize((hd + 0x184));
// LINE 875:
	MTCreateDOF4x4Y((hd + 0x184), (hd->dybucket + 0x24));
// LINE 880:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC0];
	__asm        mov    [ecx+0x18], eax;
// LINE 881:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC0];
	__asm        mov    [ecx+0x1C], eax;
// LINE 882:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC0];
	__asm        mov    [ecx+0x20], eax;
// LINE 884:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 888:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA8];
	__asm        mov    [ecx+0x18], eax;
// LINE 889:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA8];
	__asm        mov    [ecx+0x1C], eax;
// LINE 890:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA8];
	__asm        mov    [ecx+0x20], eax;
// LINE 892:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 896:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xAC];
	__asm        mov    [ecx+0x18], eax;
// LINE 897:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xAC];
	__asm        mov    [ecx+0x1C], eax;
// LINE 898:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xAC];
	__asm        mov    [ecx+0x20], eax;
// LINE 899:
	__asm        mov    eax, hd;
	__asm        add    eax, 0x20;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 903:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC4];
	__asm        mov    [ecx+0x18], eax;
// LINE 904:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC4];
	__asm        mov    [ecx+0x1C], eax;
// LINE 905:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC4];
	__asm        mov    [ecx+0x20], eax;
// LINE 909:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB0];
	__asm        mov    [ecx+0x18], eax;
// LINE 910:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB0];
	__asm        mov    [ecx+0x1C], eax;
// LINE 911:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB0];
	__asm        mov    [ecx+0x20], eax;
// LINE 912:
	__asm        mov    eax, hd;
	__asm        add    eax, 0x60;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 916:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB4];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 919:
	hd->dyheli->next = hd->dyrotor;
// LINE 920:
	hd->dyrotor->next = hd->dyrotortl;
// LINE 921:
	hd->dyrotortl->next = hd->dyrotshadow;
// LINE 922:
	hd->dyrotshadow->next = hd->dyshadow;
// LINE 923:
	hd->dyshadow->next = hd->dyrope;
// LINE 924:
	hd->dyrope->next = hd->dybucket;
// LINE 925:
	hd->dybucket->next = hd->dycannon;
// LINE 926:
	hd->dycannon->next = hd->dyspot;
// LINE 927:
	hd->dyspot->next = hd->dybracket;
// LINE 928:
	hd->dybracket->next = cptr->dyptr;
// LINE 929:
	cptr->dyptr = hd->dyheli;
// LINE 932:
	hd->dyheli->vnext = hd->dyrotor;
// LINE 933:
	hd->dyrotor->vnext = hd->dyrotortl;
// LINE 934:
	hd->dyrotortl->vnext = hd->dyrotshadow;
// LINE 935:
	hd->dyrotshadow->vnext = hd->dyshadow;
// LINE 936:
	hd->dyshadow->vnext = hd->dyrope;
// LINE 937:
	hd->dyrope->vnext = hd->dybucket;
// LINE 938:
	hd->dybucket->vnext = hd->dycannon;
// LINE 939:
	hd->dycannon->vnext = hd->dyspot;
// LINE 940:
	hd->dyspot->vnext = hd->dybracket;
// LINE 941:
	hd->dybracket->vnext = 0x0;
// LINE 944:
	hd->currpos.x = reinterpret_cast<int16_t>(reinterpret_cast<uint16_t>(mapx));
	hd->lastpos.x = hd->currpos.x;
// LINE 945:
	hd->currpos.y = reinterpret_cast<int16_t>(reinterpret_cast<uint16_t>(mapy));
	hd->lastpos.y = hd->currpos.y;
// LINE 947:
	hd->vector.x = 0x0;
// LINE 948:
	hd->vector.y = 0x0;
// LINE 949:
	hd->vector.z = 0x10000;
// LINE 952:
	S_shadbmp = VRInt2BmpHdr(0x6, G_restex);
// LINE 954:
	__asm        mov    eax, hd;
	__asm        add    eax, 0xE0;
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    dword ptr [eax+8], 0;
// LINE 956:
	hd->state = 0x0;
// LINE 957:
	hd->rotspeed = 0x0;
// LINE 958:
	hd->rotstate = 0x1;
// LINE 959:
	hd->rinfo.bucketdown = 0x0;
// LINE 960:
	hd->pitch = 0x0;
// LINE 961:
	hd->yawrate = 0x0;
// LINE 962:
	hd->fwd_speed = 0x0;
// LINE 964:
	hd->heli_p.M = 0x10000;
// LINE 965:
	hd->heli_r.M = 0x10000;
// LINE 966:
	hd->yaw = 0x0;
// LINE 967:
	hd->roll = 0x0;
// LINE 968:
	hd->slide = 0x0;
// LINE 969:
	hd->collide_delay = 0x0;
// LINE 970:
	hd->fireprojectile = 0x0;
// LINE 971:
	hd->can_land = 0x1;
// LINE 972:
	hd->damage = htd->max_damage;
// LINE 973:
	hd->fuel = htd->fuel_capacity;
// LINE 974:
	hd->flight_time = 0x0;
// LINE 975:
	hd->smokeseq = 0x0;
// LINE 976:
	hd->spotlevel = 0x0;
// LINE 978:
	hd->hover_ht = 0x0;
// LINE 980:
	hd->altdelta = 0x0;
// LINE 981:
	hd->rinfo.raiselower = 0x0;
// LINE 982:
	hd->winfo.dropwater = 0x0;
// LINE 983:
	hd->winfo.load = 0x0;
// LINE 986:
	hd->rinfo.bucketdown = 0x11;
// LINE 987:
	hd->rinfo.bucketraised = 0x1;
// LINE 988:
	hd->rinfo.harnessraised = 0x1;
// LINE 989:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 990:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 992:
	__asm        mov    eax, hd;
	__asm        or     dword ptr [eax+8], 2;
// LINE 993:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax], 2;
	__asm        jne    _T803;
// LINE 994:
	G_apache_placed = 0x1;
// LINE 996:
_T803:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     __RETURN;
// LINE 997:
	SetIdealCameraPos();
// LINE 998:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f07ba
void S3HeliNextFrame(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   /*packed*/ struct Point2d *freepad;
	/*bp-0x8*/   int32_t normz;
	/*bp-0x48*/  int32_t tmpmatrix[4][4]; // 0x40 bytes
	/*bp-0x54*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x58*/  int32_t currload;
	/*bp-0x5c*/  int32_t alt;
	/*bp-0x9c*/  int32_t matrix[4][4]; // 0x40 bytes
	/*bp-0xa0*/  /*packed*/ struct _CELL_INFO *lcptr;
	/*bp-0xa4*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0xa8*/  int32_t maxload;
	/*bp-0xac*/  /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0xb0*/  int32_t normx;
	/*bp-0x108*/ /*packed*/ struct VRview pos; // 0x58 bytes
	/*bp-0x10c*/ int32_t normy;

// LINE 1011:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 1025:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+4];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, htd;
	__asm        add    eax, [ecx+8];
	__asm        shl    eax, 0x10;
	__asm        mov    maxload, eax;
// LINE 1027:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1CC];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, hd;
	__asm        add    eax, [ecx+0x1C0];
	__asm        shl    eax, 0x10;
	__asm        mov    currload, eax;
// LINE 1028:
	__asm        mov    eax, maxload;
	__asm        push   eax;
	__asm        mov    eax, maxload;
	__asm        sub    eax, currload;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x328], eax;
// LINE 1032:
	__asm        cmp    G_camera_mode, 1;
	__asm        je     _Tb1;
// LINE 1034:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1038:
_Tb1:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T3b5;
// LINE 1040:
	G_camera_targ2firey = 0x0;
// LINE 1043:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x11;
	__asm        jne    _T10b;
// LINE 1045:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1046:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1048:
	__asm        jmp    _T139;
// LINE 1050:
_T10b:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1051:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1055:
_T139:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 4;
	__asm        je     _T164;
// LINE 1057:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1059:
	__asm        jmp    _T17b;
// LINE 1061:
_T164:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1064:
_T17b:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 0x10;
	__asm        je     _T1a6;
// LINE 1066:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1068:
	__asm        jmp    _T1bd;
// LINE 1070:
_T1a6:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1074:
_T1bd:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        jne    _T1f4;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x168];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jge    _T1f4;
// LINE 1076:
	hd->state = 0x6;
// LINE 1077:
	hd->crash_seq = 0x0;
// LINE 1080:
_T1f4:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        jne    _T2ac;
// LINE 1082:
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliCrashed;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T29d;
// LINE 1085:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1086:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1087:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1088:
	__asm        mov    eax, hd;
	__asm        and    dword ptr [eax+8], 0xFFFFFFFE;
// LINE 1089:
	freepad = S3HeliGetFreePad();
// LINE 1090:
	S3PersonUserAppear(0x50000, 0x50000, freepad->y, freepad->x);
// LINE 1091:
	G_camera_mode = 0x3;
// LINE 1092:
	S3PersonUserNextFrame();
// LINE 1094:
	__asm        jmp    _T2a7;
// LINE 1096:
_T29d:
	SetIdealCameraPos();
// LINE 1097:
	S3ViewerControl();
// LINE 1099:
_T2a7:
	return;
// LINE 1103:
_T2ac:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xD0], 0;
	__asm        jge    _T33a;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        je     _T33a;
// LINE 1106:
	hd->state = 0x5;
// LINE 1107:
	hd->crash_timer = 0xcccc;
// LINE 1108:
	hd->damage = htd->max_damage;
// LINE 1119:
	hd->crash_traj = S3MissileStart(-0x1, hd->fwd_speed, hd->dyheli, 0x1, (hd + 0x100), (hd->dyheli + 0x18), (hd + 0x18), 0x8);
// LINE 1122:
_T33a:
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliControlInputs;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T3a4;
// LINE 1125:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1126:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1127:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1128:
	__asm        mov    eax, hd;
	__asm        and    dword ptr [eax+8], 0xFFFFFFFE;
// LINE 1129:
	S3PersonUserNextFrame();
// LINE 1130:
	return;
// LINE 1132:
_T3a4:
	S3HeliTurbulence(hd);
// LINE 1134:
	__asm        jmp    _T4b1;
// LINE 1139:
_T3b5:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1140:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1143:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1144:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1145:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1146:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1147:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1150:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xD0], 0;
	__asm        jge    _T48a;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        je     _T48a;
// LINE 1152:
	hd->state = 0x6;
// LINE 1153:
	hd->crash_seq = 0x0;
// LINE 1156:
_T48a:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        jne    _T4b1;
// LINE 1158:
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliCrashed;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T4ac;
// LINE 1161:
_T4ac:
	return;
// LINE 1165:
_T4b1:
	S3HeliYawPitchRollSlide(hd);
// LINE 1166:
	S3HeliMoveXZ(hd);
// LINE 1167:
	hd->currpos.x = ((hd->dyheli->loc.x + 0x20000000) >> 0x16);
// LINE 1168:
	hd->currpos.y = ((0x20000000 - hd->dyheli->loc.z) >> 0x16);
// LINE 1169:
	S3HeliMoveY(hd);
// LINE 1173:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T520;
// LINE 1175:
	SetIdealCameraPos();
// LINE 1176:
	S3ViewerControl();
// LINE 1183:
_T520:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x18];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1187:
	__asm        mov    eax, hd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x10];
	__asm        cmp    [eax+0x18], ecx;
	__asm        jne    _T56b;

	__asm        mov    eax, hd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x1C];
	__asm        cmp    [eax+0x14], ecx;
	__asm        je     _T5f3;
// LINE 1190:
_T56b:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x14];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x10];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    lcptr, eax;
// LINE 1191:
	S3HeliUnlink(lcptr, hd);
// LINE 1193:
	hd->dyheli->next->next->next->next->next->next->next->next->next->next = cptr->dyptr;
// LINE 1194:
	cptr->dyptr = hd->dyheli;
// LINE 1197:
	__asm        mov    eax, hd;
	__asm        add    eax, 0x18;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, hd;
	__asm        add    edx, 0x10;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1202:
_T5f3:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1203:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xA4];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1204:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1207:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC4];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1208:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xA4];
	__asm        mov    eax, hd;
	__asm        mov    edi, [eax+0xC4];
	__asm        add    edi, 0x24;
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1209:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1212:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1213:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xA4];
	__asm        mov    eax, hd;
	__asm        mov    edi, [eax+0xA0];
	__asm        add    edi, 0x24;
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1214:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1216:
	S3HeliMainRotor(hd);
// LINE 1217:
	S3HeliRopeAndBucket(cptr, hd);
// LINE 1229:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normx, eax;
// LINE 1230:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normz, eax;
// LINE 1231:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normy, eax;
// LINE 1233:
	S3HeliDropWater(cptr, hd->buildalt, hd);
// LINE 1234:
	S3HeliSimDust(hd->buildalt, hd);
// LINE 1235:
	S3HeliSetShadow(hd->shad_color, hd->buildalt, (hd->buildalt - hd->terralt), hd);
// LINE 1236:
	S3HeliSetSpotlite(hd->shad_color, hd->buildalt, (hd->buildalt - hd->terralt), hd);
// LINE 1239:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T849;
// LINE 1241:
	G_camera_targ2objy = hd->terralt;
// LINE 1245:
_T849:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 1;
	__asm        jne    _T8d0;
// LINE 1247:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jle    _T8c2;

	__asm        cmp    G_CheatCodes[2], 0;
	__asm        jne    _T8c2;
// LINE 1249:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x11;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x320], ebx;
// LINE 1250:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jge    _T8c2;
// LINE 1253:
	hd->fuel = 0x0;
// LINE 1256:
_T8c2:
	hd->flight_time += G_AvLoopTime;
// LINE 1265:
_T8d0:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        je     _Te52;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        je     _Te52;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _Te52;
// LINE 1268:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x150];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    _Ta22;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x174], 1;
	__asm        jne    _Ta22;
// LINE 1270:
	hd->dyheli->loc.y = hd->terralt;
// LINE 1271:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _T976;
// LINE 1272:
	hd->damage -= 0x4;
// LINE 1274:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jne    _T976;
// LINE 1276:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 1279:
_T976:
	S3ExplosionSmokeStart(0x9, (hd->dyheli + 0x18), cptr);
// LINE 1281:
	__asm        push   0xF;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T9bf;
// LINE 1282:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0xf);
// LINE 1284:
_T9bf:
	__asm        mov    ebx, 1;
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x14];
	__asm        sar    eax, 2;
	__asm        imul   ebx, eax;
	__asm        mov    eax, hd;
	__asm        mov    [eax+0x11C], ebx;
// LINE 1285:
	__asm        mov    ebx, 1;
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x10];
	__asm        sar    eax, 2;
	__asm        imul   ebx, eax;
	__asm        mov    eax, hd;
	__asm        mov    [eax+0x118], ebx;
// LINE 1288:
	__asm        jmp    _Te52;
_Ta22:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x150];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    _Tb3b;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x13C], 0;
	__asm        jne    _Tb3b;
// LINE 1290:
	hd->dyheli->loc.y = hd->terralt;
// LINE 1291:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _Taa1;
// LINE 1292:
	hd->damage -= 0x4;
// LINE 1294:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jne    _Taa1;
// LINE 1296:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 1299:
_Taa1:
	S3ExplosionSmokeStart(0x1, (hd->dyheli + 0x18), cptr);
// LINE 1301:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x1);
// LINE 1303:
	__asm        mov    ebx, 1;
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x14];
	__asm        sar    eax, 2;
	__asm        imul   ebx, eax;
	__asm        mov    eax, hd;
	__asm        mov    [eax+0x11C], ebx;
// LINE 1304:
	__asm        mov    ebx, 1;
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x10];
	__asm        sar    eax, 2;
	__asm        imul   ebx, eax;
	__asm        mov    eax, hd;
	__asm        mov    [eax+0x118], ebx;
// LINE 1307:
	__asm        jmp    _Te52;
_Tb3b:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x154];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    _Td62;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x110], 0;
	__asm        jg     _Td62;
// LINE 1309:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _Tbae;
// LINE 1311:
	__asm        xor    eax, eax;
	__asm        sub    eax, S_htwk_collide_damage_val;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 1313:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jne    _Tbae;
// LINE 1315:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 1318:
_Tbae:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x150];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    _Tbde;
// LINE 1320:
	hd->dyheli->loc.y = hd->terralt;
// LINE 1324:
_Tbde:
	MTCreateDOF4x4((hd + 0x100), tmpmatrix[0][0]);
// LINE 1325:
	__asm        lea    eax, matrix[0][0];
	__asm        push   eax;
	__asm        lea    eax, tmpmatrix[0][0];
	__asm        push   eax;
	__asm        call   0x004D8C2E;
	__asm        add    esp, 8;
// LINE 1327:
	__asm        lea    eax, matrix[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        add    eax, 0x158;
	__asm        push   eax;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 1328:
	MTNormalize(vec.x);
// LINE 1329:
	MTNormalize((hd + 0x158));
// LINE 1330:
	__asm        mov    eax, vec.z;
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x11C], eax;
// LINE 1331:
	__asm        mov    eax, vec.x;
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x118], eax;
// LINE 1337:
	hd->collide_delay = 0x3333;
// LINE 1339:
	alt = hd->dyheli->loc.y;
// LINE 1341:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x1);
// LINE 1345:
	__asm        cmp    G_camera_mode, 1;
	__asm        jne    _Td14;
// LINE 1350:
	__asm        push   0xFFFFFFFF;
	__asm        push   2;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x108];
	__asm        shl    eax, 3;
	__asm        add    eax, normz;
	__asm        push   eax;
	__asm        mov    eax, alt;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        add    eax, 0x50000;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x100];
	__asm        shl    eax, 3;
	__asm        add    eax, normx;
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        call   S3ExplosionStart;
	__asm        add    esp, 0x18;
// LINE 1351:
	__asm        jmp    _Td5d;
// LINE 1356:
_Td14:
	__asm        push   0xFFFFFFFF;
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x160];
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, normz;
	__asm        push   eax;
	__asm        mov    eax, alt;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x158];
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, normx;
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        call   S3ExplosionStart;
	__asm        add    esp, 0x18;
// LINE 1359:
_Td5d:
	__asm        jmp    _Te52;
_Td62:
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliDyObjCollisionCheck;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _Te52;
// LINE 1361:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _Tdb6;
// LINE 1362:
	hd->damage -= 0x4;
// LINE 1364:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jne    _Tdb6;
// LINE 1366:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 1369:
_Tdb6:
	S3ExplosionStart(-0x1, 0x1, normz, normy, normx, cptr);
// LINE 1371:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x1);
// LINE 1373:
	__asm        mov    ebx, 1;
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x14];
	__asm        sar    eax, 2;
	__asm        imul   ebx, eax;
	__asm        mov    eax, hd;
	__asm        mov    [eax+0x11C], ebx;
// LINE 1374:
	__asm        mov    ebx, 1;
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x10];
	__asm        sar    eax, 2;
	__asm        imul   ebx, eax;
	__asm        mov    eax, hd;
	__asm        mov    [eax+0x118], ebx;
// LINE 1379:
_Te52:
	S3HeliSmokeTrail(hd);
// LINE 1381:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x14C], 0;
	__asm        je     __RETURN;
// LINE 1386:
// Block start:
	/*bp-0x110*/ int32_t speed;
	/*bp-0x11c*/ /*packed*/ struct Point3d loc; // 0xc bytes
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x14C], 1;
	__asm        jne    _Te8d;
// LINE 1387:
	speed = 0x1c20000;
// LINE 1388:
	__asm        jmp    _Tf2b;
_Te8d:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x14C], 2;
	__asm        jne    _Teac;
// LINE 1389:
	speed = 0x2580000;
// LINE 1390:
	__asm        jmp    _Tf2b;
_Teac:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x14C], 3;
	__asm        jne    _Tecb;
// LINE 1391:
	speed = 0x640000;
// LINE 1392:
	__asm        jmp    _Tf2b;
// LINE 1393:
_Tecb:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x14C], 5;
	__asm        je     _Teeb;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x14C], 6;
	__asm        jne    _Tf2b;
// LINE 1395:
_Teeb:
	speed = S_htwk_watercannon_speed;
// LINE 1396:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_bucket_dumprate;
	__asm        sar    ecx, 1;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x1C0], eax;
// LINE 1397:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1C0], 0;
	__asm        jge    _Tf2b;
// LINE 1398:
	hd->winfo.load = 0x0;
// LINE 1402:
_Tf2b:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1403:
	loc.y += 0x30000;
// LINE 1405:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 1415:
	S3MissileStart(-0x1, speed, hd->dyheli, 0x1, vec.x, loc.x, (hd + 0x18), hd->fireprojectile);
// LINE 1425:
// Block end:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f176d
int32_t S3HeliCollideTest(/*packed*/ struct _HELI_DATA *hd, long no_frames) {
	/*bp-0xc*/   /*packed*/ struct Point3d saveloc; // 0xc bytes
	/*bp-0x18*/  /*packed*/ struct Point3d V; // 0xc bytes
	/*bp-0x1c*/  int32_t movex;
	/*bp-0x20*/  int32_t movez;
	/*bp-0x2c*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x30*/  int32_t fwd_speed;
	/*bp-0x34*/  int32_t alt;

// LINE 1446:
	fwd_speed = hd->fwd_speed;
// LINE 1447:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        lea    eax, loc.x;
	__asm        lea    ecx, saveloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1448:
	__asm        cmp    fwd_speed, 0;
	__asm        jne    _T5b;
// LINE 1449:
	return 0x0;
// LINE 1453:
_T5b:
	__asm        cmp    G_camera_mode, 0;
	__asm        jne    _Tbb;
// LINE 1455:
	__asm        mov    eax, hd;
	__asm        mov    ecx, fwd_speed;
	__asm        cmp    [eax+0x11C], ecx;
	__asm        jle    _T8c;
// LINE 1456:
	fwd_speed += ((hd->pitch - fwd_speed) >> 0x5);
// LINE 1457:
_T8c:
	__asm        mov    eax, hd;
	__asm        mov    ecx, fwd_speed;
	__asm        cmp    [eax+0x11C], ecx;
	__asm        jge    _Tb6;
// LINE 1458:
	__asm        xor    eax, eax;
	__asm        mov    ecx, fwd_speed;
	__asm        mov    edx, hd;
	__asm        sub    ecx, [edx+0x11C];
	__asm        sar    ecx, 5;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    fwd_speed, eax;
// LINE 1460:
_Tb6:
	__asm        jmp    _T113;
// LINE 1462:
_Tbb:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        add    eax, eax;
	__asm        cmp    eax, fwd_speed;
	__asm        jle    _Te3;
// LINE 1463:
	fwd_speed += (((hd->pitch + hd->pitch) - fwd_speed) >> 0x5);
// LINE 1464:
_Te3:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        add    eax, eax;
	__asm        cmp    eax, fwd_speed;
	__asm        jge    _T113;
// LINE 1465:
	__asm        xor    eax, eax;
	__asm        mov    ecx, fwd_speed;
	__asm        mov    edx, hd;
	__asm        mov    edx, [edx+0x11C];
	__asm        add    edx, edx;
	__asm        sub    ecx, edx;
	__asm        sar    ecx, 4;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    fwd_speed, eax;
// LINE 1468:
_T113:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T140;
// LINE 1470:
	__asm        push   0xD6D8;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x128];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x128], eax;
// LINE 1474:
_T140:
	__asm        mov    eax, fwd_speed;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x100];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    V.x, eax;
// LINE 1475:
	__asm        mov    eax, fwd_speed;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    V.z, eax;
// LINE 1478:
	__asm        xor    ebx, ebx;
	__asm        push   0x7D00;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x118];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        sub    V.x, ebx;
// LINE 1479:
	__asm        push   0x7D00;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x118];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x100];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    V.z, eax;
// LINE 1481:
	__asm        push   0x9C40;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xE0];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    movex, eax;
// LINE 1482:
	__asm        push   0x9C40;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xE8];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    movez, eax;
// LINE 1483:
	movex = (movex * no_frames);
// LINE 1484:
	movez = (movez * no_frames);
// LINE 1486:
	loc.z += movez;
// LINE 1487:
	loc.x += movex;
// LINE 1490:
	__asm        lea    eax, loc.x;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1491:
	alt = GetCopterBldAlt(hd);
// LINE 1493:
	__asm        lea    eax, saveloc.x;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1495:
	__asm        mov    eax, alt;
	__asm        cmp    loc.y, eax;
	__asm        jge    _T2a7;
// LINE 1496:
	return 0x1;
// LINE 1498:
_T2a7:
	return 0x0;
// LINE 1499:
}

// FUNCTION: COPTER_D 0x004f1a20
int32_t S3HeliHeadToLocXZ(/*packed*/ struct _HELI_DATA *hd, /*packed*/ struct Point3d *loc) {
	/*bp-0x4*/   int32_t newyaw;
	/*bp-0x8*/   int32_t dist;
	/*bp-0xc*/   int32_t deflectangle;
	/*bp-0x10*/  int32_t deltayaw;
	/*bp-0x1c*/  /*packed*/ struct Point3d tmpvect; // 0xc bytes
	/*bp-0x20*/  int32_t curryaw;
	/*bp-0x24*/  int32_t alt;
	/*bp-0x30*/  /*packed*/ struct Point3d newvect; // 0xc bytes

// LINE 1516:
	dist = 0x0;
// LINE 1517:
	newyaw = 0x0;
// LINE 1518:
	curryaw = 0x0;
// LINE 1519:
	deltayaw = 0x0;
// LINE 1520:
	deflectangle = 0x0;
// LINE 1521:
	alt = 0x0;
// LINE 1524:
	newvect.y = 0x0;
// LINE 1525:
	newvect.z = (loc->z - hd->dyheli->loc.z);
// LINE 1526:
	newvect.x = (loc->x - hd->dyheli->loc.x);
// LINE 1529:
	dist = MTNormalize(newvect.x);
// LINE 1532:
	__asm        cmp    dist, 0x140000;
	__asm        jg     _T96;
// LINE 1534:
	hd->yawrate = 0x0;
// LINE 1535:
	return 0x1;
// LINE 1541:
_T96:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x100];
	__asm        push   eax;
	__asm        call   0x004D20B1;
	__asm        add    esp, 8;
	__asm        mov    curryaw, eax;
// LINE 1545:
	__asm        mov    eax, newvect.z;
	__asm        push   eax;
	__asm        mov    eax, newvect.x;
	__asm        push   eax;
	__asm        call   0x004D20B1;
	__asm        add    esp, 8;
	__asm        mov    newyaw, eax;
// LINE 1550:
	__asm        mov    eax, newyaw;
	__asm        sub    eax, curryaw;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    deltayaw, eax;
// LINE 1551:
	__asm        cmp    dist, 0x400000;
	__asm        jg     _Tfd;

	__asm        cmp    deltayaw, 0x1E0000;
	__asm        jle    _Tfd;
// LINE 1553:
	hd->pitch = 0x0;
// LINE 1558:
_Tfd:
	deflectangle = S3HeliGetDeflection(alt, dist, newvect.x, hd);
// LINE 1559:
	__asm        cmp    deflectangle, 0;
	__asm        jle    _T188;
// LINE 1562:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x138];
	__asm        neg    eax;
	__asm        sub    alt, eax;
// LINE 1563:
	tmpvect.x = dist;
// LINE 1564:
	tmpvect.y = alt;
// LINE 1565:
	tmpvect.z = 0x0;
// LINE 1566:
	dist = MTNormalize(tmpvect.x);
// LINE 1567:
	__asm        mov    eax, tmpvect.y;
	__asm        push   eax;
	__asm        mov    eax, tmpvect.x;
	__asm        push   eax;
	__asm        call   0x004D20B1;
	__asm        add    esp, 8;
	__asm        mov    dist, eax;
// LINE 1568:
	__asm        mov    eax, deflectangle;
	__asm        cmp    dist, eax;
	__asm        jle    _T17e;
// LINE 1569:
	newyaw += deflectangle;
// LINE 1570:
	__asm        jmp    _T188;
// LINE 1571:
_T17e:
	hd->altdelta = 0x1;
// LINE 1581:
_T188:
	__asm        mov    eax, curryaw;
	__asm        sub    eax, 0x64;
	__asm        cmp    eax, newyaw;
	__asm        jge    _T1b8;

	__asm        mov    eax, curryaw;
	__asm        add    eax, 0x64;
	__asm        cmp    eax, newyaw;
	__asm        jle    _T1b8;
// LINE 1583:
	hd->yawrate = 0x0;
// LINE 1585:
	__asm        jmp    _T217;
// LINE 1587:
_T1b8:
	deltayaw = MTAngleBounds((newyaw - curryaw));
// LINE 1591:
	__asm        cmp    G_AvLoopTime, 0x400;
	__asm        jge    _T1f9;
// LINE 1592:
	__asm        push   0x4000;
	__asm        mov    eax, deltayaw;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x120], eax;
// LINE 1593:
	__asm        jmp    _T217;
// LINE 1594:
_T1f9:
	__asm        mov    eax, G_AvLoopTime;
	__asm        shl    eax, 4;
	__asm        push   eax;
	__asm        mov    eax, deltayaw;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x120], eax;
// LINE 1597:
_T217:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x120], 0x320000;
	__asm        jle    _T237;
// LINE 1598:
	hd->yawrate = 0x320000;
// LINE 1599:
_T237:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x120], 0xFFCE0000;
	__asm        jge    _T257;
// LINE 1600:
	hd->yawrate = 0xffce0000;
// LINE 1602:
_T257:
	return 0x0;
// LINE 1603:
}

// FUNCTION: COPTER_D 0x004f1c83
void S3HeliSetShadow(/*packed*/ struct _HELI_DATA *hd, int32_t maxobjy, int32_t alt, int32_t color) {
	/*bp-0x58*/  /*packed*/ struct VRview pos; // 0x58 bytes

// LINE 1621:
	__asm        cmp    G_daynight, 1;
	__asm        je     _T23;

	__asm        cmp    G_camera_mode, 3;
	__asm        jne    _T56;
// LINE 1623:
_T23:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1624:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1625:
	return;
// LINE 1628:
_T56:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        jne    _T68;
// LINE 1629:
	return;
// LINE 1631:
_T68:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1632:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 1640:
	MTCreateDOF4x4((hd + 0x100), (hd->dyshadow + 0x24));
// LINE 1641:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        add    eax, 0x20;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D8900;
	__asm        add    esp, 0xC;
// LINE 1658:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        lea    eax, pos.loc.x;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB4];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA8];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1661:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x154];
	__asm        mov    ecx, S_shadalt;
	__asm        sub    eax, ecx;
	__asm        lea    eax, [eax+ecx*8];
	__asm        sar    eax, 3;
	__asm        mov    S_shadalt, eax;
// LINE 1664:
	pos.loc.y = S_shadalt;
// LINE 1667:
	hd->dyrotshadow->loc.y = pos.loc.y;
	hd->dyshadow->loc.y = hd->dyrotshadow->loc.y;
// LINE 1670:
	alt = (hd->dyheli->loc.y - alt);
// LINE 1672:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xA8];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1673:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1675:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xB4];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1676:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1677:
}

// FUNCTION: COPTER_D 0x004f1e8a
int32_t S3HeliControlInputs(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t tempfix;
	/*bp-0x8*/   int32_t sliderate;
	/*bp-0xc*/   long lJoystickMiscValue1;
	/*bp-0x10*/  long lJoystickUpDownValue;
	/*bp-0x14*/  int32_t bSlideEventIsSet;
	/*bp-0x18*/  long lJoystickLeftRightValue;
	/*bp-0x1c*/  int32_t pitchrate;
	/*bp-0x20*/  int32_t yawrate;
	/*bp-0x24*/  /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 1689:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 1699:
	__asm        cmp    G_testmode, 1;
	__asm        jne    _T43;
// LINE 1701:
	S3HeliTestCopter(hd);
// LINE 1702:
	return 0x1;
// LINE 1706:
_T43:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        je     _T5d;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        jne    _T8e;
// LINE 1708:
_T5d:
	hd->rinfo.raiselower = 0x0;
// LINE 1709:
	hd->winfo.dropwater = 0x0;
// LINE 1710:
	hd->fireprojectile = 0x0;
// LINE 1711:
	return 0x1;
// LINE 1714:
_T8e:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x110], 0;
	__asm        jle    _Ta8;
// LINE 1715:
	return 0x1;
// LINE 1718:
_Ta8:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    pitchrate, eax;
// LINE 1720:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _Td5;
// LINE 1721:
	__asm        sar    pitchrate, 1;
// LINE 1723:
_Td5:
	lJoystickLeftRightValue = GetJoystickValueEither(0x7, 0x6);
// LINE 1724:
	__asm        push   0x1A;
	__asm        call   GetJoystickValue;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T108;

	__asm        push   0x1A;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T114;
_T108:
	bSlideEventIsSet = 0x1;
	__asm        jmp    _T11b;
_T114:
	bSlideEventIsSet = 0x0;
// LINE 1727:
_T11b:
	__asm        push   8;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T14d;
// LINE 1728:
	__asm        mov    eax, pitchrate;
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x11C], eax;
// LINE 1729:
	__asm        jmp    _T266;
_T14d:
	__asm        push   9;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T185;
// LINE 1730:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, pitchrate;
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x11C], ebx;
// LINE 1731:
	__asm        jmp    _T266;
_T185:
	__asm        push   8;
	__asm        push   9;
	__asm        call   GetJoystickValueEither;
	__asm        add    esp, 8;
	__asm        mov    lJoystickUpDownValue, eax;
	__asm        cmp    lJoystickUpDownValue, 0;
	__asm        je     _T202;
// LINE 1733:
	__asm        push   0x30000;
	__asm        mov    eax, lJoystickUpDownValue;
	__asm        shl    eax, 0x10;
	__asm        neg    eax;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1734:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x11C];
	__asm        neg    eax;
	__asm        sub    tempfix, eax;
// LINE 1735:
	__asm        mov    eax, G_AvLoopTime;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1736:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x11C], eax;
// LINE 1738:
	__asm        jmp    _T266;
// LINE 1740:
_T202:
	__asm        cmp    G_camera_mode, 0;
	__asm        jne    _T23f;
// LINE 1741:
	__asm        mov    eax, 0x10000;
	__asm        mov    ecx, G_AvLoopTime;
	__asm        add    ecx, ecx;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x11C], eax;
// LINE 1742:
	__asm        jmp    _T266;
// LINE 1743:
_T23f:
	__asm        mov    eax, 0x10000;
	__asm        sub    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x11C], eax;
// LINE 1747:
_T266:
	__asm        push   7;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T2a1;
// LINE 1748:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x24];
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x114], ebx;
// LINE 1749:
	__asm        jmp    _T365;
_T2a1:
	__asm        push   6;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T2d6;
// LINE 1750:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x24];
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x114], eax;
// LINE 1751:
	__asm        jmp    _T365;
_T2d6:
	__asm        cmp    lJoystickLeftRightValue, 0;
	__asm        je     _T339;

	__asm        cmp    bSlideEventIsSet, 0;
	__asm        jne    _T339;
// LINE 1753:
	__asm        push   0x60000;
	__asm        mov    eax, lJoystickLeftRightValue;
	__asm        shl    eax, 0x10;
	__asm        neg    eax;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1754:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x114];
	__asm        neg    eax;
	__asm        sub    tempfix, eax;
// LINE 1755:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1756:
	hd->roll += tempfix;
// LINE 1758:
	__asm        jmp    _T365;
// LINE 1759:
_T339:
	__asm        mov    eax, 0x10000;
	__asm        mov    ecx, G_AvLoopTime;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x114];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x114], eax;
// LINE 1764:
_T365:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    yawrate, eax;
// LINE 1766:
	__asm        push   7;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T3b3;
// LINE 1767:
	__asm        mov    eax, yawrate;
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x120], eax;
// LINE 1768:
	__asm        jmp    _T45d;
_T3b3:
	__asm        push   6;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T3eb;
// LINE 1769:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, yawrate;
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x120], ebx;
// LINE 1770:
	__asm        jmp    _T45d;
_T3eb:
	__asm        cmp    lJoystickLeftRightValue, 0;
	__asm        je     _T431;

	__asm        cmp    bSlideEventIsSet, 0;
	__asm        jne    _T431;
// LINE 1772:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, lJoystickLeftRightValue;
	__asm        neg    eax;
	__asm        sar    eax, 2;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x120], ebx;
// LINE 1773:
	__asm        jmp    _T45d;
// LINE 1774:
_T431:
	__asm        mov    eax, 0x10000;
	__asm        mov    ecx, G_AvLoopTime;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x120];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x120], eax;
// LINE 1777:
_T45d:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x28];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    sliderate, eax;
// LINE 1780:
	__asm        push   0xB;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T4ab;
// LINE 1781:
	__asm        mov    eax, sliderate;
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x118], eax;
// LINE 1782:
	__asm        jmp    _T5b2;
_T4ab:
	__asm        push   0xA;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T4e3;
// LINE 1783:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, sliderate;
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x118], ebx;
// LINE 1784:
	__asm        jmp    _T5b2;
_T4e3:
	__asm        cmp    lJoystickLeftRightValue, 0;
	__asm        je     _T559;

	__asm        cmp    bSlideEventIsSet, 0;
	__asm        je     _T559;
// LINE 1786:
	__asm        push   0x20000;
	__asm        mov    eax, lJoystickLeftRightValue;
	__asm        shl    eax, 0x10;
	__asm        neg    eax;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1787:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x118];
	__asm        neg    eax;
	__asm        sub    tempfix, eax;
// LINE 1788:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1789:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x118], eax;
// LINE 1791:
	__asm        jmp    _T5b2;
// LINE 1793:
_T559:
	__asm        movsx  eax, ControlNoise;
	__asm        test   eax, eax;
	__asm        je     _T587;
// LINE 1794:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx-5];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x118], eax;
// LINE 1795:
_T587:
	__asm        mov    eax, 0x10000;
	__asm        mov    ecx, G_AvLoopTime;
	__asm        add    ecx, ecx;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x118];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x118], eax;
// LINE 1799:
_T5b2:
	__asm        push   0xC;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T5d3;
// LINE 1800:
	hd->altdelta = 0x1;
// LINE 1801:
	__asm        jmp    _T63b;
_T5d3:
	__asm        push   0xD;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T5f4;
// LINE 1802:
	hd->altdelta = 0xffffffff;
// LINE 1803:
	__asm        jmp    _T63b;
_T5f4:
	__asm        push   0xD;
	__asm        push   0xC;
	__asm        call   GetJoystickValueEither;
	__asm        add    esp, 8;
	__asm        mov    lJoystickMiscValue1, eax;
	__asm        cmp    lJoystickMiscValue1, 0;
	__asm        je     _T631;
// LINE 1804:
	__asm        jle    _T622;
// LINE 1805:
	hd->altdelta = 0x1;
// LINE 1806:
	__asm        jmp    _T62c;
// LINE 1807:
_T622:
	hd->altdelta = 0xffffffff;
// LINE 1809:
_T62c:
	__asm        jmp    _T63b;
// LINE 1810:
_T631:
	hd->altdelta = 0x0;
// LINE 1813:
_T63b:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jg     _T655;
// LINE 1814:
	hd->altdelta = 0xffffffff;
// LINE 1820:
_T655:
	hd->rinfo.raiselower = 0x0;
// LINE 1821:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 1;
	__asm        je     _T79b;
// LINE 1822:
	__asm        push   0xE;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T6c7;
// LINE 1823:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B4], 0;
	__asm        jne    _T6a5;
// LINE 1824:
	hd->rinfo.raiselower = 0x2;
// LINE 1825:
	__asm        jmp    _T6c2;
_T6a5:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 3;
	__asm        jle    _T6c2;
// LINE 1826:
	hd->rinfo.raiselower = 0xffffffff;
// LINE 1828:
_T6c2:
	__asm        jmp    _T79b;
_T6c7:
	__asm        push   0xF;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T70b;
// LINE 1829:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T706;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x11;
	__asm        jge    _T706;
// LINE 1830:
	hd->rinfo.raiselower = 0x1;
// LINE 1832:
_T706:
	__asm        jmp    _T79b;
_T70b:
	__asm        push   0xF;
	__asm        push   0xE;
	__asm        call   GetJoystickValueEither;
	__asm        add    esp, 8;
	__asm        mov    lJoystickMiscValue1, eax;
	__asm        cmp    lJoystickMiscValue1, 0;
	__asm        je     _T79b;
// LINE 1833:
	__asm        jge    _T76e;
// LINE 1834:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B4], 0;
	__asm        jne    _T74c;
// LINE 1835:
	hd->rinfo.raiselower = 0x2;
// LINE 1836:
	__asm        jmp    _T769;
_T74c:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 3;
	__asm        jle    _T769;
// LINE 1837:
	hd->rinfo.raiselower = 0xffffffff;
// LINE 1839:
_T769:
	__asm        jmp    _T79b;
// LINE 1840:
_T76e:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T79b;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x11;
	__asm        jge    _T79b;
// LINE 1841:
	hd->rinfo.raiselower = 0x1;
// LINE 1846:
_T79b:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 4;
	__asm        je     _T8d4;
// LINE 1847:
	__asm        push   0x11;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T800;
// LINE 1848:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T7de;
// LINE 1849:
	hd->rinfo.raiselower = 0x1;
// LINE 1850:
	__asm        jmp    _T7fb;
_T7de:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 3;
	__asm        jle    _T7fb;
// LINE 1851:
	hd->rinfo.raiselower = 0xfffffffe;
// LINE 1853:
_T7fb:
	__asm        jmp    _T8d4;
_T800:
	__asm        push   0x12;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T844;
// LINE 1854:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B4], 0;
	__asm        jne    _T83f;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x11;
	__asm        jge    _T83f;
// LINE 1855:
	hd->rinfo.raiselower = 0x2;
// LINE 1857:
_T83f:
	__asm        jmp    _T8d4;
_T844:
	__asm        push   0x12;
	__asm        push   0x11;
	__asm        call   GetJoystickValueEither;
	__asm        add    esp, 8;
	__asm        mov    lJoystickMiscValue1, eax;
	__asm        cmp    lJoystickMiscValue1, 0;
	__asm        je     _T8d4;
// LINE 1858:
	__asm        jge    _T8a7;
// LINE 1859:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T885;
// LINE 1860:
	hd->rinfo.raiselower = 0x1;
// LINE 1861:
	__asm        jmp    _T8a2;
_T885:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 3;
	__asm        jle    _T8a2;
// LINE 1862:
	hd->rinfo.raiselower = 0xfffffffe;
// LINE 1864:
_T8a2:
	__asm        jmp    _T8d4;
// LINE 1865:
_T8a7:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B4], 0;
	__asm        jne    _T8d4;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x11;
	__asm        jge    _T8d4;
// LINE 1866:
	hd->rinfo.raiselower = 0x2;
// LINE 1873:
_T8d4:
	__asm        push   0x10;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T8f8;

	__asm        push   0x10;
	__asm        call   GetJoystickValue;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T939;
_T8f8:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T939;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1C0], 0;
	__asm        je     _T939;
// LINE 1875:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 1;
	__asm        je     _T934;
// LINE 1876:
	hd->winfo.dropwater = 0x1;
// LINE 1878:
_T934:
	__asm        jmp    _T946;
// LINE 1879:
_T939:
	hd->winfo.dropwater = 0x0;
// LINE 1882:
_T946:
	__asm        push   2;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T96a;

	__asm        push   2;
	__asm        call   GetJoystickValue;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T9b8;
// LINE 1884:
_T96a:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 8;
	__asm        je     _T9b3;
// LINE 1886:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax], 2;
	__asm        jne    _T997;
// LINE 1887:
	hd->fireprojectile = 0x1;
// LINE 1888:
	__asm        jmp    _T9b3;
// LINE 1889:
_T997:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jle    _T9b3;
// LINE 1890:
	hd->fireprojectile = 0x3;
// LINE 1896:
_T9b3:
	__asm        jmp    _Ta7d;
_T9b8:
	__asm        push   0x13;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T9dc;

	__asm        push   0x13;
	__asm        call   GetJoystickValue;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _Ta70;
// LINE 1898:
_T9dc:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 1;
	__asm        je     _Ta5e;
// LINE 1900:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax], 2;
	__asm        jne    _Ta09;
// LINE 1901:
	hd->fireprojectile = 0x2;
// LINE 1902:
	__asm        jmp    _Ta59;
_Ta09:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1C0], 0;
	__asm        je     _Ta4c;
// LINE 1904:
	hd->fireprojectile = 0x5;
// LINE 1906:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, pitchrate;
	__asm        push   eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x11C], ebx;
// LINE 1908:
	__asm        jmp    _Ta59;
// LINE 1909:
_Ta4c:
	hd->fireprojectile = 0x0;
// LINE 1911:
_Ta59:
	__asm        jmp    _Ta6b;
// LINE 1912:
_Ta5e:
	hd->fireprojectile = 0x0;
// LINE 1914:
_Ta6b:
	__asm        jmp    _Ta7d;
// LINE 1915:
_Ta70:
	hd->fireprojectile = 0x0;
// LINE 1917:
_Ta7d:
	return 0x1;
// LINE 1918:
}

// FUNCTION: COPTER_D 0x004f2916
void S3HeliYawPitchRollSlide(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t tempfix;
	/*bp-0x44*/  int32_t matrix[4][4]; // 0x40 bytes
	/*bp-0x48*/  /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0x4c*/  int32_t tempfix2;
	/*bp-0x50*/  int32_t max_pitch;

// LINE 1932:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 1935:
	max_pitch = htd->max_pitch;
// LINE 1938:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        je     _T43;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        jne    _T11e;
// LINE 1941:
_T43:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x168];
	__asm        cmp    dword ptr [eax+0xC], 0x30000;
	__asm        jle    _Td4;
// LINE 1943:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0x384;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        add    eax, 0x3840000;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1945:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x168];
	__asm        cmp    dword ptr [eax+0x38], 1;
	__asm        jne    _Tb6;
// LINE 1947:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 1949:
	__asm        jmp    _Tcf;
// LINE 1951:
_Tb6:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 1954:
_Tcf:
	__asm        jmp    _T119;
// LINE 1956:
_Td4:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0x190;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        add    eax, 0x640000;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1957:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 1959:
_T119:
	return;
// LINE 1962:
_T11e:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T1a7;
// LINE 1964:
	hd->pitch = 0x0;
// LINE 1965:
	hd->roll = 0x0;
// LINE 1966:
	hd->yawrate = 0x0;
// LINE 1967:
	hd->slide = 0x0;
// LINE 1968:
	S3AngleRotMat(hd->roll, hd->pitch, hd->yaw, matrix[0][0]);
// LINE 1969:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, matrix[0][0];
	__asm        push   eax;
	__asm        call   0x004D8C2E;
	__asm        add    esp, 8;
// LINE 1970:
	return;
// LINE 1974:
_T1a7:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T1c2;
// LINE 1975:
	hd->pitch += S_turbpitch[0];
// LINE 1978:
_T1c2:
	tempfix = (hd->dyheli->loc.y - hd->terralt);
// LINE 1979:
	tempfix = (0x960000 - tempfix);
// LINE 1981:
	tempfix2 = 0x0;
// LINE 1982:
	__asm        cmp    tempfix, 0;
	__asm        jle    _T232;

	__asm        cmp    tempfix, 0x960000;
	__asm        jge    _T232;
// LINE 1984:
	__asm        push   0x960000;
	__asm        mov    eax, 0x960000;
	__asm        sub    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 1985:
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        mov    eax, max_pitch;
	__asm        sar    eax, 3;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix2, eax;
// LINE 1989:
_T232:
	__asm        cmp    G_camera_mode, 0;
	__asm        jne    _T290;
// LINE 1991:
	__asm        mov    eax, max_pitch;
	__asm        add    eax, tempfix2;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x11C];
	__asm        jge    _T263;
// LINE 1992:
	hd->pitch = (max_pitch + tempfix2);
// LINE 1993:
_T263:
	__asm        mov    eax, max_pitch;
	__asm        neg    eax;
	__asm        sub    eax, tempfix2;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x11C];
	__asm        jle    _T28b;
// LINE 1994:
	__asm        mov    eax, max_pitch;
	__asm        neg    eax;
	__asm        sub    eax, tempfix2;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x11C], eax;
// LINE 1996:
_T28b:
	__asm        jmp    _T2fc;
// LINE 1998:
_T290:
	__asm        mov    eax, max_pitch;
	__asm        sar    eax, 1;
	__asm        mov    ecx, tempfix2;
	__asm        sar    ecx, 1;
	__asm        add    eax, ecx;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x11C];
	__asm        jge    _T2c4;
// LINE 1999:
	hd->pitch = ((max_pitch >> 0x1) + (tempfix2 >> 0x1));
// LINE 2000:
_T2c4:
	__asm        mov    eax, max_pitch;
	__asm        sar    eax, 1;
	__asm        neg    eax;
	__asm        mov    ecx, tempfix2;
	__asm        sar    ecx, 1;
	__asm        sub    eax, ecx;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x11C];
	__asm        jle    _T2fc;
// LINE 2001:
	__asm        mov    eax, max_pitch;
	__asm        sar    eax, 1;
	__asm        neg    eax;
	__asm        mov    ecx, tempfix2;
	__asm        sar    ecx, 1;
	__asm        sub    eax, ecx;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x11C], eax;
// LINE 2020:
_T2fc:
	__asm        mov    eax, hd;
	__asm        mov    ecx, htd;
	__asm        mov    ecx, [ecx+0xC];
	__asm        cmp    [eax+0x114], ecx;
	__asm        jle    _T320;
// LINE 2021:
	hd->roll = htd->max_bank;
// LINE 2022:
_T320:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0xC];
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x114];
	__asm        jle    _T348;
// LINE 2023:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0xC];
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x114], eax;
// LINE 2024:
_T348:
	tempfix = hd->pitch;
// LINE 2025:
	__asm        cmp    tempfix, 0;
	__asm        jge    _T366;
// LINE 2026:
	__asm        mov    eax, tempfix;
	__asm        neg    eax;
	__asm        mov    tempfix, eax;
// LINE 2027:
_T366:
	tempfix += 0x12c0000;
// LINE 2028:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x114], 0;
	__asm        jle    _T3a0;
// LINE 2030:
	__asm        mov    eax, hd;
	__asm        mov    ecx, tempfix;
	__asm        cmp    [eax+0x114], ecx;
	__asm        jle    _T39b;
// LINE 2031:
	hd->roll = tempfix;
// LINE 2033:
_T39b:
	__asm        jmp    _T3d2;
_T3a0:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x114], 0;
	__asm        jge    _T3d2;
// LINE 2035:
	__asm        mov    eax, hd;
	__asm        mov    ecx, tempfix;
	__asm        neg    ecx;
	__asm        cmp    [eax+0x114], ecx;
	__asm        jge    _T3d2;
// LINE 2036:
	__asm        mov    eax, tempfix;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x114], eax;
// LINE 2040:
_T3d2:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T3ed;
// LINE 2041:
	hd->slide += S_turbslide[0];
// LINE 2044:
_T3ed:
	__asm        mov    eax, hd;
	__asm        mov    ecx, htd;
	__asm        mov    ecx, [ecx+0x10];
	__asm        cmp    [eax+0x118], ecx;
	__asm        jle    _T411;
// LINE 2045:
	hd->slide = htd->max_slide;
// LINE 2046:
_T411:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x10];
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x118];
	__asm        jle    _T439;
// LINE 2047:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x10];
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x118], eax;
// LINE 2051:
_T439:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T454;
// LINE 2052:
	hd->yawrate += S_turbyaw[0];
// LINE 2055:
_T454:
	__asm        mov    eax, htd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x120];
	__asm        cmp    [eax+0x18], ecx;
	__asm        jge    _T478;
// LINE 2056:
	hd->yawrate = htd->max_yawrate;
// LINE 2057:
_T478:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x18];
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x120];
	__asm        jle    _T4a0;
// LINE 2058:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x18];
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x120], eax;
// LINE 2060:
_T4a0:
	__asm        push   0xF0000;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x120];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x10C], eax;
// LINE 2062:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x10C], 0xE100000;
	__asm        jle    _T4f4;
// LINE 2063:
	hd->yaw -= 0xe100000;
// LINE 2064:
	__asm        jmp    _T511;
_T4f4:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x10C], 0;
	__asm        jge    _T511;
// LINE 2065:
	hd->yaw += 0xe100000;
// LINE 2068:
_T511:
	tempfix = hd->roll;
// LINE 2069:
	__asm        cmp    tempfix, 0;
	__asm        jge    _T52f;
// LINE 2070:
	__asm        mov    eax, tempfix;
	__asm        neg    eax;
	__asm        mov    tempfix, eax;
// LINE 2071:
_T52f:
	tempfix2 = hd->slide;
// LINE 2072:
	__asm        cmp    tempfix2, 0;
	__asm        jge    _T54d;
// LINE 2073:
	__asm        mov    eax, tempfix2;
	__asm        neg    eax;
	__asm        mov    tempfix2, eax;
// LINE 2074:
_T54d:
	__asm        mov    eax, tempfix;
	__asm        cmp    tempfix2, eax;
	__asm        jle    _T56b;
// LINE 2075:
	hd->roll = hd->slide;
// LINE 2077:
_T56b:
	S3AngleRotMat(hd->roll, hd->pitch, hd->yaw, matrix[0][0]);
// LINE 2078:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, matrix[0][0];
	__asm        push   eax;
	__asm        call   0x004D8C2E;
	__asm        add    esp, 8;
// LINE 2079:
}

// FUNCTION: COPTER_D 0x004f2ec9
void S3HeliMoveXZ(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t origFwdSpeed;
	/*bp-0x8*/   int32_t velocity;

// LINE 2090:
	origFwdSpeed = hd->fwd_speed;
// LINE 2093:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        jne    _T41;
// LINE 2095:
	hd->movex = 0x0;
// LINE 2096:
	hd->movez = 0x0;
// LINE 2097:
	return;
// LINE 2101:
_T41:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        jne    _Tc6;
// LINE 2103:
	hd->movex = (hd->crash_traj->dymissile->loc.x - hd->dyheli->loc.x);
// LINE 2104:
	hd->movez = (hd->crash_traj->dymissile->loc.z - hd->dyheli->loc.z);
// LINE 2105:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x168];
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2106:
	return;
// LINE 2110:
_Tc6:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        add    eax, 0x100;
	__asm        push   eax;
	__asm        push   0x5B4910;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 2111:
	hd->vector.y = 0x0;
// LINE 2112:
	NormalizeXZVector((hd + 0x100));
// LINE 2116:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x110], 0;
	__asm        jle    _T144;
// LINE 2118:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x110], eax;
// LINE 2119:
	hd->fwd_speed = (hd->pitch >> 0x3);
// LINE 2121:
	__asm        jmp    _T244;
_T144:
	__asm        cmp    G_camera_mode, 0;
	__asm        jne    _T1c8;
// LINE 2123:
	__asm        mov    eax, hd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x11C];
	__asm        cmp    [eax+0x128], ecx;
	__asm        jge    _T187;
// LINE 2124:
	hd->fwd_speed += ((hd->pitch - hd->fwd_speed) >> 0x5);
// LINE 2125:
_T187:
	__asm        mov    eax, hd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x11C];
	__asm        cmp    [eax+0x128], ecx;
	__asm        jle    _T1c3;
// LINE 2126:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x128];
	__asm        mov    edx, hd;
	__asm        sub    ecx, [edx+0x11C];
	__asm        sar    ecx, 5;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x128], eax;
// LINE 2128:
_T1c3:
	__asm        jmp    _T244;
// LINE 2130:
_T1c8:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        add    eax, eax;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x128];
	__asm        jle    _T202;
// LINE 2131:
	hd->fwd_speed += (((hd->pitch + hd->pitch) - hd->fwd_speed) >> 0x5);
// LINE 2132:
_T202:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        add    eax, eax;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x128];
	__asm        jge    _T244;
// LINE 2133:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x128];
	__asm        mov    edx, hd;
	__asm        mov    edx, [edx+0x11C];
	__asm        add    edx, edx;
	__asm        sub    ecx, edx;
	__asm        sar    ecx, 4;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x128], eax;
// LINE 2136:
_T244:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T25e;
// LINE 2138:
	hd->fwd_speed = 0x0;
// LINE 2142:
_T25e:
	hd->delta_fwd_speed = (hd->fwd_speed - origFwdSpeed);
// LINE 2144:
	velocity = hd->fwd_speed;
// LINE 2147:
	__asm        cmp    G_CheatCodes[0], 0;
	__asm        je     _T2d8;

	__asm        push   1;
	__asm        call   IsModifierSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T2d8;

	__asm        push   8;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T2c4;

	__asm        push   8;
	__asm        push   9;
	__asm        call   GetJoystickValueEither;
	__asm        add    esp, 8;
	__asm        test   eax, eax;
	__asm        je     _T2d8;
// LINE 2149:
_T2c4:
	__asm        push   0xA0000;
	__asm        mov    eax, velocity;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    velocity, eax;
// LINE 2152:
_T2d8:
	AdjustPersonBeamingSlices(velocity);
// LINE 2154:
	__asm        mov    eax, velocity;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x100];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0xE0], eax;
// LINE 2155:
	__asm        mov    eax, velocity;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0xE8], eax;
// LINE 2158:
	__asm        xor    ebx, ebx;
	__asm        push   0x7D00;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x118];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0xE0], ebx;
// LINE 2159:
	__asm        push   0x7D00;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x118];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x100];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0xE8], eax;
// LINE 2161:
	hd->heli_p.Vmag = MTMagnitude((hd + 0xe0));
// LINE 2163:
	__asm        push   0x9C40;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xE0];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x130], eax;
// LINE 2165:
	__asm        push   0x9C40;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xE8];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x134], eax;
// LINE 2167:
	hd->dyheli->loc.z += hd->movez;
// LINE 2168:
	hd->dyheli->loc.x += hd->movex;
// LINE 2169:
}

// FUNCTION: COPTER_D 0x004f32fe
void S3HeliMoveY(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t yrate;
	/*bp-0x8*/   long texid;
	/*bp-0xc*/   /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 2182:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 2187:
	hd->terralt = GetCopterTerAlt(hd);
// LINE 2189:
	hd->buildalt = GetCopterBldAlt(hd);
// LINE 2193:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_turbpitch[0];
	__asm        sar    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x124], eax;
// LINE 2196:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x18];
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x1C];
	__asm        and    ecx, 0xFF;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        mov    texid, edx;
// LINE 2197:
	__asm        cmp    texid, 0;
	__asm        jl     _T9c;

	__asm        cmp    texid, 5;
	__asm        jl     _Tb0;
_T9c:
	__asm        cmp    texid, 5;
	__asm        jl     _Te7;

	__asm        cmp    texid, 0xA;
	__asm        jge    _Te7;
_Tb0:
	__asm        mov    eax, hd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x154];
	__asm        cmp    [eax+0x150], ecx;
	__asm        jl     _Te7;
// LINE 2199:
	hd->can_land = 0x0;
// LINE 2200:
	hd->over_water = 0x1;
// LINE 2202:
	__asm        jmp    _Tf4;
// LINE 2204:
_Te7:
	hd->over_water = 0x0;
// LINE 2208:
_Tf4:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        je     _T10e;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        jne    _T113;
// LINE 2209:
_T10e:
	return;
// LINE 2213:
_T113:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jle    _T28c;
// LINE 2216:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x2C];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    yrate, eax;
// LINE 2218:
	__asm        mov    eax, hd;
	__asm        mov    ecx, yrate;
	__asm        cmp    [eax+0x124], ecx;
	__asm        jle    _T15d;
// LINE 2220:
	hd->yspeed = yrate;
// LINE 2225:
_T15d:
	__asm        cmp    G_CheatCodes[0], 0;
	__asm        je     _T1c0;

	__asm        push   1;
	__asm        call   IsModifierSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T1c0;

	__asm        push   0xC;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T1a0;

	__asm        push   0xD;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T1c0;
// LINE 2227:
_T1a0:
	__asm        push   0xA0000;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x124];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x124], eax;
// LINE 2231:
_T1c0:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x12C;
	__asm        jge    _T206;
// LINE 2233:
	hd->rotspeed += 0x4;
// LINE 2235:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T1f4;
// LINE 2237:
	hd->rotspeed += 0x14;
// LINE 2240:
_T1f4:
	hd->yspeed = 0x0;
// LINE 2242:
	__asm        jmp    _T259;
// LINE 2245:
_T206:
	__asm        mov    eax, G_AvLoopTime;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x2C];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    yrate, eax;
// LINE 2246:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x328];
	__asm        push   eax;
	__asm        mov    eax, yrate;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    yrate, eax;
// LINE 2247:
	__asm        mov    eax, G_AvLoopTime;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x2C];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        add    [ecx+0x124], eax;
// LINE 2251:
_T259:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x150];
	__asm        cmp    eax, S_htwk_max_helialt;
	__asm        jle    _T287;
// LINE 2252:
	hd->yspeed = 0x0;
// LINE 2254:
_T287:
	__asm        jmp    _T506;
_T28c:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jge    _T40b;
// LINE 2261:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, G_AvLoopTime;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, S_htwk_max_descent_rate;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x124], ebx;
// LINE 2263:
	__asm        mov    eax, S_htwk_max_descent_rate;
	__asm        shl    eax, 2;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0x124];
	__asm        jle    _T2ea;
// LINE 2265:
	__asm        mov    eax, S_htwk_max_descent_rate;
	__asm        shl    eax, 2;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x124], eax;
// LINE 2272:
_T2ea:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jne    _T351;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        jle    _T351;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x12C], 0;
	__asm        jge    _T351;
// LINE 2274:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x12C];
	__asm        add    ecx, ecx;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x124], eax;
// LINE 2275:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x124], 0;
	__asm        jle    _T351;

	hd->yspeed = 0x0;
// LINE 2280:
_T351:
	__asm        cmp    G_CheatCodes[0], 0;
	__asm        je     _T3b6;

	__asm        push   1;
	__asm        call   IsModifierSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T3b6;

	__asm        push   0xC;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T394;

	__asm        push   0xD;
	__asm        call   IsEventSet;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T3b6;
// LINE 2282:
_T394:
	__asm        push   0xA0000;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x124];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0x124], eax;
// LINE 2287:
_T3b6:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x154];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jle    _T3f9;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x150];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jle    _T3f9;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T406;
// LINE 2289:
_T3f9:
	hd->yspeed = 0x0;
// LINE 2292:
_T406:
	__asm        jmp    _T506;
// LINE 2295:
_T40b:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x124], 0;
	__asm        jle    _T463;
// LINE 2297:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x124];
	__asm        push   eax;
	__asm        push   0xCCC;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x124], ebx;
// LINE 2298:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x124], 0;
	__asm        jge    _T45e;

	hd->yspeed = 0x0;
// LINE 2300:
_T45e:
	__asm        jmp    _T4b6;
_T463:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x124], 0;
	__asm        jge    _T4b6;
// LINE 2302:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x124];
	__asm        push   eax;
	__asm        push   0x1999;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, hd;
	__asm        sub    [eax+0x124], ebx;
// LINE 2303:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x124], 0;
	__asm        jle    _T4b6;

	hd->yspeed = 0x0;
// LINE 2308:
_T4b6:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x154];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jle    _T4f9;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x150];
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jle    _T4f9;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T506;
// LINE 2309:
_T4f9:
	hd->yspeed = 0x0;
// LINE 2313:
_T506:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x124];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        add    [ecx+0x1C], eax;
// LINE 2314:
	hd->hover_ht = (hd->dyheli->loc.y - hd->terralt);
// LINE 2316:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T5cb;
// LINE 2318:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jle    _T5c6;
// LINE 2321:
	__asm        push   3;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T58d;
// LINE 2322:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x3);
// LINE 2324:
_T58d:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T5bc;
// LINE 2326:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x12C;
	__asm        jl     _T5b7;
// LINE 2327:
	hd->state = 0x1;
// LINE 2329:
_T5b7:
	__asm        jmp    _T5c6;
// LINE 2330:
_T5bc:
	hd->state = 0x4;
// LINE 2335:
_T5c6:
	return;
// LINE 2340:
_T5cb:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x13C], 1;
	__asm        jne    _T70f;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x150];
	__asm        add    ecx, 0x10000;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    _T70f;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_pitch;
	__asm        jg     _T70f;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x124];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_yspeed;
	__asm        jg     _T70f;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x118];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_slide;
	__asm        jg     _T70f;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x128];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_speed;
	__asm        jg     _T70f;
// LINE 2342:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 4;
	__asm        je     _T70a;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T70a;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        je     _T70a;
// LINE 2345:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jle    _T6b9;
// LINE 2346:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x2);
// LINE 2347:
	__asm        jmp    _T6d2;
// LINE 2348:
_T6b9:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x16);
// LINE 2350:
_T6d2:
	hd->dyheli->loc.y = (hd->terralt + 0x13333);
// LINE 2351:
	hd->state = 0x0;
// LINE 2352:
	PersonHeliHasLanded();
// LINE 2355:
	hd->damage = htd->max_damage;
// LINE 2359:
_T70a:
	return;
// LINE 2366:
_T70f:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x13C], 1;
	__asm        jne    __RETURN;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x154];
	__asm        add    ecx, 0x10000;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    __RETURN;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x154];
	__asm        sub    ecx, 0x10000;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jle    __RETURN;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x110], 0;
	__asm        jg     __RETURN;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x11C];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_pitch;
	__asm        jg     __RETURN;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x124];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_yspeed;
	__asm        jg     __RETURN;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x118];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_slide;
	__asm        jg     __RETURN;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x128];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    eax, S_htwk_landing_speed;
	__asm        jg     __RETURN;
// LINE 2368:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 4;
	__asm        je     __RETURN;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     __RETURN;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        je     __RETURN;
// LINE 2371:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jle    _T82e;
// LINE 2372:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x2);
// LINE 2373:
	__asm        jmp    _T847;
// LINE 2374:
_T82e:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x16);
// LINE 2376:
_T847:
	hd->state = 0x0;
// LINE 2377:
	hd->dyheli->loc.y = (hd->buildalt + 0x13333);
// LINE 2378:
	PersonHeliHasLanded();
// LINE 2381:
	hd->damage = htd->max_damage;
// LINE 2385:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f3b82
void S3HeliMainRotor(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t tempfix;
	/*bp-0x28*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x2c*/  int32_t face;
	/*bp-0x30*/  int32_t count;
	/*bp-0x50*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes
	/*bp-0x54*/  /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0x94*/  int32_t tmpmat[4][4]; // 0x40 bytes
	/*bp-0x98*/  int32_t tempfix2;
	/*bp-0xf0*/  /*packed*/ struct VRview pos; // 0x58 bytes

// LINE 2406:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T37;
// LINE 2409:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0;
	__asm        jle    _T32;

	hd->rotspeed--;
// LINE 2411:
_T32:
	__asm        jmp    _T80;
_T37:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        jne    _T63;
// LINE 2414:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0xA;
	__asm        jle    _T5e;

	hd->rotspeed -= 0xa;
// LINE 2416:
_T5e:
	__asm        jmp    _T80;
// LINE 2419:
_T63:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x168;
	__asm        jge    _T80;
// LINE 2420:
	hd->rotspeed += 0x3;
// LINE 2423:
_T80:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0xFA;
	__asm        jle    _T9f;
// LINE 2425:
	tempfix = 0x1870000;
// LINE 2427:
	__asm        jmp    _Td1;
// LINE 2429:
_T9f:
	tempfix = (hd->rotspeed << 0x10);
// LINE 2430:
	__asm        mov    eax, G_AvLoopTime;
	__asm        shl    eax, 5;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    tempfix, eax;
// LINE 2431:
	tempfix2 = (tempfix + tempfix);
// LINE 2434:
_Td1:
	__asm        mov    eax, hd;
	__asm        add    eax, 0x20;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 2435:
	__asm        mov    eax, hd;
	__asm        add    eax, 0x60;
	__asm        push   eax;
	__asm        mov    eax, tempfix;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 2439:
	__asm        mov    esi, hd;
	__asm        lea    edi, tmpmat[0][0];
	__asm        add    esi, 0x60;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 2440:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 2441:
	tmpmat[0][3] = htd->tlrotor_disp.x;
// LINE 2442:
	tmpmat[1][3] = htd->tlrotor_disp.y;
// LINE 2443:
	tmpmat[2][3] = htd->tlrotor_disp.z;
// LINE 2447:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        add    eax, 0x20;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D8900;
	__asm        add    esp, 0xC;
// LINE 2448:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, tmpmat[0][0];
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D8900;
	__asm        add    esp, 0xC;
// LINE 2451:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        lea    eax, pos.loc.x;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB0];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xAC];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2452:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xAC];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 2453:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 2455:
	__asm        mov    eax, htd;
	__asm        test   byte ptr [eax+0x3C], 1;
	__asm        je     _T25d;
// LINE 2457:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2459:
	__asm        jmp    _T294;
// LINE 2461:
_T25d:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xB0];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 2462:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 2466:
_T294:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x12C;
	__asm        jge    _T3ee;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x144], 1;
	__asm        jne    _T3ee;
// LINE 2468:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 2469:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2470:
_FOR_2f4:
	count = 0x0;
	__asm        jmp    _FOR_COND_2f4;
_FOR_NEXT_2f4:
	count++;
_FOR_COND_2f4:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T34c;
// LINE 2472:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 2473:
	__asm        cmp    finfo.Plotter, 0xB;
	__asm        jne    _T338;
// LINE 2475:
	finfo.Attribute = (finfo.Attribute | 0x80000000);
// LINE 2476:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 2478:
_T338:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2479:
	__asm        jmp    _FOR_NEXT_2f4;
// LINE 2481:
_T34c:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 2482:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2483:
_FOR_389:
	count = 0x0;
	__asm        jmp    _FOR_COND_389;
_FOR_NEXT_389:
	count++;
_FOR_COND_389:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T3e1;
// LINE 2485:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 2486:
	__asm        cmp    finfo.Plotter, 0xB;
	__asm        jne    _T3cd;
// LINE 2488:
	finfo.Attribute = (finfo.Attribute | 0x80000000);
// LINE 2489:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 2491:
_T3cd:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2492:
	__asm        jmp    _FOR_NEXT_389;
// LINE 2493:
_T3e1:
	hd->rotstate = 0x0;
// LINE 2496:
_T3ee:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x12C;
	__asm        jl     __RETURN;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x144], 0;
	__asm        jne    __RETURN;
// LINE 2498:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 2499:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2500:
_FOR_44e:
	count = 0x0;
	__asm        jmp    _FOR_COND_44e;
_FOR_NEXT_44e:
	count++;
_FOR_COND_44e:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T4a2;
// LINE 2502:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 2503:
	__asm        cmp    finfo.Plotter, 0xB;
	__asm        jne    _T48e;
// LINE 2505:
	__asm        and    finfo.Attribute, 0x7FFFFFFF;
// LINE 2506:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 2509:
_T48e:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2510:
	__asm        jmp    _FOR_NEXT_44e;
// LINE 2512:
_T4a2:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 2513:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2514:
_FOR_4df:
	count = 0x0;
	__asm        jmp    _FOR_COND_4df;
_FOR_NEXT_4df:
	count++;
_FOR_COND_4df:
	__asm        mov    eax, count;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T533;
// LINE 2516:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 2517:
	__asm        cmp    finfo.Plotter, 0xB;
	__asm        jne    _T51f;
// LINE 2519:
	__asm        and    finfo.Attribute, 0x7FFFFFFF;
// LINE 2520:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 2522:
_T51f:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 2523:
	__asm        jmp    _FOR_NEXT_4df;
// LINE 2524:
_T533:
	hd->rotstate = 0x1;
// LINE 2526:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f40c7
void S3HeliRopeAndBucket(/*packed*/ struct _HELI_DATA *hd, /*packed*/ struct _CELL_INFO *cptr) {
	/*bp-0x4*/   int32_t x;
	/*bp-0x8*/   int32_t y;
	/*bp-0x14*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x18*/  char texid;
	/*bp-0x1c*/  /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0x20*/  int32_t galt;
	/*bp-0x78*/  /*packed*/ struct VRview pos; // 0x58 bytes

// LINE 2542:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 2545:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B8], 0;
	__asm        jge    _T124;
// LINE 2548:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T68;

	__asm        push   0x15;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T68;
// LINE 2550:
	S3DSPlay(0x1, (hd->dyheli + 0x18), 0x15);
// LINE 2553:
_T68:
	hd->rinfo.bucketdown--;
// LINE 2555:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x10;
	__asm        jne    _T11f;
// LINE 2557:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2558:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B8], 0xFFFFFFFF;
	__asm        jne    _Te6;
// LINE 2560:
	hd->rinfo.bucketraised = 0x0;
// LINE 2561:
	hd->dybucket->mesh = hd->bucketmesh;
// LINE 2562:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2564:
	__asm        jmp    _T11f;
// LINE 2566:
_Te6:
	hd->rinfo.harnessraised = 0x0;
// LINE 2567:
	hd->dybucket->mesh = hd->harnessmesh;
// LINE 2568:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2572:
_T11f:
	__asm        jmp    _T220;
_T124:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B8], 0;
	__asm        jle    _T1f6;
// LINE 2575:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T17b;
// LINE 2577:
	__asm        push   0x15;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T16c;
// LINE 2579:
	S3DSPlay(0x1, (hd->dyheli + 0x18), 0x15);
// LINE 2581:
_T16c:
	S3SoundAdjFreq(0xa0, 0x15);
// LINE 2584:
_T17b:
	hd->rinfo.bucketdown++;
// LINE 2588:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x11;
	__asm        jne    _T1f1;
// LINE 2590:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2591:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2592:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B8], 1;
	__asm        jne    _T1e4;
// LINE 2594:
	hd->rinfo.bucketraised = 0x1;
// LINE 2596:
	__asm        jmp    _T1f1;
// LINE 2598:
_T1e4:
	hd->rinfo.harnessraised = 0x1;
// LINE 2603:
_T1f1:
	__asm        jmp    _T220;
_T1f6:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T220;
// LINE 2606:
	__asm        push   0x15;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T220;
// LINE 2607:
	S3DSStopPlay(0x15);
// LINE 2612:
_T220:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xB8];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2615:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B4], 0;
	__asm        jne    _T2a3;
// LINE 2617:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, loc.x;
	__asm        push   eax;
	__asm        push   0x5B4C90;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 2618:
	hd->dyrope->loc.x += loc.x;
// LINE 2619:
	hd->dyrope->loc.y += loc.y;
// LINE 2620:
	hd->dyrope->loc.z += loc.z;
// LINE 2625:
_T2a3:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 1;
	__asm        jne    _T2c8;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B4], 1;
	__asm        jne    _T2c8;
// LINE 2626:
	return;
// LINE 2628:
_T2c8:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2630:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xB8];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 2631:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xB8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 2633:
	galt = S3TerrPrecisionAlt(0x0, pos.loc.z, pos.loc.x);
// LINE 2634:
	S3HeliRopeNextFrame(cptr, galt, hd);
// LINE 2636:
	hd->rinfo.lastbuckloc.x = hd->dybucket->loc.x;
// LINE 2637:
	hd->rinfo.lastbuckloc.y = hd->dybucket->loc.y;
// LINE 2638:
	hd->rinfo.lastbuckloc.z = hd->dybucket->loc.z;
// LINE 2643:
	hd->dybucket->loc.x = (hd->dyrope->loc.x + hd->rinfo.nlast_vert->x);
// LINE 2644:
	hd->dybucket->loc.y = (hd->rinfo.nlast_vert->y + hd->dyrope->loc.y);
// LINE 2645:
	hd->dybucket->loc.z = (hd->rinfo.nlast_vert->z + hd->dyrope->loc.z);
// LINE 2649:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    ecx, galt;
	__asm        add    ecx, 0x20000;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jg     _T548;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T548;
// LINE 2651:
	x = ((hd->dybucket->loc.x + 0x20000000) >> 0x16);
// LINE 2652:
	y = ((0x20000000 - hd->dybucket->loc.z) >> 0x16);
// LINE 2654:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        mov    al, G_texmap[0][eax+ecx];
	__asm        mov    texid, al;
// LINE 2655:
	__asm        movsx  eax, texid;
	__asm        test   eax, eax;
	__asm        jl     _T47b;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 5;
	__asm        jl     _T495;
_T47b:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 5;
	__asm        jl     _T548;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0xA;
	__asm        jge    _T548;
// LINE 2657:
_T495:
	hd->winfo.load += S_htwk_bucket_fillrate;
// LINE 2658:
	__asm        mov    eax, htd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x1C0];
	__asm        cmp    [eax+8], ecx;
	__asm        jge    _T4e7;
// LINE 2660:
	hd->winfo.load = htd->max_load;
// LINE 2661:
	S3ExplosionSmokeStart(0x3, (hd->dybucket + 0x18), cptr);
// LINE 2663:
	__asm        jmp    _T548;
// LINE 2666:
_T4e7:
	__asm        push   0xA;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T512;
// LINE 2667:
	S3DSPlay(0x0, (hd->dybucket + 0x18), 0xa);
// LINE 2669:
_T512:
	S3ExplosionSmokeStart(0x8, (hd->dybucket + 0x18), cptr);
// LINE 2670:
	S3ExplosionSmokeStart(0x3, (hd->dybucket + 0x18), cptr);
// LINE 2675:
_T548:
	__asm        mov    eax, hd;
	__asm        add    eax, 0x184;
	__asm        mov    ecx, hd;
	__asm        add    ecx, 0x19C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2676:
	hd->rinfo.buckdir.x = (hd->rinfo.nlast_vert->x - hd->rinfo.last_vert->x);
// LINE 2677:
	hd->rinfo.buckdir.y = (hd->rinfo.nlast_vert->y - hd->rinfo.last_vert->y);
// LINE 2678:
	hd->rinfo.buckdir.z = (hd->rinfo.nlast_vert->z - hd->rinfo.last_vert->z);
// LINE 2679:
	MTNormalize((hd + 0x184));
// LINE 2681:
	hd->rinfo.throwfactor = (hd->rinfo.lastbuckdir.y - hd->rinfo.buckdir.y);
// LINE 2682:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1A8], 0;
	__asm        jge    _T613;
// LINE 2683:
	hd->rinfo.throwfactor = 0x0;
// LINE 2684:
_T613:
	hd->rinfo.throwfactor = (hd->rinfo.throwfactor * S_htwk_water_throwfact);
// LINE 2687:
	MTCreateDOF4x4Y((hd + 0x184), (hd->dybucket + 0x24));
// LINE 2688:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2689:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xBC];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 2690:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 2692:
}

// FUNCTION: COPTER_D 0x004f4766
void S3HeliDropWater(/*packed*/ struct _HELI_DATA *hd, int32_t alt, /*packed*/ struct _CELL_INFO *cptr) {
	/*bp-0x4*/   int32_t dz;
	/*bp-0x10*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x1c*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x20*/  int32_t dx;

// LINE 2706:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1C0], 0;
	__asm        jne    _T1e;
// LINE 2707:
	return;
// LINE 2710:
_T1e:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1BC], 1;
	__asm        jne    _T17c;
// LINE 2712:
	__asm        xor    eax, eax;
	__asm        sub    eax, S_htwk_bucket_dumprate;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x1C0], eax;
// LINE 2713:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1C0], 0;
	__asm        jge    _T5e;
// LINE 2714:
	hd->winfo.load = 0x0;
// LINE 2716:
_T5e:
	dx = (hd->rinfo.lastbuckloc.x - hd->dybucket->loc.x);
// LINE 2717:
	dz = (hd->rinfo.lastbuckloc.z - hd->dybucket->loc.z);
// LINE 2720:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x184];
	__asm        neg    eax;
	__asm        mov    vec.x, eax;
// LINE 2721:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x188];
	__asm        neg    eax;
	__asm        mov    vec.y, eax;
// LINE 2722:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x18C];
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 2723:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xBC];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2724:
	loc.x += (vec.x << 0x3);
// LINE 2725:
	loc.y += (vec.y << 0x3);
// LINE 2726:
	loc.z += (vec.z << 0x3);
// LINE 2727:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1A8];
	__asm        push   eax;
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 1;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        inc    eax;
	__asm        imul   eax, dx;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    loc.x, eax;
// LINE 2728:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1A8];
	__asm        push   eax;
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 1;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        inc    eax;
	__asm        imul   eax, dz;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    loc.z, eax;
// LINE 2739:
	S3MissileStart(-0x1, 0xf0000, hd->dybucket, 0x1, vec.x, loc.x, (hd + 0x18), 0x6);
// LINE 2742:
_T17c:
	return;
// LINE 2744:
}

// FUNCTION: COPTER_D 0x004f48ec
void S3HeliSimDust(/*packed*/ struct _HELI_DATA *hd, int32_t alt) {
	/*bp-0x40*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x4c*/  /*packed*/ struct Point3d dvec; // 0xc bytes
	/*bp-0x58*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x64*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x68*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x6c*/  int32_t num;

// LINE 2760:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        sub    eax, alt;
	__asm        cmp    eax, 0x140000;
	__asm        jge    _T173;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x118;
	__asm        jle    _T173;
// LINE 2763:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T5c;
// LINE 2764:
	num = ((hd->rotspeed - 0x118) >> 0x2);
// LINE 2765:
	__asm        jmp    _T7b;
// LINE 2766:
_T5c:
	num = ((0x14 - ((hd->dyheli->loc.y - alt) >> 0x10)) >> 0x1);
// LINE 2768:
_T7b:
	__asm        cmp    num, 0;
	__asm        jge    _T8a;

	return;
// LINE 2770:
_T8a:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2771:
	loc.y = alt;
// LINE 2773:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 2774:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x100];
	__asm        neg    eax;
	__asm        mov    vec.x, eax;
// LINE 2775:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x104];
	__asm        neg    eax;
	__asm        mov    vec.y, eax;
// LINE 2776:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x108];
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 2777:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        mov    ebx, 0x5DC0000;
	__asm        call   rand;
	__asm        mov    ecx, 0xBB8;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        sub    ebx, eax;
	__asm        push   ebx;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 2778:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, dvec.x;
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 2779:
	loc.x += (dvec.x << 0x5);
// LINE 2780:
	loc.y += (dvec.y << 0x5);
// LINE 2781:
	loc.z += (dvec.z << 0x5);
// LINE 2782:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x18];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 2783:
	S3ExplosionSmokeStart(0x8, loc.x, cptr);
// LINE 2800:
_T173:
	return;
// LINE 2802:
}

// FUNCTION: COPTER_D 0x004f4a69
void NormalizeMapPoints(int32_t * x, int32_t * z) {
// LINE 2813:
	__asm        mov    eax, x;
	__asm        cmp    dword ptr [eax], 0x20000000;
	__asm        jle    _T1e;
// LINE 2814:
	x[0] -= 0x40000000;
// LINE 2815:
_T1e:
	__asm        mov    eax, x;
	__asm        cmp    dword ptr [eax], 0xE0000000;
	__asm        jge    _T36;
// LINE 2816:
	x[0] += 0x40000000;
// LINE 2818:
_T36:
	__asm        mov    eax, z;
	__asm        cmp    dword ptr [eax], 0x20000000;
	__asm        jle    _T4e;
// LINE 2819:
	z[0] -= 0x40000000;
// LINE 2820:
_T4e:
	__asm        mov    eax, z;
	__asm        cmp    dword ptr [eax], 0xE0000000;
	__asm        jge    __RETURN;
// LINE 2821:
	z[0] += 0x40000000;
// LINE 2822:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f4ad4
void NormalizeXZVector(/*packed*/ struct Point3d *vector) {
	/*bp-0x4*/   int32_t angle;
	/*bp-0x8*/   int32_t length;

// LINE 2838:
	vector->y = 0x0;
// LINE 2840:
	__asm        mov    eax, vector;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, vector;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   0x004D20B1;
	__asm        add    esp, 8;
	__asm        mov    angle, eax;
// LINE 2841:
	__asm        mov    eax, vector;
	__asm        add    eax, 8;
	__asm        push   eax;
	__asm        mov    eax, vector;
	__asm        push   eax;
	__asm        mov    eax, angle;
	__asm        push   eax;
	__asm        call   0x004D19FC;
	__asm        add    esp, 0xC;
// LINE 2847:
__DO_42:
	length = MTMagnitude(vector);
// LINE 2848:
	__asm        cmp    length, 0x10000;
	__asm        jge    __DO_WHILE_42;
// LINE 2850:
	__asm        mov    eax, vector;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _T95;
// LINE 2852:
	__asm        mov    eax, vector;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jle    _T86;
// LINE 2853:
	vector->z = 0x10000;
// LINE 2854:
	__asm        jmp    _T90;
// LINE 2855:
_T86:
	vector->z = 0xffff0000;
// LINE 2857:
_T90:
	__asm        jmp    __DO_WHILE_42;
_T95:
	__asm        mov    eax, vector;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jne    _Tcb;
// LINE 2859:
	__asm        mov    eax, vector;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jle    _Tbd;
// LINE 2860:
	vector->x = 0x10000;
// LINE 2861:
	__asm        jmp    _Tc6;
// LINE 2862:
_Tbd:
	vector->x = 0xffff0000;
// LINE 2864:
_Tc6:
	__asm        jmp    __DO_WHILE_42;
_Tcb:
	__asm        mov    eax, vector;
	__asm        mov    eax, [eax];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, vector;
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jge    _T10a;
// LINE 2866:
	__asm        mov    eax, vector;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jle    _T100;
// LINE 2867:
	vector->x++;
// LINE 2868:
	__asm        jmp    _T105;
// LINE 2869:
_T100:
	vector->x--;
// LINE 2871:
_T105:
	__asm        jmp    __DO_WHILE_42;
// LINE 2873:
_T10a:
	__asm        mov    eax, vector;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jle    _T122;
// LINE 2874:
	vector->z++;
// LINE 2875:
	__asm        jmp    __DO_WHILE_42;
// LINE 2876:
_T122:
	vector->z--;
// LINE 2879:
__DO_WHILE_42:
	__asm        cmp    length, 0x10000;
	__asm        jl     __DO_42;
// LINE 2881:
}

// FUNCTION: COPTER_D 0x004f4c0e
void S3HeliRopeNextFrame(/*packed*/ struct _HELI_DATA *hd, int32_t gralt, /*packed*/ struct _CELL_INFO *cptr) {
	/*bp-0xc*/   /*packed*/ struct Point3d ploc; // 0xc bytes
	/*bp-0x10*/  int32_t flags;
	/*bp-0x14*/  int32_t normz;
	/*bp-0x18*/  int32_t vectorz;
	/*bp-0x1c*/  int32_t ropeload;
	/*bp-0x20*/  int32_t maxobjy;
	/*bp-0x24*/  /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0x28*/  int32_t vectorx;
	/*bp-0x2c*/  int32_t c;
	/*bp-0x30*/  int32_t absvectorxz;
	/*bp-0x34*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x38*/  /*packed*/ struct Point3d *vert;
	/*bp-0x3c*/  int32_t absdx;
	/*bp-0x48*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x4c*/  /*packed*/ struct Point3d *pvert;
	/*bp-0x50*/  int32_t absdz;
	/*bp-0x54*/  int32_t absvectorz;
	/*bp-0x58*/  int32_t objy;
	/*bp-0x5c*/  int32_t absvectorx;
	/*bp-0x68*/  /*packed*/ struct Point3d oloc; // 0xc bytes
	/*bp-0x6c*/  int32_t alt;
	/*bp-0x70*/  int32_t distx;
	/*bp-0x74*/  /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0x78*/  int32_t distz;
	/*bp-0x7c*/  int32_t normx;
	/*bp-0x80*/  int32_t normy;

// LINE 2906:
	ropeload = 0x8;
// LINE 2907:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 2910:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T60;
// LINE 2912:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C0];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, htd;
	__asm        cdq;
	__asm        idiv   dword ptr [ecx+8];
	__asm        imul   eax, S_htwk_rope_loadfactor;
	__asm        mov    c, eax;
// LINE 2913:
	ropeload += (c >> 0x10);
// LINE 2918:
_T60:
	absdx = hd->movex;
// LINE 2919:
	absdz = hd->movez;
// LINE 2920:
	__asm        cmp    absdx, 0;
	__asm        jge    _T8a;

	__asm        mov    eax, absdx;
	__asm        neg    eax;
	__asm        mov    absdx, eax;
// LINE 2921:
_T8a:
	__asm        cmp    absdz, 0;
	__asm        jge    _FOR_b4;

	__asm        mov    eax, absdz;
	__asm        neg    eax;
	__asm        mov    absdz, eax;
// LINE 2924:
_FOR_b4:
	c = 0x0;
	vert = hd->rinfo.verts;
	__asm        jmp    _FOR_COND_b4;
_FOR_NEXT_b4:
	c++;
	vert += 0xc;
_FOR_COND_b4:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1AC];
	__asm        inc    eax;
	__asm        cmp    eax, c;
	__asm        jle    _Tf4;
// LINE 2926:
	vert->z = 0x0;
	vert->y = vert->z;
	vert->x = vert->y;
// LINE 2927:
	__asm        jmp    _FOR_NEXT_b4;
// LINE 2930:
_Tf4:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1AC];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    ecx, hd;
	__asm        add    eax, [ecx+0x178];
	__asm        mov    pvert, eax;
// LINE 2931:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1AC];
	__asm        lea    eax, [eax+eax*2+3];
	__asm        shl    eax, 2;
	__asm        mov    ecx, hd;
	__asm        add    eax, [ecx+0x178];
	__asm        mov    vert, eax;
// LINE 2932:
_FOR_13d:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1AC];
	__asm        inc    eax;
	__asm        mov    c, eax;
	__asm        jmp    _FOR_COND_13d;
_FOR_NEXT_13d:
	c++;
	vert += 0xc;
	pvert += 0xc;
_FOR_COND_13d:
	__asm        cmp    c, 0x14;
	__asm        jge    __RETURN;
// LINE 2934:
	distx = ((vert->x - pvert->x) + hd->movex);
// LINE 2935:
	distz = ((vert->z - pvert->z) + hd->movez);
// LINE 2943:
	__asm        mov    eax, S_htwk_rope_tension;
	__asm        push   eax;
	__asm        mov    eax, distz;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    vectorz, eax;
// LINE 2944:
	__asm        mov    eax, S_htwk_rope_tension;
	__asm        push   eax;
	__asm        mov    eax, distx;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    vectorx, eax;
// LINE 2946:
	__asm        cmp    distx, 0;
	__asm        jl     _T1c3;
// LINE 2947:
	__asm        mov    eax, distx;
	__asm        cdq;
	__asm        idiv   ropeload;
	__asm        mov    absvectorx, eax;
// LINE 2948:
	__asm        jmp    _T1cf;
// LINE 2949:
_T1c3:
	__asm        mov    eax, distx;
	__asm        cdq;
	__asm        idiv   ropeload;
	__asm        neg    eax;
	__asm        mov    absvectorx, eax;
// LINE 2951:
_T1cf:
	__asm        cmp    distz, 0;
	__asm        jl     _T1e8;
// LINE 2952:
	__asm        mov    eax, distz;
	__asm        cdq;
	__asm        idiv   ropeload;
	__asm        mov    absvectorz, eax;
// LINE 2953:
	__asm        jmp    _T1f4;
// LINE 2954:
_T1e8:
	__asm        mov    eax, distz;
	__asm        cdq;
	__asm        idiv   ropeload;
	__asm        neg    eax;
	__asm        mov    absvectorz, eax;
// LINE 2957:
_T1f4:
	absvectorxz = (absvectorx + absvectorz);
// LINE 2958:
	__asm        mov    eax, absvectorxz;
	__asm        cmp    RopeSeg, eax;
	__asm        jge    _T214;
// LINE 2959:
	absvectorxz = RopeSeg;
// LINE 2961:
_T214:
	vert->y = ((pvert->y - RopeSeg) + absvectorxz);
// LINE 2969:
	ploc.x = (hd->dyrope->loc.x + vert->x);
// LINE 2970:
	ploc.z = (hd->dyrope->loc.z + vert->z);
// LINE 2971:
	ploc.y = (hd->dyrope->loc.y + vert->y);
// LINE 2974:
	__asm        mov    eax, ploc.x;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normx, eax;
// LINE 2975:
	__asm        mov    eax, ploc.z;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normz, eax;
// LINE 2976:
	__asm        mov    eax, ploc.y;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normy, eax;
// LINE 2979:
	stobj = cptr->stptr;
// LINE 2980:
	objy = 0x0;
// LINE 2981:
	maxobjy = 0x0;
// LINE 2982:
__WHILE_2b4:
	__asm        cmp    stobj, 0;
	__asm        je     _T318;
// LINE 2984:
	flags = stobj->user1;
// LINE 2985:
	objy = VRGetObjAlt2(0x0, 0x0, RopeDim, RopeDim, flags, normz, normy, normx, stobj->mesh);
// LINE 2986:
	__asm        mov    eax, objy;
	__asm        cmp    maxobjy, eax;
	__asm        jge    _T30b;
// LINE 2987:
	maxobjy = objy;
// LINE 2988:
_T30b:
	stobj = stobj->next;
// LINE 2989:
	__asm        jmp    __WHILE_2b4;
// LINE 2992:
_T318:
	alt = ((gralt + maxobjy) - hd->dyrope->loc.y);
// LINE 2994:
	dyobj = cptr->dyptr;
// LINE 2995:
	objy = 0x0;
// LINE 2996:
	maxobjy = 0x0;
// LINE 2997:
__WHILE_344:
	__asm        cmp    dyobj, 0;
	__asm        je     _T40f;
// LINE 3000:
	__asm        mov    eax, G_uheli;
	__asm        mov    ecx, dyobj;
	__asm        cmp    [eax+0xA4], ecx;
	__asm        jne    _T367;
// LINE 3002:
	__asm        jmp    next_dyobj;
// LINE 3005:
_T367:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _T37b;
// LINE 3007:
	__asm        jmp    next_dyobj;
// LINE 3009:
_T37b:
	oloc.x = (ploc.x - dyobj->loc.x);
// LINE 3010:
	oloc.y = (ploc.y - dyobj->loc.y);
// LINE 3011:
	oloc.z = (ploc.z - dyobj->loc.z);
// LINE 3016:
	objy = VRGetDyObjAlt(RopeDim, oloc.x, (dyobj + 0x24), dyobj->mesh);
// LINE 3017:
	__asm        mov    eax, objy;
	__asm        cmp    maxobjy, eax;
	__asm        jge    next_dyobj;
// LINE 3018:
	maxobjy = objy;
// LINE 3022:
next_dyobj:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T402;
// LINE 3024:
	dyobj = dyobj->next->next->next->next->next->next->next->next->next->next;
// LINE 3026:
	__asm        jmp    _T40a;
// LINE 3027:
_T402:
	dyobj = dyobj->next;
// LINE 3028:
_T40a:
	__asm        jmp    __WHILE_344;
// LINE 3030:
_T40f:
	alt += maxobjy;
// LINE 3032:
	__asm        mov    eax, vert;
	__asm        mov    ecx, alt;
	__asm        cmp    [eax+4], ecx;
	__asm        jge    _T492;
// LINE 3034:
	vert->y = alt;
// LINE 3035:
	__asm        mov    eax, absdx;
	__asm        cmp    absvectorx, eax;
	__asm        jle    _T44a;
// LINE 3036:
	__asm        xor    eax, eax;
	__asm        sub    eax, vectorx;
	__asm        neg    eax;
	__asm        mov    ecx, vert;
	__asm        sub    [ecx], eax;
// LINE 3037:
	__asm        jmp    _T45c;
// LINE 3038:
_T44a:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x130];
	__asm        neg    eax;
	__asm        mov    ecx, vert;
	__asm        sub    [ecx], eax;
// LINE 3040:
_T45c:
	__asm        mov    eax, absvectorz;
	__asm        cmp    absdz, eax;
	__asm        jge    _T47a;
// LINE 3041:
	__asm        xor    eax, eax;
	__asm        sub    eax, vectorz;
	__asm        neg    eax;
	__asm        mov    ecx, vert;
	__asm        sub    [ecx+8], eax;
// LINE 3042:
	__asm        jmp    _T48d;
// LINE 3043:
_T47a:
	__asm        xor    eax, eax;
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0x134];
	__asm        neg    eax;
	__asm        mov    ecx, vert;
	__asm        sub    [ecx+8], eax;
// LINE 3045:
_T48d:
	__asm        jmp    _T4ab;
// LINE 3047:
_T492:
	__asm        xor    eax, eax;
	__asm        sub    eax, vectorx;
	__asm        neg    eax;
	__asm        mov    ecx, vert;
	__asm        sub    [ecx], eax;
// LINE 3048:
	__asm        xor    eax, eax;
	__asm        sub    eax, vectorz;
	__asm        neg    eax;
	__asm        mov    ecx, vert;
	__asm        sub    [ecx+8], eax;
// LINE 3053:
_T4ab:
	vec.x = (vert->x - pvert->x);
// LINE 3054:
	vec.y = (vert->y - pvert->y);
// LINE 3055:
	vec.z = (vert->z - pvert->z);
// LINE 3056:
	MTNormalize(vec.x);
// LINE 3057:
	vert->x = ((vec.x << 0x2) + pvert->x);
// LINE 3058:
	vert->y = ((vec.y << 0x2) + pvert->y);
// LINE 3059:
	vert->z = ((vec.z << 0x2) + pvert->z);
// LINE 3061:
	__asm        jmp    _FOR_NEXT_13d;
// LINE 3063:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f512e
void S3DrawWater(/*packed*/ struct VRBlit *blit) {
// LINE 3319:
}

// FUNCTION: COPTER_D 0x004f5139
int32_t GetCopterTerAlt(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t alt;

// LINE 3327:
	alt = S3TerrPrecisionAlt((hd + 0x13c), hd->dyheli->loc.z, hd->dyheli->loc.x);
// LINE 3329:
	return alt;
// LINE 3331:
}

// FUNCTION: COPTER_D 0x004f517d
int32_t GetCopterBldAlt(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t flags;
	/*bp-0x8*/   int32_t normz;
	/*bp-0xc*/   int32_t landable;
	/*bp-0x10*/  int32_t maxobjy;
	/*bp-0x14*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x20*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x24*/  int32_t objy;
	/*bp-0x28*/  int32_t alt;
	/*bp-0x2c*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x30*/  int32_t normx;
	/*bp-0x34*/  int32_t normy;

// LINE 3345:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x18];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 3347:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normx, eax;
// LINE 3348:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normz, eax;
// LINE 3349:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normy, eax;
// LINE 3351:
	objy = 0x0;
// LINE 3352:
	maxobjy = 0x0;
// LINE 3353:
	landable = 0x0;
// LINE 3354:
	stobj = cptr->stptr;
// LINE 3355:
__WHILE_9c:
	__asm        cmp    stobj, 0;
	__asm        je     _T146;
// LINE 3357:
	flags = stobj->user1;
// LINE 3363:
	objy = VRGetObjAlt2(landable, vec.x, hd->dyheli->height, hd->dyheli->radius, flags, normz, normy, normx, stobj->mesh);
// LINE 3364:
	__asm        mov    eax, objy;
	__asm        cmp    maxobjy, eax;
	__asm        jge    _T139;
// LINE 3366:
	hd->shad_color = flags;
// LINE 3367:
	maxobjy = objy;
// LINE 3368:
	__asm        lea    eax, vec.x;
	__asm        mov    ecx, hd;
	__asm        add    ecx, 0x158;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 3369:
	hd->can_land = landable;
// LINE 3371:
_T139:
	stobj = stobj->next;
// LINE 3372:
	__asm        jmp    __WHILE_9c;
// LINE 3377:
_T146:
	__asm        cmp    maxobjy, 0;
	__asm        jne    _T17c;
// LINE 3378:
	alt = S3TerrPrecisionAlt(0x0, hd->dyheli->loc.z, hd->dyheli->loc.x);
// LINE 3379:
	__asm        jmp    _T18c;
// LINE 3380:
_T17c:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        add    eax, maxobjy;
	__asm        mov    alt, eax;
// LINE 3382:
_T18c:
	return alt;
// LINE 3383:
}

// FUNCTION: COPTER_D 0x004f5316
void S3HeliTestCopter(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t randz;
	/*bp-0x8*/   long x;
	/*bp-0xc*/   long y;
	/*bp-0x10*/  int32_t randx;

// LINE 3403:
	__asm        cmp    hd, 0;
	__asm        jne    _T18;
// LINE 3404:
	return;
// LINE 3406:
_T18:
	__asm        cmp    S_avoiding, 0;
	__asm        je     _T30;
// LINE 3410:
	S_avoiding--;
// LINE 3412:
	return;
// LINE 3413:
_T30:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 1;
	__asm        je     _T4a;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 2;
	__asm        jne    _T8a;
_T4a:
	__asm        push   8;
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliCollideTest;
	__asm        add    esp, 8;
	__asm        cmp    eax, 1;
	__asm        jne    _T8a;
// LINE 3416:
	hd->pitch = 0xfed40000;
// LINE 3417:
	hd->slide = 0xfa0000;
// LINE 3418:
	S_avoiding = 0x8;
// LINE 3420:
	return;
// LINE 3421:
_T8a:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 3;
	__asm        je     _Tb1;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 2;
	__asm        je     _Tb1;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T1a0;
// LINE 3423:
_Tb1:
	hd->winfo.dropwater = 0x0;
// LINE 3424:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 0x11;
	__asm        jge    _Te0;
// LINE 3426:
	hd->rinfo.raiselower = 0x1;
// LINE 3428:
	__asm        jmp    _Ted;
// LINE 3430:
_Te0:
	hd->rinfo.raiselower = 0x0;
// LINE 3432:
_Ted:
	__asm        push   0x6BF1C0;
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliLand;
	__asm        add    esp, 8;
	__asm        cmp    eax, 1;
	__asm        jne    _T19b;
// LINE 3434:
	hd->state = 0x4;
// LINE 3437:
	__asm        call   rand;
	__asm        mov    ecx, 0x1F40;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        neg    eax;
	__asm        mov    randx, eax;
// LINE 3438:
	__asm        call   rand;
	__asm        mov    ecx, 0x1F40;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    randz, edx;
// LINE 3441:
	G_testloc.x = (randx << 0x10);
// LINE 3442:
	G_testloc.z = (randz << 0x10);
// LINE 3443:
	x = ((G_testloc.x + 0x20000000) >> 0x16);
// LINE 3444:
	y = ((0x20000000 - G_testloc.z) >> 0x16);
// LINE 3445:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        push   eax;
	__asm        call   S3HeliHighestBuildAlt;
	__asm        add    esp, 4;
	__asm        mov    S_targalt, eax;
// LINE 3448:
_T19b:
	return;
_T1a0:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 4;
	__asm        jne    _T20d;
// LINE 3450:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x1AC], 3;
	__asm        jle    _T1cf;
// LINE 3452:
	hd->rinfo.raiselower = 0xffffffff;
// LINE 3454:
	__asm        jmp    _T1dc;
// LINE 3456:
_T1cf:
	hd->rinfo.raiselower = 0x0;
// LINE 3458:
_T1dc:
	hd->winfo.dropwater = 0x0;
// LINE 3459:
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliTakeOff;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T208;
// LINE 3461:
	hd->state = 0x1;
// LINE 3464:
_T208:
	return;
// LINE 3467:
_T20d:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T224;
// LINE 3468:
	hd->state = 0x4;
// LINE 3471:
_T224:
	hd->pitch = 0x4b0000;
// LINE 3472:
	hd->slide = 0x0;
// LINE 3473:
	hd->roll = 0x0;
// LINE 3476:
	__asm        mov    eax, hd;
	__asm        mov    ecx, S_targalt;
	__asm        add    ecx, 0xB40000;
	__asm        cmp    [eax+0x138], ecx;
	__asm        jle    _T275;
// LINE 3477:
	hd->altdelta = 0xffffffff;
// LINE 3478:
	__asm        jmp    _T2a9;
_T275:
	__asm        mov    eax, hd;
	__asm        mov    ecx, S_targalt;
	__asm        add    ecx, 0x960000;
	__asm        cmp    [eax+0x138], ecx;
	__asm        jge    _T29f;
// LINE 3479:
	hd->altdelta = 0x1;
// LINE 3480:
	__asm        jmp    _T2a9;
// LINE 3481:
_T29f:
	hd->altdelta = 0x0;
// LINE 3483:
_T2a9:
	__asm        push   0x6BF1C0;
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliHeadToLocXZ;
	__asm        add    esp, 8;
	__asm        cmp    eax, 1;
	__asm        jne    _T34d;
// LINE 3486:
	__asm        call   rand;
	__asm        mov    ecx, 0x1F40;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        neg    eax;
	__asm        mov    randx, eax;
// LINE 3487:
	__asm        call   rand;
	__asm        mov    ecx, 0x1F40;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    randz, edx;
// LINE 3490:
	G_testloc.x = (randx << 0x10);
// LINE 3491:
	G_testloc.z = (randz << 0x10);
// LINE 3492:
	x = ((G_testloc.x + 0x20000000) >> 0x16);
// LINE 3493:
	y = ((0x20000000 - G_testloc.z) >> 0x16);
// LINE 3494:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        push   eax;
	__asm        call   S3HeliHighestBuildAlt;
	__asm        add    esp, 4;
	__asm        mov    S_targalt, eax;
// LINE 3510:
_T34d:
	__asm        mov    eax, S_test_frames;
	__asm        mov    [ebp-0x14], eax;
	__asm        inc    S_test_frames;
	__asm        cmp    dword ptr [ebp-0x14], 0x32;
	__asm        jge    _T377;
// LINE 3512:
	hd->winfo.dropwater = 0x1;
// LINE 3514:
	return;
// LINE 3516:
_T377:
	hd->winfo.dropwater = 0x0;
// LINE 3517:
	__asm        cmp    S_test_frames, 0x96;
	__asm        jle    __RETURN;

	S_test_frames = 0x0;
// LINE 3520:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f56b9
int32_t S3HeliLand(/*packed*/ struct _HELI_DATA *hd, /*packed*/ struct Point3d *loc) {
// LINE 3537:
	hd->slide = 0x0;
// LINE 3538:
	hd->roll = 0x0;
// LINE 3542:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 2;
	__asm        jne    _Tee;
// LINE 3546:
	__asm        mov    eax, loc;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, 0x960000;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        cmp    eax, [ecx+0x1C];
	__asm        jge    _T66;
// LINE 3548:
	hd->altdelta = 0xffffffff;
// LINE 3549:
	hd->pitch = 0x140000;
// LINE 3551:
	__asm        jmp    _Tb7;
_T66:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, loc;
	__asm        mov    ecx, [ecx+4];
	__asm        add    ecx, 0x640000;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    _Ta0;
// LINE 3553:
	hd->altdelta = 0x1;
// LINE 3554:
	hd->pitch = 0x140000;
// LINE 3556:
	__asm        jmp    _Tb7;
// LINE 3558:
_Ta0:
	hd->altdelta = 0x0;
// LINE 3559:
	hd->pitch = 0x4b0000;
// LINE 3561:
_Tb7:
	__asm        mov    eax, loc;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        push   eax;
	__asm        call   S3HeliHeadToLocXZ;
	__asm        add    esp, 8;
	__asm        cmp    eax, 1;
	__asm        jne    _Te7;
// LINE 3563:
	hd->state = 0x3;
// LINE 3564:
	hd->fwd_speed = 0x0;
// LINE 3567:
_Te7:
	return 0x0;
// LINE 3571:
_Tee:
	hd->pitch = 0x0;
// LINE 3572:
	hd->altdelta = 0x0;
// LINE 3574:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T131;
// LINE 3577:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x14;
	__asm        jge    _T12c;
// LINE 3578:
	return 0x1;
// LINE 3580:
_T12c:
	__asm        jmp    _T13b;
// LINE 3582:
_T131:
	hd->altdelta = 0xffffffff;
// LINE 3585:
_T13b:
	return 0x0;
// LINE 3586:
}

// FUNCTION: COPTER_D 0x004f5800
int32_t S3HeliTakeOff(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t alt;

// LINE 3602:
	hd->slide = 0x0;
// LINE 3603:
	hd->roll = 0x0;
// LINE 3604:
	hd->pitch = 0x0;
// LINE 3607:
	hd->altdelta = 0x1;
// LINE 3609:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T4e;
// LINE 3611:
	return 0x0;
// LINE 3615:
_T4e:
	alt = GetCopterBldAlt(hd);
// LINE 3616:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    ecx, alt;
	__asm        add    ecx, 0x960000;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    _T7f;
// LINE 3619:
	return 0x0;
// LINE 3622:
_T7f:
	hd->altdelta = 0x0;
// LINE 3623:
	return 0x1;
// LINE 3624:
}

// FUNCTION: COPTER_D 0x004f5898
void S3HeliHeadsUp() {
// LINE 3638:
}

// FUNCTION: COPTER_D 0x004f58a3
int32_t S3HeliGetDeflection(/*packed*/ struct _HELI_DATA *hd, /*packed*/ struct Point3d *vector, int32_t * dist, int32_t * alt) {
	/*bp-0x4*/   int32_t deltaz;
	/*bp-0x8*/   int32_t deflectangle;
	/*bp-0xc*/   int32_t fx;
	/*bp-0x10*/  int32_t maxradius;
	/*bp-0x14*/  long x;
	/*bp-0x18*/  int32_t fz;
	/*bp-0x1c*/  long i;
	/*bp-0x20*/  long y;
	/*bp-0x24*/  /*packed*/ struct _CELL_INFO *lcptr;
	/*bp-0x28*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x2c*/  int32_t deltax;

// LINE 3667:
	deltax = (vector->x << 0x2);
// LINE 3668:
	deltaz = (vector->z << 0x2);
// LINE 3671:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, deltax;
	__asm        lea    eax, [eax+ecx*2];
	__asm        mov    fx, eax;
// LINE 3672:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, deltaz;
	__asm        lea    eax, [eax+ecx*2];
	__asm        mov    fz, eax;
// LINE 3675:
	lcptr = 0x0;
// LINE 3680:
_FOR_5d:
	i = 0x0;
	__asm        jmp    _FOR_COND_5d;
_FOR_NEXT_5d:
	i++;
	fx += deltax;
	fz += deltaz;
_FOR_COND_5d:
	__asm        cmp    i, 0x50;
	__asm        jge    _Tf2;
// LINE 3683:
	x = ((fx + 0x20000000) >> 0x16);
// LINE 3684:
	y = ((0x20000000 - fz) >> 0x16);
// LINE 3685:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 3686:
	__asm        mov    eax, cptr;
	__asm        cmp    lcptr, eax;
	__asm        jne    _Tc1;
// LINE 3687:
	__asm        jmp    _FOR_NEXT_5d;
// LINE 3688:
_Tc1:
	lcptr = cptr;
// LINE 3693:
	maxradius = S3HeliHighestBuildAlt(cptr);
// LINE 3694:
	__asm        mov    eax, hd;
	__asm        mov    ecx, maxradius;
	__asm        cmp    [eax+0x138], ecx;
	__asm        jge    _Ted;
// LINE 3695:
	__asm        jmp    _Tf2;
// LINE 3696:
_Ted:
	__asm        jmp    _FOR_NEXT_5d;
// LINE 3698:
_Tf2:
	alt[0] = maxradius;
// LINE 3701:
	__asm        cmp    i, 0x50;
	__asm        jne    _T10b;
// LINE 3702:
	return 0x0;
// LINE 3706:
_T10b:
	__asm        mov    eax, i;
	__asm        inc    eax;
	__asm        shl    eax, 0x12;
	__asm        mov    ecx, dist;
	__asm        mov    [ecx], eax;
// LINE 3707:
	__asm        mov    eax, dist;
	__asm        cmp    dword ptr [eax], 0x1400000;
	__asm        jl     _T12d;
// LINE 3708:
	return 0x0;
// LINE 3710:
_T12d:
	__asm        mov    ebx, 0x10000;
	__asm        push   0x1400000;
	__asm        mov    eax, dist;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    deflectangle, ebx;
// LINE 3711:
	__asm        mov    eax, deflectangle;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*4];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    deflectangle, eax;
// LINE 3713:
	return deflectangle;
// LINE 3715:
}

// FUNCTION: COPTER_D 0x004f5a0c
int32_t S3HeliHighestBuildAlt(/*packed*/ struct _CELL_INFO *cptr) {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x2c*/  int32_t maxradius;

// LINE 3733:
	stobj = cptr->stptr;
// LINE 3734:
	maxradius = 0x0;
// LINE 3735:
__WHILE_19:
	__asm        cmp    stobj, 0;
	__asm        je     _T65;
// LINE 3737:
	__asm        mov    eax, stobj;
	__asm        test   dword ptr [eax+8], 0x1A4;
	__asm        je     _T58;
// LINE 3739:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, stobj;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 3740:
	__asm        mov    eax, maxradius;
	__asm        cmp    oinfo.Radius, eax;
	__asm        jle    _T58;
// LINE 3741:
	maxradius = oinfo.Radius;
// LINE 3744:
_T58:
	stobj = stobj->next;
// LINE 3745:
	__asm        jmp    __WHILE_19;
// LINE 3747:
_T65:
	return (maxradius + maxradius);
// LINE 3748:
}

// FUNCTION: COPTER_D 0x004f5a80
void S3HeliSwitchType(/*packed*/ struct _HELI_DATA *hd) {
// LINE 3760:
	return;
// LINE 3761:
}

// FUNCTION: COPTER_D 0x004f5a90
/*packed*/ struct _HELI_DATA* S3HeliGetDataByDyObj(/*packed*/ struct _DYOBJ_INST *dyheli) {
	/*bp-0x4*/   long heliidx;

// LINE 3775:
_FOR_15:
	heliidx = 0x0;
	__asm        jmp    _FOR_COND_15;
_FOR_NEXT_15:
	heliidx++;
_FOR_COND_15:
	__asm        cmp    heliidx, 0xA;
	__asm        jge    _T60;
// LINE 3777:
	__asm        mov    eax, heliidx;
	__asm        cmp    G_helis[0][eax*4], 0;
	__asm        je     _T5b;
// LINE 3779:
	__asm        mov    eax, heliidx;
	__asm        mov    eax, G_helis[0][eax*4];
	__asm        mov    ecx, dyheli;
	__asm        cmp    [eax+0xA4], ecx;
	__asm        jne    _T5b;
// LINE 3780:
	__asm        mov    eax, heliidx;
	__asm        mov    eax, G_helis[0][eax*4];
	__asm        jmp    __RETURN;
// LINE 3782:
_T5b:
	__asm        jmp    _FOR_NEXT_15;
// LINE 3784:
_T60:
	return 0x0;
// LINE 3785:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f5afc
void S3HeliNextFrameDriver() {
	/*bp-0x4*/   long heliidx;

// LINE 3800:
_FOR_15:
	heliidx = 0x0;
	__asm        jmp    _FOR_COND_15;
_FOR_NEXT_15:
	heliidx++;
_FOR_COND_15:
	__asm        cmp    heliidx, 0xA;
	__asm        jge    _T64;
// LINE 3802:
	__asm        mov    eax, heliidx;
	__asm        cmp    G_helis[0][eax*4], 0;
	__asm        je     _T5f;
// LINE 3804:
	__asm        mov    eax, heliidx;
	__asm        mov    eax, G_helis[0][eax*4];
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T4c;
// LINE 3805:
	__asm        jmp    _FOR_NEXT_15;
// LINE 3810:
_T4c:
	__asm        mov    eax, heliidx;
	__asm        mov    eax, G_helis[0][eax*4];
	__asm        push   eax;
	__asm        call   S3HeliNextFrame;
	__asm        add    esp, 4;
// LINE 3812:
_T5f:
	__asm        jmp    _FOR_NEXT_15;
// LINE 3815:
_T64:
	S3HeliSoundDriver();
// LINE 3817:
}

// FUNCTION: COPTER_D 0x004f5b6a
void S3HeliSoundDriver() {
	/*bp-0x4*/   /*packed*/ struct _HELI_DATA *closehd;
	/*bp-0x8*/   long heliidx;
	/*bp-0xc*/   int32_t dist;
	/*bp-0x10*/  /*packed*/ struct _HELI_DATA *hd;
	/*bp-0x1c*/  /*packed*/ struct Point3d viewvect; // 0xc bytes
	/*bp-0x20*/  int32_t vol_adj;
	/*bp-0x24*/  int32_t closest;

// LINE 3841:
	__asm        mov    eax, S_sound_frames;
	__asm        mov    [ebp-0x28], eax;
	__asm        inc    S_sound_frames;
	__asm        cmp    dword ptr [ebp-0x28], 5;
	__asm        jle    _T30;
// LINE 3843:
	S_sound_frames = 0x0;
// LINE 3845:
	__asm        jmp    _T35;
// LINE 3847:
_T30:
	return;
// LINE 3852:
_T35:
	__asm        cmp    G_camera_mode, 3;
	__asm        je     _T4f;
// LINE 3854:
	hd = G_uheli;
// LINE 3856:
	__asm        jmp    _T133;
// LINE 3859:
_T4f:
	closest = 0x7800000;
// LINE 3860:
	closehd = 0x0;
// LINE 3862:
_FOR_69:
	heliidx = 0x0;
	__asm        jmp    _FOR_COND_69;
_FOR_NEXT_69:
	heliidx++;
_FOR_COND_69:
	__asm        cmp    heliidx, 0xA;
	__asm        jge    _T10f;
// LINE 3864:
	__asm        mov    eax, heliidx;
	__asm        cmp    G_helis[0][eax*4], 0;
	__asm        je     _T10a;
// LINE 3866:
	__asm        mov    eax, heliidx;
	__asm        mov    eax, G_helis[0][eax*4];
	__asm        mov    hd, eax;
// LINE 3867:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0;
	__asm        je     _T10a;
// LINE 3869:
	viewvect.x = (hd->dyheli->loc.x - ViewState.world_pos.x);
// LINE 3870:
	viewvect.y = (hd->dyheli->loc.y - ViewState.world_pos.y);
// LINE 3871:
	viewvect.z = (hd->dyheli->loc.z - ViewState.world_pos.z);
// LINE 3872:
	dist = MTMagnitude(viewvect.x);
// LINE 3873:
	__asm        mov    eax, dist;
	__asm        cmp    closest, eax;
	__asm        jle    _T10a;
// LINE 3875:
	closest = dist;
// LINE 3876:
	closehd = hd;
// LINE 3880:
_T10a:
	__asm        jmp    _FOR_NEXT_69;
// LINE 3882:
_T10f:
	__asm        cmp    closehd, 0;
	__asm        jne    _T12d;
// LINE 3884:
	S3DSStopPlay(0x0);
// LINE 3885:
	return;
// LINE 3887:
	__asm        jmp    _T133;
// LINE 3889:
_T12d:
	hd = closehd;
// LINE 3893:
_T133:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T247;
// LINE 3895:
	viewvect.x = (hd->dyheli->loc.x - ViewState.world_pos.x);
// LINE 3896:
	viewvect.y = (hd->dyheli->loc.y - ViewState.world_pos.y);
// LINE 3897:
	viewvect.z = (hd->dyheli->loc.z - ViewState.world_pos.z);
// LINE 3898:
	dist = MTMagnitude(viewvect.x);
// LINE 3901:
	__asm        cmp    dist, 0x7800000;
	__asm        jge    _T1be;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0x96;
	__asm        jl     _T1be;

	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jg     _T1cd;
// LINE 3903:
_T1be:
	S3DSStopPlay(0x0);
// LINE 3904:
	return;
// LINE 3909:
_T1cd:
	__asm        push   0;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T1f8;
// LINE 3911:
	S3DSPlay(0x1, (hd->dyheli + 0x18), 0x0);
// LINE 3914:
_T1f8:
	S3SoundAdjFreq((hd->heli_p.Vmag >> 0xc), 0x0);
// LINE 3919:
	__asm        push   0xF0600000;
	__asm        push   0x7800000;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        mov    vol_adj, eax;
// LINE 3921:
	S3SoundAdjVol(vol_adj, 0x0);
// LINE 3924:
	__asm        jmp    _T2f3;
// LINE 3927:
_T247:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x148], 0xFA;
	__asm        jge    _T269;
// LINE 3929:
	S3DSStopPlay(0x0);
// LINE 3930:
	return;
// LINE 3935:
_T269:
	__asm        push   0;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T2ae;
// LINE 3937:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x320], 0;
	__asm        jle    _T2a9;
// LINE 3938:
	S3DSPlay(0x1, (hd->dyheli + 0x18), 0x0);
// LINE 3939:
	__asm        jmp    _T2ae;
// LINE 3940:
_T2a9:
	return;
// LINE 3944:
_T2ae:
	vol_adj = (hd->rotspeed - 0x168);
// LINE 3945:
	__asm        mov    eax, vol_adj;
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        push   eax;
	__asm        push   0;
	__asm        call   S3SoundAdjFreq;
	__asm        add    esp, 8;
// LINE 3946:
	__asm        mov    eax, vol_adj;
	__asm        cdq;
	__asm        and    edx, 3;
	__asm        add    eax, edx;
	__asm        sar    eax, 2;
	__asm        mov    vol_adj, eax;
// LINE 3947:
	S3SoundAdjVol(vol_adj, 0x0);
// LINE 3952:
_T2f3:
	return;
// LINE 3953:
}

// FUNCTION: COPTER_D 0x004f5e67
void S3HeliSetSpotlite(/*packed*/ struct _HELI_DATA *hd, int32_t maxobjy, int32_t alt, int32_t color) {
	/*bp-0x4*/   int32_t scale;
	/*bp-0x10*/  /*packed*/ struct Point3d svec; // 0xc bytes
	/*bp-0x14*/  int32_t totdist;
	/*bp-0x20*/  /*packed*/ struct Point3d vstep; // 0xc bytes
	/*bp-0x24*/  int32_t dist;
	/*bp-0x28*/  long spotlevel;
	/*bp-0x2c*/  long i;
	/*bp-0x38*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x3c*/  /*packed*/ struct _CELL_INFO *ncptr;
	/*bp-0x40*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x98*/  /*packed*/ struct VRview pos; // 0x58 bytes

// LINE 3979:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        jne    _T1e;
// LINE 3980:
	return;
// LINE 3983:
_T1e:
	color = 0x1;
	maxobjy = color;
	alt = maxobjy;
// LINE 3985:
	__asm        push   0;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 3988:
	MTCreateDOF4x4((hd + 0x100), (hd->dyspot + 0x24));
// LINE 3989:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, svec.x;
	__asm        push   eax;
	__asm        push   0x6071E0;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 3991:
	vstep.x = (svec.x << 0x5);
// LINE 3992:
	vstep.y = (svec.y << 0x5);
// LINE 3993:
	vstep.z = (svec.z << 0x5);
// LINE 3996:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 3998:
	totdist = 0x0;
// LINE 4002:
_FOR_d1:
	i = 0x0;
	__asm        jmp    _FOR_COND_d1;
_FOR_NEXT_d1:
	i++;
_FOR_COND_d1:
	__asm        cmp    i, 0x10;
	__asm        jge    _T1ce;
// LINE 4004:
	__asm        mov    eax, 0x20000000;
	__asm        sub    eax, loc.z;
	__asm        shr    eax, 0x16;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, loc.x;
	__asm        add    ecx, 0x20000000;
	__asm        shr    ecx, 0x16;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 4005:
	__asm        mov    eax, 0x20000000;
	__asm        sub    eax, loc.z;
	__asm        add    eax, vstep.z;
	__asm        shr    eax, 0x16;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, loc.x;
	__asm        add    ecx, vstep.x;
	__asm        add    ecx, 0x20000000;
	__asm        shr    ecx, 0x16;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    ncptr, eax;
// LINE 4008:
	dist = S3HeliSpotDistance(cptr, 0x200000, svec.x, loc.x);
// LINE 4010:
	__asm        cmp    dist, 0;
	__asm        jle    _T173;
// LINE 4012:
	totdist += dist;
// LINE 4014:
	__asm        jmp    _T1ce;
// LINE 4017:
_T173:
	__asm        mov    eax, cptr;
	__asm        cmp    ncptr, eax;
	__asm        je     _T19b;
// LINE 4018:
	dist = S3HeliSpotDistance(ncptr, 0x200000, svec.x, loc.x);
// LINE 4019:
_T19b:
	__asm        cmp    dist, 0;
	__asm        jle    _T1b0;
// LINE 4021:
	totdist += dist;
// LINE 4023:
	__asm        jmp    _T1ce;
// LINE 4027:
_T1b0:
	loc.x += vstep.x;
// LINE 4028:
	loc.y += vstep.y;
// LINE 4029:
	loc.z += vstep.z;
// LINE 4030:
	totdist += 0x200000;
// LINE 4032:
	__asm        jmp    _FOR_NEXT_d1;
// LINE 4036:
_T1ce:
	__asm        cmp    totdist, 0x2000000;
	__asm        jl     _T1e2;
// LINE 4040:
	totdist = 0x1ff0000;
// LINE 4044:
_T1e2:
	S_spotdist = ((((S_spotdist << 0x3) - S_spotdist) + totdist) >> 0x3);
// LINE 4047:
	__asm        cmp    S_spotdist, 0x800000;
	__asm        jg     _T215;
// LINE 4049:
	spotlevel = 0x0;
// LINE 4051:
	__asm        jmp    _T254;
_T215:
	__asm        cmp    S_spotdist, 0x1000000;
	__asm        jg     _T231;
// LINE 4053:
	spotlevel = 0x1;
// LINE 4055:
	__asm        jmp    _T254;
_T231:
	__asm        cmp    S_spotdist, 0x1800000;
	__asm        jg     _T24d;
// LINE 4057:
	spotlevel = 0x2;
// LINE 4059:
	__asm        jmp    _T254;
// LINE 4061:
_T24d:
	spotlevel = 0x3;
// LINE 4065:
_T254:
	__asm        mov    eax, hd;
	__asm        mov    ecx, spotlevel;
	__asm        cmp    [eax+0x140], ecx;
	__asm        je     _T31d;
// LINE 4071:
// Block start:
	/*bp-0xbc*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0xc0*/  int32_t face;
	/*bp-0xe0*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 4072:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 4073:
_FOR_2a9:
	i = 0x0;
	__asm        jmp    _FOR_COND_2a9;
_FOR_NEXT_2a9:
	i++;
_FOR_COND_2a9:
	__asm        mov    eax, i;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T311;
// LINE 4075:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 4076:
	__asm        mov    eax, spotlevel;
	__asm        mov    eax, S_spotlevels[0][eax*4];
	__asm        mov    finfo.Bitmap, eax;
// LINE 4077:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 4078:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 4079:
	__asm        jmp    _FOR_NEXT_2a9;
// LINE 4081:
_T311:
	hd->spotlevel = spotlevel;
// LINE 4085:
// Block end:
_T31d:
	__asm        mov    eax, S_spotdist;
	__asm        push   eax;
	__asm        mov    eax, svec.x;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    pos.loc.x, ecx;
// LINE 4086:
	__asm        mov    eax, S_spotdist;
	__asm        push   eax;
	__asm        mov    eax, svec.z;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    pos.loc.z, ecx;
// LINE 4087:
	__asm        mov    eax, S_spotdist;
	__asm        push   eax;
	__asm        mov    eax, svec.y;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    pos.loc.y, ecx;
// LINE 4089:
	__asm        lea    eax, pos.loc.x;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xC0];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4092:
	__asm        push   0x2000000;
	__asm        mov    eax, S_spotdist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    scale, eax;
// LINE 4093:
	__asm        mov    eax, scale;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        mov    scale, eax;
// LINE 4094:
	__asm        cmp    scale, 0x4CCC;
	__asm        jge    _T3e6;

	scale = 0x4ccc;
// LINE 4095:
_T3e6:
	pos.scale.z = scale;
	pos.scale.y = pos.scale.z;
	pos.scale.x = pos.scale.y;
// LINE 4096:
	__asm        mov    eax, hd;
	__asm        mov    esi, [eax+0xC0];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 4102:
	__asm        push   1;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 4105:
	S_spotloc.x = ((hd->dyspot->loc.x + 0x20000000) >> 0x16);
// LINE 4106:
	S_spotloc.y = ((0x20000000 - hd->dyspot->loc.z) >> 0x16);
// LINE 4109:
	S3HeliHitSpiral(spotlevel, -0x1, hd->dyspot, 0x6bf1b8, 0x1);
// LINE 4112:
	__asm        cmp    G_camera_mode, 3;
	__asm        jne    __RETURN;
// LINE 4114:
	__asm        push   1;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 4115:
	return;
// LINE 4118:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f6321
void S3HeliGetSpotLoc(/*packed*/ struct Point2d *loc) {
// LINE 4130:
	loc->x = S_spotloc.x;
// LINE 4131:
	loc->y = S_spotloc.y;
// LINE 4132:
}

// FUNCTION: COPTER_D 0x004f6341
int32_t S3HeliSpotDistance(/*packed*/ struct Point3d *spotloc, /*packed*/ struct Point3d *spotvec, int32_t dist, /*packed*/ struct _CELL_INFO *cptr) {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x30*/  /*packed*/ struct Point3d cloc; // 0xc bytes
	/*bp-0x34*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x40*/  /*packed*/ struct Point3d center; // 0xc bytes
	/*bp-0x4c*/  /*packed*/ struct Point3d oloc; // 0xc bytes
	/*bp-0x50*/  int32_t newdist;

// LINE 4152:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    cloc.x, eax;
// LINE 4153:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    cloc.y, eax;
// LINE 4154:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    cloc.z, eax;
// LINE 4156:
	stobj = cptr->stptr;
// LINE 4158:
__WHILE_39:
	__asm        cmp    stobj, 0;
	__asm        je     _Tfd;
// LINE 4161:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, stobj;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 4162:
	__asm        lea    eax, center.x;
	__asm        push   eax;
	__asm        mov    eax, stobj;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D88C3;
	__asm        add    esp, 8;
// LINE 4165:
	__asm        lea    eax, cloc.x;
	__asm        lea    ecx, oloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4166:
	oloc.x += center.x;
// LINE 4167:
	oloc.y += center.y;
// LINE 4168:
	oloc.z += center.z;
// LINE 4174:
	newdist = S3MissileSphereHit(oinfo.Radius, oloc.x, dist, spotvec, spotloc);
// LINE 4178:
	__asm        cmp    newdist, 0;
	__asm        jle    _Tde;
// LINE 4185:
	newdist = VRStObjPolyHit(0x0, stobj->mesh, cloc.x, dist, spotvec, spotloc);
// LINE 4188:
_Tde:
	__asm        cmp    newdist, 0;
	__asm        jle    _Tf0;
// LINE 4191:
	return newdist;
// LINE 4196:
_Tf0:
	stobj = stobj->next;
// LINE 4197:
	__asm        jmp    __WHILE_39;
// LINE 4203:
_Tfd:
	newdist = S3MissileGroundHit(cloc.x, dist, spotvec, spotloc);
// LINE 4204:
	__asm        cmp    newdist, 0;
	__asm        jle    _T12a;
// LINE 4206:
	return newdist;
// LINE 4209:
_T12a:
	return 0x0;
// LINE 4210:
}

// FUNCTION: COPTER_D 0x004f6477
void S3HeliRotateSpotLite(int32_t rotx, int32_t roty) {
// LINE 4254:
	G_SpotLiteXRotation += rotx;
// LINE 4255:
	__asm        cmp    G_SpotLiteXRotation, 0x1F40000;
	__asm        jle    _T2e;
// LINE 4256:
	G_SpotLiteXRotation = 0x1f40000;
// LINE 4257:
	__asm        jmp    _T48;
_T2e:
	__asm        cmp    G_SpotLiteXRotation, 0xFE0C0000;
	__asm        jge    _T48;
// LINE 4258:
	G_SpotLiteXRotation = 0xfe0c0000;
// LINE 4260:
_T48:
	G_SpotLiteYRotation += roty;
// LINE 4261:
	__asm        cmp    G_SpotLiteYRotation, 0x1F40000;
	__asm        jle    _T70;
// LINE 4262:
	G_SpotLiteYRotation = 0x1f40000;
// LINE 4263:
	__asm        jmp    _T8a;
_T70:
	__asm        cmp    G_SpotLiteYRotation, 0xFE0C0000;
	__asm        jge    _T8a;
// LINE 4264:
	G_SpotLiteYRotation = 0xfe0c0000;
// LINE 4266:
_T8a:
	__asm        push   0x607218;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 4267:
	__asm        push   0x607218;
	__asm        mov    eax, G_SpotLiteXRotation;
	__asm        sub    eax, 0x1680000;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 4268:
	__asm        push   0x607218;
	__asm        mov    eax, G_SpotLiteYRotation;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 4269:
	__asm        push   0x607218;
	__asm        push   0x6071E0;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 4270:
}

// FUNCTION: COPTER_D 0x004f6555
void S3HeliTurbulence(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t slide;
	/*bp-0x10*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x14*/  int32_t i;
	/*bp-0x18*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x1c*/  int32_t yaw;
	/*bp-0x20*/  int32_t firealt;
	/*bp-0x24*/  /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0x28*/  int32_t pitch;
	/*bp-0x2c*/  int32_t ffactor;
	/*bp-0x30*/  int32_t tfactor;

// LINE 4292:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 4294:
	G_camera_targ2firey = 0x0;
// LINE 4298:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        add    eax, 0x20000000;
	__asm        shr    eax, 0x16;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, 0x20000000;
	__asm        mov    edx, hd;
	__asm        mov    edx, [edx+0xA4];
	__asm        sub    ecx, [edx+0x20];
	__asm        shr    ecx, 0x16;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    cptr, eax;
// LINE 4301:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.x, eax;
// LINE 4302:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.y, eax;
// LINE 4303:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.z, eax;
// LINE 4306:
	firealt = S3FireGetAltitude(loc.x, cptr);
// LINE 4307:
	__asm        cmp    firealt, 0;
	__asm        je     _Tf9;

	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _Tf9;
// LINE 4309:
	G_camera_targ2firey = (hd->dyheli->loc.y - firealt);
// LINE 4313:
_Tf9:
	__asm        mov    eax, htd;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xD0];
	__asm        cmp    [eax+0x4C], ecx;
	__asm        jne    _T16a;

	__asm        cmp    firealt, 0;
	__asm        je     _T125;

	__asm        cmp    firealt, 0xFA0000;
	__asm        jle    _T16a;
// LINE 4322:
_T125:
	tfactor = 0x3;
// LINE 4323:
	__asm        lea    edi, S_turbslide[1];
	__asm        lea    esi, S_turbslide[2];
	__asm        mov    ecx, 8;
	__asm        rep movsd;
// LINE 4324:
	__asm        lea    edi, S_turbpitch[1];
	__asm        lea    esi, S_turbpitch[2];
	__asm        mov    ecx, 8;
	__asm        rep movsd;
// LINE 4325:
	__asm        lea    edi, S_turbyaw[1];
	__asm        lea    esi, S_turbyaw[2];
	__asm        mov    ecx, 8;
	__asm        rep movsd;
// LINE 4326:
	__asm        jmp    calc_turbulence;
// LINE 4330:
_T16a:
	__asm        lea    edi, S_turbslide[1];
	__asm        lea    esi, S_turbslide[2];
	__asm        mov    ecx, 8;
	__asm        rep movsd;
// LINE 4331:
	__asm        lea    edi, S_turbpitch[1];
	__asm        lea    esi, S_turbpitch[2];
	__asm        mov    ecx, 8;
	__asm        rep movsd;
// LINE 4332:
	__asm        lea    edi, S_turbyaw[1];
	__asm        lea    esi, S_turbyaw[2];
	__asm        mov    ecx, 8;
	__asm        rep movsd;
// LINE 4338:
	ffactor = 0x0;
// LINE 4339:
	__asm        cmp    firealt, 0;
	__asm        je     _T24c;
// LINE 4342:
	__asm        mov    eax, S_htwk_firedmg_alt_min;
	__asm        cmp    firealt, eax;
	__asm        jl     _T216;

	__asm        mov    eax, S_htwk_firedmg_alt_max;
	__asm        cmp    firealt, eax;
	__asm        jg     _T216;

	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _T216;
// LINE 4344:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_firedmg_alt_max;
	__asm        sar    ecx, 0x10;
	__asm        mov    edx, firealt;
	__asm        sar    edx, 0x10;
	__asm        sub    ecx, edx;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 4346:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x10);
// LINE 4353:
_T216:
	__asm        cmp    firealt, 0xFFD00000;
	__asm        jl     _T245;

	__asm        cmp    firealt, 0xFA0000;
	__asm        jg     _T245;
// LINE 4355:
	ffactor = (0xfa - (firealt >> 0x10));
// LINE 4357:
	__asm        jmp    _T24c;
// LINE 4359:
_T245:
	ffactor = 0x0;
// LINE 4364:
_T24c:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    ecx, hd;
	__asm        sub    eax, [ecx+0xD0];
	__asm        mov    ecx, 0x14;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, ffactor;
	__asm        add    ecx, eax;
	__asm        mov    tfactor, ecx;
// LINE 4366:
	__asm        cmp    tfactor, 0;
	__asm        jg     calc_turbulence;

	tfactor = 0x1;
// LINE 4369:
calc_turbulence:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   tfactor;
	__asm        mov    slide, edx;
// LINE 4370:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 1;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T2ad;
// LINE 4371:
	__asm        mov    eax, slide;
	__asm        neg    eax;
	__asm        mov    slide, eax;
// LINE 4372:
_T2ad:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   tfactor;
	__asm        mov    pitch, edx;
// LINE 4373:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 1;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T2de;
// LINE 4374:
	__asm        mov    eax, pitch;
	__asm        neg    eax;
	__asm        mov    pitch, eax;
// LINE 4375:
_T2de:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   tfactor;
	__asm        mov    yaw, edx;
// LINE 4376:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 1;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T30f;
// LINE 4377:
	__asm        mov    eax, yaw;
	__asm        neg    eax;
	__asm        mov    yaw, eax;
// LINE 4380:
_T30f:
	S_turbslide[9] = (slide << 0x10);
// LINE 4381:
	S_turbyaw[9] = (yaw << 0x10);
// LINE 4382:
	S_turbpitch[9] = (pitch << 0x10);
// LINE 4385:
	yaw = 0x0;
	pitch = yaw;
	slide = pitch;
// LINE 4386:
_FOR_34f:
	i = 0x1;
	__asm        jmp    _FOR_COND_34f;
_FOR_NEXT_34f:
	i++;
_FOR_COND_34f:
	__asm        cmp    i, 0xA;
	__asm        jge    _T388;
// LINE 4388:
	__asm        mov    eax, i;
	__asm        mov    eax, S_turbslide[eax*4];
	__asm        add    slide, eax;
// LINE 4389:
	__asm        mov    eax, i;
	__asm        mov    eax, S_turbyaw[eax*4];
	__asm        add    yaw, eax;
// LINE 4390:
	__asm        mov    eax, i;
	__asm        mov    eax, S_turbpitch[eax*4];
	__asm        add    pitch, eax;
// LINE 4391:
	__asm        jmp    _FOR_NEXT_34f;
// LINE 4394:
_T388:
	__asm        mov    ecx, 9;
	__asm        mov    eax, slide;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    S_turbslide[0], eax;
// LINE 4395:
	__asm        mov    ecx, 9;
	__asm        mov    eax, yaw;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    S_turbyaw[0], eax;
// LINE 4396:
	__asm        mov    ecx, 9;
	__asm        mov    eax, pitch;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    S_turbpitch[0], eax;
// LINE 4398:
}

// FUNCTION: COPTER_D 0x004f6912
void S3HeliSmokeTrail(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   long scale;
	/*bp-0x8*/   int32_t speed;
	/*bp-0x48*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x54*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x60*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x64*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x68*/  /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 4417:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 4419:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x18];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 4423:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 5;
	__asm        jne    _T38a;
// LINE 4425:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x16C], eax;
// LINE 4426:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0;
	__asm        jge    _T81;
// LINE 4427:
	hd->crash_timer = 0x11999;
// LINE 4429:
_T81:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0x10000;
	__asm        jle    _Tb4;
// LINE 4430:
	S3ExplosionSmokeStart(0x5, (hd->dyheli + 0x18), cptr);
// LINE 4431:
	__asm        jmp    _T148;
_Tb4:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0xE666;
	__asm        jle    _Te7;
// LINE 4432:
	S3ExplosionSmokeStart(0x4, (hd->dyheli + 0x18), cptr);
// LINE 4433:
	__asm        jmp    _T148;
_Te7:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0x1999;
	__asm        jge    _T11a;
// LINE 4434:
	S3ExplosionSmokeStart(0x2, (hd->dyheli + 0x18), cptr);
// LINE 4435:
	__asm        jmp    _T148;
_T11a:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0x3333;
	__asm        jge    _T148;
// LINE 4436:
	S3ExplosionSmokeStart(0x1, (hd->dyheli + 0x18), cptr);
// LINE 4439:
_T148:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x168];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jge    _T385;

	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x168];
	__asm        cmp    dword ptr [eax+0x38], 1;
	__asm        jne    _T385;
// LINE 4441:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4443:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        inc    eax;
	__asm        mov    scale, eax;
// LINE 4445:
	__asm        cmp    G_camera_mode, 1;
	__asm        jne    _T1f0;
// LINE 4447:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 4448:
	loc.x += (vec.x << 0x4);
// LINE 4449:
	loc.y += (vec.y << 0x4);
// LINE 4450:
	loc.z += (vec.z << 0x4);
// LINE 4452:
	__asm        jmp    _T247;
// LINE 4454:
_T1f0:
	__asm        mov    ebx, 0xA;
	__asm        call   rand;
	__asm        mov    ecx, 0x14;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        shl    ebx, 0x10;
	__asm        add    loc.x, ebx;
// LINE 4455:
	__asm        mov    ebx, 0xA;
	__asm        call   rand;
	__asm        mov    ecx, 0x14;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        shl    ebx, 0x10;
	__asm        add    loc.y, ebx;
// LINE 4456:
	__asm        mov    ebx, 0xA;
	__asm        call   rand;
	__asm        mov    ecx, 0x14;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        shl    ebx, 0x10;
	__asm        add    loc.z, ebx;
// LINE 4459:
_T247:
	hd->crash_traj->smoketime = 0xcccc;
// LINE 4461:
	__asm        call   rand;
	__asm        mov    ecx, 6;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T320;
// LINE 4463:
	__asm        call   rand;
	__asm        mov    ecx, 0x64;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        add    eax, 0x320000;
	__asm        mov    speed, eax;
// LINE 4464:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 4465:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xE10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 4466:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xC8;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+0x28A];
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 4467:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 4478:
	S3MissileStart(-0x1, speed, hd->dyheli, 0x3, vec.x, loc.x, (hd + 0x18), 0x4);
// LINE 4485:
_T320:
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, scale;
	__asm        push   eax;
	__asm        mov    eax, loc.z;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, loc.y;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, loc.x;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        call   S3ExplosionStart;
	__asm        add    esp, 0x18;
// LINE 4487:
	__asm        cmp    scale, 0;
	__asm        jle    _T385;
// LINE 4490:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x4);
// LINE 4494:
_T385:
	return;
// LINE 4498:
_T38a:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 6;
	__asm        jne    _T39c;
// LINE 4500:
	return;
// LINE 4504:
_T39c:
	__asm        mov    eax, hd;
	__asm        mov    ecx, htd;
	__asm        mov    ecx, [ecx+0x4C];
	__asm        cmp    [eax+0xD0], ecx;
	__asm        jl     _T3b6;
// LINE 4506:
	return;
// LINE 4509:
_T3b6:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T3c8;
// LINE 4510:
	return;
// LINE 4516:
_T3c8:
	hd->smokeseq++;
// LINE 4517:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0xD4], 7;
	__asm        jle    _T43c;
// LINE 4519:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xD0];
	__asm        sar    eax, 3;
	__asm        add    eax, 7;
	__asm        mov    ecx, hd;
	__asm        cmp    eax, [ecx+0xD4];
	__asm        jg     _T437;
// LINE 4522:
	__asm        push   0xE;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T42a;
// LINE 4523:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0xe);
// LINE 4525:
_T42a:
	hd->smokeseq = 0x0;
// LINE 4527:
_T437:
	return;
// LINE 4530:
_T43c:
	S3ExplosionSmokeStart(0x1, (hd->dyheli + 0x18), cptr);
// LINE 4532:
}

// FUNCTION: COPTER_D 0x004f6d6e
void S3HeliReset() {
// LINE 4544:
	__asm        mov    edi, 0x5B4940;
	__asm        xor    eax, eax;
	__asm        mov    ecx, 0xA;
	__asm        rep stosd;
// LINE 4545:
}

// FUNCTION: COPTER_D 0x004f6d87
void S3HeliTweakInit() {
	/*bp-0x4*/   /*packed*/ struct _HELI_TYPE_DATA *htd;
	/*bp-0x3c*/  int32_t * pvals[14]; // 0x38 bytes

// LINE 4560:
	htd = 0x5b4978;
// LINE 4562:
	pvals[0] = (htd + 0xc);
// LINE 4563:
	pvals[1] = (htd + 0x10);
// LINE 4564:
	pvals[2] = (htd + 0x14);
// LINE 4565:
	pvals[3] = (htd + 0x1c);
// LINE 4566:
	pvals[4] = (htd + 0x20);
// LINE 4567:
	pvals[5] = (htd + 0x24);
// LINE 4568:
	pvals[6] = (htd + 0x28);
// LINE 4569:
	pvals[7] = (htd + 0x2c);
// LINE 4570:
	pvals[8] = (htd + 0x8);
// LINE 4571:
	pvals[9] = (htd + 0x18);
// LINE 4572:
	pvals[10] = (htd + 0x44);
// LINE 4573:
	pvals[11] = (htd + 0x48);
// LINE 4574:
	pvals[12] = (htd + 0x4c);
// LINE 4575:
	pvals[13] = (htd + 0x40);
// LINE 4577:
	TWKEnQueue(0x5b4cc4, 0xe, pvals[0]);
// LINE 4579:
	htd = (0x5b4978 + 0x58);
// LINE 4581:
	pvals[0] = (htd + 0xc);
// LINE 4582:
	pvals[1] = (htd + 0x10);
// LINE 4583:
	pvals[2] = (htd + 0x14);
// LINE 4584:
	pvals[3] = (htd + 0x1c);
// LINE 4585:
	pvals[4] = (htd + 0x20);
// LINE 4586:
	pvals[5] = (htd + 0x24);
// LINE 4587:
	pvals[6] = (htd + 0x28);
// LINE 4588:
	pvals[7] = (htd + 0x2c);
// LINE 4589:
	pvals[8] = (htd + 0x8);
// LINE 4590:
	pvals[9] = (htd + 0x18);
// LINE 4591:
	pvals[10] = (htd + 0x44);
// LINE 4592:
	pvals[11] = (htd + 0x48);
// LINE 4593:
	pvals[12] = (htd + 0x4c);
// LINE 4594:
	pvals[13] = (htd + 0x40);
// LINE 4596:
	TWKEnQueue(0x5b4cd0, 0xe, pvals[0]);
// LINE 4598:
	htd = (0x5b4978 + 0xb0);
// LINE 4600:
	pvals[0] = (htd + 0xc);
// LINE 4601:
	pvals[1] = (htd + 0x10);
// LINE 4602:
	pvals[2] = (htd + 0x14);
// LINE 4603:
	pvals[3] = (htd + 0x1c);
// LINE 4604:
	pvals[4] = (htd + 0x20);
// LINE 4605:
	pvals[5] = (htd + 0x24);
// LINE 4606:
	pvals[6] = (htd + 0x28);
// LINE 4607:
	pvals[7] = (htd + 0x2c);
// LINE 4608:
	pvals[8] = (htd + 0x8);
// LINE 4609:
	pvals[9] = (htd + 0x18);
// LINE 4610:
	pvals[10] = (htd + 0x44);
// LINE 4611:
	pvals[11] = (htd + 0x48);
// LINE 4612:
	pvals[12] = (htd + 0x4c);
// LINE 4613:
	pvals[13] = (htd + 0x40);
// LINE 4615:
	TWKEnQueue(0x5b4cdc, 0xe, pvals[0]);
// LINE 4617:
	htd = (0x5b4978 + 0x108);
// LINE 4619:
	pvals[0] = (htd + 0xc);
// LINE 4620:
	pvals[1] = (htd + 0x10);
// LINE 4621:
	pvals[2] = (htd + 0x14);
// LINE 4622:
	pvals[3] = (htd + 0x1c);
// LINE 4623:
	pvals[4] = (htd + 0x20);
// LINE 4624:
	pvals[5] = (htd + 0x24);
// LINE 4625:
	pvals[6] = (htd + 0x28);
// LINE 4626:
	pvals[7] = (htd + 0x2c);
// LINE 4627:
	pvals[8] = (htd + 0x8);
// LINE 4628:
	pvals[9] = (htd + 0x18);
// LINE 4629:
	pvals[10] = (htd + 0x44);
// LINE 4630:
	pvals[11] = (htd + 0x48);
// LINE 4631:
	pvals[12] = (htd + 0x4c);
// LINE 4632:
	pvals[13] = (htd + 0x40);
// LINE 4634:
	TWKEnQueue(0x5b4ce4, 0xe, pvals[0]);
// LINE 4636:
	htd = (0x5b4978 + 0x160);
// LINE 4638:
	pvals[0] = (htd + 0xc);
// LINE 4639:
	pvals[1] = (htd + 0x10);
// LINE 4640:
	pvals[2] = (htd + 0x14);
// LINE 4641:
	pvals[3] = (htd + 0x1c);
// LINE 4642:
	pvals[4] = (htd + 0x20);
// LINE 4643:
	pvals[5] = (htd + 0x24);
// LINE 4644:
	pvals[6] = (htd + 0x28);
// LINE 4645:
	pvals[7] = (htd + 0x2c);
// LINE 4646:
	pvals[8] = (htd + 0x8);
// LINE 4647:
	pvals[9] = (htd + 0x18);
// LINE 4648:
	pvals[10] = (htd + 0x44);
// LINE 4649:
	pvals[11] = (htd + 0x48);
// LINE 4650:
	pvals[12] = (htd + 0x4c);
// LINE 4651:
	pvals[13] = (htd + 0x40);
// LINE 4653:
	TWKEnQueue(0x5b4cf0, 0xe, pvals[0]);
// LINE 4655:
	htd = (0x5b4978 + 0x1b8);
// LINE 4657:
	pvals[0] = (htd + 0xc);
// LINE 4658:
	pvals[1] = (htd + 0x10);
// LINE 4659:
	pvals[2] = (htd + 0x14);
// LINE 4660:
	pvals[3] = (htd + 0x1c);
// LINE 4661:
	pvals[4] = (htd + 0x20);
// LINE 4662:
	pvals[5] = (htd + 0x24);
// LINE 4663:
	pvals[6] = (htd + 0x28);
// LINE 4664:
	pvals[7] = (htd + 0x2c);
// LINE 4665:
	pvals[8] = (htd + 0x8);
// LINE 4666:
	pvals[9] = (htd + 0x18);
// LINE 4667:
	pvals[10] = (htd + 0x44);
// LINE 4668:
	pvals[11] = (htd + 0x48);
// LINE 4669:
	pvals[12] = (htd + 0x4c);
// LINE 4670:
	pvals[13] = (htd + 0x40);
// LINE 4672:
	TWKEnQueue(0x5b4d00, 0xe, pvals[0]);
// LINE 4674:
	htd = (0x5b4978 + 0x210);
// LINE 4676:
	pvals[0] = (htd + 0xc);
// LINE 4677:
	pvals[1] = (htd + 0x10);
// LINE 4678:
	pvals[2] = (htd + 0x14);
// LINE 4679:
	pvals[3] = (htd + 0x1c);
// LINE 4680:
	pvals[4] = (htd + 0x20);
// LINE 4681:
	pvals[5] = (htd + 0x24);
// LINE 4682:
	pvals[6] = (htd + 0x28);
// LINE 4683:
	pvals[7] = (htd + 0x2c);
// LINE 4684:
	pvals[8] = (htd + 0x8);
// LINE 4685:
	pvals[9] = (htd + 0x18);
// LINE 4686:
	pvals[10] = (htd + 0x44);
// LINE 4687:
	pvals[11] = (htd + 0x48);
// LINE 4688:
	pvals[12] = (htd + 0x4c);
// LINE 4689:
	pvals[13] = (htd + 0x40);
// LINE 4691:
	TWKEnQueue(0x5b4d08, 0xe, pvals[0]);
// LINE 4693:
	htd = (0x5b4978 + 0x268);
// LINE 4695:
	pvals[0] = (htd + 0xc);
// LINE 4696:
	pvals[1] = (htd + 0x10);
// LINE 4697:
	pvals[2] = (htd + 0x14);
// LINE 4698:
	pvals[3] = (htd + 0x1c);
// LINE 4699:
	pvals[4] = (htd + 0x20);
// LINE 4700:
	pvals[5] = (htd + 0x24);
// LINE 4701:
	pvals[6] = (htd + 0x28);
// LINE 4702:
	pvals[7] = (htd + 0x2c);
// LINE 4703:
	pvals[8] = (htd + 0x8);
// LINE 4704:
	pvals[9] = (htd + 0x18);
// LINE 4705:
	pvals[10] = (htd + 0x44);
// LINE 4706:
	pvals[11] = (htd + 0x48);
// LINE 4707:
	pvals[12] = (htd + 0x4c);
// LINE 4708:
	pvals[13] = (htd + 0x40);
// LINE 4710:
	TWKEnQueue(0x5b4d10, 0xe, pvals[0]);
// LINE 4712:
	htd = (0x5b4978 + 0x2c0);
// LINE 4714:
	pvals[0] = (htd + 0xc);
// LINE 4715:
	pvals[1] = (htd + 0x10);
// LINE 4716:
	pvals[2] = (htd + 0x14);
// LINE 4717:
	pvals[3] = (htd + 0x1c);
// LINE 4718:
	pvals[4] = (htd + 0x20);
// LINE 4719:
	pvals[5] = (htd + 0x24);
// LINE 4720:
	pvals[6] = (htd + 0x28);
// LINE 4721:
	pvals[7] = (htd + 0x2c);
// LINE 4722:
	pvals[8] = (htd + 0x8);
// LINE 4723:
	pvals[9] = (htd + 0x18);
// LINE 4724:
	pvals[10] = (htd + 0x44);
// LINE 4725:
	pvals[11] = (htd + 0x48);
// LINE 4726:
	pvals[12] = (htd + 0x4c);
// LINE 4727:
	pvals[13] = (htd + 0x40);
// LINE 4729:
	TWKEnQueue(0x5b4d1c, 0xe, pvals[0]);
// LINE 4731:
	pvals[0] = 0x5b48c4;
// LINE 4732:
	pvals[1] = 0x5b48c8;
// LINE 4733:
	pvals[2] = 0x5b48cc;
// LINE 4734:
	pvals[3] = 0x5b48c0;
// LINE 4735:
	pvals[4] = 0x5b48d0;
// LINE 4737:
	TWKEnQueue(0x5b4d24, 0x5, pvals[0]);
// LINE 4739:
	pvals[0] = 0x5b48d4;
// LINE 4740:
	pvals[1] = 0x5b48d8;
// LINE 4741:
	pvals[2] = 0x5b48dc;
// LINE 4742:
	pvals[3] = 0x5b48e0;
// LINE 4743:
	pvals[4] = 0x5b48e4;
// LINE 4744:
	pvals[5] = 0x5b48e8;
// LINE 4746:
	TWKEnQueue(0x5b4d34, 0x6, pvals[0]);
// LINE 4748:
	pvals[0] = 0x5b48ec;
// LINE 4749:
	pvals[1] = 0x5b48f0;
// LINE 4750:
	pvals[2] = 0x5b48fc;
// LINE 4751:
	pvals[3] = 0x5b48f8;
// LINE 4753:
	TWKEnQueue(0x5b4d44, 0x4, pvals[0]);
// LINE 4754:
}

// FUNCTION: COPTER_D 0x004f73bd
int32_t S3HeliGetRepairRate(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 4763:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 4764:
	return htd->repair_rate;
// LINE 4765:
}

// FUNCTION: COPTER_D 0x004f73ed
int32_t S3HeliGetFuelRate(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 4771:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 4772:
	return htd->fuel_purchase_rate;
// LINE 4773:
}

// FUNCTION: COPTER_D 0x004f741d
long S3GetFullRepairCost(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t repair_rate;
	/*bp-0x8*/   int32_t current_damage;
	/*bp-0xc*/   int32_t max_damage;

// LINE 4784:
	repair_rate = S3HeliGetRepairRate(hd);
// LINE 4785:
	current_damage = hd->damage;
// LINE 4786:
	max_damage = S3HeliGetMaximumDamage(hd);
// LINE 4787:
	__asm        mov    eax, repair_rate;
	__asm        push   eax;
	__asm        mov    eax, max_damage;
	__asm        sub    eax, current_damage;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        jmp    __RETURN;
// LINE 4788:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f7473
void S3HeliPurchaseRepairs(/*packed*/ struct _HELI_DATA *hd, long lPurchaseBucks) {
	/*bp-0x4*/   int32_t repair_rate;
	/*bp-0x8*/   int32_t current_damage;
	/*bp-0xc*/   int32_t max_damage;

// LINE 4804:
	repair_rate = S3HeliGetRepairRate(hd);
// LINE 4805:
	current_damage = hd->damage;
// LINE 4806:
	max_damage = S3HeliGetMaximumDamage(hd);
// LINE 4808:
	__asm        mov    eax, repair_rate;
	__asm        push   eax;
	__asm        mov    eax, lPurchaseBucks;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        add    eax, current_damage;
	__asm        mov    ecx, hd;
	__asm        mov    [ecx+0xD0], eax;
// LINE 4809:
	__asm        mov    eax, hd;
	__asm        mov    ecx, max_damage;
	__asm        cmp    [eax+0xD0], ecx;
	__asm        jle    __RETURN;
// LINE 4810:
	hd->damage = max_damage;
// LINE 4811:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f74eb
long S3GetFullRefuelCost(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t fuel_purchase_rate;
	/*bp-0x8*/   int32_t current_fuel;
	/*bp-0xc*/   int32_t max_fuel;

// LINE 4824:
	fuel_purchase_rate = S3HeliGetFuelRate(hd);
// LINE 4825:
	current_fuel = hd->fuel;
// LINE 4826:
	max_fuel = S3HeliGetMaximumFuel(hd);
// LINE 4827:
	__asm        mov    eax, fuel_purchase_rate;
	__asm        push   eax;
	__asm        mov    eax, max_fuel;
	__asm        sub    eax, current_fuel;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        jmp    __RETURN;
// LINE 4828:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f753e
void S3HeliPurchaseFuel(/*packed*/ struct _HELI_DATA *hd, long lPurchaseBucks) {
	/*bp-0x4*/   int32_t fuel_purchase_rate;
	/*bp-0x8*/   int32_t current_fuel;
	/*bp-0xc*/   int32_t max_fuel;

// LINE 4843:
	fuel_purchase_rate = S3HeliGetFuelRate(hd);
// LINE 4844:
	current_fuel = hd->fuel;
// LINE 4845:
	max_fuel = S3HeliGetMaximumFuel(hd);
// LINE 4847:
	__asm        mov    eax, fuel_purchase_rate;
	__asm        push   eax;
	__asm        mov    eax, lPurchaseBucks;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, current_fuel;
	__asm        add    ecx, eax;
	__asm        mov    eax, hd;
	__asm        mov    [eax+0x320], ecx;
// LINE 4848:
	__asm        mov    eax, hd;
	__asm        mov    ecx, max_fuel;
	__asm        cmp    [eax+0x320], ecx;
	__asm        jle    __RETURN;
// LINE 4849:
	hd->fuel = max_fuel;
// LINE 4850:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f75b5
int32_t S3HeliGetMaximumDamage(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 4858:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 4859:
	return htd->max_damage;
// LINE 4860:
}

// FUNCTION: COPTER_D 0x004f75e5
int32_t S3HeliGetCurrentDamage(/*packed*/ struct _HELI_DATA *hd) {
// LINE 4867:
	return hd->damage;
// LINE 4868:
}

// FUNCTION: COPTER_D 0x004f75fe
int32_t S3HeliGetMaximumFuel(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 4875:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 4876:
	return htd->fuel_capacity;
// LINE 4877:
}

// FUNCTION: COPTER_D 0x004f762e
void S3HeliCommand(int32_t nCommand) {
// LINE 4889:
	__asm        cmp    nCommand, 3;
	__asm        jne    _Tc5;
// LINE 4891:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _Tc0;
// LINE 4893:
	S3DSPlay(0x0, (G_uheli->dyheli + 0x18), 0x2b);
// LINE 4894:
	S3HeliUserExit();
// LINE 4895:
	G_uheli->flags = 0x0;
// LINE 4896:
	G_camera_mode = 0x3;
// LINE 4897:
	__asm        push   1;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA8];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 4898:
	__asm        push   1;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xB4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 4899:
	__asm        push   1;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xC0];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 4900:
	S3DSPlay(0x0, (G_uheli->dyheli + 0x18), 0x2c);
// LINE 4901:
	return;
// LINE 4904:
_Tc0:
	return;
_Tc5:
	__asm        cmp    nCommand, 0x15;
	__asm        jne    _T10f;
// LINE 4906:
	DispatchEmergencyVehicle(((0x20000000 - G_uheli->dyspot->loc.z) >> 0x16), ((G_uheli->dyspot->loc.x + 0x20000000) >> 0x16), 0x4, 0x1);
// LINE 4908:
	return;
_T10f:
	__asm        cmp    nCommand, 0x16;
	__asm        jne    _T159;
// LINE 4910:
	DispatchEmergencyVehicle(((0x20000000 - G_uheli->dyspot->loc.z) >> 0x16), ((G_uheli->dyspot->loc.x + 0x20000000) >> 0x16), 0x4, 0x2);
// LINE 4912:
	return;
_T159:
	__asm        cmp    nCommand, 0x17;
	__asm        jne    _T1a3;
// LINE 4914:
	DispatchEmergencyVehicle(((0x20000000 - G_uheli->dyspot->loc.z) >> 0x16), ((G_uheli->dyspot->loc.x + 0x20000000) >> 0x16), 0x4, 0x4);
// LINE 4916:
	return;
_T1a3:
	__asm        cmp    nCommand, 0x18;
	__asm        jne    __RETURN;
// LINE 4918:
	DispatchEmergencyVehicle(((0x20000000 - G_uheli->dyspot->loc.z) >> 0x16), ((G_uheli->dyspot->loc.x + 0x20000000) >> 0x16), 0x3, 0x3);
// LINE 4928:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f781b
void S3PlayMegaphoneMessage(int32_t nMessageType) {
	/*bp-0x30*/  char szSoundFiles[4][12]; // 0x30 bytes

// LINE 4937:
	__asm        mov    eax, 0x5B4D5C;
	__asm        lea    ecx, szSoundFiles[0][0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
	__asm        mov    reinterpret_cast<uint16_t>(szSoundFiles[0][10]), 0;
	__asm        mov    eax, 0x5B4D74;
	__asm        lea    ecx, szSoundFiles[1][0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    dx, [eax+8];
	__asm        mov    [ecx+8], dx;
	__asm        mov    al, [eax+0xA];
	__asm        mov    [ecx+0xA], al;
	__asm        mov    szSoundFiles[1][11], 0;
	__asm        mov    eax, 0x5B4D8C;
	__asm        lea    ecx, szSoundFiles[2][0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
	__asm        mov    reinterpret_cast<uint16_t>(szSoundFiles[2][10]), 0;
	__asm        mov    eax, 0x5B4DA8;
	__asm        lea    ecx, szSoundFiles[3][0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4938:
	__asm        mov    eax, nMessageType;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [ebp+eax*4-0x30];
	__asm        push   eax;
	__asm        push   0xC;
	__asm        call   S3DSSetFile;
	__asm        add    esp, 8;
// LINE 4939:
	S3DSPlay(0x0, (G_uheli->dyheli + 0x18), 0xc);
// LINE 4943:
	S3HeliHitSpiral(nMessageType, -0x1, G_uheli->dyheli, (G_uheli + 0x18), 0x2);
// LINE 4944:
}

// FUNCTION: COPTER_D 0x004f78fa
int32_t S3HeliCrashed(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   /*packed*/ struct Point2d *freepad;
	/*bp-0x8*/   int32_t speed;
	/*bp-0x48*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x54*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x58*/  int32_t i;
	/*bp-0x64*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x68*/  /*packed*/ struct tagUserPersonalInfo *up;
	/*bp-0x6c*/  /*packed*/ struct _CELL_INFO *cptr;

// LINE 4967:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x18];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 4969:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4971:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T9f;

	__asm        cmp    G_camera_mode, 1;
	__asm        jne    _T9f;
// LINE 4973:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 4974:
	loc.x += (vec.x << 0x4);
// LINE 4975:
	loc.y += (vec.y << 0x4);
// LINE 4976:
	loc.z += (vec.z << 0x4);
// LINE 4980:
_T9f:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x170];
	__asm        mov    [ebp-0x70], eax;
	__asm        jmp    _T4b8;
// LINE 4984:
_Tb0:
	S3HeliUnlink(cptr, hd);
// LINE 4985:
	hd->crash_seq++;
// LINE 4986:
	__asm        jmp    _T4e0;
// LINE 4989:
_Tce:
	S3ExplosionSmokeStart(0x1, (hd->dyheli + 0x18), cptr);
// LINE 4991:
_FOR_f5:
	i = 0x0;
	__asm        jmp    _FOR_COND_f5;
_FOR_NEXT_f5:
	i++;
_FOR_COND_f5:
	__asm        cmp    i, 5;
	__asm        jge    _T1b8;
// LINE 4993:
	__asm        call   rand;
	__asm        mov    ecx, 0x64;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        add    eax, 0x320000;
	__asm        mov    speed, eax;
// LINE 4994:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 4995:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xE10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 4996:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xC8;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+0x28A];
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 4997:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 5008:
	S3MissileStart(-0x1, speed, hd->dyheli, 0x3, vec.x, loc.x, (hd + 0x18), 0x4);
// LINE 5009:
	__asm        jmp    _FOR_NEXT_f5;
// LINE 5015:
_T1b8:
	__asm        push   0xFFFFFFFF;
	__asm        push   4;
	__asm        mov    eax, loc.z;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, loc.y;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, loc.x;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        call   S3ExplosionStart;
	__asm        add    esp, 0x18;
// LINE 5018:
	S3DSPlay(0x0, (hd->dyheli + 0x18), 0x7);
// LINE 5022:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T287;
// LINE 5024:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        mov    ecx, 0x607258;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 5025:
	S_sound_loc.x += 0x3200000;
// LINE 5027:
	__asm        push   0x26;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T26c;
// LINE 5029:
	S3DSPlay(0x1, 0x607258, 0x26);
// LINE 5032:
_T26c:
	hd->crash_timer = 0x30000;
// LINE 5033:
	hd->crash_seq++;
// LINE 5035:
	__asm        jmp    _T294;
// LINE 5039:
_T287:
	hd->crash_seq = 0x4;
// LINE 5042:
_T294:
	__asm        jmp    _T4e0;
// LINE 5045:
_T299:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x640000;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        sub    S_sound_loc.x, ebx;
// LINE 5046:
	S3SoundSetPosition(0x607258, 0x26);
// LINE 5049:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x16C], eax;
// LINE 5050:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0x10000;
	__asm        jle    _T304;
// LINE 5052:
	S3ExplosionSmokeStart(0x1, loc.x, cptr);
// LINE 5054:
	__asm        jmp    _T316;
// LINE 5056:
_T304:
	S3ExplosionSmokeStart(0x4, loc.x, cptr);
// LINE 5059:
_T316:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0;
	__asm        jge    _T33c;
// LINE 5061:
	hd->crash_timer = 0x80000;
// LINE 5062:
	hd->crash_seq++;
// LINE 5064:
_T33c:
	__asm        jmp    _T4e0;
// LINE 5067:
_T341:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x640000;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        sub    S_sound_loc.x, ebx;
// LINE 5068:
	S3SoundSetPosition(0x607258, 0x26);
// LINE 5071:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0x16C], eax;
// LINE 5072:
	__asm        mov    eax, hd;
	__asm        cmp    dword ptr [eax+0x16C], 0;
	__asm        jge    _T3a8;
// LINE 5074:
	hd->crash_timer = 0x80000;
// LINE 5075:
	hd->crash_seq++;
// LINE 5077:
_T3a8:
	__asm        jmp    _T4e0;
// LINE 5080:
_FOR_3b9:
	i = 0x0;
	__asm        jmp    _FOR_COND_3b9;
_FOR_NEXT_3b9:
	i++;
_FOR_COND_3b9:
	__asm        cmp    i, 0xA;
	__asm        jge    _T3f1;
// LINE 5082:
	__asm        mov    eax, i;
	__asm        mov    ecx, hd;
	__asm        cmp    G_helis[0][eax*4], ecx;
	__asm        jne    _T3ec;
// LINE 5084:
	__asm        mov    eax, i;
	__asm        mov    G_helis[0][eax*4], 0;
// LINE 5085:
	__asm        jmp    _T3f1;
// LINE 5087:
_T3ec:
	__asm        jmp    _FOR_NEXT_3b9;
// LINE 5089:
_T3f1:
	up = GetCurrentUserPersonalInfo();
// LINE 5090:
	__asm        mov    eax, 1;
	__asm        mov    edx, hd;
	__asm        mov    cl, [edx];
	__asm        shl    eax, cl;
	__asm        not    eax;
	__asm        mov    ecx, up;
	__asm        and    [ecx+0x44], eax;
// LINE 5092:
	__asm        mov    eax, hd;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T4a4;
// LINE 5095:
	S3DSStopPlay(0x26);
// LINE 5098:
	freepad = S3HeliGetFreePad();
// LINE 5102:
	__asm        mov    eax, freepad;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, hd;
	__asm        add    edx, 0x18;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 5103:
	__asm        mov    eax, freepad;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, freepad;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 5104:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+0x18], eax;
// LINE 5105:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+0x1C], eax;
// LINE 5106:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    [ecx+0x20], eax;
// LINE 5111:
_T4a4:
	return 0x1;
// LINE 5112:
	__asm        jmp    _T4e0;
// LINE 5113:
	__asm        jmp    _T4e0;
_T4b8:
	__asm        cmp    dword ptr [ebp-0x70], 4;
	__asm        ja     _T4e0;

	__asm        mov    eax, [ebp-0x70];
	__asm        jmp    _Switch_4cc[0][eax*4];
// Switch pointers:
//   _Tb0
//   _Tce
//   _T299
//   _T341
//   _FOR_3b9
// LINE 5115:
_T4e0:
	return 0x0;
// LINE 5117:
}

// FUNCTION: COPTER_D 0x004f7de6
int32_t S3HeliDyObjCollisionCheck(/*packed*/ struct _HELI_DATA *hd) {
	/*bp-0x4*/   int32_t ret_code;
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0x14*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x18*/  /*packed*/ struct _CELL_INFO *cptr;

// LINE 5131:
	ret_code = 0x0;
// LINE 5134:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x18];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 5137:
	dyobj = cptr->dyptr;
// LINE 5138:
__WHILE_3d:
	__asm        cmp    dyobj, 0;
	__asm        je     _T18a;
// LINE 5141:
	__asm        mov    eax, hd;
	__asm        mov    ecx, dyobj;
	__asm        cmp    [eax+0xA4], ecx;
	__asm        jne    _T5e;
// LINE 5143:
	__asm        jmp    next_dyobj;
// LINE 5148:
_T5e:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x20;
	__asm        je     _T72;
// LINE 5150:
	__asm        jmp    next_dyobj;
// LINE 5154:
_T72:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x40;
	__asm        je     _T86;
// LINE 5156:
	__asm        jmp    next_dyobj;
// LINE 5159:
_T86:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 5167:
	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, dyobj;
	__asm        add    eax, [ecx+0x10];
	__asm        cmp    eax, loc.x;
	__asm        jle    next_dyobj;

	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, dyobj;
	__asm        sub    eax, [ecx+0x10];
	__asm        cmp    eax, loc.x;
	__asm        jge    next_dyobj;

	__asm        mov    eax, dyobj;
	__asm        mov    ecx, loc.y;
	__asm        cmp    [eax+0x1C], ecx;
	__asm        jge    next_dyobj;

	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ecx, dyobj;
	__asm        add    eax, [ecx+0x1C];
	__asm        cmp    eax, loc.y;
	__asm        jle    next_dyobj;

	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, dyobj;
	__asm        add    eax, [ecx+0x10];
	__asm        cmp    eax, loc.z;
	__asm        jle    next_dyobj;

	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, dyobj;
	__asm        sub    eax, [ecx+0x10];
	__asm        cmp    eax, loc.z;
	__asm        jge    next_dyobj;
// LINE 5170:
	S3ObjHitDispatch(0x0, -0x1, dyobj, hd->dyheli, 0xc);
// LINE 5177:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        jne    next_dyobj;
// LINE 5178:
	ret_code = 0x1;
// LINE 5190:
next_dyobj:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T17d;
// LINE 5192:
	dyobj = dyobj->next->next->next->next->next->next->next->next->next->next;
// LINE 5194:
	__asm        jmp    _T185;
// LINE 5195:
_T17d:
	dyobj = dyobj->next;
// LINE 5196:
_T185:
	__asm        jmp    __WHILE_3d;
// LINE 5198:
_T18a:
	return ret_code;
// LINE 5199:
}

// FUNCTION: COPTER_D 0x004f7f7d
void S3HeliHitSpiral(long hit_type, /*packed*/ struct Point2d *cell, /*packed*/ struct _DYOBJ_INST *dyhitter, long mission_id, long xtra_msg) {
	/*bp-0x4*/   long xdir;
	/*bp-0x8*/   long ydir;
	/*bp-0xc*/   /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0x10*/  long curr_dist;
	/*bp-0x14*/  long spiral_dist;
	/*bp-0x18*/  long x;
	/*bp-0x1c*/  long y;
	/*bp-0x20*/  long i;
	/*bp-0x24*/  long curr_dir;
	/*bp-0x28*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x2c*/  int32_t stop_now;

// LINE 5214:
	curr_dist = 0x0;
// LINE 5215:
	curr_dir = 0xffffffff;
// LINE 5217:
	stop_now = 0x0;
// LINE 5225:
	__asm        mov    eax, hit_type;
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _T50;
// LINE 5228:
_T29:
	spiral_dist = 0x3;
// LINE 5229:
	__asm        jmp    _T69;
// LINE 5231:
_T35:
	spiral_dist = 0x5;
// LINE 5232:
	__asm        jmp    _T69;
// LINE 5234:
	return;
// LINE 5235:
	__asm        jmp    _T69;
// LINE 5236:
	__asm        jmp    _T69;
_T50:
	__asm        cmp    dword ptr [ebp-0x30], 1;
	__asm        je     _T29;

	__asm        cmp    dword ptr [ebp-0x30], 2;
	__asm        je     _T35;

	return;
// LINE 5238:
_T69:
	x = cell->x;
// LINE 5239:
	y = cell->y;
// LINE 5247:
_LOOP_7a:
	curr_dir++;
// LINE 5248:
	__asm        mov    eax, curr_dir;
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _Te6;
// LINE 5252:
_T88:
	curr_dir = 0x0;
// LINE 5253:
	curr_dist++;
// LINE 5254:
	xdir = 0x0;
// LINE 5255:
	ydir = 0xffffffff;
// LINE 5256:
	__asm        jmp    _T10e;
// LINE 5258:
_Ta5:
	xdir = 0x1;
// LINE 5259:
	ydir = 0x0;
// LINE 5260:
	__asm        jmp    _T10e;
// LINE 5262:
_Tb8:
	curr_dist++;
// LINE 5263:
	xdir = 0x0;
// LINE 5264:
	ydir = 0x1;
// LINE 5265:
	__asm        jmp    _T10e;
// LINE 5267:
_Tce:
	xdir = 0xffffffff;
// LINE 5268:
	ydir = 0x0;
// LINE 5269:
	__asm        jmp    _T10e;
// LINE 5270:
	__asm        jmp    _T10e;
_Te6:
	__asm        cmp    dword ptr [ebp-0x34], 4;
	__asm        ja     _T10e;

	__asm        mov    eax, [ebp-0x34];
	__asm        jmp    _Switch_fa[0][eax*4];
// Switch pointers:
//   _T88
//   _Ta5
//   _Tb8
//   _Tce
//   _T88
// LINE 5274:
_T10e:
	__asm        mov    eax, curr_dist;
	__asm        cmp    spiral_dist, eax;
	__asm        jne    _FOR_130;
// LINE 5276:
	curr_dist--;
// LINE 5277:
	stop_now = 0x1;
// LINE 5281:
_FOR_130:
	i = 0x0;
	__asm        jmp    _FOR_COND_130;
_FOR_NEXT_130:
	i++;
_FOR_COND_130:
	__asm        mov    eax, i;
	__asm        cmp    curr_dist, eax;
	__asm        jle    _T225;
// LINE 5284:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 5287:
	dyobj = cptr->dyptr;
// LINE 5288:
__WHILE_166:
	__asm        cmp    dyobj, 0;
	__asm        je     _T214;
// LINE 5291:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T184;
// LINE 5293:
	__asm        jmp    next_dyobj;
// LINE 5297:
_T184:
	__asm        mov    eax, dyhitter;
	__asm        cmp    dyobj, eax;
	__asm        jne    _T195;
// LINE 5299:
	__asm        jmp    next_dyobj;
// LINE 5303:
_T195:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x20;
	__asm        je     _T1a9;
// LINE 5305:
	__asm        jmp    next_dyobj;
// LINE 5309:
_T1a9:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x40;
	__asm        je     _T1bd;
// LINE 5311:
	__asm        jmp    next_dyobj;
// LINE 5315:
_T1bd:
	S3ObjHitDispatch(xtra_msg, mission_id, dyobj, dyhitter, hit_type);
// LINE 5319:
next_dyobj:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T207;
// LINE 5321:
	dyobj = dyobj->next->next->next->next->next->next->next->next->next->next;
// LINE 5323:
	__asm        jmp    _T20f;
// LINE 5324:
_T207:
	dyobj = dyobj->next;
// LINE 5325:
_T20f:
	__asm        jmp    __WHILE_166;
// LINE 5328:
_T214:
	x += xdir;
// LINE 5329:
	y += ydir;
// LINE 5330:
	__asm        jmp    _FOR_NEXT_130;
// LINE 5332:
_T225:
	__asm        cmp    stop_now, 1;
	__asm        jne    _T234;
// LINE 5333:
	return;
// LINE 5334:
_T234:
	__asm        jmp    _LOOP_7a;
// LINE 5335:
}

// FUNCTION: COPTER_D 0x004f81bb
/*packed*/ struct Point2d* S3HeliGetFreePad() {
	/*bp-0x4*/   /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0x8*/   /*packed*/ struct Point2d *pad;
	/*bp-0xc*/   /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x10*/  /*packed*/ struct Point2d *noheliloc;

// LINE 5355:
	noheliloc = 0x0;
// LINE 5358:
	pad = 0x6c1190;
// LINE 5361:
_FOR_1c:
	__asm        jmp    _FOR_COND_1c;
_FOR_NEXT_1c:
	pad += 0x8;
_FOR_COND_1c:
	__asm        mov    eax, 0x6C1190;
	__asm        add    eax, 0x60;
	__asm        cmp    eax, pad;
	__asm        je     _Ta8;
// LINE 5364:
	__asm        mov    eax, pad;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, pad;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 5367:
	__asm        mov    eax, cptr;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        jne    _T69;
// LINE 5368:
	return pad;
// LINE 5371:
_T69:
	dyobj = cptr->dyptr;
// LINE 5372:
__WHILE_72:
	__asm        cmp    dyobj, 0;
	__asm        je     _T9d;
// LINE 5374:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T90;
// LINE 5375:
	__asm        jmp    contains_a_heli;
// LINE 5378:
_T90:
	dyobj = dyobj->next;
// LINE 5379:
	__asm        jmp    __WHILE_72;
// LINE 5382:
_T9d:
	noheliloc = pad;
// LINE 5386:
contains_a_heli:
	__asm        jmp    _FOR_NEXT_1c;
// LINE 5390:
_Ta8:
	return noheliloc;
// LINE 5391:
}

// FUNCTION: COPTER_D 0x004f8270
/*packed*/ struct _HELI_DATA* S3HeliGetDataForType(long lHeliType) {
	/*bp-0x4*/   int32_t i;

// LINE 5405:
_FOR_15:
	i = 0x0;
	__asm        jmp    _FOR_COND_15;
_FOR_NEXT_15:
	i++;
_FOR_COND_15:
	__asm        cmp    i, 0xA;
	__asm        jge    _T63;
// LINE 5406:
	__asm        mov    eax, i;
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*8];
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, ecx;
	__asm        mov    ecx, lHeliType;
	__asm        cmp    G_helidata[0].type[eax*2], ecx;
	__asm        jne    _T5e;
// LINE 5407:
	__asm        mov    eax, i;
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*8];
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, ecx;
	__asm        lea    eax, G_helidata[0].type[eax*2];
	__asm        jmp    __RETURN;
// LINE 5408:
_T5e:
	__asm        jmp    _FOR_NEXT_15;
// LINE 5409:
_T63:
	return 0x0;
// LINE 5410:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f82df
long S3HeliGetNewValue(long lHeliType) {
	/*bp-0x4*/   /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 5420:
	__asm        mov    eax, lHeliType;
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 5422:
	__asm        cmp    htd, 0;
	__asm        je     _T33;
// LINE 5425:
	return htd->cost;
// LINE 5427:
_T33:
	return 0x0;
// LINE 5428:
}

// FUNCTION: COPTER_D 0x004f831e
long S3HeliGetCurrentValue(long lHeliType) {
	/*bp-0x4*/   int32_t newval;
	/*bp-0x8*/   /*packed*/ struct _HELI_DATA *hd;
	/*bp-0xc*/   /*packed*/ struct _HELI_TYPE_DATA *htd;

// LINE 5439:
	hd = S3HeliGetDataForType(lHeliType);
// LINE 5440:
	__asm        mov    eax, lHeliType;
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        lea    eax, S_helitype_data[0].num_initialized[eax*8];
	__asm        mov    htd, eax;
// LINE 5443:
	__asm        cmp    hd, 0;
	__asm        je     _T7e;
// LINE 5448:
	__asm        mov    eax, S_htwk_depreciation;
	__asm        push   eax;
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x324];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    newval, eax;
// LINE 5449:
	newval = (htd->cost - (newval >> 0x10));
// LINE 5452:
	__asm        mov    eax, htd;
	__asm        mov    eax, [eax+0x48];
	__asm        sar    eax, 1;
	__asm        mov    ecx, newval;
	__asm        cmp    eax, ecx;
	__asm        jg     _T79;

	__asm        mov    eax, ecx;
_T79:
	__asm        jmp    __RETURN;
// LINE 5454:
_T7e:
	return 0x0;
// LINE 5455:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f83a8
long S3HeliGetEquipmentNewValue(long lEquipmentType) {
	/*bp-0x14*/  long lValues[5]; // 0x14 bytes
	/*bp-0x18*/  long lTeargasCanisterCount;

// LINE 5468:
	lValues[0] = 0x7d0;
// LINE 5469:
	lValues[1] = 0x3e8;
// LINE 5470:
	lValues[2] = 0x7d0;
// LINE 5471:
	lValues[3] = 0x64;
// LINE 5472:
	lValues[4] = 0x7d0;
// LINE 5476:
	__asm        cmp    lEquipmentType, 3;
	__asm        jne    _T85;
// LINE 5484:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        test   byte ptr [eax+0x48], 8;
	__asm        jne    _T58;
// LINE 5485:
	__asm        mov    eax, lValues[3];
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        jmp    __RETURN;
// LINE 5486:
	__asm        jmp    _T85;
// LINE 5487:
_T58:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    lTeargasCanisterCount, eax;
// LINE 5488:
	__asm        cmp    lTeargasCanisterCount, 0xA;
	__asm        jle    _T74;
// LINE 5489:
	lTeargasCanisterCount = 0xa;
// LINE 5490:
_T74:
	return ((0xa - lTeargasCanisterCount) * lValues[3]);
// LINE 5493:
_T85:
	__asm        mov    eax, lEquipmentType;
	__asm        mov    eax, [ebp+eax*4-0x14];
	__asm        jmp    __RETURN;
// LINE 5494:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f843e
void S3HeliPurchaseTeargasCanisters(long lBucks) {
// LINE 5503:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        mov    [ebp-4], eax;
	__asm        mov    ecx, 0x64;
	__asm        mov    eax, lBucks;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, [ebp-4];
	__asm        add    [ecx+0x54], eax;
// LINE 5504:
}

// FUNCTION: COPTER_D 0x004f8465
long S3HeliGetEquipmentCurrentValue(long lEquipmentType) {
// LINE 5516:
	__asm        mov    eax, lEquipmentType;
	__asm        push   eax;
	__asm        call   S3HeliGetEquipmentNewValue;
	__asm        add    esp, 4;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, 0x64;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        jmp    __RETURN;
// LINE 5517:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f8492
void S3HeliMakeHelicopter(long lHeliType) {
	/*bp-0x4*/   /*packed*/ struct Point2d *freepad;
	/*bp-0x8*/   /*packed*/ struct _HELI_DATA *hd;
	/*bp-0xc*/   /*packed*/ struct tagUserPersonalInfo *up;

// LINE 5529:
	hd = S3HeliGetDataForType(lHeliType);
// LINE 5534:
	up = GetCurrentUserPersonalInfo();
// LINE 5537:
	__asm        mov    eax, up;
	__asm        mov    edx, 1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(lHeliType);
	__asm        shl    edx, cl;
	__asm        test   [eax+0x44], edx;
	__asm        je     _T3b;
// LINE 5538:
	return;
// LINE 5540:
_T3b:
	__asm        cmp    lHeliType, 2;
	__asm        jne    _T62;

	__asm        cmp    G_apachebase_found, 1;
	__asm        jne    _T62;
// LINE 5541:
	freepad = (0x6c1190 + 0x68);
// LINE 5542:
	__asm        jmp    _T6a;
// LINE 5543:
_T62:
	freepad = S3HeliGetFreePad();
// LINE 5545:
_T6a:
	__asm        mov    eax, 1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(lHeliType);
	__asm        shl    eax, cl;
	__asm        mov    ecx, up;
	__asm        or     [ecx+0x44], eax;
// LINE 5546:
	S3HeliGenInit(freepad->y, freepad->x, hd);
// LINE 5547:
}

// FUNCTION: COPTER_D 0x004f852a
void S3HeliRemoveHelicopter(long lHeliType) {
	/*bp-0x4*/   long i;
	/*bp-0x8*/   /*packed*/ struct _HELI_DATA *hd;
	/*bp-0xc*/   /*packed*/ struct tagUserPersonalInfo *up;
	/*bp-0x10*/  /*packed*/ struct _CELL_INFO *cptr;

// LINE 5557:
	hd = S3HeliGetDataForType(lHeliType);
// LINE 5563:
	__asm        cmp    hd, 0;
	__asm        jne    _T27;
// LINE 5564:
	return;
// LINE 5566:
_T27:
	up = GetCurrentUserPersonalInfo();
// LINE 5569:
_FOR_3b:
	i = 0x0;
	__asm        jmp    _FOR_COND_3b;
_FOR_NEXT_3b:
	i++;
_FOR_COND_3b:
	__asm        cmp    i, 0xA;
	__asm        jge    __RETURN;
// LINE 5571:
	__asm        mov    eax, i;
	__asm        mov    ecx, hd;
	__asm        cmp    G_helis[0][eax*4], ecx;
	__asm        jne    _Tb4;
// LINE 5573:
	__asm        mov    eax, hd;
	__asm        mov    eax, [eax+0x1C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, hd;
	__asm        mov    ecx, [ecx+0x18];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 5574:
	S3HeliUnlink(cptr, hd);
// LINE 5575:
	__asm        mov    eax, i;
	__asm        mov    G_helis[0][eax*4], 0;
// LINE 5576:
	__asm        mov    eax, 1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(lHeliType);
	__asm        shl    eax, cl;
	__asm        not    eax;
	__asm        mov    ecx, up;
	__asm        and    [ecx+0x44], eax;
// LINE 5577:
	return;
// LINE 5579:
_Tb4:
	__asm        jmp    _FOR_NEXT_3b;
// LINE 5581:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f85e8
void S3HeliUnlink(/*packed*/ struct _HELI_DATA *hd, /*packed*/ struct _CELL_INFO *cptr) {
	/*bp-0x4*/   /*packed*/ struct _DYOBJ_INST **dyptrptr;

// LINE 5594:
	dyptrptr = (cptr + 0x10);
// LINE 5595:
__WHILE_12:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     __RETURN;
// LINE 5597:
	__asm        mov    eax, hd;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0xA4], ecx;
	__asm        jne    _T59;
// LINE 5599:
	dyptrptr-> = hd->dyheli->next->next->next->next->next->next->next->next->next->next;
// LINE 5600:
	return;
// LINE 5602:
_T59:
	dyptrptr = dyptrptr->;
// LINE 5603:
	__asm        jmp    __WHILE_12;
// LINE 5604:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f8653
void S3HeliHitDispatch(long hitter_type, /*packed*/ struct _DYOBJ_INST *dyhitter, /*packed*/ struct _DYOBJ_INST *dyhittee, long mission_id, long xtra_msg) {
	/*bp-0x4*/   /*packed*/ struct _HELI_DATA *hd;

// LINE 5617:
	__asm        mov    eax, dyhittee;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*8];
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, ecx;
	__asm        lea    eax, G_helidata[0].type[eax*2];
	__asm        mov    hd, eax;
// LINE 5620:
	__asm        mov    eax, hitter_type;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T197;
// LINE 5623:
_T32:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _T57;
// LINE 5624:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        sar    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 5625:
_T57:
	return;
// LINE 5627:
_T5c:
	return;
// LINE 5629:
_T61:
	return;
// LINE 5631:
_T66:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _T8b;
// LINE 5632:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 5633:
_T8b:
	return;
// LINE 5635:
_T90:
	return;
// LINE 5637:
_T95:
	return;
// LINE 5639:
_T9a:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _Tbf;
// LINE 5640:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 5641:
_Tbf:
	return;
// LINE 5643:
_Tc4:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _Te4;
// LINE 5644:
	__asm        xor    eax, eax;
	__asm        sub    eax, S_htwk_collide_damage_val;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 5645:
_Te4:
	return;
// LINE 5647:
_Te9:
	return;
// LINE 5649:
_Tee:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _T113;
// LINE 5650:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 5651:
_T113:
	return;
// LINE 5653:
_T118:
	return;
// LINE 5655:
_T11d:
	return;
// LINE 5657:
_T122:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _T142;
// LINE 5658:
	__asm        xor    eax, eax;
	__asm        sub    eax, S_htwk_collide_damage_val;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 5659:
_T142:
	return;
// LINE 5661:
_T147:
	return;
// LINE 5663:
_T14c:
	return;
// LINE 5666:
_T151:
	hd->damage = 0xffffffff;
// LINE 5667:
	return;
// LINE 5669:
_T163:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _T188;
// LINE 5670:
	__asm        xor    eax, eax;
	__asm        mov    ecx, S_htwk_collide_damage_val;
	__asm        sar    ecx, 3;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        mov    ecx, hd;
	__asm        sub    [ecx+0xD0], eax;
// LINE 5671:
_T188:
	return;
// LINE 5673:
	return;
// LINE 5674:
	return;
_T197:
	__asm        cmp    dword ptr [ebp-8], 0x10;
	__asm        ja     __RETURN;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    _Switch_1ab[0][eax*4];
// Switch pointers:
//   _T32
//   _T5c
//   _T61
//   _T66
//   _T90
//   _T95
//   _T9a
//   _Tc4
//   _Te9
//   _Tee
//   _T118
//   _T11d
//   _T122
//   _T147
//   _T14c
//   _T163
//   _T151
// LINE 5676:
__RETURN:
}

// FUNCTION: COPTER_D 0x004f8847
int32_t S3HeliMIFFLoad(void * __ptr32 miffReader) {
	/*bp-0x4*/   long ret;
	/*bp-0x8*/   long i;
	/*bp-0xc*/   /*packed*/ struct _HELI_DATA *hd;

// LINE 5702:
	ret = ReadFirstMIFFChunk(0x32c, 0x606eb0, HeliMIFFID, miffReader);
// LINE 5703:
	__asm        cmp    ret, 0;
	__asm        jne    _FOR_45;
// LINE 5704:
	return 0x0;
// LINE 5707:
_FOR_45:
	i = 0x0;
	__asm        jmp    _FOR_COND_45;
_FOR_NEXT_45:
	i++;
_FOR_COND_45:
	__asm        cmp    i, 0xA;
	__asm        jge    _Tf9;
// LINE 5709:
	__asm        mov    eax, i;
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*8];
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, ecx;
	__asm        lea    eax, G_helidata[0].type[eax*2];
	__asm        mov    hd, eax;
// LINE 5712:
	hd->damage = lsheli.damage;
// LINE 5713:
	hd->winfo.load = lsheli.winfo.load;
// LINE 5714:
	hd->fuel = lsheli.fuel;
// LINE 5715:
	hd->flight_time = lsheli.flight_time;
// LINE 5716:
	__asm        mov    edi, hd;
	__asm        add    edi, 0x1C4;
	__asm        lea    esi, lsheli.passengerData.lPassengerDataChanged;
	__asm        mov    ecx, 0x57;
	__asm        rep movsd;
// LINE 5723:
	ret = ReadNextMIFFChunk(0x32c, 0x606eb0, HeliMIFFID, miffReader);
// LINE 5724:
	__asm        cmp    ret, 0;
	__asm        jne    _Tf4;

	__asm        cmp    i, 9;
	__asm        je     _Tf4;
// LINE 5725:
	return 0x0;
// LINE 5726:
_Tf4:
	__asm        jmp    _FOR_NEXT_45;
// LINE 5728:
_Tf9:
	return 0x1;
// LINE 5729:
}

// FUNCTION: COPTER_D 0x004f894f
int32_t S3HeliMIFFSave(void * __ptr32 miffWriter) {
	/*bp-0x4*/   long ret;
	/*bp-0x8*/   long i;

// LINE 5737:
_FOR_15:
	i = 0x0;
	__asm        jmp    _FOR_COND_15;
_FOR_NEXT_15:
	i++;
_FOR_COND_15:
	__asm        cmp    i, 0xA;
	__asm        jge    _T6a;
// LINE 5742:
	__asm        push   0x32C;
	__asm        mov    eax, i;
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*8];
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, ecx;
	__asm        lea    eax, G_helidata[0].type[eax*2];
	__asm        push   eax;
	__asm        mov    eax, HeliMIFFID;
	__asm        push   eax;
	__asm        mov    eax, miffWriter;
	__asm        push   eax;
	__asm        call   WriteMIFFChunk;
	__asm        add    esp, 0x10;
	__asm        mov    ret, eax;
// LINE 5743:
	__asm        cmp    ret, 0;
	__asm        jne    _T65;
// LINE 5744:
	return 0x0;
// LINE 5745:
_T65:
	__asm        jmp    _FOR_NEXT_15;
// LINE 5747:
_T6a:
	return 0x1;
// LINE 5748:
}

// FUNCTION: COPTER_D 0x004f89c8
void S3HeliUserExit() {
	/*bp-0x4*/   int32_t rcos;
	/*bp-0x10*/  /*packed*/ struct Point3d vehicleLoc; // 0xc bytes
	/*bp-0x14*/  int32_t angle;
	/*bp-0x20*/  /*packed*/ struct Point3d personLoc; // 0xc bytes
	/*bp-0x24*/  int32_t rsin;
	/*bp-0x28*/  int32_t radius;
	/*bp-0x2c*/  int32_t maxRadius;

// LINE 5761:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, vehicleLoc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 5762:
	maxRadius = 0x200000;
// LINE 5768:
_FOR_3d:
	radius = 0x80000;
	__asm        jmp    _FOR_COND_3d;
_FOR_NEXT_3d:
	radius += 0x80000;
_FOR_COND_3d:
	__asm        mov    eax, maxRadius;
	__asm        cmp    radius, eax;
	__asm        jge    __RETURN;
// LINE 5770:
_FOR_5c:
	angle = 0x0;
	__asm        jmp    _FOR_COND_5c;
_FOR_NEXT_5c:
	angle += 0x640000;
_FOR_COND_5c:
	__asm        cmp    angle, 0xE100000;
	__asm        jge    _T11a;
// LINE 5772:
	__asm        lea    eax, rcos;
	__asm        push   eax;
	__asm        lea    eax, rsin;
	__asm        push   eax;
	__asm        mov    eax, angle;
	__asm        push   eax;
	__asm        call   0x004D19FC;
	__asm        add    esp, 0xC;
// LINE 5773:
	__asm        mov    eax, rcos;
	__asm        push   eax;
	__asm        mov    eax, radius;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, vehicleLoc.x;
	__asm        add    ecx, eax;
	__asm        mov    personLoc.x, ecx;
// LINE 5774:
	__asm        mov    eax, rsin;
	__asm        push   eax;
	__asm        mov    eax, radius;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, vehicleLoc.z;
	__asm        add    ecx, eax;
	__asm        mov    personLoc.z, ecx;
// LINE 5775:
	personLoc.y = S3ObjectPrecisionAlt(personLoc.z, personLoc.x);
// LINE 5781:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x154];
	__asm        sub    eax, 0x50000;
	__asm        cmp    eax, personLoc.y;
	__asm        jg     _T115;

	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x154];
	__asm        add    eax, 0x50000;
	__asm        cmp    eax, personLoc.y;
	__asm        jl     _T115;
// LINE 5784:
	S3PersonUserAppearNew((G_uheli + 0x100), personLoc.x);
// LINE 5785:
	return;
// LINE 5788:
_T115:
	__asm        jmp    _FOR_NEXT_5c;
// LINE 5789:
_T11a:
	__asm        jmp    _FOR_NEXT_3d;
// LINE 5790:
__RETURN:
}



// Contribution: 2:00003688-00003897 Module: 176, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x00592688
static const int32_t TurnTable3[4][8] = {{0, 1, 2, 3, 4, 5, 6, 7}, {2, 3, 4, 5, 6, 7, 0, 1}, {6, 7, 0, 1, 2, 3, 4, 5}, {4, 5, 6, 7, 0, 1, 2, 3}};

// GLOBAL: COPTER_D 0x00592708
static const int32_t TurnTable2[4][4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {3, 0, 1, 2}, {2, 3, 0, 1}};

// GLOBAL: COPTER_D 0x00592748
static const int32_t IndexToType[4] = {1, 2, 4, 8};

// GLOBAL: COPTER_D 0x00592758
static const int32_t TypeToIndex2[16] = {-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1};

// GLOBAL: COPTER_D 0x00592798
static const int32_t TILUT[4][4] = {{0, 1, 3, 2}, {2, 0, 1, 3}, {3, 2, 0, 1}, {1, 3, 2, 0}};

// GLOBAL: COPTER_D 0x005927d8
static const /*packed*/ struct _dPoint2d OT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00592818
static const /*packed*/ struct _dPoint2d RRT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00592858
static const /*packed*/ struct _dPoint2d LRT[4] = { 0 /* todo */ };



// Contribution: 3:0001d8c0-0001ddb4 Module: 176, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b48c0
int32_t S_htwk_landing_yspeed = 327680;

// GLOBAL: COPTER_D 0x005b48c4
int32_t S_htwk_landing_pitch = 655360;

// GLOBAL: COPTER_D 0x005b48c8
int32_t S_htwk_landing_slide = 655360;

// GLOBAL: COPTER_D 0x005b48cc
int32_t S_htwk_landing_speed = 655360;

// GLOBAL: COPTER_D 0x005b48d0
int32_t S_htwk_max_descent_rate = 655360;

// GLOBAL: COPTER_D 0x005b48d4
int32_t S_htwk_bucket_fillrate = 30;

// GLOBAL: COPTER_D 0x005b48d8
int32_t S_htwk_bucket_dumprate = 10;

// GLOBAL: COPTER_D 0x005b48dc
int32_t S_htwk_rope_loadfactor = 40;

// GLOBAL: COPTER_D 0x005b48e0
int32_t S_htwk_rope_tension = 6553;

// GLOBAL: COPTER_D 0x005b48e4
int32_t S_htwk_water_throwfact = 18;

// GLOBAL: COPTER_D 0x005b48e8
int32_t S_htwk_watercannon_speed = 9830400;

// GLOBAL: COPTER_D 0x005b48ec
int32_t S_htwk_firedmg_alt_min = -3145728;

// GLOBAL: COPTER_D 0x005b48f0
int32_t S_htwk_firedmg_alt_max = 7864320;

// GLOBAL: COPTER_D 0x005b48f4
int32_t S_htwk_max_helialt = 52428800;

// GLOBAL: COPTER_D 0x005b48f8
int32_t S_htwk_collide_damage_val = 50;

// GLOBAL: COPTER_D 0x005b48fc
int32_t S_htwk_depreciation = 32768;

// GLOBAL: COPTER_D 0x005b4900
static char ControlNoise = 0;

// GLOBAL: COPTER_D 0x005b4904
static long S_sound_frames = 0;

// GLOBAL: COPTER_D 0x005b4908
static int32_t RopeSeg = 262144;

// GLOBAL: COPTER_D 0x005b490c
static int32_t RopeDim = 65536;

// GLOBAL: COPTER_D 0x005b4910
/*packed*/ struct Point3d G_helidir = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b491c
int32_t G_helibase_found = 0;

// GLOBAL: COPTER_D 0x005b4920
int32_t G_apachebase_found = 0;

// GLOBAL: COPTER_D 0x005b4924
int32_t G_apache_placed = 0;

// GLOBAL: COPTER_D 0x005b4928
int32_t G_uheli_objalt = 0;

// GLOBAL: COPTER_D 0x005b492c
long G_SpotLiteXRotation = 0;

// GLOBAL: COPTER_D 0x005b4930
long G_SpotLiteYRotation = 0;

// GLOBAL: COPTER_D 0x005b4934
static long S_test_frames = 0;

// GLOBAL: COPTER_D 0x005b4938
static long S_avoiding = 0;

// GLOBAL: COPTER_D 0x005b493c
static int32_t S_targalt = 6553600;

// GLOBAL: COPTER_D 0x005b4940
/*packed*/ struct _HELI_DATA *G_helis[10] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b4968
/*packed*/ struct _HELI_DATA *G_uheli = { 0 /* todo */ };
// has alternate definitions: (original TI: 0x2a5a)
//   /*unpacked*/ struct _HELI_DATA *G_uheli (TI: 0x38f7)

// GLOBAL: COPTER_D 0x005b496c
/*packed*/ struct _HELI_DATA *G_testheli = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b4970
static long S_numhelis = 0;

// GLOBAL: COPTER_D 0x005b4978
/*packed*/ struct _HELI_TYPE_DATA S_helitype_data[9] = { 0 /* todo */ };
// has alternate definitions: (original TI: 0x486c)
//   /*packed*/ struct _HELI_TYPE_DATA S_helitype_data[1] (TI: 0x4870)

// GLOBAL: COPTER_D 0x005b4c90
static /*packed*/ struct Point3d S_bracket_loc = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b4c9c
static int32_t S_shadalt = 0;

// GLOBAL: COPTER_D 0x005b4ca0
static int32_t S_spotdist = 0;

// GLOBAL: COPTER_D 0x005b4ca4
static long HeliMIFFID = 1212501065;



// Contribution: 3:0006feb0-000702b7 Module: 176, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00606eb0
static /*packed*/ struct _HELI_DATA lsheli;

// GLOBAL: COPTER_D 0x006071e0
static /*packed*/ struct Point3d S_spotvect;

// GLOBAL: COPTER_D 0x006071ec
static /*packed*/ struct VRBmpHdr *S_shadbmp;

// GLOBAL: COPTER_D 0x006071f0
static int32_t S_turbyaw[10];

// GLOBAL: COPTER_D 0x00607218
static int32_t S_spotmat[4][4];

// GLOBAL: COPTER_D 0x00607258
static /*packed*/ struct Point3d S_sound_loc;

// GLOBAL: COPTER_D 0x00607268
static int32_t S_turbslide[10];

// GLOBAL: COPTER_D 0x00607290
static int32_t S_turbpitch[10];



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.

// WARNING: this global might actually belong to: C:\Copter\source\game\S3city.c
// GLOBAL: COPTER_D 0x006c1190
/*packed*/ struct _HELIBASE_DATA G_helibase; // Contrib missing

// GLOBAL: COPTER_D 0x006c1200
/*packed*/ struct VRBmpHdr *S_spotlevels[4]; // Contrib missing

// GLOBAL: COPTER_D 0x006bf1d0
/*packed*/ struct _HELI_DATA G_helidata[10]; // Contrib missing

// GLOBAL: COPTER_D 0x006bf1c0
/*packed*/ struct Point3d G_testloc; // Contrib missing

// GLOBAL: COPTER_D 0x006bf1b8
/*packed*/ struct Point2d S_spotloc; // Contrib missing

// GLOBAL: COPTER_D 0x006bf1b8
/*packed*/ struct Point2d S_spotloc; // Contrib missing

// GLOBAL: COPTER_D 0x006bf1d0
/*packed*/ struct _HELI_DATA G_helidata[10]; // Contrib missing

// GLOBAL: COPTER_D 0x006bf1c0
/*packed*/ struct Point3d G_testloc; // Contrib missing

// GLOBAL: COPTER_D 0x006c1200
/*packed*/ struct VRBmpHdr *S_spotlevels[4]; // Contrib missing

