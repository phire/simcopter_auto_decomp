// Module: S3auto.obj
// Source: C:\Copter\source\game\S3auto.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class AutomobileClass (forward reference);
// VTABLE: COPTER_D 0x00592d98
class AutomobileClass{ // packed(0x11a bytes) TI: 0x4880
	enum CarType {
		kCarAmbulance = 0,
		kCarCop = 1,
		kCarFiretruck = 2,
		kCarCriminal = 3,
	};
	enum AutoMessageID {
		AM_NO_MESSAGE = 0,
		AM_CANCEL_AUTO_MISSION = 1,
	};
	enum /* __unnamed */ {
		CAR_TYPES = 7,
		PERCENTAGE_OF_AUTO1 = 10,
		PERCENTAGE_OF_AUTO2 = 20,
		PERCENTAGE_OF_AUTO3 = 20,
		PERCENTAGE_OF_AUTO4 = 10,
		PERCENTAGE_OF_AUTO5 = 10,
		PERCENTAGE_OF_AUTO6 = 20,
		PERCENTAGE_OF_AUTO7 = 20,
		TOTAL_PERCENTAGE = 110,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
		DEAD_END_HIWAY = 16,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		AUTO_IN_WAY = 4,
		DEBRIS_IN_WAY = 5,
		UNIDENTIFIED_IN_WAY = 6,
		HELI_IN_WAY = 7,
		END_OF_ROAD = 8,
		END_OF_HIWAY = 9,
		INTERSECTION_FULL = 10,
		BEEN_PULLED_OVER = 11,
	};
	enum RoadTileOffsets {
		RD_CENTOFF = 851968,
		RD_EDGEOFF = 131072,
	};
	enum HiwayOffsets {
		HW_CENTOFF_LANE1 = 851968,
		HW_EDGEOFF_LANE1 = 131072,
		HW_CENTOFF_LANE2 = 851968,
		HW_EDGEOFF_LANE2 = 131072,
		HW_HEIGHT = 2031616,
	};
public:
	static int32_t fireSirenDist;
	static int32_t policeSirenDist;
	static int32_t ambSirenDist;
	static int32_t fireHoseDist;
	enum /* __unnamed */ {
		CAR_RADIUS = 327680,
		COLLISION_SPACE = 655360,
		ROAD_SPEED = 2621440,
		ROAD_SLOWDOWN_FACTOR = 131072,
		HIWAY_SPEED = 6225920,
		HIWAY_SLOWDOWN_FACTOR = 327680,
		SPEED_VARIANCE = 262144,
		HIWAY_VARIANCE = 655360,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
	};
	enum Flags {
		AUTO_INITIALIZED = 1,
		AUTO_PLACED = 2,
		AUTO_NEEDS_TO_PULL_OVER = 4,
		AUTO_PULL_OVER = 8,
		AUTO_PULLING_OVER = 16,
		AUTO_PULLED_OVER = 32,
		AUTO_PULLING_OUT = 64,
		AUTO_IN_INTERSECTION = 128,
		AUTO_ON_FIRE = 256,
		AUTO_JAMMED = 512,
		AUTO_RIGHT_OF_WAY = 1024,
		AUTO_ON_HIWAY = 2048,
		AUTO_SPEEDER = 4096,
		AUTO_SPEEDER_DONE = 8192,
		AUTO_UTURN = 16384,
	};
public:
	/*+0x4*/   long carModel;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x70*/  /*packed*/ struct Goal goal; // 0x2a bytes
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	/*+0x9a*/  int32_t DeltaFromCenter;
	/*+0x9e*/  int32_t stalledTimer;
	/*+0xa2*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xae*/  int32_t remainingTime;
	/*+0xb2*/  int32_t desiredSpeed;
	/*+0xb6*/  int32_t desiredHiwaySpeed;
	/*+0xba*/  int32_t beamDelay;
	/*+0xbe*/  int32_t beamTimer;
	/*+0xc2*/  int32_t m_cellBaseY;
	/*+0xc6*/  int32_t timePulledOver;
	/*+0xca*/  int32_t hornSoundId;
	/*+0xce*/  enum DirectionTypes hiwaydir;
	/*+0xd2*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xd4*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xd6*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xd8*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xda*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xdc*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
protected:
	/*+0xde*/  int32_t speed;
	/*+0xe2*/  enum DirIndex2 prevDir;
	/*+0xe6*/  enum TurnIndex turnIndex;
	/*+0xea*/  int32_t currDist;
	/*+0xee*/  int32_t legOfTurn;
	/*+0xf2*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xf6*/  int32_t personDone;
	/*+0xfa*/  int32_t personState;
	/*+0xfe*/  int32_t personTimer;
	/*+0x102*/ int32_t timeToLive;
	/*+0x106*/ int32_t fireTime;
	/*+0x10a*/ long fireSeq;
	/*+0x10e*/ long missionId;
	/*+0x112*/ /*packed*/ struct _CELL_INFO *cptr;
	/*+0x116*/ int32_t spotlightHitCounter;
	int32_t IsCarPersistant();
	int32_t CanCarBeamToHiwayTile(unsigned short);
public:
	void AutomobileClass(const /*packed*/ class AutomobileClass&);
	void AutomobileClass();
	virtual void ~AutomobileClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class AutomobileClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class AutomobileClass* GetAutoPointer(long);
	// calltype: NearC
	static void DestroyInstance(/*packed*/ class AutomobileClass*);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t MissionStartFire(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static int32_t MissionStartJam(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static void MissionCancel(long);
	// calltype: NearC
	static void SetAllHeadlights(int32_t);
	// calltype: NearC
	static int32_t S3AutoMessage(short, short);
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
	void HitDispatch(long, /*packed*/ struct _DYOBJ_INST*, long, long);
	int32_t AmIABadGuy();
	int32_t Initialize(int32_t);
	void WaterDouse(/*packed*/ struct _DYOBJ_INST*);
	void IveBeenMegaphoned(long);
	void StartFire(long);
	void StartJam(long);
	virtual void PullOver(short); // vtable+0x4
	void PullOut();
	int32_t CanIPullOut();
	int32_t CanIPullOver();
	void DoAUTurn();
	long GetCarModel();
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* GetClosestCar(int32_t, int32_t, int32_t);
protected:
	void Itterate();
	virtual void AdjustSpeed(); // vtable+0x8
	void Reset();
	virtual enum TurnIndex PickTurnDir(/*packed*/ struct Goal*); // vtable+0xc
	void UnPlaceCar();
	void PullOverCiviliansInWay();
	virtual void ItterateFSM(); // vtable+0x10
	int32_t InitializeInstance(int32_t);
	void LinkToCell(const /*packed*/ struct _GridCoordinates&);
	int32_t AreCarsHeadOn(/*packed*/ struct Point3d*);
	enum AutomobileClass::StoppedReasons CollisionCheck(int32_t, /*packed*/ struct _DYOBJ_INST**);
	int32_t IsCarOutOfCameraRange();
	void TurnOffHeadlight();
	void TurnOnHeadlight();
	int32_t AutoMessage(short);
	int32_t PlacePerson(int32_t, int32_t);
	virtual void SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x14
	virtual void LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x18
	void HonkHorn();
	void SetHiwayDirection(unsigned short);
	int32_t DoHiwayTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void AdjustCurrentHiwayPosition();
	void AdjustNextHiwayPosition();
	enum AutomobileClass::IntersectionTypes PickHiwayDir(/*packed*/ struct _GridCoordinates&);
	void MakeAHiwayTurn(enum AutomobileClass::IntersectionTypes);
	void GoStraight();
	void TurnLeft();
	void TurnRight();
	void MoveForwardOnHiway();
	void DoDiagonalRoadFixup();
	virtual void BeamToWithinCameraRange(); // vtable+0x1c
	virtual int32_t BeamToLocation(const /*packed*/ struct _GridCoordinates&); // vtable+0x20
	void MoveAuto(int32_t);
	void ChangeAutoColor();
private:
	void UnlinkFromCell(const /*packed*/ struct _GridCoordinates&);
	void TransitionBetweenGoals();
	void RunFireState();
	void RunJamState();
	void IveBeenSpotlighted(/*packed*/ struct _DYOBJ_INST*);
	int32_t IsThisAnEmergencyVehicle();
	void DoPullOverStuff(int32_t);
	int32_t CanIDoAUTurn();
public:
	/*packed*/ class AutomobileClass operator=(const /*packed*/ class AutomobileClass&);
};

// Type: /*packed*/ struct CONNECTION_INFO_TYPE (forward reference);
struct CONNECTION_INFO_TYPE{ // packed(0x8 bytes) TI: 0x30c5
	/*+0x0*/   enum RailTypes tile;
	/*+0x4*/   enum DirectionTypes connections;
};

// Type: int32_t;

// Type: /*packed*/ struct _AUTO_LOAD_SAVE;
struct _AUTO_LOAD_SAVE{ // packed(0x344 bytes) TI: 0x42d7
	/*+0x0*/   int32_t flags;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x68*/  /*packed*/ struct Goal goal; // 0x2a bytes
	/*+0x92*/  /*packed*/ struct _GridCoordinates goalpRGVFixup; // 0x2 bytes
	/*+0x94*/  int32_t DeltaFromCenter;
	/*+0x98*/  int32_t stalledTimer;
	/*+0x9c*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xa8*/  int32_t remainingTime;
	/*+0xac*/  int32_t desiredSpeed;
	/*+0xb0*/  int32_t desiredHiwaySpeed;
	/*+0xb4*/  int32_t beamDelay;
	/*+0xb8*/  int32_t beamTimer;
	/*+0xbc*/  int32_t m_cellBaseY;
	/*+0xc0*/  int32_t timePulledOver;
	/*+0xc4*/  enum DirectionTypes hiwaydir;
	/*+0xc8*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xca*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xcc*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xce*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xd0*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xd2*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
	/*+0xd4*/  int32_t speed;
	/*+0xd8*/  long prevDir;
	/*+0xdc*/  long turnIndex;
	/*+0xe0*/  int32_t currDist;
	/*+0xe4*/  int32_t legOfTurn;
	/*+0xe8*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xec*/  int32_t personDone;
	/*+0xf0*/  int32_t personState;
	/*+0xf4*/  int32_t personTimer;
	/*+0xf8*/  int32_t timeToLive;
	/*+0xfc*/  int32_t fireTime;
	/*+0x100*/ long fireSeq;
	/*+0x104*/ long missionId;
	/*+0x108*/ /*packed*/ struct _GridCoordinates cptrfixup; // 0x2 bytes
	/*+0x10a*/ int32_t spotlightHitCounter;
	struct _AUTO_LOAD_SAVE::_CRIMINAL{ // packed(0x10 bytes) TI: 0x42df
		/*+0x0*/   long missionState;
		/*+0x4*/   long criminalType;
		/*+0x8*/   int32_t timeToLeaveCar;
		/*+0xc*/   int32_t timeToBeOnTheRun;
	};
public:
	/*+0x10e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_CRIMINAL c; // 0x10 bytes
	struct _AUTO_LOAD_SAVE::_EMERGENCY{ // packed(0x186 bytes) TI: 0x42dd
		/*+0x0*/   /*packed*/ struct _GridCoordinates baseLocation; // 0x2 bytes
		/*+0x2*/   /*packed*/ struct _GridCoordinates emergencyLocation; // 0x2 bytes
		/*+0x4*/   long emergencyType;
		/*+0x8*/   long timeOfArrival;
		/*+0xc*/   /*packed*/ struct _DYOBJ_INST dispatchIcon; // 0x64 bytes
		/*+0x70*/  int32_t timeToEmergency;
		/*+0x74*/  long targetfixup;
		/*+0x78*/  unsigned char dispatchPath[256]; // 0x100 bytes
		/*+0x178*/ unsigned char dispatchPathIndex; // 0x1 bytes
		/*+0x179*/ unsigned char dispatchPathLength; // 0x1 bytes
		/*+0x17a*/ long emergencyState;
		/*+0x17e*/ int32_t stationID;
		/*+0x182*/ int32_t numberOfSeats;
	};
public:
	/*+0x11e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_EMERGENCY e; // 0x186 bytes
	struct _AUTO_LOAD_SAVE::_FIRE{ // packed(0x18 bytes) TI: 0x42db
		/*+0x0*/   int32_t dousingFire;
		/*+0x4*/   int32_t distToFire;
		/*+0x8*/   /*packed*/ struct Point3d firevec; // 0xc bytes
		/*+0x14*/  int32_t pathID;
	};
public:
	/*+0x2a4*/ /*packed*/ struct _AUTO_LOAD_SAVE::_FIRE f; // 0x18 bytes
	struct _AUTO_LOAD_SAVE::_POLICE{ // packed(0x88 bytes) TI: 0x42d9
		/*+0x0*/   /*packed*/ struct Goal currDestGoal; // 0x2a bytes
		/*+0x2a*/  /*packed*/ struct _GridCoordinates currpRGVFixup; // 0x2 bytes
		/*+0x2c*/  /*packed*/ struct Goal destGoal1; // 0x2a bytes
		/*+0x56*/  /*packed*/ struct _GridCoordinates dest1pRGVFixup; // 0x2 bytes
		/*+0x58*/  /*packed*/ struct Goal destGoal2; // 0x2a bytes
		/*+0x82*/  /*packed*/ struct _GridCoordinates dest2pRGVFixup; // 0x2 bytes
		/*+0x84*/  int32_t foundRoad;
	};
public:
	/*+0x2bc*/ /*packed*/ struct _AUTO_LOAD_SAVE::_POLICE p; // 0x88 bytes
};

// Type: enum DirIndex2;
enum DirIndex2 {
	i2N = 0,
	i2E = 1,
	i2S = 2,
	i2W = 3,
	i2X = -1,
	i2I = -2,
};

// Type: enum DirectionTypes;
enum DirectionTypes {
	NO_DIRECTION = 0,
	NORTH = 1,
	EAST = 2,
	SOUTH = 4,
	WEST = 8,
	RISING = 16,
	RISING_NORTH = 17,
	RISING_SOUTH = 20,
	RISING_EAST = 18,
	RISING_WEST = 24,
	NORTH_EAST = 3,
	SOUTH_EAST = 6,
	SOUTH_WEST = 12,
	NORTH_WEST = 9,
};

// Type: enum TurnIndex;
enum TurnIndex {
	iTS = 0,
	iTR = 1,
	iTL = 2,
	iTU = 3,
};

// Type: /*packed*/ struct _dPoint2d (forward reference);
struct _dPoint2d{ // packed(0x10 bytes) TI: 0x2766
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double z; // 0x8 bytes
};

// Type: /*packed*/ struct _GridCoordinates;
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: short;

// Type: long;

// Type: void;

// Type: /*packed*/ struct VRview;
struct VRview{ // packed(0x58 bytes) TI: 0x2ecc
	/*+0x0*/   /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0xc*/   /*packed*/ struct Point3d scale; // 0xc bytes
	/*+0x18*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct MISSION_DATA (forward reference);
struct MISSION_DATA{ // packed(0xd4 bytes) TI: 0x31c4
	/*+0x0*/   char mtext[32]; // 0x20 bytes
	/*+0x20*/  long type_ctr;
	/*+0x24*/  long key;
	/*+0x28*/  /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x30*/  /*packed*/ struct Point2d destmaploc; // 0x8 bytes
	/*+0x38*/  /*packed*/ struct Point2d pickuploc; // 0x8 bytes
	/*+0x40*/  int32_t timer;
	/*+0x44*/  long money_bonus;
	/*+0x48*/  long points_bonus;
	/*+0x4c*/  long flags;
	/*+0x50*/  long type;
	/*+0x54*/  long state;
	/*+0x58*/  /*packed*/ struct __unnamed mdata; // 0x7c bytes
};

// Type: /*packed*/ struct _MISSION_PARMS;
struct _MISSION_PARMS{ // packed(0x18 bytes) TI: 0x307d
	/*+0x0*/   long op;
	/*+0x4*/   long id;
	/*+0x8*/   /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x10*/  long i2num;
	/*+0x14*/  long flags;
};

// Type: /*packed*/ struct _GridCoordinates (forward reference);
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct Goal (forward reference);
struct Goal{ // packed(0x2a bytes) TI: 0x12ce
	/*+0x0*/   /*packed*/ struct RGVertex *pRGV;
	/*+0x4*/   int32_t elementIndex;
	/*+0x8*/   int32_t gridIndex;
	/*+0xc*/   /*packed*/ struct _GridCoordinates gridLoc; // 0x2 bytes
	/*+0xe*/   enum DirIndex2 edgeIndex;
	/*+0x12*/  enum DirIndex2 direction;
	/*+0x16*/  int32_t distance;
	/*+0x1a*/  int32_t turnFlags;
	/*+0x1e*/  int32_t deadEndFlags;
	/*+0x22*/  int32_t fElevated;
	/*+0x26*/  enum SlopeIndex slope;
};

// Type: unsigned short;

// Type: /*packed*/ struct Goal;
struct Goal{ // packed(0x2a bytes) TI: 0x12ce
	/*+0x0*/   /*packed*/ struct RGVertex *pRGV;
	/*+0x4*/   int32_t elementIndex;
	/*+0x8*/   int32_t gridIndex;
	/*+0xc*/   /*packed*/ struct _GridCoordinates gridLoc; // 0x2 bytes
	/*+0xe*/   enum DirIndex2 edgeIndex;
	/*+0x12*/  enum DirIndex2 direction;
	/*+0x16*/  int32_t distance;
	/*+0x1a*/  int32_t turnFlags;
	/*+0x1e*/  int32_t deadEndFlags;
	/*+0x22*/  int32_t fElevated;
	/*+0x26*/  enum SlopeIndex slope;
};

// Type: /*packed*/ class SpiralScan;
class SpiralScan{ // packed(0x10 bytes) TI: 0x2fb5
public:
	void SpiralScan(int32_t);
	void ~SpiralScan();
	int32_t Next(/*packed*/ struct _GridCoordinates&);
	int32_t InCityGridLimits(/*packed*/ struct _GridCoordinates);
private:
	/*+0x0*/   int32_t currDist;
	/*+0x4*/   int32_t currDir;
	/*+0x8*/   int32_t currDia;
	/*+0xc*/   int32_t maxDia;
};

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: char *;

// Type: unsigned char;

// Type: enum AutomobileClass::StoppedReasons;
enum StoppedReasons {
	NO_REASON = 0,
	TRAFFIC = 1,
	STOPPED_TRAFFIC = 2,
	PERSON_IN_WAY = 3,
	AUTO_IN_WAY = 4,
	DEBRIS_IN_WAY = 5,
	UNIDENTIFIED_IN_WAY = 6,
	HELI_IN_WAY = 7,
	END_OF_ROAD = 8,
	END_OF_HIWAY = 9,
	INTERSECTION_FULL = 10,
	BEEN_PULLED_OVER = 11,
};

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct Point2d;
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct VRFaceInfo;
struct VRFaceInfo{ // packed(0x20 bytes) TI: 0x30c0
	/*+0x0*/   int32_t Face;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Plotter;
	/*+0x10*/  /*packed*/ struct VRBmpHdr *Bitmap;
	/*+0x14*/  int32_t * VertList;
	/*+0x18*/  /*packed*/ struct MapVert *MapVList;
	/*+0x1c*/  /*packed*/ struct MapVert *BarryPtr;
};

// Type: enum AutomobileClass::IntersectionTypes;
enum IntersectionTypes {
	DEAD_END = 0,
	STRAIGHT_AHEAD = 1,
	LEFT_ONLY = 2,
	RIGHT_ONLY = 4,
	LEFT_OR_STRAIGHT = 3,
	LEFT_OR_RIGHT = 6,
	RIGHT_OR_STRAIGHT = 5,
	LEFT_STRAIGHT_OR_RIGHT = 7,
	DEAD_END_HIWAY = 16,
};

// Type: void * __ptr32;

// Type: /*packed*/ struct _AUTO_LOAD_SAVE (forward reference);
struct _AUTO_LOAD_SAVE{ // packed(0x344 bytes) TI: 0x42d7
	/*+0x0*/   int32_t flags;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x68*/  /*packed*/ struct Goal goal; // 0x2a bytes
	/*+0x92*/  /*packed*/ struct _GridCoordinates goalpRGVFixup; // 0x2 bytes
	/*+0x94*/  int32_t DeltaFromCenter;
	/*+0x98*/  int32_t stalledTimer;
	/*+0x9c*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xa8*/  int32_t remainingTime;
	/*+0xac*/  int32_t desiredSpeed;
	/*+0xb0*/  int32_t desiredHiwaySpeed;
	/*+0xb4*/  int32_t beamDelay;
	/*+0xb8*/  int32_t beamTimer;
	/*+0xbc*/  int32_t m_cellBaseY;
	/*+0xc0*/  int32_t timePulledOver;
	/*+0xc4*/  enum DirectionTypes hiwaydir;
	/*+0xc8*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xca*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xcc*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xce*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xd0*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xd2*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
	/*+0xd4*/  int32_t speed;
	/*+0xd8*/  long prevDir;
	/*+0xdc*/  long turnIndex;
	/*+0xe0*/  int32_t currDist;
	/*+0xe4*/  int32_t legOfTurn;
	/*+0xe8*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xec*/  int32_t personDone;
	/*+0xf0*/  int32_t personState;
	/*+0xf4*/  int32_t personTimer;
	/*+0xf8*/  int32_t timeToLive;
	/*+0xfc*/  int32_t fireTime;
	/*+0x100*/ long fireSeq;
	/*+0x104*/ long missionId;
	/*+0x108*/ /*packed*/ struct _GridCoordinates cptrfixup; // 0x2 bytes
	/*+0x10a*/ int32_t spotlightHitCounter;
	struct _AUTO_LOAD_SAVE::_CRIMINAL{ // packed(0x10 bytes) TI: 0x42df
		/*+0x0*/   long missionState;
		/*+0x4*/   long criminalType;
		/*+0x8*/   int32_t timeToLeaveCar;
		/*+0xc*/   int32_t timeToBeOnTheRun;
	};
public:
	/*+0x10e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_CRIMINAL c; // 0x10 bytes
	struct _AUTO_LOAD_SAVE::_EMERGENCY{ // packed(0x186 bytes) TI: 0x42dd
		/*+0x0*/   /*packed*/ struct _GridCoordinates baseLocation; // 0x2 bytes
		/*+0x2*/   /*packed*/ struct _GridCoordinates emergencyLocation; // 0x2 bytes
		/*+0x4*/   long emergencyType;
		/*+0x8*/   long timeOfArrival;
		/*+0xc*/   /*packed*/ struct _DYOBJ_INST dispatchIcon; // 0x64 bytes
		/*+0x70*/  int32_t timeToEmergency;
		/*+0x74*/  long targetfixup;
		/*+0x78*/  unsigned char dispatchPath[256]; // 0x100 bytes
		/*+0x178*/ unsigned char dispatchPathIndex; // 0x1 bytes
		/*+0x179*/ unsigned char dispatchPathLength; // 0x1 bytes
		/*+0x17a*/ long emergencyState;
		/*+0x17e*/ int32_t stationID;
		/*+0x182*/ int32_t numberOfSeats;
	};
public:
	/*+0x11e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_EMERGENCY e; // 0x186 bytes
	struct _AUTO_LOAD_SAVE::_FIRE{ // packed(0x18 bytes) TI: 0x42db
		/*+0x0*/   int32_t dousingFire;
		/*+0x4*/   int32_t distToFire;
		/*+0x8*/   /*packed*/ struct Point3d firevec; // 0xc bytes
		/*+0x14*/  int32_t pathID;
	};
public:
	/*+0x2a4*/ /*packed*/ struct _AUTO_LOAD_SAVE::_FIRE f; // 0x18 bytes
	struct _AUTO_LOAD_SAVE::_POLICE{ // packed(0x88 bytes) TI: 0x42d9
		/*+0x0*/   /*packed*/ struct Goal currDestGoal; // 0x2a bytes
		/*+0x2a*/  /*packed*/ struct _GridCoordinates currpRGVFixup; // 0x2 bytes
		/*+0x2c*/  /*packed*/ struct Goal destGoal1; // 0x2a bytes
		/*+0x56*/  /*packed*/ struct _GridCoordinates dest1pRGVFixup; // 0x2 bytes
		/*+0x58*/  /*packed*/ struct Goal destGoal2; // 0x2a bytes
		/*+0x82*/  /*packed*/ struct _GridCoordinates dest2pRGVFixup; // 0x2 bytes
		/*+0x84*/  int32_t foundRoad;
	};
public:
	/*+0x2bc*/ /*packed*/ struct _AUTO_LOAD_SAVE::_POLICE p; // 0x88 bytes
};

// Type: uint32_t;



// Contribution: 1:001005e0-00108fb1 Module: 171, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x005015e0
int32_t S3StartSpeederMission() {
	/*bp-0x4*/   /*packed*/ class AutomobileClass *pCar;
	/*bp-0x8*/   int32_t i;

// LINE 74:
_FOR_15:
	for (i = 0x1; (i < 0x46); i++) {
		// LINE 76:
			__asm        mov    eax, i;
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    pCar, eax;
		// LINE 87:
			__asm        mov    eax, pCar;
			__asm        cmp    dword ptr [eax+4], 0x7A;
			__asm        je     _T86;

			__asm        mov    eax, pCar;
			__asm        cmp    dword ptr [eax+4], 0x7D;
			__asm        je     _T86;

			__asm        mov    eax, pCar;
			__asm        cmp    dword ptr [eax+4], 0x7E;
			__asm        je     _T86;

			__asm        mov    eax, pCar;
			__asm        cmp    dword ptr [eax+4], 0x12A;
			__asm        je     _T86;

			__asm        mov    eax, pCar;
			__asm        cmp    dword ptr [eax+4], 0x12B;
			__asm        je     _T86;

			__asm        mov    eax, pCar;
			__asm        cmp    dword ptr [eax+4], 0x12C;
			__asm        jne    _Td8;
		_T86:
			__asm        mov    eax, pCar;
			__asm        test   byte ptr [eax+9], 1;
			__asm        jne    _Td8;

			__asm        mov    eax, pCar;
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _Td8;

			__asm        mov    eax, pCar;
			__asm        test   byte ptr [eax+8], 1;
			__asm        je     _Td8;

			__asm        mov    eax, i;
			__asm        cmp    lastSpeederID, eax;
			__asm        je     _Td8;
		// LINE 90:
			__asm        mov    eax, pCar;
			__asm        or     dword ptr [eax+8], 0x1000;
		// LINE 93:
			lastSpeederID = i;
		// LINE 94:
			return 0x1;
		// LINE 96:
		_Td8:
	}
// LINE 98:
_Tdd:
	return 0x0;
// LINE 99:
}

// FUNCTION: COPTER_D 0x005016c9
int32_t Distance(/*packed*/ struct _GridCoordinates loc1, /*packed*/ struct _GridCoordinates loc2) {
	/*bp-0x4*/   int32_t deltax;
	/*bp-0x8*/   int32_t deltay;

// LINE 109:
	__asm        xor    eax, eax;
	__asm        mov    al, loc2.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, loc1.x;
	__asm        cmp    eax, ecx;
	__asm        jge    _T2f;
// LINE 110:
	__asm        xor    eax, eax;
	__asm        mov    al, loc1.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, loc2.x;
	__asm        sub    eax, ecx;
	__asm        mov    deltax, eax;
// LINE 111:
	__asm        jmp    _T3e;
// LINE 112:
_T2f:
	__asm        xor    eax, eax;
	__asm        mov    al, loc2.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, loc1.x;
	__asm        sub    eax, ecx;
	__asm        mov    deltax, eax;
// LINE 114:
_T3e:
	__asm        xor    eax, eax;
	__asm        mov    al, loc2.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, loc1.y;
	__asm        cmp    eax, ecx;
	__asm        jge    _T64;
// LINE 115:
	__asm        xor    eax, eax;
	__asm        mov    al, loc1.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, loc2.y;
	__asm        sub    eax, ecx;
	__asm        mov    deltay, eax;
// LINE 116:
	__asm        jmp    _T73;
// LINE 117:
_T64:
	__asm        xor    eax, eax;
	__asm        mov    al, loc2.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, loc1.y;
	__asm        sub    eax, ecx;
	__asm        mov    deltay, eax;
// LINE 119:
_T73:
	__asm        mov    eax, deltax;
	__asm        cmp    deltay, eax;
	__asm        jge    _T92;
// LINE 121:
	return ((deltay >> 0x1) + deltax);
// LINE 123:
	__asm        jmp    __RETURN;
// LINE 125:
_T92:
	return ((deltax >> 0x1) + deltay);
// LINE 127:
__RETURN:
}

// FUNCTION: COPTER_D 0x0050176e
/*packed*/ struct _DYOBJ_INST* AutomobileClass::GetClosestCar(int32_t cartype, int32_t cellx, int32_t celly) {
	/*bp-0x4*/   int32_t carID;
	/*bp-0x8*/   int32_t dist;
	/*bp-0xc*/   /*packed*/ struct _GridCoordinates here;
	/*bp-0x10*/  int32_t i;
	/*bp-0x14*/  int32_t minDist;
	/*bp-0x18*/  /*packed*/ struct _GridCoordinates there;

// LINE 142:
	minDist = 0x7d00;
// LINE 147:
	__asm        mov    al, reinterpret_cast<uint8_t>(cellx);
	__asm        mov    there.x, al;
// LINE 148:
	__asm        mov    al, reinterpret_cast<uint8_t>(celly);
	__asm        mov    there.y, al;
// LINE 150:
	__asm        mov    eax, cartype;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T2eb;
// LINE 153:
_FOR_33:
	for (i = 0x0; (i < 0x5); i++) {
		// LINE 156:
			__asm        mov    eax, i;
			__asm        mov    eax, ambulances[0][eax*4];
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _Ta5;

			__asm        mov    eax, i;
			__asm        mov    eax, ambulances[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x20;
			__asm        je     _Ta5;
		// LINE 158:
			__asm        mov    eax, i;
			__asm        mov    eax, ambulances[0][eax*4];
			__asm        mov    ax, [eax+0x7C];
			__asm        mov    reinterpret_cast<uint16_t>(here.x), ax;
		// LINE 159:
			dist = Distance(reinterpret_cast<uint32_t>(there.x), reinterpret_cast<uint32_t>(here.x));
		// LINE 160:
			__asm        mov    eax, minDist;
			__asm        cmp    dist, eax;
			__asm        jge    _Ta5;
		// LINE 162:
			minDist = dist;
		// LINE 163:
			carID = i;
		// LINE 166:
		_Ta5:
	}
// LINE 168:
_Taa:
	__asm        cmp    minDist, 0x7D00;
	__asm        jne    _Tc3;
// LINE 169:
	return 0x0;
// LINE 170:
	__asm        jmp    _FOR_e1;
// LINE 171:
_Tc3:
	__asm        mov    eax, carID;
	__asm        mov    eax, ambulances[0][eax*4];
	__asm        add    eax, 0xC;
	__asm        jmp    __RETURN;
// LINE 174:
_FOR_e1:
	for (i = 0x0; (i < 0x5); i++) {
		// LINE 177:
			__asm        mov    eax, i;
			__asm        mov    eax, policeCars[0][eax*4];
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _T153;

			__asm        mov    eax, i;
			__asm        mov    eax, policeCars[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x20;
			__asm        je     _T153;
		// LINE 179:
			__asm        mov    eax, i;
			__asm        mov    eax, policeCars[0][eax*4];
			__asm        mov    ax, [eax+0x7C];
			__asm        mov    reinterpret_cast<uint16_t>(here.x), ax;
		// LINE 180:
			dist = Distance(reinterpret_cast<uint32_t>(there.x), reinterpret_cast<uint32_t>(here.x));
		// LINE 181:
			__asm        mov    eax, minDist;
			__asm        cmp    dist, eax;
			__asm        jge    _T153;
		// LINE 183:
			minDist = dist;
		// LINE 184:
			carID = i;
		// LINE 187:
		_T153:
	}
// LINE 189:
_T158:
	__asm        cmp    minDist, 0x7D00;
	__asm        jne    _T171;
// LINE 190:
	return 0x0;
// LINE 191:
	__asm        jmp    _FOR_18f;
// LINE 192:
_T171:
	__asm        mov    eax, carID;
	__asm        mov    eax, policeCars[0][eax*4];
	__asm        add    eax, 0xC;
	__asm        jmp    __RETURN;
// LINE 195:
_FOR_18f:
	for (i = 0x0; (i < 0x5); i++) {
		// LINE 198:
			__asm        mov    eax, i;
			__asm        mov    eax, fireTrucks[0][eax*4];
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _T201;

			__asm        mov    eax, i;
			__asm        mov    eax, fireTrucks[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x20;
			__asm        je     _T201;
		// LINE 200:
			__asm        mov    eax, i;
			__asm        mov    eax, fireTrucks[0][eax*4];
			__asm        mov    ax, [eax+0x7C];
			__asm        mov    reinterpret_cast<uint16_t>(here.x), ax;
		// LINE 201:
			dist = Distance(reinterpret_cast<uint32_t>(there.x), reinterpret_cast<uint32_t>(here.x));
		// LINE 202:
			__asm        mov    eax, minDist;
			__asm        cmp    dist, eax;
			__asm        jge    _T201;
		// LINE 204:
			minDist = dist;
		// LINE 205:
			carID = i;
		// LINE 208:
		_T201:
	}
// LINE 210:
_T206:
	__asm        cmp    minDist, 0x7D00;
	__asm        jne    _T21f;
// LINE 211:
	return 0x0;
// LINE 212:
	__asm        jmp    _FOR_23d;
// LINE 213:
_T21f:
	__asm        mov    eax, carID;
	__asm        mov    eax, fireTrucks[0][eax*4];
	__asm        add    eax, 0xC;
	__asm        jmp    __RETURN;
// LINE 216:
_FOR_23d:
	for (i = 0x0; (i < 0x5); i++) {
		// LINE 219:
			__asm        mov    eax, i;
			__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _T2af;

			__asm        mov    eax, i;
			__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x20;
			__asm        je     _T2af;
		// LINE 221:
			__asm        mov    eax, i;
			__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
			__asm        mov    ax, [eax+0x7C];
			__asm        mov    reinterpret_cast<uint16_t>(here.x), ax;
		// LINE 222:
			dist = Distance(reinterpret_cast<uint32_t>(there.x), reinterpret_cast<uint32_t>(here.x));
		// LINE 223:
			__asm        mov    eax, minDist;
			__asm        cmp    dist, eax;
			__asm        jge    _T2af;
		// LINE 225:
			minDist = dist;
		// LINE 226:
			carID = i;
		// LINE 229:
		_T2af:
	}
// LINE 231:
_T2b4:
	__asm        cmp    minDist, 0x7D00;
	__asm        jne    _T2cd;
// LINE 232:
	return 0x0;
// LINE 233:
	__asm        jmp    _T2df;
// LINE 234:
_T2cd:
	__asm        mov    eax, carID;
	__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
	__asm        add    eax, 0xC;
	__asm        jmp    __RETURN;
// LINE 237:
_T2df:
	return 0x0;
// LINE 238:
	__asm        jmp    _T30f;
_T2eb:
	__asm        cmp    dword ptr [ebp-0x1C], 3;
	__asm        ja     _T2df;

	__asm        mov    eax, [ebp-0x1C];
	__asm        jmp    _Switch_2ff[0][eax*4];
// Switch pointers:
//   _FOR_33
//   _FOR_e1
//   _FOR_18f
//   _FOR_23d
// LINE 240:
_T30f:
	return 0x0;
// LINE 241:
__RETURN:
}

// FUNCTION: COPTER_D 0x00501a89
int32_t AutomobileClass::S3AutoMessage(short vehicleID, short messID) {
// LINE 246:
	__asm        mov    eax, reinterpret_cast<uint32_t>(messID);
	__asm        push   eax;
	__asm        movsx  eax, vehicleID;
	__asm        mov    ecx, cars[0][eax*4];
	__asm        call   AutomobileClass::AutoMessage;
	__asm        jmp    __RETURN;
// LINE 247:
__RETURN:
}

// FUNCTION: COPTER_D 0x00501aad
int32_t AutomobileClass::AutoMessage(short messID) {
// LINE 252:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        jne    _T20;

	return 0x0;
// LINE 254:
_T20:
	__asm        movsx  eax, messID;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T36;
// LINE 258:
	__asm        jmp    _T3b;
// LINE 259:
	__asm        jmp    _T3b;
_T36:
	__asm        jmp    _T3b;
// LINE 261:
_T3b:
	return 0x1;
// LINE 262:
}

// FUNCTION: COPTER_D 0x00501af9
int32_t GetTheCurrentNumberOfAutomobiles() {
// LINE 269:
	return curAutos;
// LINE 270:
}

// FUNCTION: COPTER_D 0x00501b0e
int32_t SetTheCurrentNumberOfAutomobiles(int32_t num) {
// LINE 275:
	__asm        cmp    num, 0x32;
	__asm        jg     _T22;
// LINE 277:
	curAutos = num;
// LINE 278:
	return 0x1;
// LINE 281:
_T22:
	return 0x0;
// LINE 282:
}

// FUNCTION: COPTER_D 0x00501b3c
int32_t CreateAutomobileInstance(int32_t instanceID) {
// LINE 304:
_T24:
_T26:
	return (AutomobileClass::CreateInstance(instanceID) == 0x0);
// LINE 305:
}

// FUNCTION: COPTER_D 0x00501b6c
void AutomobileClass::AutomobileClass() {
	/*bp-0x4*/   long odds;


	this-><vftable> = 0x592d98;
// LINE 327:
	this->stalledTimer = 0x0;
// LINE 328:
	this->beamTimer = 0x1e0000;
// LINE 329:
	this->DeltaFromCenter = 0x0;
// LINE 330:
	this->spotlightHitCounter = 0x0;
// LINE 333:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0xC], edx;
	__asm        jmp    _T9c;
// LINE 336:
_T61:
	this->hornSoundId = 0x2d;
// LINE 337:
	__asm        jmp    _Tbf;
// LINE 339:
_T73:
	this->hornSoundId = 0x2e;
// LINE 340:
	__asm        jmp    _Tbf;
// LINE 342:
_T85:
	this->hornSoundId = 0x2f;
// LINE 343:
	__asm        jmp    _Tbf;
// LINE 344:
	__asm        jmp    _Tbf;
_T9c:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T61;

	__asm        cmp    dword ptr [ebp-0xC], 1;
	__asm        je     _T73;

	__asm        cmp    dword ptr [ebp-0xC], 2;
	__asm        je     _T85;

	__asm        jmp    _Tbf;
// LINE 349:
_Tbf:
	__asm        call   rand;
	__asm        mov    ecx, 0x6E;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    odds, edx;
// LINE 351:
	__asm        cmp    odds, 0xA;
	__asm        jge    _Teb;
// LINE 353:
	this->carModel = 0x7a;
// LINE 361:
	__asm        jmp    _T189;
// LINE 363:
_Teb:
	__asm        cmp    odds, 0x32;
	__asm        jge    _T104;
// LINE 365:
	this->carModel = 0x7d;
// LINE 367:
	__asm        jmp    _T189;
// LINE 370:
_T104:
	__asm        cmp    odds, 0x3C;
	__asm        jge    _T11d;
// LINE 372:
	this->carModel = 0x7e;
// LINE 374:
	__asm        jmp    _T189;
// LINE 378:
_T11d:
	__asm        cmp    odds, 0x46;
	__asm        jge    _T136;
// LINE 380:
	this->carModel = 0x12a;
// LINE 382:
	__asm        jmp    _T189;
// LINE 387:
_T136:
	__asm        cmp    odds, 0x5A;
	__asm        jge    _T14f;
// LINE 389:
	this->carModel = 0x12b;
// LINE 391:
	__asm        jmp    _T189;
_T14f:
	__asm        cmp    odds, 0x6E;
	__asm        jge    _T168;
// LINE 393:
	this->carModel = 0x12c;
// LINE 395:
	__asm        jmp    _T189;
// LINE 397:
_T168:
	_assert(0x18d, 0x5b52cc, 0x5b52f0);
	__asm        jmp    _T189;

	__asm        jmp    _T189;
// LINE 400:
_T189:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFF8F;
// LINE 402:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00501d09
void AutomobileClass::~AutomobileClass() {

	this-><vftable> = 0x592d98;
// LINE 414:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 1;
	__asm        je     _T3e;
// LINE 416:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T3e;
// LINE 418:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::UnlinkFromCell;
// LINE 430:
_T3e:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFFFE;
// LINE 431:
	return;
}

// FUNCTION: COPTER_D 0x00501d58
/*packed*/ class AutomobileClass* AutomobileClass::GetAutoPointer(long index) {
// LINE 451:
	__asm        mov    eax, index;
	__asm        cmp    curAutos, eax;
	__asm        jg     _T31;

	_assert(0x1c3, 0x5b52f8, 0x5b531c);
	__asm        jmp    _T36;
_T31:
	__asm        jmp    _T36;
// LINE 453:
_T36:
	__asm        mov    eax, index;
	__asm        cmp    curAutos, eax;
	__asm        jg     _T4c;
// LINE 454:
	return 0x0;
// LINE 456:
_T4c:
	__asm        mov    eax, index;
	__asm        mov    eax, cars[0][eax*4];
	__asm        jmp    __RETURN;
// LINE 457:
__RETURN:
}

// FUNCTION: COPTER_D 0x00501db8
/*packed*/ class AutomobileClass* AutomobileClass::CreateInstance(int32_t instanceID) {
	/*bp-0x4*/   /*packed*/ class AutomobileClass *youveWonABrandNewCar;

// LINE 480:
	__asm        push   0x11A;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T33;

	__asm        mov    ecx, [ebp-8];
	__asm        call   AutomobileClass::AutomobileClass;
	__asm        mov    youveWonABrandNewCar, eax;
	__asm        jmp    _T3a;
_T33:
	youveWonABrandNewCar = 0x0;
// LINE 483:
_T3a:
	__asm        cmp    youveWonABrandNewCar, 0;
	__asm        je     _Tad;
// LINE 486:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    ecx, youveWonABrandNewCar;
	__asm        call   AutomobileClass::InitializeInstance;
	__asm        test   eax, eax;
	__asm        je     _T65;
// LINE 488:
	return youveWonABrandNewCar;
// LINE 490:
	__asm        jmp    _Tad;
// LINE 493:
_T65:
	__asm        mov    eax, youveWonABrandNewCar;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T8c;

	__asm        push   1;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T8c;
// LINE 494:
_T8c:
	_assert(0x1ee, 0x5b5330, 0x5b5354);
	__asm        jmp    _Tad;

	__asm        jmp    _Tad;
// LINE 500:
_Tad:
	return 0x0;
// LINE 501:
}

// FUNCTION: COPTER_D 0x00501e71
void AutomobileClass::ResetAll() {
	/*bp-0x4*/   int32_t currentCarIndex;

// LINE 543:
_FOR_15:
	for (currentCarIndex = 0x0; (currentCarIndex < 0x46); currentCarIndex++) {
		// LINE 545:
			__asm        mov    eax, currentCarIndex;
			__asm        mov    ecx, cars[0][eax*4];
			__asm        call   AutomobileClass::Reset;
	}
// LINE 547:
_T36:
	return;
}

// FUNCTION: COPTER_D 0x00501eb1
void AutomobileClass::ItterateAll() {
	/*bp-0x4*/   int32_t currentCarIndex;

// LINE 574:
_FOR_15:
	for (currentCarIndex = 0x0; (currentCarIndex < 0x46); currentCarIndex++) {
		// LINE 576:
			__asm        mov    eax, currentCarIndex;
			__asm        mov    ecx, cars[0][eax*4];
			__asm        call   AutomobileClass::Itterate;
	}
// LINE 578:
_T36:
	return;
}

// FUNCTION: COPTER_D 0x00501ef1
void AutomobileClass::Itterate() {
// LINE 601:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 1;
	__asm        jne    _T35;

	_assert(0x259, 0x5b535c, 0x5b5380);
	__asm        jmp    _T3a;
_T35:
	__asm        jmp    _T3a;
// LINE 608:
_T3a:
	this->beamTimer += LoopTime;
// LINE 613:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T25e;
// LINE 617:
// Block start:
	/*bp-0x58*/  /*packed*/ struct VRview position; // 0x58 bytes
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x13;
	__asm        je     _T6e;

	__asm        mov    dword ptr [ebp-0x5C], 1;
	__asm        jmp    _Tc5;
_T6e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x68], eax;
	__asm        jmp    _T8d;
_T7c:
	__asm        mov    dword ptr [ebp-0x5C], 1;
	__asm        jmp    _Tc5;

	__asm        jmp    _Tb9;
_T8d:
	__asm        cmp    dword ptr [ebp-0x68], 0x11C;
	__asm        jl     _Tb9;

	__asm        cmp    dword ptr [ebp-0x68], 0x11F;
	__asm        jle    _T7c;

	__asm        cmp    dword ptr [ebp-0x68], 0x181;
	__asm        je     _T7c;

	__asm        jmp    _Tb9;
_Tb9:
	__asm        mov    dword ptr [ebp-0x5C], 0;
	__asm        jmp    _Tc5;
_Tc5:
	__asm        cmp    dword ptr [ebp-0x5C], 0;
	__asm        jne    _Tec;

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::IsCarOutOfCameraRange;
	__asm        test   eax, eax;
	__asm        je     _Tec;
// LINE 619:
	this->AutomobileClass::UnPlaceCar();
// LINE 620:
	return;
// LINE 623:
_Tec:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     _T200;
// LINE 625:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xC6], 0;
	__asm        jle    _T121;
// LINE 627:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0xC6], eax;
// LINE 629:
	__asm        jmp    _T200;
_T121:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIPullOut;
	__asm        test   eax, eax;
	__asm        je     _T1d0;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x40;
	__asm        jne    _T1d0;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x13;
	__asm        je     _T157;

	__asm        mov    dword ptr [ebp-0x60], 1;
	__asm        jmp    _T1ae;
_T157:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T176;
_T165:
	__asm        mov    dword ptr [ebp-0x60], 1;
	__asm        jmp    _T1ae;

	__asm        jmp    _T1a2;
_T176:
	__asm        cmp    dword ptr [ebp-0x6C], 0x11C;
	__asm        jl     _T1a2;

	__asm        cmp    dword ptr [ebp-0x6C], 0x11F;
	__asm        jle    _T165;

	__asm        cmp    dword ptr [ebp-0x6C], 0x181;
	__asm        je     _T165;

	__asm        jmp    _T1a2;
_T1a2:
	__asm        mov    dword ptr [ebp-0x60], 0;
	__asm        jmp    _T1ae;
_T1ae:
	__asm        cmp    dword ptr [ebp-0x60], 0;
	__asm        jne    _T1d0;
// LINE 631:
	this->AutomobileClass::PullOut();
// LINE 632:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 634:
	__asm        jmp    _T200;
_T1d0:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        je     _T200;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        jg     _T200;
// LINE 636:
	this->AutomobileClass::PullOut();
// LINE 637:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 665:
_T200:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xDE], 0;
	__asm        jle    _T21b;
// LINE 667:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
// LINE 672:
_T21b:
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        lea    ecx, position.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 675:
	__asm        mov    esi, this;
	__asm        lea    edi, position.matrix[0][0];
	__asm        add    esi, 0x30;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 678:
	__asm        push   3;
	__asm        lea    eax, position.loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 680:
// Block end:
	__asm        jmp    _T281;
_T25e:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xBE];
	__asm        cmp    [eax+0xBA], ecx;
	__asm        jge    _T281;
// LINE 683:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x1C];
// LINE 685:
_T281:
	return;
}

// FUNCTION: COPTER_D 0x0050217c
int32_t AutomobileClass::PlacePerson(int32_t personType, int32_t personAction) {
	/*bp-0x4*/   int32_t rcos;
	/*bp-0x10*/  /*packed*/ struct Point3d vehicleLoc; // 0xc bytes
	/*bp-0x14*/  int32_t angle;
	/*bp-0x20*/  /*packed*/ struct Point3d personLoc; // 0xc bytes
	/*bp-0x24*/  int32_t rsin;
	/*bp-0x28*/  int32_t radius;
	/*bp-0x2c*/  int32_t maxRadius;

// LINE 749:
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        lea    ecx, vehicleLoc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 750:
	maxRadius = (this->autoDynomitor.radius + 0x400000);
// LINE 756:
_FOR_46:
	for (radius = (this->autoDynomitor.radius + 0x50000); (radius < maxRadius); radius += 0xa0000) {
		// LINE 758:
		_FOR_65:
			for (angle = 0x0; (angle < 0xe100000); angle += 0x640000) {
				// LINE 760:
					__asm        lea    eax, rcos;
					__asm        push   eax;
					__asm        lea    eax, rsin;
					__asm        push   eax;
					__asm        mov    eax, angle;
					__asm        push   eax;
					__asm        call   0x004D19FC;
					__asm        add    esp, 0xC;
				// LINE 761:
					__asm        mov    eax, rcos;
					__asm        push   eax;
					__asm        mov    eax, radius;
					__asm        push   eax;
					__asm        call   0x004D19BD;
					__asm        add    esp, 8;
					__asm        mov    ecx, vehicleLoc.x;
					__asm        add    ecx, eax;
					__asm        mov    personLoc.x, ecx;
				// LINE 762:
					__asm        mov    eax, rsin;
					__asm        push   eax;
					__asm        mov    eax, radius;
					__asm        push   eax;
					__asm        call   0x004D19BD;
					__asm        add    esp, 8;
					__asm        mov    ecx, vehicleLoc.z;
					__asm        add    ecx, eax;
					__asm        mov    personLoc.z, ecx;
				// LINE 763:
					personLoc.y = S3ObjectPrecisionAlt(personLoc.z, personLoc.x);
				// LINE 766:
					__asm        lea    eax, personLoc.x;
					__asm        push   eax;
					__asm        mov    eax, this;
					__asm        add    eax, 0xC;
					__asm        push   eax;
					__asm        mov    eax, this;
					__asm        mov    eax, [eax+0x10E];
					__asm        push   eax;
					__asm        mov    eax, this;
					__asm        movzx  ax, byte ptr [eax+0x7D];
					__asm        push   eax;
					__asm        mov    eax, this;
					__asm        movzx  ax, byte ptr [eax+0x7C];
					__asm        push   eax;
					__asm        mov    eax, personAction;
					__asm        push   eax;
					__asm        mov    eax, personType;
					__asm        push   eax;
					__asm        call   StartPerson;
					__asm        add    esp, 0x1C;
					__asm        movsx  eax, ax;
					__asm        test   eax, eax;
					__asm        je     _T11c;
				// LINE 767:
					return 0x1;
				// LINE 768:
				_T11c:
			}
		// LINE 769:
		_T121:
	}
// LINE 771:
_T126:
	return 0x0;
// LINE 772:
}

// FUNCTION: COPTER_D 0x005022b0
void AutomobileClass::ItterateFSM() {
	/*bp-0x4*/   /*packed*/ class AutomobileClass *carblock;
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST *dyblock;
	/*bp-0xc*/   int32_t itterationDist;
	/*bp-0x10*/  /*packed*/ struct MISSION_DATA *md;

// LINE 796:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 1;
	__asm        je     _T2b;
// LINE 798:
	this->AutomobileClass::RunFireState();
// LINE 799:
	return;
// LINE 801:
	__asm        jmp    _Tae;
_T2b:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 2;
	__asm        je     _T4a;
// LINE 803:
	this->AutomobileClass::RunJamState();
// LINE 804:
	return;
// LINE 806:
	__asm        jmp    _Tae;
_T4a:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        je     _Tae;
// LINE 808:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x20;
	__asm        je     _Tae;

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIPullOut;
	__asm        test   eax, eax;
	__asm        je     _Tae;
// LINE 813:
// Block start:
	/*bp-0x28*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	mp.id = 0xffffffff;
// LINE 814:
	mp.i2num = 0x1;
// LINE 815:
	mp.op = 0x26;
// LINE 816:
	mp.flags = 0x0;
// LINE 818:
	S3MissionUpdate(mp.op);
// LINE 820:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFCFFF;
// LINE 821:
	this->AutomobileClass::PullOut();
// LINE 826:
// Block end:
_Tae:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9E], 0x50000;
	__asm        jle    _Tc9;
// LINE 828:
	this->AutomobileClass::HonkHorn();
// LINE 831:
_Tc9:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     _Te2;

	itterationDist = 0x0;
	__asm        jmp    _Tfd;
_Te2:
	__asm        mov    eax, LoopTime;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    itterationDist, eax;
// LINE 838:
_Tfd:
	__asm        lea    eax, dyblock;
	__asm        push   eax;
	__asm        mov    eax, itterationDist;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CollisionCheck;
	__asm        mov    [ebp-0x58], eax;
	__asm        jmp    _T573;
// LINE 841:
_T115:
	__asm        jmp    _T59f;
// LINE 845:
_T11a:
	this->stalledTimer += LoopTime;
// LINE 849:
	__asm        mov    eax, dyblock;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        mov    eax, cars[0][eax*4];
	__asm        mov    carblock, eax;
// LINE 852:
	__asm        mov    eax, carblock;
	__asm        test   byte ptr [eax+9], 2;
	__asm        je     _T219;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9E], 0x140000;
	__asm        jle    _T219;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x13;
	__asm        je     _T172;

	__asm        mov    dword ptr [ebp-0x44], 1;
	__asm        jmp    _T1c9;
_T172:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x5C], eax;
	__asm        jmp    _T191;
_T180:
	__asm        mov    dword ptr [ebp-0x44], 1;
	__asm        jmp    _T1c9;

	__asm        jmp    _T1bd;
_T191:
	__asm        cmp    dword ptr [ebp-0x5C], 0x11C;
	__asm        jl     _T1bd;

	__asm        cmp    dword ptr [ebp-0x5C], 0x11F;
	__asm        jle    _T180;

	__asm        cmp    dword ptr [ebp-0x5C], 0x181;
	__asm        je     _T180;

	__asm        jmp    _T1bd;
_T1bd:
	__asm        mov    dword ptr [ebp-0x44], 0;
	__asm        jmp    _T1c9;
_T1c9:
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        jne    _T219;
// LINE 855:
	md = S3MissionGetByID(carblock->missionId);
// LINE 859:
	__asm        cmp    md, 0;
	__asm        je     _T214;

	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0xC4], 6;
	__asm        jge    _T214;
// LINE 860:
	__asm        mov    eax, carblock;
	__asm        mov    eax, [eax+0x10E];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::StartJam;
// LINE 864:
_T214:
	__asm        jmp    _T31a;
// LINE 865:
_T219:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9E], 0x460000;
	__asm        jle    _T31a;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x13;
	__asm        je     _T245;

	__asm        mov    dword ptr [ebp-0x48], 1;
	__asm        jmp    _T29c;
_T245:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x60], eax;
	__asm        jmp    _T264;
_T253:
	__asm        mov    dword ptr [ebp-0x48], 1;
	__asm        jmp    _T29c;

	__asm        jmp    _T290;
_T264:
	__asm        cmp    dword ptr [ebp-0x60], 0x11C;
	__asm        jl     _T290;

	__asm        cmp    dword ptr [ebp-0x60], 0x11F;
	__asm        jle    _T253;

	__asm        cmp    dword ptr [ebp-0x60], 0x181;
	__asm        je     _T253;

	__asm        jmp    _T290;
_T290:
	__asm        mov    dword ptr [ebp-0x48], 0;
	__asm        jmp    _T29c;
_T29c:
	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        jne    _T31a;
// LINE 870:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0xF;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T2fd;
// LINE 872:
	this->missionId = S3MissionStartDirect(0x800);
// LINE 873:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T2f8;
// LINE 875:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::StartJam;
// LINE 878:
_T2f8:
	__asm        jmp    _T31a;
_T2fd:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIDoAUTurn;
	__asm        test   eax, eax;
	__asm        je     _T31a;
// LINE 880:
	this->AutomobileClass::DoAUTurn();
// LINE 881:
	__asm        jmp    _T59f;
// LINE 885:
_T31a:
	return;
// LINE 886:
	__asm        jmp    _T59f;
// LINE 889:
_T324:
	this->stalledTimer += LoopTime;
// LINE 891:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9E], 0x1E0000;
	__asm        jle    _T433;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x13;
	__asm        je     _T35e;

	__asm        mov    dword ptr [ebp-0x4C], 1;
	__asm        jmp    _T3b5;
_T35e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x64], eax;
	__asm        jmp    _T37d;
_T36c:
	__asm        mov    dword ptr [ebp-0x4C], 1;
	__asm        jmp    _T3b5;

	__asm        jmp    _T3a9;
_T37d:
	__asm        cmp    dword ptr [ebp-0x64], 0x11C;
	__asm        jl     _T3a9;

	__asm        cmp    dword ptr [ebp-0x64], 0x11F;
	__asm        jle    _T36c;

	__asm        cmp    dword ptr [ebp-0x64], 0x181;
	__asm        je     _T36c;

	__asm        jmp    _T3a9;
_T3a9:
	__asm        mov    dword ptr [ebp-0x4C], 0;
	__asm        jmp    _T3b5;
_T3b5:
	__asm        cmp    dword ptr [ebp-0x4C], 0;
	__asm        jne    _T433;
// LINE 896:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0xF;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T416;
// LINE 898:
	this->missionId = S3MissionStartDirect(0x800);
// LINE 899:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T411;
// LINE 901:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::StartJam;
// LINE 904:
_T411:
	__asm        jmp    _T433;
_T416:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIDoAUTurn;
	__asm        test   eax, eax;
	__asm        je     _T433;
// LINE 906:
	this->AutomobileClass::DoAUTurn();
// LINE 907:
	__asm        jmp    _T59f;
// LINE 911:
_T433:
	return;
// LINE 912:
	__asm        jmp    _T59f;
// LINE 916:
_T43d:
	this->stalledTimer += LoopTime;
// LINE 918:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9E], 0x3C0000;
	__asm        jle    _T54c;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x13;
	__asm        je     _T477;

	__asm        mov    dword ptr [ebp-0x50], 1;
	__asm        jmp    _T4ce;
_T477:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x68], eax;
	__asm        jmp    _T496;
_T485:
	__asm        mov    dword ptr [ebp-0x50], 1;
	__asm        jmp    _T4ce;

	__asm        jmp    _T4c2;
_T496:
	__asm        cmp    dword ptr [ebp-0x68], 0x11C;
	__asm        jl     _T4c2;

	__asm        cmp    dword ptr [ebp-0x68], 0x11F;
	__asm        jle    _T485;

	__asm        cmp    dword ptr [ebp-0x68], 0x181;
	__asm        je     _T485;

	__asm        jmp    _T4c2;
_T4c2:
	__asm        mov    dword ptr [ebp-0x50], 0;
	__asm        jmp    _T4ce;
_T4ce:
	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        jne    _T54c;
// LINE 923:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0xF;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T52f;
// LINE 925:
	this->missionId = S3MissionStartDirect(0x800);
// LINE 926:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T52a;
// LINE 928:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::StartJam;
// LINE 931:
_T52a:
	__asm        jmp    _T54c;
_T52f:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIDoAUTurn;
	__asm        test   eax, eax;
	__asm        je     _T54c;
// LINE 933:
	this->AutomobileClass::DoAUTurn();
// LINE 934:
	__asm        jmp    _T59f;
// LINE 938:
_T54c:
	return;
// LINE 939:
	__asm        jmp    _T59f;
// LINE 942:
_T556:
	this->stalledTimer += LoopTime;
// LINE 943:
	return;
// LINE 944:
	__asm        jmp    _T59f;
// LINE 945:
	__asm        jmp    _T59f;
_T573:
	__asm        cmp    dword ptr [ebp-0x58], 5;
	__asm        ja     _T556;

	__asm        mov    eax, [ebp-0x58];
	__asm        jmp    _Switch_587[0][eax*4];
// Switch pointers:
//   _T115
//   _T556
//   _T556
//   _T43d
//   _T11a
//   _T324
// LINE 949:
_T59f:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::AmIABadGuy;
	__asm        test   eax, eax;
	__asm        je     _T6ce;
// LINE 951:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9E], 0;
	__asm        je     _T6b9;

	__asm        push   0x30;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T6b9;
// LINE 955:
// Block start:
	/*bp-0x34*/  /*packed*/ struct Point3d loc; // 0xc bytes
	loc.x = (this->autoDynomitor.loc.x - (this->pDirVector->x << 0x4));
// LINE 956:
	loc.y = (this->autoDynomitor.loc.y - (this->pDirVector->y << 0x4));
// LINE 957:
	loc.z = (this->autoDynomitor.loc.z - (this->pDirVector->z << 0x4));
// LINE 958:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x30;
	__asm        call   S3DSPlay;
	__asm        add    esp, 0xC;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0x3C], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x40], ecx;
// LINE 959:
	__asm        mov    eax, [ebp-0x3C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x40];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x38], eax;
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        jne    _T68b;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T690;
_T68b:
	__asm        jmp    _T690;
_T690:
	__asm        jmp    _T695;
_T695:
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 960:
	S3ExplosionSmokeStart(0x6, loc.x, this->cptr);
// LINE 963:
// Block end:
_T6b9:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        je     _T6ce;
// LINE 964:
	this->AutomobileClass::PullOverCiviliansInWay();
// LINE 968:
_T6ce:
	this->stalledTimer = 0x0;
// LINE 971:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 8;
	__asm        je     _T75d;
// LINE 973:
	this->AutomobileClass::MoveForwardOnHiway();
// LINE 976:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xEA], 0;
	__asm        jg     _T758;
// LINE 979:
	__asm        mov    eax, this;
	__asm        add    eax, 0xD2;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::UnlinkFromCell;
// LINE 980:
	__asm        mov    eax, this;
	__asm        add    eax, 0xD4;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 981:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD2], ax;
// LINE 983:
	__asm        mov    eax, this;
	__asm        add    eax, 0xD2;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::PickHiwayDir;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::MakeAHiwayTurn;
// LINE 989:
	this->AutomobileClass::AdjustNextHiwayPosition();
// LINE 991:
_T758:
	return;
// LINE 1003:
_T75d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        jle    __WHILE_776;
// LINE 1004:
	this->spotlightHitCounter--;
// LINE 1009:
__WHILE_776:
	while ((this->goal.distance <= (this->currDist + itterationDist))) {
		// LINE 1011:
			itterationDist += (this->currDist - this->goal.distance);
		// LINE 1012:
			this->currDist = 0x0;
		// LINE 1014:
			this->AutomobileClass::TransitionBetweenGoals();
	}
// LINE 1032:
_T7c0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xEA];
	__asm        add    eax, itterationDist;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::MoveAuto;
// LINE 1034:
	this->currDist += itterationDist;
// LINE 1044:
	return;
}

// FUNCTION: COPTER_D 0x00502a9b
void AutomobileClass::UnlinkFromCell(const /*packed*/ struct _GridCoordinates& point) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *pCell;

// LINE 1054:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        mov    eax, point;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax];
	__asm        shl    edx, 0xA;
	__asm        mov    eax, G_omap[0][0][edx+ecx*4];
	__asm        mov    pCell, eax;
// LINE 1055:
	__asm        cmp    pCell, 0;
	__asm        jne    _T4e;

	_assert(0x41f, 0x5b539c, 0x5b53c0);
	__asm        jmp    _T53;
_T4e:
	__asm        jmp    _T53;
// LINE 1057:
_T53:
	__asm        cmp    pCell, 0;
	__asm        je     _Tcd;
// LINE 1059:
// Block start:
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST **dyptrptr;
	dyptrptr = (pCell + 0x10);
// LINE 1061:
__WHILE_66:
	while ((dyptrptr-> != 0x0)) {
		// LINE 1064:
			__asm        mov    eax, this;
			__asm        add    eax, 0xC;
			__asm        mov    ecx, dyptrptr;
			__asm        cmp    eax, [ecx];
			__asm        jne    _T93;
		// LINE 1067:
			dyptrptr-> = this->autoDynomitor.next;
		// LINE 1068:
			return;
		// LINE 1070:
		_T93:
			dyptrptr = dyptrptr->;
	}
// LINE 1073:
_Ta0:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _Tc8;

	_assert(0x431, 0x5b53c8, 0x5b53ec);
	__asm        jmp    _Tcd;
_Tc8:
	__asm        jmp    _Tcd;
// LINE 1075:
// Block end:
_Tcd:
	return;
}

// FUNCTION: COPTER_D 0x00502b74
void AutomobileClass::LinkToCell(const /*packed*/ struct _GridCoordinates& point) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *pCell;

// LINE 1086:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        mov    eax, point;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax];
	__asm        shl    edx, 0xA;
	__asm        mov    eax, G_omap[0][0][edx+ecx*4];
	__asm        mov    pCell, eax;
// LINE 1087:
	__asm        cmp    pCell, 0;
	__asm        jne    _T4e;

	_assert(0x43f, 0x5b53f8, 0x5b541c);
	__asm        jmp    _T53;
_T4e:
	__asm        jmp    _T53;
// LINE 1089:
_T53:
	__asm        cmp    pCell, 0;
	__asm        je     _T112;
// LINE 1091:
// Block start:
	/*bp-0x8*/   int32_t x;
	/*bp-0xc*/   int32_t z;
	this->autoDynomitor.next = pCell->dyptr;
// LINE 1092:
	pCell->dyptr = (this + 0xc);
// LINE 1096:
	__asm        mov    eax, pCell;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    x, eax;
// LINE 1097:
	__asm        mov    eax, pCell;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    z, eax;
// LINE 1099:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _Td5;
// LINE 1101:
_Ta0:
	z -= 0x200000;
	__asm        jmp    _Tf9;
// LINE 1102:
_Tac:
	z += 0x200000;
	__asm        jmp    _Tf9;
// LINE 1103:
_Tb8:
	x += 0x200000;
	__asm        jmp    _Tf9;
// LINE 1104:
_Tc4:
	x -= 0x200000;
	__asm        jmp    _Tf9;
// LINE 1105:
	__asm        jmp    _Tf9;
_Td5:
	__asm        cmp    dword ptr [ebp-0x14], 3;
	__asm        ja     _Tf9;

	__asm        mov    eax, [ebp-0x14];
	__asm        jmp    _Switch_e9[0][eax*4];
// Switch pointers:
//   _Ta0
//   _Tc4
//   _Tac
//   _Tb8
// LINE 1107:
_Tf9:
	this->m_cellBaseY = S3ObjectPrecisionAlt(z, x);
// LINE 1109:
// Block end:
_T112:
	return;
}

// FUNCTION: COPTER_D 0x00502c92
enum TurnIndex AutomobileClass::PickTurnDir(/*packed*/ struct Goal *pGoal) {
	/*bp-0x4*/   enum TurnIndex turn;
	/*bp-0x8*/   int32_t rightleftorstraight;
	/*bp-0xc*/   int32_t possibleTurnDir;

// LINE 1152:
	__asm        mov    eax, pGoal;
	__asm        mov    eax, [eax+0x12];
	__asm        sub    eax, 2;
	__asm        and    eax, 3;
	__asm        mov    eax, IndexToType[0][eax*4];
	__asm        not    eax;
	__asm        mov    ecx, pGoal;
	__asm        and    eax, [ecx+0x1A];
	__asm        mov    possibleTurnDir, eax;
// LINE 1157:
	__asm        mov    eax, pGoal;
	__asm        mov    eax, [eax+0x1E];
	__asm        not    eax;
	__asm        test   possibleTurnDir, eax;
	__asm        je     _T60;
// LINE 1159:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T60;
// LINE 1160:
	__asm        mov    eax, pGoal;
	__asm        mov    eax, [eax+0x1E];
	__asm        not    eax;
	__asm        and    possibleTurnDir, eax;
// LINE 1165:
_T60:
	rightleftorstraight = 0x0;
// LINE 1166:
	__asm        mov    eax, pGoal;
	__asm        mov    eax, [eax+0x12];
	__asm        mov    eax, IndexToType[0][eax*4];
	__asm        test   possibleTurnDir, eax;
	__asm        je     _T81;

	__asm        or     rightleftorstraight, 4;
// LINE 1167:
_T81:
	__asm        mov    eax, pGoal;
	__asm        mov    eax, [eax+0x12];
	__asm        mov    eax, TurnTable2[1][0][eax*4];
	__asm        mov    eax, IndexToType[0][eax*4];
	__asm        test   possibleTurnDir, eax;
	__asm        je     _Ta2;

	__asm        or     rightleftorstraight, 2;
// LINE 1168:
_Ta2:
	__asm        mov    eax, pGoal;
	__asm        mov    eax, [eax+0x12];
	__asm        mov    eax, TurnTable2[2][0][eax*4];
	__asm        mov    eax, IndexToType[0][eax*4];
	__asm        test   possibleTurnDir, eax;
	__asm        je     _Tc3;

	__asm        or     rightleftorstraight, 1;
// LINE 1172:
_Tc3:
	__asm        mov    eax, rightleftorstraight;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T23d;
// LINE 1175:
_Tce:
	turn = 0x2;
	__asm        jmp    _T270;
// LINE 1177:
_Tda:
	turn = 0x1;
	__asm        jmp    _T270;
// LINE 1179:
_Te6:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T102;

	turn = 0x1;
	__asm        jmp    _T109;
_T102:
	turn = 0x2;
_T109:
	__asm        jmp    _T270;
// LINE 1181:
_T10e:
	turn = 0x0;
	__asm        jmp    _T270;
// LINE 1183:
_T11a:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T153;
_T136:
	turn = 0x2;
	__asm        jmp    _T162;
_T142:
	turn = 0x0;
	__asm        jmp    _T162;

	__asm        jmp    _T162;
_T153:
	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        je     _T136;

	__asm        jmp    _T142;
_T162:
	__asm        jmp    _T270;
// LINE 1185:
_T167:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T1a0;
_T183:
	turn = 0x1;
	__asm        jmp    _T1af;
_T18f:
	turn = 0x0;
	__asm        jmp    _T1af;

	__asm        jmp    _T1af;
_T1a0:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T183;

	__asm        jmp    _T18f;
_T1af:
	__asm        jmp    _T270;
// LINE 1187:
_T1b4:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 7;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T1f9;
// LINE 1188:
_T1d0:
	turn = 0x1;
	__asm        jmp    _T212;
_T1dc:
	turn = 0x2;
	__asm        jmp    _T212;
_T1e8:
	turn = 0x0;
	__asm        jmp    _T212;

	__asm        jmp    _T212;
_T1f9:
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        je     _T1d0;

	__asm        cmp    dword ptr [ebp-0x20], 1;
	__asm        je     _T1dc;

	__asm        jmp    _T1e8;
_T212:
	__asm        jmp    _T270;
// LINE 1190:
_T217:
	_assert(0x4a6, 0x5b5424, 0x5b5448);
	__asm        jmp    _T238;

	__asm        jmp    _T238;
// LINE 1191:
_T238:
	__asm        jmp    _T270;
_T23d:
	__asm        dec    dword ptr [ebp-0x14];
	__asm        cmp    dword ptr [ebp-0x14], 6;
	__asm        ja     _T217;

	__asm        mov    eax, [ebp-0x14];
	__asm        jmp    _Switch_254[0][eax*4];
// Switch pointers:
//   _Tce
//   _Tda
//   _Te6
//   _T10e
//   _T11a
//   _T167
//   _T1b4
// LINE 1193:
_T270:
	return turn;
// LINE 1194:
}

// FUNCTION: COPTER_D 0x00502f11
void AutomobileClass::BeamToWithinCameraRange() {
	/*bp-0x4*/   /*packed*/ struct _GridCoordinates beamCell;
	/*bp-0x10*/  /*packed*/ struct Point3d vec; // 0xc bytes

// LINE 1209:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x14;
	__asm        lea    ecx, vec.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1211:
	this->beamTimer = 0x0;
// LINE 1214:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0xF;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T12d;
// LINE 1218:
_T50:
	vec.y = vec.z;
// LINE 1219:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 1220:
	vec.x = vec.y;
// LINE 1222:
	vec.x = (vec.x * (G_ViewSize >> 0x1));
// LINE 1223:
	vec.z = (vec.z * (G_ViewSize >> 0x1));
// LINE 1224:
	__asm        jmp    _T150;
// LINE 1227:
_T8d:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    vec.y, eax;
// LINE 1228:
	vec.z = vec.x;
// LINE 1229:
	vec.x = vec.y;
// LINE 1231:
	vec.x = (vec.x * (G_ViewSize >> 0x1));
// LINE 1232:
	vec.z = (vec.z * (G_ViewSize >> 0x1));
// LINE 1233:
	__asm        jmp    _T150;
// LINE 1236:
_Tca:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    vec.x, eax;
// LINE 1237:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 1239:
	vec.x = (vec.x * (G_ViewSize >> 0x1));
// LINE 1240:
	vec.z = (vec.z * (G_ViewSize >> 0x1));
// LINE 1241:
	__asm        jmp    _T150;
// LINE 1245:
_T103:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        inc    eax;
	__asm        imul   eax, vec.x;
	__asm        mov    vec.x, eax;
// LINE 1246:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        inc    eax;
	__asm        imul   eax, vec.z;
	__asm        mov    vec.z, eax;
// LINE 1247:
	__asm        jmp    _T150;
// LINE 1248:
	__asm        jmp    _T150;
_T12d:
	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        je     _T50;

	__asm        cmp    dword ptr [ebp-0x18], 1;
	__asm        je     _T8d;

	__asm        cmp    dword ptr [ebp-0x18], 2;
	__asm        je     _Tca;

	__asm        jmp    _T103;
// LINE 1256:
_T150:
	__asm        mov    eax, vec.x;
	__asm        shl    eax, 6;
	__asm        add    eax, ViewState.world_pos.x;
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    beamCell.x, al;
// LINE 1257:
	__asm        mov    eax, 0x20000000;
	__asm        sub    eax, ViewState.world_pos.z;
	__asm        mov    ecx, vec.z;
	__asm        shl    ecx, 6;
	__asm        add    eax, ecx;
	__asm        sar    eax, 0x16;
	__asm        mov    beamCell.y, al;
// LINE 1261:
	__asm        lea    eax, beamCell.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x20];
// LINE 1262:
	return;
}

// FUNCTION: COPTER_D 0x005030aa
int32_t AutomobileClass::BeamToLocation(const /*packed*/ struct _GridCoordinates& cell) {
	/*bp-0x2c*/  /*packed*/ struct Goal goal1; // 0x2a bytes
	/*bp-0x3c*/  /*packed*/ class SpiralScan scan; // 0x10 bytes
	/*bp-0x68*/  /*packed*/ struct Goal goal2; // 0x2a bytes
	/*bp-0x6c*/  int32_t hiway;
	/*bp-0x70*/  /*packed*/ struct _GridCoordinates scanLoc;
	/*bp-0x74*/  /*packed*/ struct _GridCoordinates prevGridLoc;
	/*bp-0x78*/  int32_t foundcell;
	/*bp-0x7c*/  unsigned short tile;

// LINE 1284:
	__asm        mov    eax, cell;
	__asm        mov    ax, [eax];
	__asm        mov    reinterpret_cast<uint16_t>(scanLoc.x), ax;
// LINE 1285:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x7C];
	__asm        mov    reinterpret_cast<uint16_t>(prevGridLoc.x), ax;
// LINE 1289:
	__asm        push   9;
	__asm        lea    ecx, scan.currDist;
	__asm        call   SpiralScan::SpiralScan;
// LINE 1290:
	foundcell = 0x0;
// LINE 1291:
	hiway = 0x0;
// LINE 1298:
__DO_42:
	do {
		// LINE 1298:
		__DO_42:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        test   eax, eax;
			__asm        jl     _T7c;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        test   eax, eax;
			__asm        jl     _T7c;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        cmp    eax, 0x80;
			__asm        jge    _T7c;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        cmp    eax, 0x80;
			__asm        jl     _T87;
		_T7c:
			tile = 0x0;
			__asm        jmp    _Tc7;
		_T87:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        mov    eax, BitsMap[eax*4];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, scanLoc.y;
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+ecx];
			__asm        and    edx, 2;
			__asm        movsx  eax, dx;
			__asm        shl    eax, 0xE;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, scanLoc.x;
			__asm        mov    ecx, BuildMap[ecx*4];
			__asm        xor    edx, edx;
			__asm        mov    dl, scanLoc.y;
			__asm        xor    ebx, ebx;
			__asm        mov    bl, [ecx+edx];
			__asm        or     eax, ebx;
			__asm        mov    tile, ax;
			__asm        jmp    _Tc7;
		// LINE 1300:
		_Tc7:
			__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
			__asm        and    eax, 0xFFFF;
			__asm        mov    [ebp-0x10C], eax;
			__asm        jmp    _Tee;

			__asm        jmp    _T159;

			__asm        jmp    _T282;

			__asm        jmp    _T159;

			__asm        jmp    _T14c;
		_Tee:
			__asm        cmp    dword ptr [ebp-0x10C], 0x6B;
			__asm        jg     _T127;

			__asm        cmp    dword ptr [ebp-0x10C], 0x61;
			__asm        jge    _T159;

			__asm        cmp    dword ptr [ebp-0x10C], 0x49;
			__asm        jl     _T282;

			__asm        cmp    dword ptr [ebp-0x10C], 0x50;
			__asm        jle    _T159;

			__asm        jmp    _T282;
		_T127:
			__asm        cmp    dword ptr [ebp-0x10C], 0x806A;
			__asm        jl     _T282;

			__asm        cmp    dword ptr [ebp-0x10C], 0x806B;
			__asm        jle    _T159;

			__asm        jmp    _T282;
		_T14c:
			__asm        cmp    dword ptr [ebp-0xF8], 0;
			__asm        je     _T282;
		// LINE 1304:
		_T159:
			__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
			__asm        and    eax, 0xFFFF;
			__asm        mov    [ebp-0x110], eax;
			__asm        jmp    _T180;

			__asm        jmp    _T1ac;

			__asm        jmp    _T27d;

			__asm        jmp    _T1ac;

			__asm        jmp    _T19f;
		_T180:
			__asm        cmp    dword ptr [ebp-0x110], 0x49;
			__asm        jl     _T27d;

			__asm        cmp    dword ptr [ebp-0x110], 0x50;
			__asm        jle    _T1ac;

			__asm        jmp    _T27d;
		_T19f:
			__asm        cmp    dword ptr [ebp-0xE0], 0;
			__asm        je     _T27d;
		_T1ac:
			__asm        mov    ecx, this;
			__asm        call   AutomobileClass::IsThisAnEmergencyVehicle;
			__asm        test   eax, eax;
			__asm        jne    _T27d;

			__asm        mov    ecx, this;
			__asm        call   AutomobileClass::AmIABadGuy;
			__asm        test   eax, eax;
			__asm        jne    _T27d;
		// LINE 1305:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        mov    [ebp-0xF0], eax;
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        mov    [ebp-0xF4], eax;
		// LINE 1306:
			__asm        mov    eax, [ebp-0xF0];
			__asm        and    eax, 0xFF;
			__asm        mov    ecx, [ebp-0xF4];
			__asm        and    ecx, 0xFF;
			__asm        shl    ecx, 0xA;
			__asm        mov    eax, G_omap[0][0][ecx+eax*4];
			__asm        mov    [ebp-0xEC], eax;
			__asm        cmp    dword ptr [ebp-0xEC], 0;
			__asm        jne    _T238;

			_assert(0xa0, 0x5b57c4, 0x5b57b8);
			__asm        jmp    _T23d;
		_T238:
			__asm        jmp    _T23d;
		_T23d:
			__asm        jmp    _T242;
		_T242:
			__asm        mov    eax, [ebp-0xEC];
			__asm        mov    ecx, this;
			__asm        mov    [ecx+0x112], eax;
		// LINE 1310:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+0x112];
			__asm        cmp    dword ptr [eax+0x10], 0;
			__asm        jne    _T27d;
		// LINE 1312:
			foundcell = 0x1;
		// LINE 1313:
			hiway = 0x1;
		// LINE 1314:
			__asm        jmp    _T4be;
		// LINE 1318:
		_T27d:
			__asm        jmp    _T4a0;
		_T282:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        test   eax, eax;
			__asm        jl     _T2bc;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        test   eax, eax;
			__asm        jl     _T2bc;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        cmp    eax, 0x80;
			__asm        jge    _T2bc;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        cmp    eax, 0x80;
			__asm        jl     _T2ca;
		_T2bc:
			__asm        mov    word ptr [ebp-0xDC], 0;
			__asm        jmp    _T30d;
		_T2ca:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        mov    eax, BitsMap[eax*4];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, scanLoc.y;
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+ecx];
			__asm        and    edx, 2;
			__asm        movsx  eax, dx;
			__asm        shl    eax, 0xE;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, scanLoc.x;
			__asm        mov    ecx, BuildMap[ecx*4];
			__asm        xor    edx, edx;
			__asm        mov    dl, scanLoc.y;
			__asm        xor    ebx, ebx;
			__asm        mov    bl, [ecx+edx];
			__asm        or     eax, ebx;
			__asm        mov    [ebp-0xDC], ax;
			__asm        jmp    _T30d;
		_T30d:
			__asm        mov    ax, [ebp-0xDC];
			__asm        mov    [ebp-0xE4], ax;
			__asm        mov    eax, [ebp-0xE4];
			__asm        and    eax, 0xFF;
			__asm        mov    [ebp-0xE4], ax;
			__asm        mov    eax, [ebp-0xE4];
			__asm        and    eax, 0xFFFF;
			__asm        cmp    eax, 0x1D;
			__asm        jl     _T387;

			__asm        mov    eax, [ebp-0xE4];
			__asm        and    eax, 0xFFFF;
			__asm        cmp    eax, 0x2C;
			__asm        jge    _T387;

			__asm        mov    eax, [ebp-0xE4];
			__asm        and    eax, 0xFFFF;
			__asm        cmp    eax, 0x1F;
			__asm        jl     _T37d;

			__asm        mov    eax, [ebp-0xE4];
			__asm        and    eax, 0xFFFF;
			__asm        cmp    eax, 0x26;
			__asm        jle    _T387;
		_T37d:
			__asm        jmp    _T39e;

			__asm        jmp    _T391;
		_T387:
			__asm        jmp    _T4a0;

			__asm        jmp    _T39e;
		_T391:
			__asm        cmp    dword ptr [ebp-0xE8], 0;
			__asm        je     _T4a0;
		// LINE 1322:
		_T39e:
			__asm        lea    eax, goal2.pRGV;
			__asm        push   eax;
			__asm        lea    eax, goal1.pRGV;
			__asm        push   eax;
			__asm        mov    eax, reinterpret_cast<uint32_t>(scanLoc.x);
			__asm        push   eax;
			__asm        mov    eax, reinterpret_cast<uint32_t>(scanLoc.x);
			__asm        push   eax;
			__asm        lea    eax, [ebp-0xB4];
			__asm        push   eax;
			__asm        mov    ecx, 0x5C3828;
			__asm        call   RoadGraph::FindIntersections;
		// LINE 1325:
			__asm        cmp    goal1.pRGV, 0;
			__asm        jne    _T3e3;
		// LINE 1326:
			__asm        lea    esi, goal2.pRGV;
			__asm        mov    edi, this;
			__asm        add    edi, 0x70;
			__asm        mov    ecx, 0xA;
			__asm        rep movsd;
			__asm        movsw;
		// LINE 1327:
			__asm        jmp    _T3f8;
		// LINE 1328:
		_T3e3:
			__asm        lea    esi, goal1.pRGV;
			__asm        mov    edi, this;
			__asm        add    edi, 0x70;
			__asm        mov    ecx, 0xA;
			__asm        rep movsd;
			__asm        movsw;
		// LINE 1332:
		_T3f8:
			__asm        mov    eax, this;
			__asm        cmp    dword ptr [eax+0x70], 0;
			__asm        je     _T4a0;

			__asm        mov    eax, this;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+0x7D];
			__asm        mov    [ebp-0xD0], ecx;
			__asm        mov    eax, this;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+0x7C];
			__asm        mov    [ebp-0xD4], ecx;
			__asm        mov    eax, [ebp-0xD0];
			__asm        and    eax, 0xFF;
			__asm        mov    ecx, [ebp-0xD4];
			__asm        and    ecx, 0xFF;
			__asm        shl    ecx, 0xA;
			__asm        mov    eax, G_omap[0][0][ecx+eax*4];
			__asm        mov    [ebp-0xCC], eax;
			__asm        cmp    dword ptr [ebp-0xCC], 0;
			__asm        jne    _T47a;

			_assert(0xa0, 0x5b57c4, 0x5b57b8);
			__asm        jmp    _T47f;
		_T47a:
			__asm        jmp    _T47f;
		_T47f:
			__asm        jmp    _T484;
		_T484:
			__asm        mov    eax, [ebp-0xCC];
			__asm        cmp    dword ptr [eax+0x10], 0;
			__asm        jne    _T4a0;
		// LINE 1334:
			foundcell = 0x1;
		// LINE 1335:
			__asm        jmp    _T4be;
		// LINE 1339:
		_T4a0:
			__asm        lea    eax, scanLoc.x;
			__asm        push   eax;
			__asm        lea    ecx, scan.currDist;
			__asm        call   SpiralScan::Next;
			__asm        test   eax, eax;
			__asm        je     _T4be;
	} while ((foundcell == 0x0));
// LINE 1342:
_T4be:
	__asm        cmp    foundcell, 0;
	__asm        jne    _T4ec;
// LINE 1344:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFFFD;
// LINE 1345:
	__asm        mov    dword ptr [ebp-0xB8], 0;
	__asm        jmp    _T4e1;
_T4e1:
	__asm        mov    eax, [ebp-0xB8];
	__asm        jmp    __RETURN;
// LINE 1477:
_T4ec:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T50b;
// LINE 1479:
	__asm        lea    eax, prevGridLoc.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::UnlinkFromCell;
// LINE 1483:
_T50b:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 1;
	__asm        jne    _T537;

	_assert(0x5cb, 0x5b5450, 0x5b5474);
	__asm        jmp    _T53c;
_T537:
	__asm        jmp    _T53c;
// LINE 1484:
_T53c:
	this->flags = 0x3;
// LINE 1487:
	__asm        cmp    hiway, 0;
	__asm        je     _T6f9;
// LINE 1491:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x802;
// LINE 1493:
	this->stalledTimer = 0x0;
// LINE 1494:
	this->hiwaydir = 0x0;
// LINE 1496:
	__asm        mov    al, scanLoc.x;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD2], al;
// LINE 1497:
	__asm        mov    al, scanLoc.y;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD3], al;
// LINE 1501:
	__asm        mov    eax, this;
	__asm        add    eax, 0xD2;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 1505:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        test   ecx, ecx;
	__asm        jl     _T615;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        test   ecx, ecx;
	__asm        jl     _T615;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T615;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T623;
_T615:
	__asm        mov    word ptr [ebp-0xFC], 0;
	__asm        jmp    _T68a;
_T623:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD3];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD2];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD3];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    [ebp-0xFC], ax;
	__asm        jmp    _T68a;
_T68a:
	__asm        mov    eax, [ebp-0xFC];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::SetHiwayDirection;
// LINE 1506:
	this->AutomobileClass::AdjustCurrentHiwayPosition();
// LINE 1507:
	this->AutomobileClass::AdjustNextHiwayPosition();
// LINE 1508:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 1509:
	this->pDirVector = (this + 0xa2);
// LINE 1510:
	__asm        mov    dword ptr [ebp-0xBC], 1;
	__asm        jmp    _T6e9;
_T6e9:
	__asm        mov    eax, [ebp-0xBC];
	__asm        jmp    __RETURN;
// LINE 1512:
	__asm        jmp    _Tdb8;
// LINE 1515:
// Block start:
	/*bp-0x80*/  /*packed*/ struct _GridCoordinates nextLoc;
	/*bp-0x84*/  int32_t dirIndex;
	/*bp-0x88*/  int32_t i;
_T6f9:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.x;
	__asm        cmp    ecx, eax;
	__asm        jne    _T729;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.y;
	__asm        cmp    ecx, eax;
	__asm        je     _T745;
_T729:
	_assert(0x5eb, 0x5b5490, 0x5b54b4);
	__asm        jmp    _T74a;
_T745:
	__asm        jmp    _T74a;
// LINE 1518:
_T74a:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    dirIndex, eax;
// LINE 1525:
_FOR_773:
	for (i = 0x0; (i < 0x4); i++) {
		// LINE 1527:
			__asm        mov    eax, dirIndex;
			__asm        inc    eax;
			__asm        and    eax, 3;
			__asm        mov    dirIndex, eax;
		// LINE 1528:
			__asm        mov    eax, dirIndex;
			__asm        mov    [ebp-0x114], eax;
			__asm        jmp    _T7fc;
		// LINE 1530:
		_T7a7:
			__asm        mov    al, scanLoc.x;
			__asm        mov    nextLoc.x, al;
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        dec    eax;
			__asm        mov    nextLoc.y, al;
			__asm        jmp    _T826;
		// LINE 1531:
		_T7bb:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        inc    eax;
			__asm        mov    nextLoc.x, al;
			__asm        mov    al, scanLoc.y;
			__asm        mov    nextLoc.y, al;
			__asm        jmp    _T826;
		// LINE 1532:
		_T7cf:
			__asm        mov    al, scanLoc.x;
			__asm        mov    nextLoc.x, al;
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        inc    eax;
			__asm        mov    nextLoc.y, al;
			__asm        jmp    _T826;
		// LINE 1533:
		_T7e3:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        dec    eax;
			__asm        mov    nextLoc.x, al;
			__asm        mov    al, scanLoc.y;
			__asm        mov    nextLoc.y, al;
			__asm        jmp    _T826;
		// LINE 1534:
			__asm        jmp    _T826;
		_T7fc:
			__asm        cmp    dword ptr [ebp-0x114], 3;
			__asm        ja     _T826;

			__asm        mov    eax, [ebp-0x114];
			__asm        jmp    _Switch_816[0][eax*4];
		// Switch pointers:
		//   _T7a7
		//   _T7bb
		//   _T7cf
		//   _T7e3
		// LINE 1539:
		_T826:
			__asm        xor    eax, eax;
			__asm        mov    al, nextLoc.x;
			__asm        test   eax, eax;
			__asm        jl     _T860;

			__asm        xor    eax, eax;
			__asm        mov    al, nextLoc.y;
			__asm        test   eax, eax;
			__asm        jl     _T860;

			__asm        xor    eax, eax;
			__asm        mov    al, nextLoc.x;
			__asm        cmp    eax, 0x80;
			__asm        jge    _T860;

			__asm        xor    eax, eax;
			__asm        mov    al, nextLoc.y;
			__asm        cmp    eax, 0x80;
			__asm        jl     _T86e;
		_T860:
			__asm        mov    word ptr [ebp-0x100], 0;
			__asm        jmp    _T8b1;
		_T86e:
			__asm        xor    eax, eax;
			__asm        mov    al, nextLoc.x;
			__asm        mov    eax, BitsMap[eax*4];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, nextLoc.y;
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+ecx];
			__asm        and    edx, 2;
			__asm        movsx  eax, dx;
			__asm        shl    eax, 0xE;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, nextLoc.x;
			__asm        mov    ecx, BuildMap[ecx*4];
			__asm        xor    edx, edx;
			__asm        mov    dl, nextLoc.y;
			__asm        xor    ebx, ebx;
			__asm        mov    bl, [ecx+edx];
			__asm        or     eax, ebx;
			__asm        mov    [ebp-0x100], ax;
			__asm        jmp    _T8b1;
		_T8b1:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        test   eax, eax;
			__asm        jl     _T8eb;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        test   eax, eax;
			__asm        jl     _T8eb;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        cmp    eax, 0x80;
			__asm        jge    _T8eb;

			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.y;
			__asm        cmp    eax, 0x80;
			__asm        jl     _T8f9;
		_T8eb:
			__asm        mov    word ptr [ebp-0x104], 0;
			__asm        jmp    _T93c;
		_T8f9:
			__asm        xor    eax, eax;
			__asm        mov    al, scanLoc.x;
			__asm        mov    eax, BitsMap[eax*4];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, scanLoc.y;
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+ecx];
			__asm        and    edx, 2;
			__asm        movsx  eax, dx;
			__asm        shl    eax, 0xE;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, scanLoc.x;
			__asm        mov    ecx, BuildMap[ecx*4];
			__asm        xor    edx, edx;
			__asm        mov    dl, scanLoc.y;
			__asm        xor    ebx, ebx;
			__asm        mov    bl, [ecx+edx];
			__asm        or     eax, ebx;
			__asm        mov    [ebp-0x104], ax;
			__asm        jmp    _T93c;
		_T93c:
			__asm        mov    eax, 1;
			__asm        mov    cl, reinterpret_cast<uint8_t>(dirIndex);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        mov    eax, 1;
			__asm        mov    cl, reinterpret_cast<uint8_t>(dirIndex);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        mov    eax, [ebp-0x100];
			__asm        push   eax;
			__asm        mov    eax, [ebp-0x104];
			__asm        push   eax;
			__asm        call   DoRoadTilesConnect;
			__asm        add    esp, 0x10;
			__asm        test   eax, eax;
			__asm        je     _T999;
		// LINE 1546:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+0x82];
			__asm        sub    eax, 2;
			__asm        and    eax, 3;
			__asm        cmp    eax, dirIndex;
			__asm        je     _T999;
		// LINE 1553:
			__asm        jmp    _T99e;
		// LINE 1556:
		_T999:
	}
// LINE 1558:
_T99e:
	__asm        cmp    i, 4;
	__asm        jl     _T9c5;
// LINE 1559:
	__asm        mov    dword ptr [ebp-0xC0], 0;
	__asm        jmp    _T9ba;
_T9ba:
	__asm        mov    eax, [ebp-0xC0];
	__asm        jmp    __RETURN;
// LINE 1567:
_T9c5:
	this->prevDir = dirIndex;
// LINE 1570:
	this->legOfTurn = 0x0;
// LINE 1572:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7E], 0xFFFFFFFE;
	__asm        jne    _Tb35;
// LINE 1574:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    dirIndex, eax;
// LINE 1575:
_FOR_a20:
	for (i = 0x0; (i < 0x4); i++) {
		// LINE 1577:
			__asm        mov    eax, dirIndex;
			__asm        inc    eax;
			__asm        and    eax, 3;
			__asm        mov    dirIndex, eax;
		// LINE 1578:
			__asm        mov    eax, this;
			__asm        mov    edx, 1;
			__asm        mov    cl, reinterpret_cast<uint8_t>(dirIndex);
			__asm        shl    edx, cl;
			__asm        test   [eax+0x8A], edx;
			__asm        je     _Ta67;
		// LINE 1579:
			__asm        jmp    _Ta6c;
		// LINE 1580:
		_Ta67:
	}
// LINE 1581:
_Ta6c:
	__asm        cmp    i, 4;
	__asm        jl     _Ta95;

	_assert(0x62d, 0x5b54f0, 0x5b5514);
	__asm        jmp    _Ta9a;
_Ta95:
	__asm        jmp    _Ta9a;
// LINE 1582:
_Ta9a:
	this->goal.edgeIndex = dirIndex;
	this->goal.direction = this->goal.edgeIndex;
// LINE 1583:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7E];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TILUT[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 1584:
	this->goal.slope = 0x1;
// LINE 1585:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xEE];
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        shl    ecx, 3;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        mov    eax, DTT[0][0][1][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 1593:
	__asm        jmp    _Tbf3;
// LINE 1595:
_Tb35:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TILUT[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 1596:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        shl    ecx, 2;
	__asm        lea    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        shl    ecx, 3;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        mov    eax, DTT[0][0][eax+ecx];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 1597:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x96], 0;
	__asm        jl     _Tbd2;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x96], 2;
	__asm        jle    _Tbee;
_Tbd2:
	_assert(0x63d, 0x5b5518, 0x5b553c);
	__asm        jmp    _Tbf3;
_Tbee:
	__asm        jmp    _Tbf3;
// LINE 1607:
_Tbf3:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE2];
	__asm        sub    eax, 2;
	__asm        and    eax, 3;
	__asm        mov    [ebp-0x118], eax;
	__asm        jmp    _Tc65;
// LINE 1609:
_Tc10:
	__asm        mov    al, scanLoc.x;
	__asm        mov    nextLoc.x, al;
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.y;
	__asm        dec    eax;
	__asm        mov    nextLoc.y, al;
	__asm        jmp    _Tc8f;
// LINE 1610:
_Tc24:
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.x;
	__asm        inc    eax;
	__asm        mov    nextLoc.x, al;
	__asm        mov    al, scanLoc.y;
	__asm        mov    nextLoc.y, al;
	__asm        jmp    _Tc8f;
// LINE 1611:
_Tc38:
	__asm        mov    al, scanLoc.x;
	__asm        mov    nextLoc.x, al;
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.y;
	__asm        inc    eax;
	__asm        mov    nextLoc.y, al;
	__asm        jmp    _Tc8f;
// LINE 1612:
_Tc4c:
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.x;
	__asm        dec    eax;
	__asm        mov    nextLoc.x, al;
	__asm        mov    al, scanLoc.y;
	__asm        mov    nextLoc.y, al;
	__asm        jmp    _Tc8f;
// LINE 1613:
	__asm        jmp    _Tc8f;
_Tc65:
	__asm        cmp    dword ptr [ebp-0x118], 3;
	__asm        ja     _Tc8f;

	__asm        mov    eax, [ebp-0x118];
	__asm        jmp    _Switch_c7f[0][eax*4];
// Switch pointers:
//   _Tc10
//   _Tc24
//   _Tc38
//   _Tc4c
// LINE 1615:
_Tc8f:
	__asm        xor    eax, eax;
	__asm        mov    al, nextLoc.x;
	__asm        shl    eax, 0xA;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, nextLoc.y;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    [ebp-0xD8], eax;
	__asm        cmp    dword ptr [ebp-0xD8], 0;
	__asm        jne    _Tcd2;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _Tcd7;
_Tcd2:
	__asm        jmp    _Tcd7;
_Tcd7:
	__asm        jmp    _Tcdc;
_Tcdc:
	__asm        mov    eax, [ebp-0xD8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 1618:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _Td28;
// LINE 1621:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFFFD;
// LINE 1622:
	__asm        mov    dword ptr [ebp-0xC4], 0;
	__asm        jmp    _Td1d;
_Td1d:
	__asm        mov    eax, [ebp-0xC4];
	__asm        jmp    __RETURN;
// LINE 1624:
_Td28:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 1632:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::MoveAuto;
// LINE 1635:
	this->AutomobileClass::DoDiagonalRoadFixup();
// LINE 1638:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 1640:
	this->currDist = 0x0;
// LINE 1641:
	this->stalledTimer = 0x0;
// LINE 1642:
	this->beamTimer = this->beamDelay;
// LINE 1644:
	__asm        mov    dword ptr [ebp-0xC8], 1;
	__asm        jmp    _Tdad;
_Tdad:
	__asm        mov    eax, [ebp-0xC8];
	__asm        jmp    __RETURN;
// LINE 1646:
// Block end:
_Tdb8:
	__asm        jmp    __RETURN;
__RETURN:
}

// FUNCTION: COPTER_D 0x00503e6e
void AutomobileClass::UnPlaceCar() {
// LINE 1662:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFEFF;
// LINE 1663:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFDFF;
// LINE 1666:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T66;
// LINE 1668:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 8;
	__asm        je     _T50;
// LINE 1669:
	__asm        mov    eax, this;
	__asm        add    eax, 0xD2;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::UnlinkFromCell;
// LINE 1670:
	__asm        jmp    _T5f;
// LINE 1671:
_T50:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::UnlinkFromCell;
// LINE 1672:
_T5f:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFFFD;
// LINE 1674:
_T66:
	return;
}

// FUNCTION: COPTER_D 0x00503ede
void AutomobileClass::WaterDouse(/*packed*/ struct _DYOBJ_INST *dyhittee) {
	/*bp-0x18*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 1690:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 3;
	__asm        jne    _T1e;
// LINE 1691:
	return;
// LINE 1693:
_T1e:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 1;
	__asm        je     _T82;
// LINE 1695:
	this->AutomobileClass::UnPlaceCar();
// LINE 1697:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFEFF;
// LINE 1698:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x18];
	__asm        and    eax, 0xFFFFEFFF;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x18], ax;
// LINE 1701:
	mp.op = 0x1a;
// LINE 1702:
	mp.id = this->missionId;
// LINE 1703:
	mp.i2num = 0x1;
// LINE 1704:
	mp.flags = 0x0;
// LINE 1705:
	S3MissionUpdate(mp.op);
// LINE 1707:
	__asm        jmp    _Td3;
_T82:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 2;
	__asm        je     _Td3;
// LINE 1709:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFDFF;
// LINE 1710:
	this->stalledTimer = 0x0;
// LINE 1713:
	mp.op = 0x1b;
// LINE 1714:
	mp.id = this->missionId;
// LINE 1715:
	mp.i2num = 0x1;
// LINE 1716:
	mp.flags = 0x0;
// LINE 1717:
	S3MissionUpdate(mp.op);
// LINE 1722:
_Td3:
	S3DSPlay(0x0, (this + 0x24), 0xf);
// LINE 1725:
	return;
}

// FUNCTION: COPTER_D 0x00503fd0
void AutomobileClass::IveBeenMegaphoned(long msg_id) {
	/*bp-0x18*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 1735:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        je     _T55;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        jle    _T55;

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIPullOver;
	__asm        test   eax, eax;
	__asm        je     _T55;

	__asm        cmp    msg_id, 0;
	__asm        jne    _T55;
// LINE 1737:
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 1738:
	return;
// LINE 1743:
_T55:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 2;
	__asm        jne    _T67;
// LINE 1744:
	return;
// LINE 1748:
_T67:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFDFF;
// LINE 1749:
	this->stalledTimer = 0x0;
// LINE 1752:
	mp.op = 0x1b;
// LINE 1753:
	mp.id = this->missionId;
// LINE 1754:
	mp.i2num = 0x1;
// LINE 1755:
	mp.flags = 0x0;
// LINE 1756:
	S3MissionUpdate(mp.op);
// LINE 1762:
	S3DSPlay(0x0, (this + 0x24), 0x8);
// LINE 1764:
	return;
}

// FUNCTION: COPTER_D 0x0050409a
void AutomobileClass::AdjustSpeed() {
// LINE 1773:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x92], 0;
	__asm        je     _T33;

	this->speed = this->desiredHiwaySpeed;
	__asm        jmp    _T45;
_T33:
	this->speed = this->desiredSpeed;
// LINE 1775:
_T45:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        je     _T72;
// LINE 1776:
	__asm        push   0x1C000;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDE], eax;
// LINE 1777:
_T72:
	return;
}

// FUNCTION: COPTER_D 0x00504116
void AutomobileClass::Reset() {
// LINE 1791:
	this->AutomobileClass::UnPlaceCar();
// LINE 1792:
	this->flags = 0x1;
// LINE 1794:
	return;
}

// FUNCTION: COPTER_D 0x0050413e
int32_t AutomobileClass::AmIABadGuy() {
// LINE 1799:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0x11E;
	__asm        je     _T29;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        je     _T33;
// LINE 1800:
_T29:
	return 0x1;
// LINE 1802:
_T33:
	return 0x0;
// LINE 1803:
}

// FUNCTION: COPTER_D 0x0050417d
void AutomobileClass::PullOverCiviliansInWay() {
	/*bp-0x4*/   /*packed*/ struct _DYOBJ_INST *currentObject;
	/*bp-0x14*/  /*packed*/ class SpiralScan spiral; // 0x10 bytes
	/*bp-0x18*/  /*packed*/ struct _GridCoordinates scanLoc;

// LINE 1808:
	__asm        push   1;
	__asm        lea    ecx, spiral.currDist;
	__asm        call   SpiralScan::SpiralScan;
// LINE 1810:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x7C];
	__asm        mov    reinterpret_cast<uint16_t>(scanLoc.x), ax;
// LINE 1815:
__DO_21:
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.y;
	__asm        mov    [ebp-0x24], eax;
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.x;
	__asm        mov    [ebp-0x28], eax;
// LINE 1816:
	__asm        mov    eax, [ebp-0x24];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x28];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x20], eax;
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        jne    _T75;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T7a;
_T75:
	__asm        jmp    _T7a;
_T7a:
	__asm        jmp    _T7f;
_T7f:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    currentObject, eax;
// LINE 1819:
__WHILE_88:
	while ((currentObject != 0x0)) {
		// LINE 1822:
		// Block start:
			/*bp-0x1c*/  /*packed*/ class AutomobileClass *pCar;
			__asm        mov    eax, this;
			__asm        add    eax, 0xC;
			__asm        cmp    eax, currentObject;
			__asm        jne    _Tae;
		// LINE 1824:
			currentObject = currentObject->next;
		// LINE 1825:
			__asm        jmp    __WHILE_88;
		// LINE 1829:
		_Tae:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    pCar, eax;
		// LINE 1831:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x10;
			__asm        je     _T18a;

			__asm        mov    ecx, pCar;
			__asm        call   AutomobileClass::CanIPullOver;
			__asm        test   eax, eax;
			__asm        je     _T18a;
		// LINE 1836:
			__asm        mov    eax, pCar;
			__asm        test   byte ptr [eax+9], 0x13;
			__asm        je     _Tf7;

			__asm        mov    dword ptr [ebp-0x2C], 1;
			__asm        jmp    _T14e;
		_Tf7:
			__asm        mov    eax, pCar;
			__asm        mov    eax, [eax+4];
			__asm        mov    [ebp-0x34], eax;
			__asm        jmp    _T116;
		_T105:
			__asm        mov    dword ptr [ebp-0x2C], 1;
			__asm        jmp    _T14e;

			__asm        jmp    _T142;
		_T116:
			__asm        cmp    dword ptr [ebp-0x34], 0x11C;
			__asm        jl     _T142;

			__asm        cmp    dword ptr [ebp-0x34], 0x11F;
			__asm        jle    _T105;

			__asm        cmp    dword ptr [ebp-0x34], 0x181;
			__asm        je     _T105;

			__asm        jmp    _T142;
		_T142:
			__asm        mov    dword ptr [ebp-0x2C], 0;
			__asm        jmp    _T14e;
		_T14e:
			__asm        cmp    dword ptr [ebp-0x2C], 0;
			__asm        je     _T178;

			__asm        mov    eax, pCar;
			__asm        cmp    dword ptr [eax+4], 0x11E;
			__asm        jne    _T18a;

			__asm        mov    eax, this;
			__asm        cmp    dword ptr [eax+4], 0x11D;
			__asm        jne    _T18a;
		// LINE 1837:
		_T178:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        push   eax;
			__asm        mov    eax, pCar;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, pCar;
			__asm        call   dword ptr [eax+4];
		// LINE 1840:
		_T18a:
			currentObject = currentObject->next;
	}
// LINE 1843:
__DO_WHILE_21:
	__asm        lea    eax, scanLoc.x;
	__asm        push   eax;
	__asm        lea    ecx, spiral.currDist;
	__asm        call   SpiralScan::Next;
	__asm        test   eax, eax;
	__asm        jne    __DO_21;
// LINE 1844:
	__asm        jmp    _T1b0;
_T1b0:
	return;
}

// FUNCTION: COPTER_D 0x00504337
int32_t AutomobileClass::InitializeInstance(int32_t instanceID) {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo objectInfo; // 0x24 bytes
	/*bp-0x28*/  int32_t object;

// LINE 1878:
	this->autoDynomitor.mesh = 0x0;
// LINE 1881:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    object, eax;
// LINE 1884:
	__asm        cmp    object, 0;
	__asm        jne    _T4e;

	_assert(0x75c, 0x5b5560, 0x5b5584);
	__asm        jmp    _T53;
_T4e:
	__asm        jmp    _T53;
// LINE 1887:
_T53:
	__asm        cmp    instanceID, 0;
	__asm        jne    _T6b;
// LINE 1890:
	this->autoDynomitor.mesh = object;
// LINE 1899:
	__asm        jmp    _T10d;
// LINE 1904:
// Block start:
	/*bp-0x2c*/  char * objectMemory;
_T6b:
	__asm        mov    eax, object;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        mov    eax, G_dyobjmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    objectMemory, eax;
// LINE 1905:
	__asm        cmp    objectMemory, 0;
	__asm        jne    _Taf;

	_assert(0x771, 0x5b558c, 0x5b55b0);
	__asm        jmp    _Tb4;
_Taf:
	__asm        jmp    _Tb4;
// LINE 1908:
_Tb4:
	__asm        mov    eax, objectMemory;
	__asm        push   eax;
	__asm        mov    eax, object;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14], eax;
// LINE 1909:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        jne    _Tf3;

	_assert(0x775, 0x5b55c0, 0x5b55e4);
	__asm        jmp    _Tf8;
_Tf3:
	__asm        jmp    _Tf8;
// LINE 1912:
_Tf8:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 1916:
// Block end:
_T10d:
	__asm        mov    eax, instanceID;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1A], ax;
// LINE 1917:
	this->autoDynomitor.flags = 0x11;
// LINE 1919:
	__asm        lea    eax, objectInfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, object;
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 1921:
	this->autoDynomitor.radius = objectInfo.Radius;
// LINE 1922:
	this->autoDynomitor.height = VRObjGetHeight(object);
// LINE 1925:
	this->flags = 0x0;
// LINE 1926:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        shl    eax, 0x11;
	__asm        add    eax, 0x240000;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xB2], eax;
// LINE 1927:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        shl    eax, 0x11;
	__asm        add    eax, 0x280000;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xB6], eax;
// LINE 1931:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T1d9;
// LINE 1937:
_T1ad:
	this->beamDelay = 0x1e0000;
// LINE 1938:
	__asm        jmp    _T1f8;
// LINE 1940:
_T1bf:
	this->AutomobileClass::ChangeAutoColor();
// LINE 1941:
	this->beamDelay = 0xa0000;
// LINE 1942:
	__asm        jmp    _T1f8;
_T1d9:
	__asm        cmp    dword ptr [ebp-0x34], 0x11C;
	__asm        jl     _T1bf;

	__asm        cmp    dword ptr [ebp-0x34], 0x11F;
	__asm        jle    _T1ad;

	__asm        jmp    _T1bf;
// LINE 1949:
_T1f8:
	__asm        mov    eax, this;
	__asm        mov    ecx, instanceID;
	__asm        mov    cars[0][ecx*4], eax;
// LINE 1950:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 1;
// LINE 1952:
	return 0x1;
// LINE 1953:
}

// FUNCTION: COPTER_D 0x00504554
int32_t AutomobileClass::Initialize(int32_t instanceID) {
// LINE 1979:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::InitializeInstance;
	__asm        jmp    __RETURN;
// LINE 1980:
__RETURN:
}

// FUNCTION: COPTER_D 0x00504578
short GetMaximumNumberOfAutomobiles() {
// LINE 2001:
	return 0x32;
// LINE 2002:
}

// FUNCTION: COPTER_D 0x0050458c
void ItterateAllAutomobiles() {
// LINE 2024:
	AutomobileClass::ItterateAll();
// LINE 2025:
	return;
}

// FUNCTION: COPTER_D 0x005045a1
void ResetAllAutomobiles() {
// LINE 2046:
	AutomobileClass::ResetAll();
// LINE 2047:
	return;
}

// FUNCTION: COPTER_D 0x005045b6
int32_t AutomobileClass::CanIPullOver() {
	/*bp-0x4*/   /*packed*/ struct _DYOBJ_INST *currentObject;
	/*bp-0x8*/   unsigned char x;
	/*bp-0xc*/   unsigned char y;
	/*bp-0x18*/  /*packed*/ struct Point3d nextpoint; // 0xc bytes

// LINE 2099:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        test   ecx, ecx;
	__asm        jl     _T54;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        test   ecx, ecx;
	__asm        jl     _T54;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T54;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T5f;
_T54:
	__asm        mov    word ptr [ebp-0x34], 0;
	__asm        jmp    _Tab;
_T5f:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7C];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0x7D];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    [ebp-0x34], ax;
	__asm        jmp    _Tab;
_Tab:
	__asm        mov    eax, [ebp-0x34];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x27;
	__asm        jl     _Td7;

	__asm        mov    eax, [ebp-0x34];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2B;
	__asm        jg     _Td7;

	__asm        jmp    _Teb;

	__asm        jmp    _Te1;
_Td7:
	__asm        jmp    _Tf2;

	__asm        jmp    _Teb;
_Te1:
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _Tf2;
// LINE 2100:
_Teb:
	return 0x0;
// LINE 2103:
_Tf2:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x80;
	__asm        je     _T106;
// LINE 2104:
	return 0x0;
// LINE 2107:
_T106:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9E], 0;
	__asm        jle    _T11d;
// LINE 2108:
	return 0x0;
// LINE 2112:
_T11d:
	nextpoint.x = ((this->pDirVector->x << 0x5) + this->autoDynomitor.loc.x);
// LINE 2113:
	nextpoint.z = ((this->pDirVector->z << 0x5) + this->autoDynomitor.loc.z);
// LINE 2114:
	__asm        mov    eax, nextpoint.x;
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    x, al;
// LINE 2115:
	__asm        mov    eax, 0x20000000;
	__asm        sub    eax, nextpoint.z;
	__asm        sar    eax, 0x16;
	__asm        mov    y, al;
// LINE 2116:
	__asm        xor    eax, eax;
	__asm        mov    al, x;
	__asm        test   eax, eax;
	__asm        jl     _T1a2;

	__asm        xor    eax, eax;
	__asm        mov    al, y;
	__asm        test   eax, eax;
	__asm        jl     _T1a2;

	__asm        xor    eax, eax;
	__asm        mov    al, x;
	__asm        cmp    eax, 0x80;
	__asm        jge    _T1a2;

	__asm        xor    eax, eax;
	__asm        mov    al, y;
	__asm        cmp    eax, 0x80;
	__asm        jl     _T1ad;
_T1a2:
	__asm        mov    word ptr [ebp-0x2C], 0;
	__asm        jmp    _T1ed;
_T1ad:
	__asm        xor    eax, eax;
	__asm        mov    al, x;
	__asm        mov    eax, BitsMap[eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, y;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, x;
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        xor    edx, edx;
	__asm        mov    dl, y;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-0x2C], ax;
	__asm        jmp    _T1ed;
_T1ed:
	__asm        mov    eax, [ebp-0x2C];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x27;
	__asm        jl     _T219;

	__asm        mov    eax, [ebp-0x2C];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2B;
	__asm        jg     _T219;

	__asm        jmp    _T22d;

	__asm        jmp    _T223;
_T219:
	__asm        jmp    _T234;

	__asm        jmp    _T22d;
_T223:
	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        je     _T234;
// LINE 2117:
_T22d:
	return 0x0;
// LINE 2119:
_T234:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0x24], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x28], ecx;
	__asm        mov    eax, [ebp-0x24];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x28];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x20], eax;
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        jne    _T28e;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T293;
_T28e:
	__asm        jmp    _T293;
_T293:
	__asm        jmp    _T298;
_T298:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    currentObject, eax;
// LINE 2122:
__WHILE_2a1:
	while ((currentObject != 0x0)) {
		// LINE 2125:
			__asm        mov    eax, this;
			__asm        add    eax, 0xC;
			__asm        cmp    eax, currentObject;
			__asm        jne    _T2c7;
		// LINE 2127:
			currentObject = currentObject->next;
		// LINE 2128:
			__asm        jmp    __WHILE_2a1;
		// LINE 2133:
		_T2c7:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x10;
			__asm        je     _T2fb;
		// LINE 2135:
		// Block start:
			/*bp-0x1c*/  /*packed*/ class AutomobileClass *car;
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    car, eax;
		// LINE 2139:
			__asm        mov    eax, car;
			__asm        test   byte ptr [eax+8], 0xF0;
			__asm        je     _T2fb;
		// LINE 2140:
			return 0x0;
		// LINE 2143:
		// Block end:
		_T2fb:
			currentObject = currentObject->next;
	}
// LINE 2146:
_T308:
	return 0x1;
// LINE 2147:
}

// FUNCTION: COPTER_D 0x005048cd
void AutomobileClass::PullOver(short __formal) {
// LINE 2153:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x13;
	__asm        je     _T25;

	__asm        mov    dword ptr [ebp-4], 1;
	__asm        jmp    _T7c;
_T25:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T44;
_T33:
	__asm        mov    dword ptr [ebp-4], 1;
	__asm        jmp    _T7c;

	__asm        jmp    _T70;
_T44:
	__asm        cmp    dword ptr [ebp-0xC], 0x11C;
	__asm        jl     _T70;

	__asm        cmp    dword ptr [ebp-0xC], 0x11F;
	__asm        jle    _T33;

	__asm        cmp    dword ptr [ebp-0xC], 0x181;
	__asm        je     _T33;

	__asm        jmp    _T70;
_T70:
	__asm        mov    dword ptr [ebp-4], 0;
	__asm        jmp    _T7c;
_T7c:
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T98;
// LINE 2154:
	this->timePulledOver = 0x7d000000;
// LINE 2155:
	__asm        jmp    _Ta5;
// LINE 2156:
_T98:
	this->timePulledOver = 0x40000;
// LINE 2158:
_Ta5:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x70;
	__asm        jne    _Tcd;
// LINE 2160:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x10;
// LINE 2161:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFF9F;
// LINE 2162:
	this->DeltaFromCenter = 0x0;
// LINE 2165:
_Tcd:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     _T125;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        je     _T125;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xF6], 0;
	__asm        je     _T125;
// LINE 2167:
	__asm        push   7;
	__asm        push   0xE;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::PlacePerson;
	__asm        test   eax, eax;
	__asm        je     _T125;
// LINE 2169:
	this->personDone = 0x0;
// LINE 2170:
	this->personTimer = 0x780000;
// LINE 2173:
_T125:
	return;
}

// FUNCTION: COPTER_D 0x005049fe
int32_t AutomobileClass::CanIPullOut() {
	/*bp-0x4*/   /*packed*/ struct _DYOBJ_INST *currentObject;


	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0xC], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x10], ecx;
// LINE 2178:
	__asm        mov    eax, [ebp-0xC];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x10];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T66;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T6b;
_T66:
	__asm        jmp    _T6b;
_T6b:
	__asm        jmp    _T70;
_T70:
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    currentObject, eax;
// LINE 2181:
__WHILE_79:
	while ((currentObject != 0x0)) {
		// LINE 2184:
			__asm        mov    eax, this;
			__asm        add    eax, 0xC;
			__asm        cmp    eax, currentObject;
			__asm        jne    _T9f;
		// LINE 2186:
			currentObject = currentObject->next;
		// LINE 2187:
			__asm        jmp    __WHILE_79;
		// LINE 2192:
		_T9f:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x10;
			__asm        je     _Tf0;
		// LINE 2195:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    ecx, this;
			__asm        mov    ecx, [ecx+0x82];
			__asm        cmp    [eax+0x82], ecx;
			__asm        jne    _Tf0;

			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x20;
			__asm        jne    _Tf0;
		// LINE 2196:
			return 0x0;
		// LINE 2199:
		_Tf0:
			currentObject = currentObject->next;
	}
// LINE 2202:
_Tfd:
	return 0x1;
// LINE 2203:
}

// FUNCTION: COPTER_D 0x00504b0a
void AutomobileClass::PullOut() {
// LINE 2209:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     _T34;
// LINE 2211:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x40;
// LINE 2212:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFFDF;
// LINE 2213:
	this->DeltaFromCenter = 0xd0000;
// LINE 2215:
_T34:
	return;
}

// FUNCTION: COPTER_D 0x00504b48
void AutomobileClass::TransitionBetweenGoals() {
// LINE 2230:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xEE], 9;
	__asm        jge    _T64;
// LINE 2233:
	this->legOfTurn++;
// LINE 2234:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        shl    ecx, 3;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2235:
	return;
// LINE 2239:
_T64:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::UnlinkFromCell;
// LINE 2241:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _Td9;
// LINE 2243:
_T84:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        dec    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0x7D], cl;
	__asm        jmp    _Tfd;
// LINE 2244:
_T98:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        inc    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0x7C], cl;
	__asm        jmp    _Tfd;
// LINE 2245:
_Tac:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        inc    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0x7D], cl;
	__asm        jmp    _Tfd;
// LINE 2246:
_Tc0:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        dec    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0x7C], cl;
	__asm        jmp    _Tfd;
// LINE 2247:
	__asm        jmp    _Tfd;
_Td9:
	__asm        cmp    dword ptr [ebp-0x2C], 3;
	__asm        ja     _Tfd;

	__asm        mov    eax, [ebp-0x2C];
	__asm        jmp    _Switch_ed[0][eax*4];
// Switch pointers:
//   _T84
//   _T98
//   _Tac
//   _Tc0
// LINE 2250:
_Tfd:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, AltMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+edx*2];
	__asm        shr    ecx, 0xA;
	__asm        test   cl, 0x1F;
	__asm        jne    _T238;
// LINE 2252:
// Block start:
	/*bp-0x4*/   unsigned short tile;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, BuildMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        movzx  ax, byte ptr [eax+edx];
	__asm        mov    tile, ax;
	__asm        mov    ax, tile;
	__asm        mov    [ebp-0x20], ax;
// LINE 2253:
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFF;
	__asm        mov    [ebp-0x20], ax;
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1D;
	__asm        jl     _T17c;

	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2B;
	__asm        jle    _T1e2;
_T17c:
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x3F;
	__asm        jl     _T19e;

	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x46;
	__asm        jle    _T1e2;
_T19e:
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x49;
	__asm        jl     _T1c0;

	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x59;
	__asm        jle    _T1e2;
_T1c0:
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x5D;
	__asm        jl     _T1f1;

	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x6B;
	__asm        jg     _T1f1;
_T1e2:
	__asm        jmp    _T238;

	__asm        jmp    _T200;

	__asm        jmp    _T1f6;
_T1f1:
	__asm        jmp    _T200;
_T1f6:
	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        jne    _T238;
// LINE 2256:
_T200:
	_assert(0x8d0, 0x5b55f8, 0x5b561c);
	__asm        jmp    _T221;

	__asm        jmp    _T221;
// LINE 2258:
_T221:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFFFD;
// LINE 2259:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x1C];
// LINE 2260:
	return;
// LINE 2264:
// Block end:
_T238:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 2268:
	this->legOfTurn = 0xa;
// LINE 2272:
	this->prevDir = this->goal.direction;
// LINE 2275:
	__asm        mov    eax, this;
	__asm        add    eax, 0x70;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::GetNextGoal;
// LINE 2283:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7E], 0xFFFFFFFE;
	__asm        jne    _T310;
// LINE 2285:
	__asm        mov    eax, this;
	__asm        add    eax, 0x70;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 2286:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TurnTable2[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x7E], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7E];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x82], eax;
// LINE 2287:
	this->legOfTurn = 0x0;
// LINE 2288:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE6];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][1][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2290:
	__asm        jmp    _T3b3;
// LINE 2292:
_T310:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        cmp    [eax+0x82], ecx;
	__asm        jne    _T347;
// LINE 2296:
	this->turnIndex = 0x0;
// LINE 2302:
	this->goal.distance = 0x400000;
// LINE 2304:
	__asm        jmp    _T3b3;
// LINE 2312:
_T347:
	this->legOfTurn = 0x0;
// LINE 2313:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        shl    ecx, 4;
	__asm        mov    eax, TILUT[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xE6], eax;
// LINE 2314:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        shl    ecx, 3;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2321:
_T3b3:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE6], 0;
	__asm        je     _T4da;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 0x10;
	__asm        jne    _T3e0;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0x11E;
	__asm        jne    _T4da;
// LINE 2323:
_T3e0:
	__asm        push   0x31;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T4da;
// LINE 2327:
// Block start:
	/*bp-0x10*/  /*packed*/ struct Point3d loc; // 0xc bytes
	loc.x = (this->autoDynomitor.loc.x - (this->pDirVector->x << 0x4));
// LINE 2328:
	loc.y = (this->autoDynomitor.loc.y - (this->pDirVector->y << 0x4));
// LINE 2329:
	loc.z = (this->autoDynomitor.loc.z - (this->pDirVector->z << 0x4));
// LINE 2330:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x31;
	__asm        call   S3DSPlay;
	__asm        add    esp, 0xC;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0x18], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x1C], ecx;
// LINE 2331:
	__asm        mov    eax, [ebp-0x18];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x1C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        jne    _T4ac;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T4b1;
_T4ac:
	__asm        jmp    _T4b1;
_T4b1:
	__asm        jmp    _T4b6;
_T4b6:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 2332:
	S3ExplosionSmokeStart(0x6, loc.x, this->cptr);
// LINE 2338:
// Block end:
_T4da:
	this->AutomobileClass::DoDiagonalRoadFixup();
// LINE 2344:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 2345:
	return;
}

// FUNCTION: COPTER_D 0x0050503f
void AutomobileClass::DoDiagonalRoadFixup() {
	/*bp-0x4*/   int32_t diagRoad;
	/*bp-0x8*/   int32_t roadTile;

// LINE 2362:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, BuildMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        sub    ecx, 0x23;
	__asm        mov    roadTile, ecx;
// LINE 2378:
	__asm        mov    eax, roadTile;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T1c7;
// LINE 2380:
_T39:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 2;
	__asm        jne    _T55;

	diagRoad = 0x0;
	__asm        jmp    _T5c;
_T55:
	diagRoad = 0x2;
// LINE 2381:
_T5c:
	this->legOfTurn = 0xa;
	this->turnIndex = 0x0;
// LINE 2382:
	__asm        mov    eax, diagRoad;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, roadTile;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DiagOffset[0][0].y[ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2383:
	__asm        jmp    _T1eb;
// LINE 2385:
_T9a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 3;
	__asm        jne    _Tb6;

	diagRoad = 0x1;
	__asm        jmp    _Tbd;
_Tb6:
	diagRoad = 0x3;
// LINE 2386:
_Tbd:
	this->legOfTurn = 0xa;
	this->turnIndex = 0x0;
// LINE 2387:
	__asm        mov    eax, diagRoad;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, roadTile;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DiagOffset[0][0].y[ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2388:
	__asm        jmp    _T1eb;
// LINE 2390:
_Tfb:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 0;
	__asm        jne    _T117;

	diagRoad = 0x2;
	__asm        jmp    _T11e;
_T117:
	diagRoad = 0x0;
// LINE 2391:
_T11e:
	this->legOfTurn = 0xa;
	this->turnIndex = 0x0;
// LINE 2392:
	__asm        mov    eax, diagRoad;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, roadTile;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DiagOffset[0][0].y[ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2393:
	__asm        jmp    _T1eb;
// LINE 2395:
_T15c:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 1;
	__asm        jne    _T178;

	diagRoad = 0x3;
	__asm        jmp    _T17f;
_T178:
	diagRoad = 0x1;
// LINE 2396:
_T17f:
	this->legOfTurn = 0xa;
	this->turnIndex = 0x0;
// LINE 2397:
	__asm        mov    eax, diagRoad;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, roadTile;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DiagOffset[0][0].y[ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2398:
	__asm        jmp    _T1eb;
// LINE 2400:
	__asm        jmp    _T1eb;
// LINE 2401:
	__asm        jmp    _T1eb;
_T1c7:
	__asm        cmp    dword ptr [ebp-0x10], 3;
	__asm        ja     _T1eb;

	__asm        mov    eax, [ebp-0x10];
	__asm        jmp    _Switch_1db[0][eax*4];
// Switch pointers:
//   _T39
//   _T9a
//   _Tfb
//   _T15c
// LINE 2404:
_T1eb:
	return;
}

// FUNCTION: COPTER_D 0x00505234
void AutomobileClass::MoveAuto(int32_t dist) {
	/*bp-0x4*/   int32_t diagRoad;
	/*bp-0x8*/   int32_t zOffset;
	/*bp-0xc*/   int32_t *pRotMatrix[4][4];
	/*bp-0x10*/  int32_t roadTile;
	/*bp-0x14*/  /*packed*/ struct _CELL_INFO *pCell;
	/*bp-0x18*/  int32_t xOffset;


	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0x20], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x24], ecx;
// LINE 2424:
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x24];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x1C], eax;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        jne    _T66;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T6b;
_T66:
	__asm        jmp    _T6b;
_T6b:
	__asm        jmp    _T70;
_T70:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    pCell, eax;
// LINE 2432:
	this->autoDynomitor.loc.y = this->m_cellBaseY;
// LINE 2433:
	__asm        mov    eax, pCell;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x24], eax;
// LINE 2434:
	__asm        mov    eax, pCell;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x2C], eax;
// LINE 2441:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, BuildMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        sub    ecx, 0x23;
	__asm        mov    roadTile, ecx;
// LINE 2442:
	diagRoad = 0x0;
// LINE 2445:
	__asm        cmp    roadTile, 0;
	__asm        jl     _T216;

	__asm        cmp    roadTile, 4;
	__asm        jge    _T216;
// LINE 2447:
	__asm        mov    eax, roadTile;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T197;
// LINE 2449:
_Ted:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 2;
	__asm        jne    _T109;

	diagRoad = 0x0;
	__asm        jmp    _T110;
_T109:
	diagRoad = 0x2;
_T110:
	__asm        jmp    _T1bb;
// LINE 2450:
_T115:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 3;
	__asm        jne    _T131;

	diagRoad = 0x1;
	__asm        jmp    _T138;
_T131:
	diagRoad = 0x3;
_T138:
	__asm        jmp    _T1bb;
// LINE 2451:
_T13d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 0;
	__asm        jne    _T159;

	diagRoad = 0x2;
	__asm        jmp    _T160;
_T159:
	diagRoad = 0x0;
_T160:
	__asm        jmp    _T1bb;
// LINE 2452:
_T165:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE2], 1;
	__asm        jne    _T181;

	diagRoad = 0x3;
	__asm        jmp    _T188;
_T181:
	diagRoad = 0x1;
_T188:
	__asm        jmp    _T1bb;
// LINE 2453:
	__asm        jmp    _T1bb;
// LINE 2454:
	__asm        jmp    _T1bb;
_T197:
	__asm        cmp    dword ptr [ebp-0x2C], 3;
	__asm        ja     _T1bb;

	__asm        mov    eax, [ebp-0x2C];
	__asm        jmp    _Switch_1ab[0][eax*4];
// Switch pointers:
//   _Ted
//   _T115
//   _T13d
//   _T165
// LINE 2456:
_T1bb:
	__asm        mov    eax, diagRoad;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, roadTile;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DiagOffset[0][0].x[ecx+eax*4];
	__asm        mov    xOffset, eax;
// LINE 2457:
	__asm        mov    eax, diagRoad;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, roadTile;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DiagOffset[0][0].z[ecx+eax*4];
	__asm        mov    zOffset, eax;
// LINE 2458:
	__asm        mov    eax, diagRoad;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, DiagVector[0].x[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xF2], eax;
// LINE 2459:
	pRotMatrix = ((diagRoad << 0x6) + 0x62ba00);
// LINE 2461:
	__asm        jmp    _T3df;
_T216:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xEE], 0xA;
	__asm        jge    _T348;
// LINE 2464:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE2];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        shl    ecx, 3;
	__asm        lea    eax, [ecx+eax*8];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        shl    ecx, 5;
	__asm        mov    eax, OTT[0][0][0].x[eax+ecx];
	__asm        mov    xOffset, eax;
// LINE 2465:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xE2];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        shl    ecx, 3;
	__asm        lea    eax, [ecx+eax*8];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        shl    ecx, 5;
	__asm        mov    eax, OTT[0][0][0].z[eax+ecx];
	__asm        mov    zOffset, eax;
// LINE 2466:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        shl    ecx, 3;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        lea    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        shl    ecx, 5;
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        shl    ecx, 2;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        add    eax, 0x62BD10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xF2], eax;
// LINE 2467:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        shl    eax, 6;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE2];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        shl    ecx, 7;
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        shl    ecx, 6;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        shl    ecx, 9;
	__asm        add    eax, ecx;
	__asm        add    eax, 0x62D910;
	__asm        mov    pRotMatrix, eax;
// LINE 2470:
	__asm        jmp    _T3df;
// LINE 2472:
_T348:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        shl    eax, 4;
	__asm        fld    OT[0].x[eax];
	__asm        fmul   qword ptr ds:[0x592D90];
	__asm        call   0x0056EBE8;
	__asm        mov    xOffset, eax;
// LINE 2473:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x82];
	__asm        shl    eax, 4;
	__asm        fld    OT[0].z[eax];
	__asm        fmul   qword ptr ds:[0x592D90];
	__asm        call   0x0056EBE8;
	__asm        mov    zOffset, eax;
// LINE 2474:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x82];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        shl    ecx, 3;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        lea    eax, [ecx+eax*4];
	__asm        add    eax, 0x62BD10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xF2], eax;
// LINE 2475:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        shl    eax, 6;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x82];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        shl    ecx, 7;
	__asm        add    eax, ecx;
	__asm        add    eax, 0x62D910;
	__asm        mov    pRotMatrix, eax;
// LINE 2480:
_T3df:
	this->autoDynomitor.loc.x += xOffset;
// LINE 2481:
	this->autoDynomitor.loc.z += zOffset;
// LINE 2485:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x24], eax;
// LINE 2487:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x28], eax;
// LINE 2488:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x2C], eax;
// LINE 2491:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x70;
	__asm        je     _T466;
// LINE 2492:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoPullOverStuff;
// LINE 2495:
_T466:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, AltMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+edx*2];
	__asm        shr    ecx, 0xA;
	__asm        test   cl, 0x1F;
	__asm        je     _T4a5;
// LINE 2496:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2497:
	__asm        jmp    _T4b6;
// LINE 2498:
_T4a5:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 2506:
_T4b6:
	__asm        mov    edi, this;
	__asm        add    edi, 0x30;
	__asm        mov    esi, pRotMatrix;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 2507:
	return;
}

// FUNCTION: COPTER_D 0x00505706
void AutomobileClass::DoAUTurn() {
// LINE 2515:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xEE], 0xA;
	__asm        je     _T88;
// LINE 2518:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE6], 3;
	__asm        jne    _T31;
// LINE 2519:
	return;
// LINE 2522:
_T31:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE6], 2;
	__asm        jne    _T53;
// LINE 2524:
	this->turnIndex = 0x1;
// LINE 2526:
	__asm        jmp    _T70;
_T53:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xE6], 1;
	__asm        jne    _T70;
// LINE 2528:
	this->turnIndex = 0x2;
// LINE 2531:
_T70:
	__asm        mov    eax, 0xA;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0xEE];
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xEE], eax;
// LINE 2535:
_T88:
	__asm        mov    eax, this;
	__asm        add    eax, 0x70;
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::SamePlaceOtherDirection;
// LINE 2539:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xEE], 0xA;
	__asm        jne    _Tbb;
// LINE 2540:
	this->goal.distance = 0x400000;
// LINE 2541:
	__asm        jmp    _Tf5;
// LINE 2542:
_Tbb:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x96];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xE6];
	__asm        shl    ecx, 3;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    eax, [ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xEE];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    eax, DTT[0][0][eax+ecx*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x86], eax;
// LINE 2544:
_Tf5:
	this->currDist = (this->goal.distance - this->currDist);
// LINE 2545:
	return;
}

// FUNCTION: COPTER_D 0x00505820
int32_t AutomobileClass::CanIDoAUTurn() {
// LINE 2552:
	return 0x1;
// LINE 2553:
}

// FUNCTION: COPTER_D 0x0050583b
void AutomobileClass::DoPullOverStuff(int32_t dist) {
	/*bp-0x4*/   int32_t PulloverStepSize;
	/*bp-0x10*/  /*packed*/ struct Point3d pulloverVector; // 0xc bytes

// LINE 2562:
	__asm        push   0x8000;
	__asm        mov    eax, dist;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0xEA];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    PulloverStepSize, eax;
// LINE 2564:
	pulloverVector.y = 0x0;
// LINE 2565:
	__asm        push   0xFFFF0000;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    pulloverVector.z, eax;
// LINE 2566:
	pulloverVector.x = this->pDirVector->z;
// LINE 2567:
	Normalize(pulloverVector.x);
// LINE 2569:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x10;
	__asm        je     _Tc0;
// LINE 2571:
	this->DeltaFromCenter += PulloverStepSize;
// LINE 2572:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9A], 0xD0000;
	__asm        jle    _Tbb;
// LINE 2574:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFFEF;
// LINE 2575:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x20;
// LINE 2576:
	this->DeltaFromCenter = 0xd0000;
// LINE 2577:
	this->timePulledOver = 0x40000;
// LINE 2580:
_Tbb:
	__asm        jmp    _T101;
_Tc0:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x40;
	__asm        je     _T101;
// LINE 2582:
	__asm        xor    eax, eax;
	__asm        sub    eax, PulloverStepSize;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x9A], eax;
// LINE 2583:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9A], 0;
	__asm        jg     _T101;
// LINE 2585:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFF8F;
// LINE 2586:
	this->DeltaFromCenter = 0x0;
// LINE 2589:
_T101:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x9A];
	__asm        push   eax;
	__asm        mov    eax, pulloverVector.x;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    pulloverVector.x, eax;
// LINE 2590:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x9A];
	__asm        push   eax;
	__asm        mov    eax, pulloverVector.z;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    pulloverVector.z, eax;
// LINE 2592:
	this->autoDynomitor.loc.x += pulloverVector.x;
// LINE 2593:
	this->autoDynomitor.loc.z += pulloverVector.z;
// LINE 2594:
	return;
}

// FUNCTION: COPTER_D 0x0050598c
enum AutomobileClass::StoppedReasons AutomobileClass::CollisionCheck(int32_t dist, /*packed*/ struct _DYOBJ_INST **dyblock) {
	/*bp-0x4*/   int32_t ydiff;
	/*bp-0x8*/   /*packed*/ struct _GridCoordinates currentLocation;
	/*bp-0xc*/   /*packed*/ class AutomobileClass *carblock;
	/*bp-0x10*/  /*packed*/ struct _DYOBJ_INST *currentObject;
	/*bp-0x14*/  /*packed*/ struct _CELL_INFO *currentCell;
	/*bp-0x18*/  int32_t zdiff;
	/*bp-0x1c*/  int32_t xdiff;
	/*bp-0x20*/  /*packed*/ struct _GridCoordinates nextLocation;
	/*bp-0x24*/  int32_t combinedradius;
	/*bp-0x30*/  /*packed*/ struct Point3d collisionPoint; // 0xc bytes

// LINE 2625:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, AltMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+edx*2];
	__asm        shr    ecx, 0xA;
	__asm        test   cl, 0x1F;
	__asm        je     _T3c;
// LINE 2626:
	return 0x0;
// LINE 2629:
_T3c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        add    eax, 0x50000;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x24];
	__asm        add    ecx, eax;
	__asm        mov    collisionPoint.x, ecx;
// LINE 2630:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        add    eax, 0x50000;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, eax;
	__asm        mov    collisionPoint.y, ecx;
// LINE 2631:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        add    eax, 0x50000;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        add    ecx, eax;
	__asm        mov    collisionPoint.z, ecx;
// LINE 2636:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    currentLocation.x, al;
// LINE 2637:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x2C];
	__asm        sar    eax, 0x16;
	__asm        mov    currentLocation.y, al;
// LINE 2640:
	xdiff = ((this->pDirVector->x << 0x3) + collisionPoint.x);
// LINE 2641:
	zdiff = ((this->pDirVector->z << 0x3) + collisionPoint.z);
// LINE 2643:
	__asm        mov    eax, xdiff;
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    nextLocation.x, al;
// LINE 2644:
	__asm        mov    eax, 0x20000000;
	__asm        sub    eax, zdiff;
	__asm        sar    eax, 0x16;
	__asm        mov    nextLocation.y, al;
// LINE 2646:
	__asm        xor    eax, eax;
	__asm        mov    al, currentLocation.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, currentLocation.x;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x54], eax;
	__asm        cmp    dword ptr [ebp-0x54], 0;
	__asm        jne    _T163;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T168;
_T163:
	__asm        jmp    _T168;
_T168:
	__asm        jmp    _T16d;
_T16d:
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    currentCell, eax;
// LINE 2650:
	__asm        xor    eax, eax;
	__asm        mov    al, currentLocation.x;
	__asm        test   eax, eax;
	__asm        jl     _T1ad;

	__asm        xor    eax, eax;
	__asm        mov    al, currentLocation.y;
	__asm        test   eax, eax;
	__asm        jl     _T1ad;

	__asm        xor    eax, eax;
	__asm        mov    al, currentLocation.x;
	__asm        cmp    eax, 0x80;
	__asm        jge    _T1ad;

	__asm        xor    eax, eax;
	__asm        mov    al, currentLocation.y;
	__asm        cmp    eax, 0x80;
	__asm        jl     _T1b8;
_T1ad:
	__asm        mov    word ptr [ebp-0x4C], 0;
	__asm        jmp    _T1f8;
_T1b8:
	__asm        xor    eax, eax;
	__asm        mov    al, currentLocation.x;
	__asm        mov    eax, BitsMap[eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, currentLocation.y;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, currentLocation.x;
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        xor    edx, edx;
	__asm        mov    dl, currentLocation.y;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-0x4C], ax;
	__asm        jmp    _T1f8;
_T1f8:
	__asm        mov    eax, [ebp-0x4C];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x27;
	__asm        jl     _T224;

	__asm        mov    eax, [ebp-0x4C];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2B;
	__asm        jg     _T224;

	__asm        jmp    _T238;

	__asm        jmp    _T22e;
_T224:
	__asm        jmp    _T247;

	__asm        jmp    _T238;
_T22e:
	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        je     _T247;
// LINE 2652:
_T238:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x80;
// LINE 2654:
	__asm        jmp    _T25b;
// LINE 2656:
_T247:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFF7F;
// LINE 2657:
	__asm        mov    eax, this;
	__asm        and    dword ptr [eax+8], 0xFFFFFBFF;
// LINE 2661:
_T25b:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::IsThisAnEmergencyVehicle;
	__asm        test   eax, eax;
	__asm        je     _T275;
// LINE 2662:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x400;
// LINE 2665:
_T275:
	__asm        cmp    currentCell, 0;
	__asm        jne    _T2a0;
// LINE 2667:
	_assert(0xa6b, 0x5b5624, 0x5b5648);
	__asm        jmp    _T2a0;

	__asm        jmp    _T2a0;
// LINE 2675:
_T2a0:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 4;
	__asm        jne    _T52c;

	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, currentLocation.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T2d1;

	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, currentLocation.y;
	__asm        cmp    eax, ecx;
	__asm        je     _T52c;
// LINE 2680:
// Block start:
	/*bp-0x34*/  /*packed*/ struct _DYOBJ_INST *currentObject;
	/*bp-0x38*/  /*packed*/ struct _CELL_INFO *cptr;
_T2d1:
	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.x;
	__asm        test   eax, eax;
	__asm        jl     _T30b;

	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.y;
	__asm        test   eax, eax;
	__asm        jl     _T30b;

	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.x;
	__asm        cmp    eax, 0x80;
	__asm        jge    _T30b;

	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.y;
	__asm        cmp    eax, 0x80;
	__asm        jl     _T316;
_T30b:
	__asm        mov    word ptr [ebp-0x44], 0;
	__asm        jmp    _T356;
_T316:
	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.x;
	__asm        mov    eax, BitsMap[eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, nextLocation.y;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, nextLocation.x;
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        xor    edx, edx;
	__asm        mov    dl, nextLocation.y;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-0x44], ax;
	__asm        jmp    _T356;
_T356:
	__asm        mov    eax, [ebp-0x44];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x27;
	__asm        jl     _T382;

	__asm        mov    eax, [ebp-0x44];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2B;
	__asm        jg     _T382;

	__asm        jmp    _T396;

	__asm        jmp    _T38c;
_T382:
	__asm        jmp    _T52c;

	__asm        jmp    _T396;
_T38c:
	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        je     _T52c;
// LINE 2682:
_T396:
	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, nextLocation.x;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x3C], eax;
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        jne    _T3d3;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T3d8;
_T3d3:
	__asm        jmp    _T3d8;
_T3d8:
	__asm        jmp    _T3dd;
_T3dd:
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    cptr, eax;
// LINE 2683:
	currentObject = cptr->dyptr;
// LINE 2685:
_LOOP_3ec:
	for (;;) {
		// LINE 2685:
		_LOOP_3ec:
			__asm        cmp    currentObject, 0;
			__asm        je     _T52c;
		// LINE 2688:
			__asm        mov    eax, this;
			__asm        add    eax, 0xC;
			__asm        cmp    eax, currentObject;
			__asm        jne    _T412;
		// LINE 2690:
			currentObject = currentObject->next;
		// LINE 2691:
			__asm        jmp    _LOOP_3ec;
		// LINE 2695:
		_T412:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x20;
			__asm        je     _T42e;
		// LINE 2697:
			currentObject = currentObject->next;
		// LINE 2698:
			__asm        jmp    _LOOP_3ec;
		// LINE 2701:
		_T42e:
			dyblock-> = currentObject;
		// LINE 2704:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x10;
			__asm        je     _T4ba;
		// LINE 2707:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    carblock, eax;
		// LINE 2713:
			__asm        mov    eax, this;
			__asm        test   byte ptr [eax+8], 0x80;
			__asm        je     _T487;

			__asm        mov    eax, carblock;
			__asm        test   byte ptr [eax+9], 4;
			__asm        jne    _T487;
		// LINE 2715:
			__asm        mov    eax, this;
			__asm        or     dword ptr [eax+8], 0x400;
		// LINE 2716:
			currentObject = currentObject->next;
		// LINE 2717:
			__asm        jmp    _LOOP_3ec;
	}
// LINE 2723:
_T487:
	__asm        mov    eax, carblock;
	__asm        test   byte ptr [eax+8], 0x10;
	__asm        jne    _T4ab;

	__asm        mov    eax, carblock;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        jne    _T4ab;
// LINE 2725:
	return 0x1;
// LINE 2728:
_T4ab:
	return 0x4;
// LINE 2730:
	__asm        jmp    _T51f;
_T4ba:
	__asm        mov    eax, currentObject;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _T4d8;
// LINE 2732:
	return 0x3;
// LINE 2734:
	__asm        jmp    _T51f;
_T4d8:
	__asm        mov    eax, currentObject;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T4f6;
// LINE 2736:
	return 0x7;
// LINE 2738:
	__asm        jmp    _T51f;
_T4f6:
	__asm        mov    eax, currentObject;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   ah, 4;
	__asm        je     _T515;
// LINE 2740:
	return 0x5;
// LINE 2742:
	__asm        jmp    _T51f;
// LINE 2744:
_T515:
	return 0x6;
// LINE 2748:
_T51f:
	currentObject = currentObject->next;
// LINE 2749:
	__asm        jmp    _LOOP_3ec;
// LINE 2755:
// Block end:
_T52c:
	currentObject = currentCell->dyptr;
// LINE 2758:
__WHILE_535:
	while ((currentObject != 0x0)) {
		// LINE 2761:
			__asm        mov    eax, this;
			__asm        add    eax, 0xC;
			__asm        cmp    eax, currentObject;
			__asm        jne    _T55b;
		// LINE 2763:
			currentObject = currentObject->next;
		// LINE 2764:
			__asm        jmp    __WHILE_535;
		// LINE 2768:
		_T55b:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x20;
			__asm        je     _T577;
		// LINE 2770:
			currentObject = currentObject->next;
		// LINE 2771:
			__asm        jmp    __WHILE_535;
		// LINE 2776:
		_T577:
			__asm        mov    eax, collisionPoint.x;
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x18];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    xdiff, eax;
		// LINE 2777:
			__asm        mov    eax, collisionPoint.y;
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x1C];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    ydiff, eax;
		// LINE 2778:
			__asm        mov    eax, collisionPoint.z;
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x20];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    zdiff, eax;
		// LINE 2780:
			combinedradius = currentObject->radius;
		// LINE 2781:
			combinedradius += 0x50000;
		// LINE 2784:
			__asm        mov    eax, xdiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T6be;

			__asm        mov    eax, ydiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T6be;

			__asm        mov    eax, zdiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T6be;
		// LINE 2787:
			dyblock-> = currentObject;
		// LINE 2789:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x10;
			__asm        je     _T659;
		// LINE 2793:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x10;
			__asm        jne    _T654;

			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x20;
			__asm        jne    _T654;
		// LINE 2804:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    eax, [eax+0xF2];
			__asm        push   eax;
			__asm        mov    ecx, this;
			__asm        call   AutomobileClass::AreCarsHeadOn;
			__asm        test   eax, eax;
			__asm        jne    _T654;
		// LINE 2805:
			return 0x4;
		// LINE 2808:
		_T654:
			__asm        jmp    _T6be;
		_T659:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 8;
			__asm        je     _T677;
		// LINE 2810:
			return 0x3;
		// LINE 2812:
			__asm        jmp    _T6be;
		_T677:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 4;
			__asm        je     _T695;
		// LINE 2814:
			return 0x7;
		// LINE 2816:
			__asm        jmp    _T6be;
		_T695:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   ah, 4;
			__asm        je     _T6b4;
		// LINE 2818:
			return 0x5;
		// LINE 2820:
			__asm        jmp    _T6be;
		// LINE 2822:
		_T6b4:
			return 0x6;
		// LINE 2827:
		_T6be:
			currentObject = currentObject->next;
	}
// LINE 2831:
_T6cb:
	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, currentLocation.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T6f6;

	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, currentLocation.y;
	__asm        cmp    eax, ecx;
	__asm        jne    _T6f6;
// LINE 2832:
	return 0x0;
// LINE 2837:
_T6f6:
	__asm        xor    eax, eax;
	__asm        mov    al, nextLocation.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, nextLocation.x;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x40], eax;
	__asm        cmp    dword ptr [ebp-0x40], 0;
	__asm        jne    _T733;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T738;
_T733:
	__asm        jmp    _T738;
_T738:
	__asm        jmp    _T73d;
_T73d:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    currentCell, eax;
// LINE 2840:
	__asm        cmp    currentCell, 0;
	__asm        jne    _T76e;
// LINE 2842:
	_assert(0xb1a, 0x5b5650, 0x5b5674);
	__asm        jmp    _T76e;

	__asm        jmp    _T76e;
// LINE 2846:
_T76e:
	currentObject = currentCell->dyptr;
// LINE 2849:
__WHILE_777:
	while ((currentObject != 0x0)) {
		// LINE 2852:
			__asm        mov    eax, this;
			__asm        add    eax, 0xC;
			__asm        cmp    eax, currentObject;
			__asm        jne    _T79d;
		// LINE 2854:
			currentObject = currentObject->next;
		// LINE 2855:
			__asm        jmp    __WHILE_777;
		// LINE 2859:
		_T79d:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x20;
			__asm        je     _T7b9;
		// LINE 2861:
			currentObject = currentObject->next;
		// LINE 2862:
			__asm        jmp    __WHILE_777;
		// LINE 2867:
		_T7b9:
			__asm        mov    eax, collisionPoint.x;
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x18];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    xdiff, eax;
		// LINE 2868:
			__asm        mov    eax, collisionPoint.y;
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x1C];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    ydiff, eax;
		// LINE 2869:
			__asm        mov    eax, collisionPoint.z;
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x20];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    zdiff, eax;
		// LINE 2871:
			combinedradius = currentObject->radius;
		// LINE 2872:
			combinedradius += 0x50000;
		// LINE 2875:
			__asm        mov    eax, xdiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T900;

			__asm        mov    eax, ydiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T900;

			__asm        mov    eax, zdiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T900;
		// LINE 2878:
			dyblock-> = currentObject;
		// LINE 2880:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x10;
			__asm        je     _T89b;
		// LINE 2884:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x10;
			__asm        jne    _T896;

			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        test   byte ptr [eax+8], 0x20;
			__asm        jne    _T896;
		// LINE 2895:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xE];
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    eax, [eax+0xF2];
			__asm        push   eax;
			__asm        mov    ecx, this;
			__asm        call   AutomobileClass::AreCarsHeadOn;
			__asm        test   eax, eax;
			__asm        jne    _T896;
		// LINE 2896:
			return 0x4;
		// LINE 2899:
		_T896:
			__asm        jmp    _T900;
		_T89b:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 8;
			__asm        je     _T8b9;
		// LINE 2901:
			return 0x3;
		// LINE 2903:
			__asm        jmp    _T900;
		_T8b9:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 4;
			__asm        je     _T8d7;
		// LINE 2905:
			return 0x7;
		// LINE 2907:
			__asm        jmp    _T900;
		_T8d7:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   ah, 4;
			__asm        je     _T8f6;
		// LINE 2909:
			return 0x5;
		// LINE 2911:
			__asm        jmp    _T900;
		// LINE 2913:
		_T8f6:
			return 0x6;
		// LINE 2918:
		_T900:
			currentObject = currentObject->next;
	}
// LINE 2923:
_T90d:
	return 0x0;
// LINE 2924:
}

// FUNCTION: COPTER_D 0x005062a7
int32_t AutomobileClass::AreCarsHeadOn(/*packed*/ struct Point3d *dirvect) {
	/*bp-0x4*/   int32_t dotp;

// LINE 2952:
	__asm        mov    eax, dirvect;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, dirvect;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    eax, dirvect;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    dotp, ebx;
// LINE 2954:
	__asm        cmp    dotp, 0x3333;
	__asm        jl     _T7b;
// LINE 2955:
	return 0x0;
// LINE 2958:
_T7b:
	return 0x1;
// LINE 2959:
}

// FUNCTION: COPTER_D 0x00506333
int32_t AutomobileClass::IsCarOutOfCameraRange() {
	/*bp-0x4*/   int32_t ydiff;
	/*bp-0x8*/   int32_t dist;
	/*bp-0xc*/   int32_t xdiff;

// LINE 2985:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 8;
	__asm        je     _T54;
// LINE 2987:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        sub    ecx, CameraCell.x;
	__asm        mov    eax, ecx;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    xdiff, eax;
// LINE 2988:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        sub    ecx, CameraCell.y;
	__asm        mov    eax, ecx;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ydiff, eax;
// LINE 2990:
	__asm        jmp    _T84;
// LINE 2992:
_T54:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        sub    ecx, CameraCell.x;
	__asm        mov    eax, ecx;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    xdiff, eax;
// LINE 2993:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        sub    ecx, CameraCell.y;
	__asm        mov    eax, ecx;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ydiff, eax;
// LINE 2996:
_T84:
	__asm        mov    eax, xdiff;
	__asm        cmp    ydiff, eax;
	__asm        jge    _Ta0;
// LINE 2998:
	dist = ((xdiff + xdiff) + ydiff);
// LINE 3000:
	__asm        jmp    _Tab;
// LINE 3002:
_Ta0:
	dist = ((ydiff + ydiff) + xdiff);
// LINE 3006:
_Tab:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        add    eax, G_ViewSize;
	__asm        add    eax, 2;
	__asm        cmp    eax, dist;
	__asm        jge    _Td4;
// LINE 3008:
	return 0x1;
// LINE 3010:
	__asm        jmp    __RETURN;
// LINE 3012:
_Td4:
	return 0x0;
// LINE 3014:
__RETURN:
}

// FUNCTION: COPTER_D 0x00506413
void AutomobileClass::HitDispatch(long hitter_type, /*packed*/ struct _DYOBJ_INST *dyhitter, long mission_id, long xtra_msg) {
// LINE 3029:
	__asm        mov    eax, hitter_type;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _Td9;
// LINE 3032:
_T17:
	__asm        jmp    _T12d;
// LINE 3034:
_T1c:
	__asm        mov    eax, dyhitter;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::IveBeenSpotlighted;
// LINE 3035:
	__asm        jmp    _T12d;
// LINE 3037:
_T2d:
	__asm        mov    eax, xtra_msg;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::IveBeenMegaphoned;
// LINE 3038:
	__asm        jmp    _T12d;
// LINE 3040:
_T3e:
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::StartFire;
// LINE 3041:
	__asm        jmp    _T12d;
// LINE 3043:
_T4f:
	__asm        mov    eax, dyhitter;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::WaterDouse;
// LINE 3044:
	__asm        jmp    _T12d;
// LINE 3046:
_T60:
	__asm        jmp    _T12d;
// LINE 3048:
_T65:
	__asm        jmp    _T12d;
// LINE 3050:
_T6a:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::IsThisAnEmergencyVehicle;
	__asm        test   eax, eax;
	__asm        jne    _T86;
// LINE 3051:
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::StartFire;
// LINE 3052:
_T86:
	__asm        jmp    _T12d;
// LINE 3054:
_T8b:
	__asm        jmp    _T12d;
// LINE 3056:
_T90:
	__asm        jmp    _T12d;
// LINE 3058:
_T95:
	__asm        jmp    _T12d;
// LINE 3060:
_T9a:
	__asm        jmp    _T12d;
// LINE 3062:
_T9f:
	__asm        jmp    _T12d;
// LINE 3064:
_Ta4:
	__asm        jmp    _T12d;
// LINE 3066:
_Ta9:
	__asm        jmp    _T12d;
// LINE 3068:
_Tae:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::IsThisAnEmergencyVehicle;
	__asm        test   eax, eax;
	__asm        jne    _Tca;
// LINE 3069:
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::StartFire;
// LINE 3070:
_Tca:
	__asm        jmp    _T12d;
// LINE 3072:
	__asm        jmp    _T12d;
// LINE 3073:
	__asm        jmp    _T12d;
_Td9:
	__asm        cmp    dword ptr [ebp-8], 0xF;
	__asm        ja     _T12d;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    _Switch_ed[0][eax*4];
// Switch pointers:
//   _T17
//   _T1c
//   _T2d
//   _T3e
//   _T4f
//   _T60
//   _T65
//   _T6a
//   _T8b
//   _T90
//   _T95
//   _T9a
//   _T9f
//   _Ta4
//   _Ta9
//   _Tae
// LINE 3075:
_T12d:
	return;
}

// FUNCTION: COPTER_D 0x0050654c
void AutoHitDispatch(long hitter_type, /*packed*/ struct _DYOBJ_INST *dyhitter, /*packed*/ struct _DYOBJ_INST *dyhittee, long mission_id, long xtra_msg) {
// LINE 3086:
	__asm        mov    eax, xtra_msg;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        mov    eax, dyhitter;
	__asm        push   eax;
	__asm        mov    eax, hitter_type;
	__asm        push   eax;
	__asm        mov    eax, dyhittee;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        mov    ecx, cars[0][eax*4];
	__asm        call   AutomobileClass::HitDispatch;
// LINE 3087:
	return;
}

// FUNCTION: COPTER_D 0x0050657f
int32_t AutoMissionStartFire(long mission_id, /*packed*/ struct Point2d *celloc) {
// LINE 3098:
	return AutomobileClass::MissionStartFire(celloc, mission_id);
// LINE 3099:
}

// FUNCTION: COPTER_D 0x0050659f
int32_t AutoMissionStartJam(long mission_id, /*packed*/ struct Point2d *celloc) {
// LINE 3111:
	return AutomobileClass::MissionStartJam(celloc, mission_id);
// LINE 3112:
}

// FUNCTION: COPTER_D 0x005065bf
int32_t AutomobileClass::MissionStartFire(long mission_id, /*packed*/ struct Point2d *celloc) {
	/*bp-0x4*/   int32_t currentCarIndex;
	/*bp-0x8*/   /*packed*/ class AutomobileClass *targcar;

// LINE 3128:
_FOR_15:
	for (currentCarIndex = 0x0; (currentCarIndex < 0x46); currentCarIndex++) {
		// LINE 3130:
			__asm        mov    eax, currentCarIndex;
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    targcar, eax;
		// LINE 3131:
			__asm        mov    eax, targcar;
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _T4e;

			__asm        mov    eax, targcar;
			__asm        test   byte ptr [eax+9], 1;
			__asm        jne    _T4e;
		// LINE 3132:
			__asm        jmp    _T53;
		// LINE 3133:
		_T4e:
	}
// LINE 3135:
_T53:
	__asm        cmp    currentCarIndex, 0x46;
	__asm        jne    _T64;
// LINE 3136:
	return 0x0;
// LINE 3138:
_T64:
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        mov    ecx, targcar;
	__asm        call   AutomobileClass::StartFire;
// LINE 3141:
	celloc->x = ((targcar->autoDynomitor.loc.x + 0x20000000) >> 0x16);
// LINE 3142:
	celloc->y = ((0x20000000 - targcar->autoDynomitor.loc.z) >> 0x16);
// LINE 3144:
	return 0x1;
// LINE 3145:
}

// FUNCTION: COPTER_D 0x00506665
int32_t AutomobileClass::MissionStartJam(long mission_id, /*packed*/ struct Point2d *celloc) {
	/*bp-0x4*/   int32_t currentCarIndex;
	/*bp-0x8*/   /*packed*/ class AutomobileClass *targcar;

// LINE 3161:
_FOR_15:
	for (currentCarIndex = 0x0; (currentCarIndex < 0x46); currentCarIndex++) {
		// LINE 3163:
			__asm        mov    eax, currentCarIndex;
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    targcar, eax;
		// LINE 3164:
			__asm        mov    eax, targcar;
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _T4e;

			__asm        mov    eax, targcar;
			__asm        test   byte ptr [eax+9], 3;
			__asm        jne    _T4e;
		// LINE 3165:
			__asm        jmp    _T53;
		// LINE 3166:
		_T4e:
	}
// LINE 3168:
_T53:
	__asm        cmp    currentCarIndex, 0x46;
	__asm        jne    _T64;
// LINE 3169:
	return 0x0;
// LINE 3171:
_T64:
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        mov    ecx, targcar;
	__asm        call   AutomobileClass::StartJam;
// LINE 3174:
	celloc->x = ((targcar->autoDynomitor.loc.x + 0x20000000) >> 0x16);
// LINE 3175:
	celloc->y = ((0x20000000 - targcar->autoDynomitor.loc.z) >> 0x16);
// LINE 3177:
	return 0x1;
// LINE 3178:
}

// FUNCTION: COPTER_D 0x0050670b
void AutomobileClass::StartFire(long mission_id) {
	/*bp-0x8*/   /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*bp-0x20*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 3195:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 1;
	__asm        je     _T1e;
// LINE 3196:
	return;
// LINE 3199:
_T1e:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, AltMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+edx*2];
	__asm        shr    ecx, 0xA;
	__asm        test   cl, 0x1F;
	__asm        je     _T4c;
// LINE 3200:
	return;
// LINE 3204:
_T4c:
	__asm        mov    eax, this;
	__asm        add    eax, 0x30;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 3205:
	__asm        mov    eax, this;
	__asm        add    eax, 0x30;
	__asm        push   eax;
	__asm        push   0x3840000;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 3208:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x100;
// LINE 3209:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x18];
	__asm        or     eax, 0x1000;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x18], ax;
// LINE 3212:
	this->timeToLive = 0x780000;
// LINE 3213:
	this->fireSeq = 0x0;
// LINE 3214:
	this->fireTime = 0x0;
// LINE 3215:
	this->missionId = mission_id;
// LINE 3218:
	celloc.x = ((this->autoDynomitor.loc.x + 0x20000000) >> 0x16);
// LINE 3219:
	celloc.y = ((0x20000000 - this->autoDynomitor.loc.z) >> 0x16);
// LINE 3220:
	__asm        mov    eax, celloc.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, celloc.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 3223:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T142;
// LINE 3225:
	mp.op = 0x18;
// LINE 3226:
	mp.id = this->missionId;
// LINE 3227:
	mp.i2num = 0x1;
// LINE 3228:
	mp.flags = 0x0;
// LINE 3229:
	S3MissionUpdate(mp.op);
// LINE 3233:
_T142:
	return;
}

// FUNCTION: COPTER_D 0x00506859
void AutomobileClass::StartJam(long mission_id) {
	/*bp-0x8*/   /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*bp-0x20*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 3249:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 3;
	__asm        je     _T1e;
// LINE 3250:
	return;
// LINE 3253:
_T1e:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    eax, AltMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0x7D];
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+edx*2];
	__asm        shr    ecx, 0xA;
	__asm        test   cl, 0x1F;
	__asm        je     _T4c;
// LINE 3254:
	return;
// LINE 3257:
_T4c:
	__asm        mov    eax, this;
	__asm        or     dword ptr [eax+8], 0x200;
// LINE 3260:
	this->timeToLive = 0x780000;
// LINE 3261:
	this->fireSeq = 0x0;
// LINE 3262:
	this->fireTime = 0x0;
// LINE 3263:
	this->missionId = mission_id;
// LINE 3266:
	celloc.x = ((this->autoDynomitor.loc.x + 0x20000000) >> 0x16);
// LINE 3267:
	celloc.y = ((0x20000000 - this->autoDynomitor.loc.z) >> 0x16);
// LINE 3268:
	__asm        mov    eax, celloc.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, celloc.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 3271:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T10c;
// LINE 3273:
	mp.op = 0x19;
// LINE 3274:
	mp.id = this->missionId;
// LINE 3275:
	mp.i2num = 0x1;
// LINE 3276:
	mp.flags = 0x0;
// LINE 3277:
	S3MissionUpdate(mp.op);
// LINE 3281:
_T10c:
	return;
}

// FUNCTION: COPTER_D 0x00506971
void AutomobileClass::RunFireState() {
	/*bp-0x40*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x4c*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x64*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x6c*/  /*packed*/ struct Point2d currpos; // 0x8 bytes

// LINE 3298:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x102], eax;
// LINE 3299:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x106], eax;
// LINE 3302:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x106], 0;
	__asm        jg     _T71;
// LINE 3304:
	this->fireTime = 0x3333;
// LINE 3305:
	S3MissileDebrisFire((this + 0x10a), (this + 0x24), this->cptr);
// LINE 3309:
_T71:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x102], 0;
	__asm        jge    _T203;
// LINE 3311:
	currpos.x = ((this->autoDynomitor.loc.x + 0x20000000) >> 0x16);
// LINE 3312:
	currpos.y = ((0x20000000 - this->autoDynomitor.loc.z) >> 0x16);
// LINE 3314:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 3315:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xE10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 3316:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xC8;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+0x28A];
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 3317:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 3328:
	S3MissileStart(this->missionId, 0x320000, (this + 0xc), 0x1, vec.x, (this + 0x24), currpos.x, 0x4);
// LINE 3334:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        push   eax;
	__asm        push   2;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x112];
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x112];
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x112];
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        push   eax;
	__asm        call   S3ExplosionStart;
	__asm        add    esp, 0x18;
// LINE 3336:
	S3DSPlay(0x0, (this + 0x24), 0x4);
// LINE 3339:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T1f6;
// LINE 3341:
	mp.op = 0x1c;
// LINE 3342:
	mp.id = this->missionId;
// LINE 3343:
	mp.i2num = 0x1;
// LINE 3344:
	mp.flags = 0x0;
// LINE 3345:
	S3MissionUpdate(mp.op);
// LINE 3348:
_T1f6:
	this->AutomobileClass::UnPlaceCar();
// LINE 3349:
	return;
// LINE 3354:
_T203:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T254;
// LINE 3356:
	mp.op = 0x0;
// LINE 3357:
	mp.id = this->missionId;
// LINE 3358:
	mp.maploc.x = ((this->autoDynomitor.loc.x + 0x20000000) >> 0x16);
// LINE 3359:
	mp.maploc.y = ((0x20000000 - this->autoDynomitor.loc.z) >> 0x16);
// LINE 3360:
	S3MissionUpdate(mp.op);
// LINE 3362:
_T254:
	return;
}

// FUNCTION: COPTER_D 0x00506bcf
void AutomobileClass::RunJamState() {
	/*bp-0x18*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 3375:
	this->AutomobileClass::HonkHorn();
// LINE 3378:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x102], eax;
// LINE 3381:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x102], 0;
	__asm        jge    _T37;
// LINE 3389:
_T37:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10E], 0xFFFFFFFF;
	__asm        je     _T88;
// LINE 3391:
	mp.op = 0x0;
// LINE 3392:
	mp.id = this->missionId;
// LINE 3393:
	mp.maploc.x = ((this->autoDynomitor.loc.x + 0x20000000) >> 0x16);
// LINE 3394:
	mp.maploc.y = ((0x20000000 - this->autoDynomitor.loc.z) >> 0x16);
// LINE 3395:
	S3MissionUpdate(mp.op);
// LINE 3397:
_T88:
	return;
}

// FUNCTION: COPTER_D 0x00506c61
void AutoMissionCancel(long mission_id) {
// LINE 3409:
	AutomobileClass::MissionCancel(mission_id);
// LINE 3410:
	return;
}

// FUNCTION: COPTER_D 0x00506c7d
void AutomobileClass::IveBeenSpotlighted(/*packed*/ struct _DYOBJ_INST *dyhitter) {
	/*bp-0xc*/   /*packed*/ struct Point3d spotLoc; // 0xc bytes

// LINE 3433:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0xA;
	__asm        jl     _T21;
// LINE 3434:
	return;
// LINE 3442:
_T21:
	__asm        mov    eax, dyhitter;
	__asm        add    eax, 0x18;
	__asm        lea    ecx, spotLoc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 3448:
	this->spotlightHitCounter += 0x2;
// LINE 3449:
	return;
}

// FUNCTION: COPTER_D 0x00506ccd
void AutomobileClass::MissionCancel(long mission_id) {
	/*bp-0x4*/   int32_t currentCarIndex;
	/*bp-0x8*/   /*packed*/ class AutomobileClass *targcar;

// LINE 3464:
_FOR_15:
	for (currentCarIndex = 0x0; (currentCarIndex < 0x46); currentCarIndex++) {
		// LINE 3467:
			__asm        mov    eax, currentCarIndex;
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    targcar, eax;
		// LINE 3470:
			__asm        mov    eax, targcar;
			__asm        test   byte ptr [eax+8], 2;
			__asm        je     _T72;

			__asm        mov    eax, targcar;
			__asm        mov    ecx, mission_id;
			__asm        cmp    [eax+0x10E], ecx;
			__asm        jne    _T72;
		// LINE 3475:
			__asm        mov    eax, targcar;
			__asm        test   byte ptr [eax+9], 2;
			__asm        je     _T72;
		// LINE 3477:
			__asm        mov    eax, targcar;
			__asm        and    dword ptr [eax+8], 0xFFFFFDFF;
		// LINE 3478:
			targcar->missionId = 0xffffffff;
		// LINE 3481:
		_T72:
	}
// LINE 3482:
_T77:
	return;
}

// FUNCTION: COPTER_D 0x00506d4e
void AutoSetAllHeadlights(int32_t lights_on) {
// LINE 3494:
	AutomobileClass::SetAllHeadlights(lights_on);
// LINE 3495:
	return;
}

// FUNCTION: COPTER_D 0x00506d6a
void AutomobileClass::SetAllHeadlights(int32_t lights_on) {
	/*bp-0x4*/   int32_t currentCarIndex;
	/*bp-0x8*/   /*packed*/ class AutomobileClass *targcar;

// LINE 3511:
_FOR_15:
	for (currentCarIndex = 0x0; (currentCarIndex < 0x46); currentCarIndex++) {
		// LINE 3513:
			__asm        mov    eax, currentCarIndex;
			__asm        mov    eax, cars[0][eax*4];
			__asm        mov    targcar, eax;
		// LINE 3514:
			__asm        mov    eax, targcar;
			__asm        test   byte ptr [eax+8], 1;
			__asm        je     _T5b;
		// LINE 3516:
			__asm        cmp    lights_on, 1;
			__asm        jne    _T53;
		// LINE 3517:
			targcar->AutomobileClass::TurnOnHeadlight();
		// LINE 3518:
			__asm        jmp    _T5b;
		// LINE 3519:
		_T53:
			targcar->AutomobileClass::TurnOffHeadlight();
		// LINE 3521:
		_T5b:
	}
// LINE 3524:
_T60:
	return;
}

// FUNCTION: COPTER_D 0x00506dd4
void AutomobileClass::TurnOnHeadlight() {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  int32_t face;
	/*bp-0x2c*/  int32_t count;
	/*bp-0x4c*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes

// LINE 3544:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 3545:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 3546:
_FOR_3d:
	for (count = 0x0; (oinfo.Faces > count); count++) {
		// LINE 3548:
			__asm        lea    eax, finfo.Face;
			__asm        push   eax;
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D6905;
			__asm        add    esp, 8;
		// LINE 3549:
			__asm        cmp    finfo.Plotter, 0xB;
			__asm        jne    _T7d;
		// LINE 3551:
			__asm        and    finfo.Attribute, 0x7FFFFFFF;
		// LINE 3552:
			__asm        lea    eax, finfo.Face;
			__asm        push   eax;
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D6941;
			__asm        add    esp, 8;
		// LINE 3554:
		_T7d:
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D85F8;
			__asm        add    esp, 4;
			__asm        mov    face, eax;
	}
// LINE 3556:
_T91:
	return;
}

// FUNCTION: COPTER_D 0x00506e6f
void AutomobileClass::TurnOffHeadlight() {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  int32_t face;
	/*bp-0x2c*/  int32_t count;
	/*bp-0x4c*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes

// LINE 3567:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 3568:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 3569:
_FOR_3d:
	for (count = 0x0; (oinfo.Faces > count); count++) {
		// LINE 3571:
			__asm        lea    eax, finfo.Face;
			__asm        push   eax;
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D6905;
			__asm        add    esp, 8;
		// LINE 3572:
			__asm        cmp    finfo.Plotter, 0xB;
			__asm        jne    _T81;
		// LINE 3574:
			finfo.Attribute = (finfo.Attribute | 0x80000000);
		// LINE 3575:
			__asm        lea    eax, finfo.Face;
			__asm        push   eax;
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D6941;
			__asm        add    esp, 8;
		// LINE 3577:
		_T81:
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D85F8;
			__asm        add    esp, 4;
			__asm        mov    face, eax;
	}
// LINE 3579:
_T95:
	return;
}

// FUNCTION: COPTER_D 0x00506f0e
int32_t AutomobileClass::IsThisAnEmergencyVehicle() {
// LINE 3586:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T29;
// LINE 3591:
_T1a:
	return 0x1;
// LINE 3592:
	__asm        jmp    _T55;
_T29:
	__asm        cmp    dword ptr [ebp-8], 0x11C;
	__asm        jl     _T55;

	__asm        cmp    dword ptr [ebp-8], 0x11D;
	__asm        jle    _T1a;

	__asm        cmp    dword ptr [ebp-8], 0x11F;
	__asm        je     _T1a;

	__asm        jmp    _T55;
// LINE 3594:
_T55:
	return 0x0;
// LINE 3595:
}

// FUNCTION: COPTER_D 0x00506f6f
void AutomobileClass::SetHiwayDirection(unsigned short tileType) {
	/*bp-0x4*/   int32_t i;
	/*bp-0x24*/  enum DirectionTypes validdirs[8]; // 0x20 bytes
	/*bp-0x28*/  unsigned short tile;

// LINE 3616:
	validdirs[0] = 0x0;
// LINE 3617:
	validdirs[1] = 0x0;
// LINE 3618:
	validdirs[2] = 0x0;
// LINE 3619:
	validdirs[3] = 0x0;
// LINE 3620:
	validdirs[4] = 0x0;
// LINE 3621:
	validdirs[5] = 0x0;
// LINE 3622:
	validdirs[6] = 0x0;
// LINE 3623:
	validdirs[7] = 0x0;
// LINE 3624:
	i = 0x0;
// LINE 3626:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD2];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 3627:
	this->hiwaydir = 0x0;
// LINE 3631:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        test   ecx, ecx;
	__asm        jl     _Tc0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        dec    ecx;
	__asm        js     _Tc0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _Tc0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        dec    ecx;
	__asm        cmp    ecx, 0x80;
	__asm        jl     _Tcb;
_Tc0:
	tile = 0x0;
	__asm        jmp    _T125;
_Tcb:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD3];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx-1];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD2];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD3];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx-1];
	__asm        or     eax, edx;
	__asm        mov    tile, ax;
	__asm        jmp    _T125;
// LINE 3632:
_T125:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tileType);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T161;
// LINE 3634:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        test   cl, 1;
	__asm        je     _T161;
// LINE 3636:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x24], 1;
	__asm        inc    i;
// LINE 3650:
_T161:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        test   ecx, ecx;
	__asm        jl     _T1b5;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        inc    ecx;
	__asm        js     _T1b5;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T1b5;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        inc    ecx;
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T1c0;
_T1b5:
	tile = 0x0;
	__asm        jmp    _T21a;
_T1c0:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD3];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx+1];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD2];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD3];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx+1];
	__asm        or     eax, edx;
	__asm        mov    tile, ax;
	__asm        jmp    _T21a;
// LINE 3651:
_T21a:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tileType);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T256;
// LINE 3653:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        test   cl, 1;
	__asm        jne    _T256;
// LINE 3655:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x24], 4;
	__asm        inc    i;
// LINE 3660:
_T256:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        inc    ecx;
	__asm        js     _T2aa;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        test   ecx, ecx;
	__asm        jl     _T2aa;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        inc    ecx;
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T2aa;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T2b5;
_T2aa:
	tile = 0x0;
	__asm        jmp    _T30d;
_T2b5:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    eax, BitsMap[1][ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD3];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD2];
	__asm        mov    ecx, BuildMap[1][edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD3];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    tile, ax;
	__asm        jmp    _T30d;
// LINE 3661:
_T30d:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tileType);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T349;
// LINE 3663:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        test   cl, 1;
	__asm        je     _T349;
// LINE 3665:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x24], 2;
	__asm        inc    i;
// LINE 3669:
_T349:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        dec    ecx;
	__asm        js     _T39d;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        test   ecx, ecx;
	__asm        jl     _T39d;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        dec    ecx;
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T39d;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T3a8;
_T39d:
	tile = 0x0;
	__asm        jmp    _T400;
_T3a8:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    eax, [ecx*4+0x638F6C];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD3];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD2];
	__asm        mov    ecx, NeighborFame[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD3];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    tile, ax;
	__asm        jmp    _T400;
// LINE 3670:
_T400:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(tileType);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T43c;
// LINE 3672:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        test   cl, 1;
	__asm        jne    _T43c;
// LINE 3674:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x24], 8;
	__asm        inc    i;
// LINE 3681:
_T43c:
	__asm        cmp    i, 0;
	__asm        jne    _T44b;
// LINE 3682:
	return;
// LINE 3684:
_T44b:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   i;
	__asm        mov    eax, [ebp+edx*4-0x24];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xCE], eax;
// LINE 3686:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xCE];
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _T4b2;
// LINE 3690:
_T475:
	this->nextLocation.y--;
// LINE 3691:
	__asm        jmp    _T50d;
// LINE 3694:
_T483:
	this->nextLocation.y++;
// LINE 3695:
	__asm        jmp    _T50d;
// LINE 3698:
_T491:
	this->nextLocation.x++;
// LINE 3699:
	__asm        jmp    _T50d;
// LINE 3702:
_T49f:
	this->nextLocation.x--;
// LINE 3703:
	__asm        jmp    _T50d;
// LINE 3704:
	__asm        jmp    _T50d;
_T4b2:
	__asm        dec    dword ptr [ebp-0x30];
	__asm        cmp    dword ptr [ebp-0x30], 0x17;
	__asm        ja     _T50d;

	__asm        mov    eax, [ebp-0x30];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, _SwitchTable_4f5[0][eax];
	__asm        jmp    _Switch_4d1[0][ecx*4];
// Switch pointers:
//   _T475
//   _T491
//   _T483
//   _T49f
//   _T475
//   _T491
//   _T483
//   _T49f
//   _T50d
// Switch table
//  [0, 1, 8, 2, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 4, 5, 8, 6, 8, 8, 8, 7]
// LINE 3706:
_T50d:
	return;
}

// FUNCTION: COPTER_D 0x00507488
int32_t AutomobileClass::DoHiwayTilesConnect(unsigned short fromTile, unsigned short toTile, enum DirectionTypes direction) {
// LINE 3731:
	__asm        mov    eax, reinterpret_cast<uint32_t>(fromTile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T3c;
// LINE 3734:
_T1c:
	fromTile = 0x49;
// LINE 3735:
	__asm        jmp    _T55;
// LINE 3737:
_T27:
	fromTile = 0x4a;
// LINE 3738:
	__asm        jmp    _T55;
// LINE 3740:
	__asm        jmp    _T55;
// LINE 3741:
	__asm        jmp    _T55;
_T3c:
	__asm        cmp    dword ptr [ebp-0x20], 0x4B;
	__asm        je     _T1c;

	__asm        cmp    dword ptr [ebp-0x20], 0x4C;
	__asm        je     _T27;

	__asm        jmp    _T55;
// LINE 3743:
_T55:
	__asm        mov    eax, reinterpret_cast<uint32_t>(toTile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T85;
// LINE 3746:
_T65:
	toTile = 0x49;
// LINE 3747:
	__asm        jmp    _T9e;
// LINE 3749:
_T70:
	toTile = 0x4a;
// LINE 3750:
	__asm        jmp    _T9e;
// LINE 3752:
	__asm        jmp    _T9e;
// LINE 3753:
	__asm        jmp    _T9e;
_T85:
	__asm        cmp    dword ptr [ebp-0x24], 0x4B;
	__asm        je     _T65;

	__asm        cmp    dword ptr [ebp-0x24], 0x4C;
	__asm        je     _T70;

	__asm        jmp    _T9e;
// LINE 3755:
_T9e:
	__asm        mov    eax, reinterpret_cast<uint32_t>(fromTile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _Tc2;

	__asm        jmp    _T118;

	__asm        jmp    _T2ec;

	__asm        jmp    _T118;

	__asm        jmp    _T10e;
_Tc2:
	__asm        cmp    dword ptr [ebp-0x28], 0x6B;
	__asm        jg     _Tef;

	__asm        cmp    dword ptr [ebp-0x28], 0x61;
	__asm        jge    _T118;

	__asm        cmp    dword ptr [ebp-0x28], 0x49;
	__asm        jl     _T2ec;

	__asm        cmp    dword ptr [ebp-0x28], 0x50;
	__asm        jle    _T118;

	__asm        jmp    _T2ec;
_Tef:
	__asm        cmp    dword ptr [ebp-0x28], 0x806A;
	__asm        jl     _T2ec;

	__asm        cmp    dword ptr [ebp-0x28], 0x806B;
	__asm        jle    _T118;

	__asm        jmp    _T2ec;
_T10e:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T2ec;
_T118:
	__asm        mov    eax, reinterpret_cast<uint32_t>(toTile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T13c;

	__asm        jmp    _T192;

	__asm        jmp    _T2ec;

	__asm        jmp    _T192;

	__asm        jmp    _T188;
_T13c:
	__asm        cmp    dword ptr [ebp-0x2C], 0x6B;
	__asm        jg     _T169;

	__asm        cmp    dword ptr [ebp-0x2C], 0x61;
	__asm        jge    _T192;

	__asm        cmp    dword ptr [ebp-0x2C], 0x49;
	__asm        jl     _T2ec;

	__asm        cmp    dword ptr [ebp-0x2C], 0x50;
	__asm        jle    _T192;

	__asm        jmp    _T2ec;
_T169:
	__asm        cmp    dword ptr [ebp-0x2C], 0x806A;
	__asm        jl     _T2ec;

	__asm        cmp    dword ptr [ebp-0x2C], 0x806B;
	__asm        jle    _T192;

	__asm        jmp    _T2ec;
_T188:
	__asm        cmp    dword ptr [ebp-0x10], 0;
	__asm        je     _T2ec;
// LINE 3757:
// Block start:
	/*bp-0x4*/   enum DirectionTypes toConnections;
	/*bp-0x8*/   enum DirectionTypes fromConnections;
_T192:
	__asm        mov    dword ptr [ebp-0x14], 0x5B57E8;
_LOOP_199:
	for (;;) {
		_LOOP_199:
			__asm        mov    eax, [ebp-0x14];
			__asm        mov    ecx, reinterpret_cast<uint32_t>(fromTile);
			__asm        and    ecx, 0xFFFF;
			__asm        cmp    [eax], ecx;
			__asm        jne    _T1bb;

			__asm        mov    eax, [ebp-0x14];
			__asm        mov    eax, [eax+4];
			__asm        mov    fromConnections, eax;
			__asm        jmp    _T1ef;
		_T1bb:
			__asm        mov    eax, [ebp-0x14];
			__asm        cmp    dword ptr [eax], 0;
			__asm        je     _T1da;

			__asm        mov    eax, 0x5B57E8;
			__asm        add    eax, 0xF40;
			__asm        cmp    eax, [ebp-0x14];
			__asm        jae    _T1e6;
		_T1da:
			fromConnections = 0x0;
			__asm        jmp    _T1ef;
		_T1e6:
			__asm        add    dword ptr [ebp-0x14], 8;
			__asm        jmp    _LOOP_199;
	}
// LINE 3758:
_T1ef:
	__asm        mov    dword ptr [ebp-0x18], 0x5B57E8;
_LOOP_1f6:
	for (;;) {
		_LOOP_1f6:
			__asm        mov    eax, [ebp-0x18];
			__asm        mov    ecx, reinterpret_cast<uint32_t>(toTile);
			__asm        and    ecx, 0xFFFF;
			__asm        cmp    [eax], ecx;
			__asm        jne    _T218;

			__asm        mov    eax, [ebp-0x18];
			__asm        mov    eax, [eax+4];
			__asm        mov    toConnections, eax;
			__asm        jmp    _T24c;
		_T218:
			__asm        mov    eax, [ebp-0x18];
			__asm        cmp    dword ptr [eax], 0;
			__asm        je     _T237;

			__asm        mov    eax, 0x5B57E8;
			__asm        add    eax, 0xF40;
			__asm        cmp    eax, [ebp-0x18];
			__asm        jae    _T243;
		_T237:
			toConnections = 0x0;
			__asm        jmp    _T24c;
		_T243:
			__asm        add    dword ptr [ebp-0x18], 8;
			__asm        jmp    _LOOP_1f6;
	}
// LINE 3765:
_T24c:
	__asm        test   reinterpret_cast<uint8_t>(direction), 1;
	__asm        je     _T274;

	__asm        test   reinterpret_cast<uint8_t>(fromConnections), 1;
	__asm        je     _T274;

	__asm        test   reinterpret_cast<uint8_t>(toConnections), 4;
	__asm        je     _T274;
// LINE 3767:
	return 0x1;
// LINE 3771:
_T274:
	__asm        test   reinterpret_cast<uint8_t>(direction), 4;
	__asm        je     _T29c;

	__asm        test   reinterpret_cast<uint8_t>(fromConnections), 4;
	__asm        je     _T29c;

	__asm        test   reinterpret_cast<uint8_t>(toConnections), 1;
	__asm        je     _T29c;
// LINE 3773:
	return 0x1;
// LINE 3777:
_T29c:
	__asm        test   reinterpret_cast<uint8_t>(direction), 8;
	__asm        je     _T2c4;

	__asm        test   reinterpret_cast<uint8_t>(fromConnections), 8;
	__asm        je     _T2c4;

	__asm        test   reinterpret_cast<uint8_t>(toConnections), 2;
	__asm        je     _T2c4;
// LINE 3779:
	return 0x1;
// LINE 3783:
_T2c4:
	__asm        test   reinterpret_cast<uint8_t>(direction), 2;
	__asm        je     _T2ec;

	__asm        test   reinterpret_cast<uint8_t>(fromConnections), 2;
	__asm        je     _T2ec;

	__asm        test   reinterpret_cast<uint8_t>(toConnections), 8;
	__asm        je     _T2ec;
// LINE 3785:
	return 0x1;
// LINE 3790:
// Block end:
_T2ec:
	return 0x0;
// LINE 3791:
}

// FUNCTION: COPTER_D 0x00507782
void AutomobileClass::AdjustCurrentHiwayPosition() {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;


	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        mov    [ebp-0xC], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    [ebp-0x10], ecx;
// LINE 3813:
	__asm        mov    eax, [ebp-0xC];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x10];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T6c;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T71;
_T6c:
	__asm        jmp    _T71;
_T71:
	__asm        jmp    _T76;
_T76:
	__asm        mov    eax, [ebp-8];
	__asm        mov    cellPointer, eax;
// LINE 3815:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _Ta2;

	_assert(0xee7, 0x5b567c, 0x5b56a0);
	__asm        jmp    _Ta7;
_Ta2:
	__asm        jmp    _Ta7;
// LINE 3819:
_Ta7:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x24], eax;
// LINE 3820:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x28], eax;
// LINE 3821:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x2C], eax;
// LINE 3825:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 1;
	__asm        je     _T100;
// LINE 3827:
	this->autoDynomitor.loc.x += 0xd0000;
// LINE 3828:
	this->autoDynomitor.loc.z -= 0x1e0000;
// LINE 3830:
	__asm        jmp    _T176;
_T100:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 4;
	__asm        je     _T129;
// LINE 3832:
	this->autoDynomitor.loc.x -= 0xd0000;
// LINE 3833:
	this->autoDynomitor.loc.z += 0x1e0000;
// LINE 3835:
	__asm        jmp    _T176;
_T129:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 2;
	__asm        je     _T152;
// LINE 3837:
	this->autoDynomitor.loc.x -= 0x1e0000;
// LINE 3838:
	this->autoDynomitor.loc.z -= 0xd0000;
// LINE 3840:
	__asm        jmp    _T176;
_T152:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 8;
	__asm        je     _T176;
// LINE 3842:
	this->autoDynomitor.loc.x += 0x1e0000;
// LINE 3843:
	this->autoDynomitor.loc.z += 0xd0000;
// LINE 3847:
_T176:
	this->autoDynomitor.loc.y += 0x1f0000;
// LINE 3848:
	return;
}

// FUNCTION: COPTER_D 0x0050790c
void AutomobileClass::AdjustNextHiwayPosition() {
	/*bp-0x4*/   enum DirectionTypes connectionType;
	/*bp-0x8*/   int32_t ydiff;
	/*bp-0xc*/   int32_t xdiff;
	/*bp-0x18*/  /*packed*/ struct Point3d nextFineLocation; // 0xc bytes
	/*bp-0x1c*/  unsigned short ntile;
	/*bp-0x20*/  unsigned short tile;
	/*bp-0x24*/  /*packed*/ struct _CELL_INFO *cellPointer;


	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD5];
	__asm        mov    [ebp-0x2C], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        mov    [ebp-0x30], ecx;
// LINE 3869:
	__asm        mov    eax, [ebp-0x2C];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x30];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x28], eax;
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        jne    _T6c;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T71;
_T6c:
	__asm        jmp    _T71;
_T71:
	__asm        jmp    _T76;
_T76:
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    cellPointer, eax;
// LINE 3872:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        test   ecx, ecx;
	__asm        jl     _Td0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        test   ecx, ecx;
	__asm        jl     _Td0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _Td0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _Tdb;
_Td0:
	tile = 0x0;
	__asm        jmp    _T133;
_Tdb:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD3];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD2];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD3];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    tile, ax;
	__asm        jmp    _T133;
// LINE 3873:
_T133:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        test   ecx, ecx;
	__asm        jl     _T187;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD5];
	__asm        test   ecx, ecx;
	__asm        jl     _T187;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T187;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD5];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T192;
_T187:
	ntile = 0x0;
	__asm        jmp    _T1ea;
_T192:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD5];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD4];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD5];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    ntile, ax;
	__asm        jmp    _T1ea;
// LINE 3877:
_T1ea:
	__asm        mov    eax, reinterpret_cast<uint32_t>(ntile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x50], eax;
	__asm        jmp    _T20e;

	__asm        jmp    _T250;

	__asm        jmp    _T327;

	__asm        jmp    _T250;

	__asm        jmp    _T246;
_T20e:
	__asm        cmp    dword ptr [ebp-0x50], 0x806B;
	__asm        jg     _T327;

	__asm        cmp    dword ptr [ebp-0x50], 0x806A;
	__asm        jge    _T250;

	__asm        cmp    dword ptr [ebp-0x50], 0x61;
	__asm        jl     _T327;

	__asm        cmp    dword ptr [ebp-0x50], 0x6B;
	__asm        jle    _T250;

	__asm        jmp    _T327;

	__asm        jmp    _T327;
_T246:
	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        je     _T327;
// LINE 3879:
_T250:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        test   ecx, 0xFE;
	__asm        jl     _T2ac;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD5];
	__asm        test   ecx, 0xFE;
	__asm        jl     _T2ac;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        and    cl, 0xFE;
	__asm        cmp    cl, 0x80;
	__asm        jae    _T2ac;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD5];
	__asm        and    cl, 0xFE;
	__asm        cmp    cl, 0x80;
	__asm        jb     _T2b7;
_T2ac:
	ntile = 0x0;
	__asm        jmp    _T327;
_T2b7:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        and    ecx, 0xFE;
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD5];
	__asm        and    edx, 0xFE;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD4];
	__asm        and    edx, 0xFE;
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD5];
	__asm        and    ebx, 0xFE;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    ntile, ax;
	__asm        jmp    _T327;
// LINE 3882:
_T327:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T34d;

	_assert(0xf2a, 0x5b56ac, 0x5b56d0);
	__asm        jmp    _T352;
_T34d:
	__asm        jmp    _T352;
// LINE 3885:
_T352:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    nextFineLocation.x, eax;
// LINE 3886:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    nextFineLocation.y, eax;
// LINE 3887:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    nextFineLocation.z, eax;
// LINE 3894:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD4];
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0xD2];
	__asm        sub    ecx, edx;
	__asm        mov    xdiff, ecx;
// LINE 3895:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD5];
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0xD3];
	__asm        sub    ecx, edx;
	__asm        mov    ydiff, ecx;
// LINE 3897:
	__asm        cmp    xdiff, 0;
	__asm        jge    _T46c;

	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jge    _T46c;
// LINE 3899:
	__asm        mov    eax, reinterpret_cast<uint32_t>(ntile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x54], eax;
	__asm        jmp    _T3f7;

	__asm        jmp    _T439;

	__asm        jmp    _T44c;

	__asm        jmp    _T439;

	__asm        jmp    _T42f;
_T3f7:
	__asm        cmp    dword ptr [ebp-0x54], 0x806B;
	__asm        jg     _T44c;

	__asm        cmp    dword ptr [ebp-0x54], 0x806A;
	__asm        jge    _T439;

	__asm        cmp    dword ptr [ebp-0x54], 0x61;
	__asm        jl     _T44c;

	__asm        cmp    dword ptr [ebp-0x54], 0x6B;
	__asm        jle    _T439;

	__asm        jmp    _T44c;

	__asm        jmp    _T44c;
_T42f:
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _T44c;
// LINE 3901:
_T439:
	nextFineLocation.x += 0x3e0000;
// LINE 3902:
	nextFineLocation.z += 0x2d0000;
// LINE 3904:
	__asm        jmp    _T45a;
// LINE 3906:
_T44c:
	nextFineLocation.x += 0x1e0000;
// LINE 3907:
	nextFineLocation.z += 0xd0000;
// LINE 3909:
_T45a:
	this->hiwaydir = 0x8;
// LINE 3912:
	__asm        jmp    _T6a3;
_T46c:
	__asm        cmp    xdiff, 0;
	__asm        jle    _T529;

	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jge    _T529;
// LINE 3915:
	__asm        mov    eax, reinterpret_cast<uint32_t>(ntile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x58], eax;
	__asm        jmp    _T4b4;

	__asm        jmp    _T4f6;

	__asm        jmp    _T509;

	__asm        jmp    _T4f6;

	__asm        jmp    _T4ec;
_T4b4:
	__asm        cmp    dword ptr [ebp-0x58], 0x806B;
	__asm        jg     _T509;

	__asm        cmp    dword ptr [ebp-0x58], 0x806A;
	__asm        jge    _T4f6;

	__asm        cmp    dword ptr [ebp-0x58], 0x61;
	__asm        jl     _T509;

	__asm        cmp    dword ptr [ebp-0x58], 0x6B;
	__asm        jle    _T4f6;

	__asm        jmp    _T509;

	__asm        jmp    _T509;
_T4ec:
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        je     _T509;
// LINE 3917:
_T4f6:
	nextFineLocation.x -= 0x3e0000;
// LINE 3918:
	nextFineLocation.z -= 0x2d0000;
// LINE 3920:
	__asm        jmp    _T517;
// LINE 3922:
_T509:
	nextFineLocation.x -= 0x1e0000;
// LINE 3923:
	nextFineLocation.z -= 0xd0000;
// LINE 3925:
_T517:
	this->hiwaydir = 0x2;
// LINE 3927:
	__asm        jmp    _T6a3;
_T529:
	__asm        cmp    ydiff, 0;
	__asm        jle    _T5e6;

	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jle    _T5e6;
// LINE 3929:
	__asm        mov    eax, reinterpret_cast<uint32_t>(ntile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x5C], eax;
	__asm        jmp    _T571;

	__asm        jmp    _T5b3;

	__asm        jmp    _T5c6;

	__asm        jmp    _T5b3;

	__asm        jmp    _T5a9;
_T571:
	__asm        cmp    dword ptr [ebp-0x5C], 0x806B;
	__asm        jg     _T5c6;

	__asm        cmp    dword ptr [ebp-0x5C], 0x806A;
	__asm        jge    _T5b3;

	__asm        cmp    dword ptr [ebp-0x5C], 0x61;
	__asm        jl     _T5c6;

	__asm        cmp    dword ptr [ebp-0x5C], 0x6B;
	__asm        jle    _T5b3;

	__asm        jmp    _T5c6;

	__asm        jmp    _T5c6;
_T5a9:
	__asm        cmp    dword ptr [ebp-0x40], 0;
	__asm        je     _T5c6;
// LINE 3931:
_T5b3:
	nextFineLocation.z += 0x3e0000;
// LINE 3932:
	nextFineLocation.x -= 0x2d0000;
// LINE 3934:
	__asm        jmp    _T5d4;
// LINE 3936:
_T5c6:
	nextFineLocation.z += 0x1e0000;
// LINE 3937:
	nextFineLocation.x -= 0xd0000;
// LINE 3939:
_T5d4:
	this->hiwaydir = 0x4;
// LINE 3941:
	__asm        jmp    _T6a3;
_T5e6:
	__asm        cmp    ydiff, 0;
	__asm        jge    _T6a3;

	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jle    _T6a3;
// LINE 3944:
	__asm        mov    eax, reinterpret_cast<uint32_t>(ntile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x60], eax;
	__asm        jmp    _T62e;

	__asm        jmp    _T670;

	__asm        jmp    _T683;

	__asm        jmp    _T670;

	__asm        jmp    _T666;
_T62e:
	__asm        cmp    dword ptr [ebp-0x60], 0x806B;
	__asm        jg     _T683;

	__asm        cmp    dword ptr [ebp-0x60], 0x806A;
	__asm        jge    _T670;

	__asm        cmp    dword ptr [ebp-0x60], 0x61;
	__asm        jl     _T683;

	__asm        cmp    dword ptr [ebp-0x60], 0x6B;
	__asm        jle    _T670;

	__asm        jmp    _T683;

	__asm        jmp    _T683;
_T666:
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        je     _T683;
// LINE 3946:
_T670:
	nextFineLocation.z -= 0x3e0000;
// LINE 3947:
	nextFineLocation.x += 0x2d0000;
// LINE 3949:
	__asm        jmp    _T691;
// LINE 3951:
_T683:
	nextFineLocation.z -= 0x1e0000;
// LINE 3952:
	nextFineLocation.x += 0xd0000;
// LINE 3954:
_T691:
	this->hiwaydir = 0x1;
// LINE 3956:
	__asm        jmp    _T6a3;
// LINE 3963:
_T6a3:
	__asm        mov    dword ptr [ebp-0x48], 0x5B57E8;
_LOOP_6aa:
	for (;;) {
		_LOOP_6aa:
			__asm        mov    eax, [ebp-0x48];
			__asm        mov    ecx, reinterpret_cast<uint32_t>(ntile);
			__asm        and    ecx, 0xFFFF;
			__asm        cmp    [eax], ecx;
			__asm        jne    _T6cc;

			__asm        mov    eax, [ebp-0x48];
			__asm        mov    eax, [eax+4];
			__asm        mov    connectionType, eax;
			__asm        jmp    _T700;
		_T6cc:
			__asm        mov    eax, [ebp-0x48];
			__asm        cmp    dword ptr [eax], 0;
			__asm        je     _T6eb;

			__asm        mov    eax, 0x5B57E8;
			__asm        add    eax, 0xF40;
			__asm        cmp    eax, [ebp-0x48];
			__asm        jae    _T6f7;
		_T6eb:
			connectionType = 0x0;
			__asm        jmp    _T700;
		_T6f7:
			__asm        add    dword ptr [ebp-0x48], 8;
			__asm        jmp    _LOOP_6aa;
	}
// LINE 3966:
_T700:
	__asm        cmp    connectionType, 0;
	__asm        je     _T7fb;
// LINE 3968:
	__asm        mov    eax, reinterpret_cast<uint32_t>(ntile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x64], eax;
	__asm        jmp    _T7a0;
// LINE 3971:
_T71a:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 1;
	__asm        je     _T731;
// LINE 3972:
	nextFineLocation.y += 0x1f0000;
// LINE 3973:
_T731:
	__asm        jmp    _T7fb;
// LINE 3975:
_T736:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 4;
	__asm        je     _T74d;
// LINE 3976:
	nextFineLocation.y += 0x1f0000;
// LINE 3977:
_T74d:
	__asm        jmp    _T7fb;
// LINE 3979:
_T752:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 2;
	__asm        je     _T769;
// LINE 3980:
	nextFineLocation.y += 0x1f0000;
// LINE 3981:
_T769:
	__asm        jmp    _T7fb;
// LINE 3983:
_T76e:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 8;
	__asm        je     _T785;
// LINE 3984:
	nextFineLocation.y += 0x1f0000;
// LINE 3985:
_T785:
	__asm        jmp    _T7fb;
// LINE 3990:
_T78a:
	nextFineLocation.y += 0x1f0000;
// LINE 3991:
	__asm        jmp    _T7fb;
// LINE 3993:
	__asm        jmp    _T7fb;
// LINE 3994:
	__asm        jmp    _T7fb;
_T7a0:
	__asm        cmp    dword ptr [ebp-0x64], 0x6B;
	__asm        jg     _T7dc;

	__asm        cmp    dword ptr [ebp-0x64], 0x6A;
	__asm        jge    _T78a;

	__asm        sub    dword ptr [ebp-0x64], 0x61;
	__asm        cmp    dword ptr [ebp-0x64], 3;
	__asm        ja     _T7fb;

	__asm        mov    eax, [ebp-0x64];
	__asm        jmp    _Switch_7cc[0][eax*4];
// Switch pointers:
//   _T752
//   _T736
//   _T76e
//   _T71a
_T7dc:
	__asm        cmp    dword ptr [ebp-0x64], 0x806A;
	__asm        jl     _T7fb;

	__asm        cmp    dword ptr [ebp-0x64], 0x806B;
	__asm        jle    _T78a;

	__asm        jmp    _T7fb;
// LINE 3998:
_T7fb:
	nextFineLocation.y += 0x1f0000;
// LINE 4002:
	this->directionVector.x = (nextFineLocation.x - this->autoDynomitor.loc.x);
// LINE 4003:
	this->directionVector.y = (nextFineLocation.y - this->autoDynomitor.loc.y);
// LINE 4004:
	this->directionVector.z = (nextFineLocation.z - this->autoDynomitor.loc.z);
// LINE 4005:
	this->currDist = MTNormalize((this + 0xa2));
// LINE 4010:
	MTCreateDOF4x4((this + 0xa2), (this + 0x30));
// LINE 4011:
	return;
}

// FUNCTION: COPTER_D 0x00508180
enum AutomobileClass::IntersectionTypes AutomobileClass::PickHiwayDir(/*packed*/ struct _GridCoordinates& point) {
	/*bp-0x4*/   unsigned short northTile;
	/*bp-0x8*/   long intersection;
	/*bp-0xc*/   unsigned short eastTile;
	/*bp-0x10*/  unsigned short currentTile;
	/*bp-0x14*/  unsigned short westTile;
	/*bp-0x18*/  unsigned short southTile;

// LINE 4045:
	__asm        mov    eax, point;
	__asm        mov    al, [eax];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD6], al;
// LINE 4046:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        dec    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0xD7], cl;
// LINE 4047:
	__asm        mov    eax, point;
	__asm        mov    al, [eax];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD8], al;
// LINE 4048:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        inc    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0xD9], cl;
// LINE 4049:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        inc    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0xDA], cl;
// LINE 4050:
	__asm        mov    eax, point;
	__asm        mov    al, [eax+1];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDB], al;
// LINE 4051:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        dec    ecx;
	__asm        mov    eax, this;
	__asm        mov    [eax+0xDC], cl;
// LINE 4052:
	__asm        mov    eax, point;
	__asm        mov    al, [eax+1];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDD], al;
// LINE 4055:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   ecx, ecx;
	__asm        jl     _Td2;

	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        test   ecx, ecx;
	__asm        jl     _Td2;

	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _Td2;

	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _Tdd;
_Td2:
	currentTile = 0x0;
	__asm        jmp    _T127;
_Tdd:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, point;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+1];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, point;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, point;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+1];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    currentTile, ax;
	__asm        jmp    _T127;
// LINE 4059:
_T127:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T14b;

	__asm        jmp    _T18d;

	__asm        jmp    _T367;

	__asm        jmp    _T18d;

	__asm        jmp    _T183;
_T14b:
	__asm        cmp    dword ptr [ebp-0x24], 0x806B;
	__asm        jg     _T367;

	__asm        cmp    dword ptr [ebp-0x24], 0x806A;
	__asm        jge    _T18d;

	__asm        cmp    dword ptr [ebp-0x24], 0x61;
	__asm        jl     _T367;

	__asm        cmp    dword ptr [ebp-0x24], 0x6B;
	__asm        jle    _T18d;

	__asm        jmp    _T367;

	__asm        jmp    _T367;
_T183:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T367;
// LINE 4064:
_T18d:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   ecx, 0xFE;
	__asm        jl     _T1db;

	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        test   ecx, 0xFE;
	__asm        jl     _T1db;

	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        and    cl, 0xFE;
	__asm        cmp    cl, 0x80;
	__asm        jae    _T1db;

	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        and    cl, 0xFE;
	__asm        cmp    cl, 0x80;
	__asm        jb     _T1e6;
_T1db:
	currentTile = 0x0;
	__asm        jmp    _T248;
_T1e6:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        and    ecx, 0xFE;
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, point;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+1];
	__asm        and    edx, 0xFE;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, point;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx];
	__asm        and    edx, 0xFE;
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, point;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+1];
	__asm        and    ebx, 0xFE;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    currentTile, ax;
	__asm        jmp    _T248;
// LINE 4067:
_T248:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   cl, 1;
	__asm        je     _T266;
// LINE 4068:
	this->westCell.x--;
// LINE 4069:
	__asm        jmp    _T26f;
// LINE 4070:
_T266:
	this->eastCell.x++;
// LINE 4071:
_T26f:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        test   cl, 1;
	__asm        je     _T28e;
// LINE 4072:
	this->northCell.y--;
// LINE 4073:
	__asm        jmp    _T297;
// LINE 4074:
_T28e:
	this->southCell.y++;
// LINE 4077:
_T297:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _T32f;
// LINE 4080:
_T2a7:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   cl, 1;
	__asm        jne    _T2c0;
// LINE 4081:
	this->eastCell.y++;
// LINE 4082:
_T2c0:
	__asm        jmp    _T367;
// LINE 4084:
_T2c5:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   cl, 1;
	__asm        jne    _T2de;
// LINE 4085:
	this->northCell.x++;
// LINE 4086:
_T2de:
	__asm        jmp    _T367;
// LINE 4088:
_T2e3:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   cl, 1;
	__asm        je     _T2fc;
// LINE 4089:
	this->southCell.x--;
// LINE 4090:
_T2fc:
	__asm        jmp    _T367;
// LINE 4092:
_T301:
	__asm        mov    eax, point;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   cl, 1;
	__asm        je     _T31a;
// LINE 4093:
	this->westCell.y--;
// LINE 4094:
_T31a:
	__asm        jmp    _T367;
// LINE 4097:
_T31f:
	westTile = 0x0;
// LINE 4098:
	__asm        jmp    _T367;
// LINE 4099:
	__asm        jmp    _T367;
_T32f:
	__asm        sub    dword ptr [ebp-0x28], 0x61;
	__asm        cmp    dword ptr [ebp-0x28], 7;
	__asm        ja     _T367;

	__asm        mov    eax, [ebp-0x28];
	__asm        jmp    _Switch_347[0][eax*4];
// Switch pointers:
//   _T31f
//   _T367
//   _T367
//   _T367
//   _T2a7
//   _T2e3
//   _T301
//   _T2c5
// LINE 4103:
_T367:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD6];
	__asm        test   ecx, ecx;
	__asm        jl     _T3bb;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD7];
	__asm        test   ecx, ecx;
	__asm        jl     _T3bb;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD6];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T3bb;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD7];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T3c6;
_T3bb:
	northTile = 0x0;
	__asm        jmp    _T41e;
_T3c6:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD6];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD7];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD6];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD7];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    northTile, ax;
	__asm        jmp    _T41e;
// LINE 4104:
_T41e:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD8];
	__asm        test   ecx, ecx;
	__asm        jl     _T472;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD9];
	__asm        test   ecx, ecx;
	__asm        jl     _T472;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD8];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T472;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD9];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T47d;
_T472:
	southTile = 0x0;
	__asm        jmp    _T4d5;
_T47d:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD8];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD9];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xD8];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xD9];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    southTile, ax;
	__asm        jmp    _T4d5;
// LINE 4105:
_T4d5:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDA];
	__asm        test   ecx, ecx;
	__asm        jl     _T529;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDB];
	__asm        test   ecx, ecx;
	__asm        jl     _T529;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDA];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T529;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDB];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T534;
_T529:
	eastTile = 0x0;
	__asm        jmp    _T58c;
_T534:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDA];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xDB];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xDA];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xDB];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    eastTile, ax;
	__asm        jmp    _T58c;
// LINE 4106:
_T58c:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDC];
	__asm        test   ecx, ecx;
	__asm        jl     _T5e0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDD];
	__asm        test   ecx, ecx;
	__asm        jl     _T5e0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDC];
	__asm        cmp    ecx, 0x80;
	__asm        jge    _T5e0;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDD];
	__asm        cmp    ecx, 0x80;
	__asm        jl     _T5eb;
_T5e0:
	westTile = 0x0;
	__asm        jmp    _T643;
_T5eb:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDC];
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xDD];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xDC];
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xDD];
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    westTile, ax;
	__asm        jmp    _T643;
// LINE 4112:
_T643:
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T734;
// LINE 4116:
_T653:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDC];
	__asm        test   ecx, 0xFE;
	__asm        jl     _T6af;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDD];
	__asm        test   ecx, 0xFE;
	__asm        jl     _T6af;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDC];
	__asm        and    cl, 0xFE;
	__asm        cmp    cl, 0x80;
	__asm        jae    _T6af;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDD];
	__asm        and    cl, 0xFE;
	__asm        cmp    cl, 0x80;
	__asm        jb     _T6ba;
_T6af:
	westTile = 0x0;
	__asm        jmp    _T72a;
_T6ba:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xDC];
	__asm        and    ecx, 0xFE;
	__asm        mov    eax, BitsMap[ecx*4];
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xDD];
	__asm        and    edx, 0xFE;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+edx];
	__asm        and    ecx, 2;
	__asm        movsx  eax, cx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+0xDC];
	__asm        and    edx, 0xFE;
	__asm        mov    ecx, BuildMap[edx*4];
	__asm        mov    edx, this;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [edx+0xDD];
	__asm        and    ebx, 0xFE;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+ebx];
	__asm        or     eax, edx;
	__asm        mov    westTile, ax;
	__asm        jmp    _T72a;
// LINE 4117:
_T72a:
	__asm        jmp    _T74d;
// LINE 4118:
	__asm        jmp    _T74d;
_T734:
	__asm        cmp    dword ptr [ebp-0x2C], 0x6A;
	__asm        jl     _T74d;

	__asm        cmp    dword ptr [ebp-0x2C], 0x6B;
	__asm        jle    _T653;

	__asm        jmp    _T74d;
// LINE 4123:
_T74d:
	intersection = 0x0;
// LINE 4127:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 1;
	__asm        je     _T7c3;
// LINE 4130:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T782;
// LINE 4132:
	__asm        or     intersection, 1;
// LINE 4134:
_T782:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T7a0;
// LINE 4136:
	__asm        or     intersection, 2;
// LINE 4138:
_T7a0:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T7be;
// LINE 4140:
	__asm        or     intersection, 4;
// LINE 4143:
_T7be:
	__asm        jmp    _T917;
_T7c3:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 4;
	__asm        je     _T832;
// LINE 4146:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T7f1;
// LINE 4148:
	__asm        or     intersection, 1;
// LINE 4150:
_T7f1:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T80f;
// LINE 4152:
	__asm        or     intersection, 2;
// LINE 4154:
_T80f:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T82d;
// LINE 4156:
	__asm        or     intersection, 4;
// LINE 4159:
_T82d:
	__asm        jmp    _T917;
_T832:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 2;
	__asm        je     _T8a1;
// LINE 4162:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T860;
// LINE 4164:
	__asm        or     intersection, 1;
// LINE 4166:
_T860:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T87e;
// LINE 4168:
	__asm        or     intersection, 2;
// LINE 4170:
_T87e:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T89c;
// LINE 4172:
	__asm        or     intersection, 4;
// LINE 4175:
_T89c:
	__asm        jmp    _T917;
_T8a1:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 8;
	__asm        je     _T910;
// LINE 4178:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T8cf;
// LINE 4180:
	__asm        or     intersection, 1;
// LINE 4182:
_T8cf:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T8ed;
// LINE 4184:
	__asm        or     intersection, 2;
// LINE 4186:
_T8ed:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::DoHiwayTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T90b;
// LINE 4188:
	__asm        or     intersection, 4;
// LINE 4191:
_T90b:
	__asm        jmp    _T917;
// LINE 4193:
_T910:
	return 0x0;
// LINE 4200:
_T917:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x69;
	__asm        jne    _T945;
// LINE 4202:
	__asm        test   reinterpret_cast<uint8_t>(intersection), 1;
	__asm        je     _T93e;
// LINE 4203:
	intersection = 0x1;
// LINE 4204:
	__asm        jmp    _T945;
// LINE 4205:
_T93e:
	intersection = 0x0;
// LINE 4216:
_T945:
	return intersection;
// LINE 4217:
}

// FUNCTION: COPTER_D 0x00508ad4
void AutomobileClass::MakeAHiwayTurn(enum AutomobileClass::IntersectionTypes intersectionType) {
// LINE 4237:
	__asm        mov    eax, intersectionType;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T18e;
// LINE 4241:
_T17:
	this->AutomobileClass::UnPlaceCar();
// LINE 4242:
	__asm        jmp    _T1e3;
// LINE 4246:
_T24:
	this->AutomobileClass::GoStraight();
// LINE 4248:
	__asm        jmp    _T1e3;
// LINE 4252:
_T31:
	this->AutomobileClass::TurnLeft();
// LINE 4254:
	__asm        jmp    _T1e3;
// LINE 4258:
_T3e:
	this->AutomobileClass::TurnRight();
// LINE 4260:
	__asm        jmp    _T1e3;
// LINE 4264:
_T4b:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T68;
// LINE 4266:
	this->AutomobileClass::TurnLeft();
// LINE 4268:
	__asm        jmp    _T70;
// LINE 4270:
_T68:
	this->AutomobileClass::GoStraight();
// LINE 4273:
_T70:
	__asm        jmp    _T1e3;
// LINE 4277:
_T75:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T92;
// LINE 4279:
	this->AutomobileClass::TurnLeft();
// LINE 4281:
	__asm        jmp    _T9a;
// LINE 4283:
_T92:
	this->AutomobileClass::TurnRight();
// LINE 4286:
_T9a:
	__asm        jmp    _T1e3;
// LINE 4290:
_T9f:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _Tbc;
// LINE 4292:
	this->AutomobileClass::TurnRight();
// LINE 4294:
	__asm        jmp    _Tc4;
// LINE 4296:
_Tbc:
	this->AutomobileClass::GoStraight();
// LINE 4299:
_Tc4:
	__asm        jmp    _T1e3;
// LINE 4303:
_Tc9:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0xC], edx;
	__asm        jmp    _T133;
// LINE 4305:
_Te1:
	this->AutomobileClass::GoStraight();
	__asm        jmp    _T156;
// LINE 4306:
_Tee:
	this->AutomobileClass::TurnLeft();
	__asm        jmp    _T156;
// LINE 4307:
_Tfb:
	this->AutomobileClass::TurnRight();
	__asm        jmp    _T156;
// LINE 4308:
_T108:
	_assert(0x10d4, 0x5b56dc, 0x5b5700);
	__asm        jmp    _T129;

	__asm        jmp    _T129;
_T129:
	__asm        jmp    _T156;
// LINE 4309:
	__asm        jmp    _T156;
_T133:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Te1;

	__asm        cmp    dword ptr [ebp-0xC], 1;
	__asm        je     _Tee;

	__asm        cmp    dword ptr [ebp-0xC], 2;
	__asm        je     _Tfb;

	__asm        jmp    _T108;
// LINE 4311:
_T156:
	__asm        jmp    _T1e3;
// LINE 4315:
_T15b:
	this->AutomobileClass::UnPlaceCar();
// LINE 4316:
	__asm        jmp    _T1e3;
// LINE 4322:
_T168:
	_assert(0x10e2, 0x5b5708, 0x5b572c);
	__asm        jmp    _T189;

	__asm        jmp    _T189;
// LINE 4324:
_T189:
	__asm        jmp    _T1e3;
_T18e:
	__asm        cmp    dword ptr [ebp-8], 0x10;
	__asm        ja     _T168;

	__asm        mov    eax, [ebp-8];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, _SwitchTable_1d2[0][eax];
	__asm        jmp    _Switch_1aa[0][ecx*4];
// Switch pointers:
//   _T17
//   _T24
//   _T31
//   _T4b
//   _T3e
//   _T9f
//   _T75
//   _Tc9
//   _T15b
//   _T168
// Switch table
//  [0, 1, 2, 3, 4, 5, 6, 7, 9, 9, 9, 9, 9, 9, 9, 9, 8]
// LINE 4325:
_T1e3:
	return;
}

// FUNCTION: COPTER_D 0x00508cc3
void AutomobileClass::GoStraight() {
// LINE 4347:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 1;
	__asm        je     _T35;
// LINE 4350:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD6];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4352:
	__asm        jmp    _Td1;
_T35:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 4;
	__asm        je     _T5e;
// LINE 4355:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4357:
	__asm        jmp    _Td1;
_T5e:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 2;
	__asm        je     _T87;
// LINE 4360:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDA];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4362:
	__asm        jmp    _Td1;
_T87:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 8;
	__asm        je     _Tb0;
// LINE 4365:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4367:
	__asm        jmp    _Td1;
// LINE 4369:
_Tb0:
	_assert(0x1111, 0x5b5734, 0x5b5758);
	__asm        jmp    _Td1;

	__asm        jmp    _Td1;
// LINE 4371:
_Td1:
	return;
}

// FUNCTION: COPTER_D 0x00508d9e
void AutomobileClass::TurnLeft() {
// LINE 4393:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 1;
	__asm        je     _T35;
// LINE 4396:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4398:
	__asm        jmp    _Td1;
_T35:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 4;
	__asm        je     _T5e;
// LINE 4401:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDA];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4403:
	__asm        jmp    _Td1;
_T5e:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 2;
	__asm        je     _T87;
// LINE 4406:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD6];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4408:
	__asm        jmp    _Td1;
_T87:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 8;
	__asm        je     _Tb0;
// LINE 4411:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4413:
	__asm        jmp    _Td1;
// LINE 4415:
_Tb0:
	_assert(0x113f, 0x5b5760, 0x5b5784);
	__asm        jmp    _Td1;

	__asm        jmp    _Td1;
// LINE 4418:
_Td1:
	return;
}

// FUNCTION: COPTER_D 0x00508e79
void AutomobileClass::TurnRight() {
// LINE 4440:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 1;
	__asm        je     _T35;
// LINE 4443:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDA];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4446:
	__asm        jmp    _Td1;
_T35:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 4;
	__asm        je     _T5e;
// LINE 4449:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4452:
	__asm        jmp    _Td1;
_T5e:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 2;
	__asm        je     _T87;
// LINE 4455:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4458:
	__asm        jmp    _Td1;
_T87:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xCE], 8;
	__asm        je     _Tb0;
// LINE 4461:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD6];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4464:
	__asm        jmp    _Td1;
// LINE 4466:
_Tb0:
	_assert(0x1172, 0x5b578c, 0x5b57b0);
	__asm        jmp    _Td1;

	__asm        jmp    _Td1;
// LINE 4469:
_Td1:
	return;
}

// FUNCTION: COPTER_D 0x00508f54
void AutomobileClass::MoveForwardOnHiway() {
	/*bp-0x4*/   int32_t distance;

// LINE 4490:
	__asm        mov    eax, LoopTime;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    distance, eax;
// LINE 4492:
	__asm        mov    eax, this;
	__asm        mov    ecx, distance;
	__asm        cmp    [eax+0xEA], ecx;
	__asm        jge    _T45;
// LINE 4493:
	distance = this->currDist;
// LINE 4494:
_T45:
	__asm        xor    eax, eax;
	__asm        sub    eax, distance;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0xEA], eax;
// LINE 4501:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA2];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x24], eax;
// LINE 4502:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA6];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x28], eax;
// LINE 4503:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xAA];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x2C], eax;
// LINE 4506:
	return;
}

// FUNCTION: COPTER_D 0x00509007
int32_t S3AutoMIFFLoad(void * __ptr32 miffReader) {
// LINE 4518:
	return AutomobileClass::MIFFLoad(miffReader);
// LINE 4519:
}

// FUNCTION: COPTER_D 0x00509023
int32_t S3AutoMIFFSave(void * __ptr32 miffWriter) {
// LINE 4531:
	return AutomobileClass::MIFFSave(miffWriter);
// LINE 4532:
}

// FUNCTION: COPTER_D 0x0050903f
int32_t AutomobileClass::MIFFLoad(void * __ptr32 miffReader) {
	/*bp-0x4*/   int32_t ret;
	/*bp-0x8*/   int32_t i;

// LINE 4549:
	ret = ReadFirstMIFFChunk(0x344, 0x608c28, 0x4155544f, miffReader);
// LINE 4550:
	__asm        cmp    ret, 0;
	__asm        jne    _FOR_44;
// LINE 4551:
	return 0x0;
// LINE 4553:
_FOR_44:
	for (i = 0x0; (i < 0x46); i++) {
		// LINE 4555:
			__asm        push   0x608C28;
			__asm        mov    eax, i;
			__asm        mov    ecx, i;
			__asm        mov    ecx, cars[0][ecx*4];
			__asm        mov    edx, [ecx];
			__asm        mov    ecx, cars[0][eax*4];
			__asm        call   dword ptr [edx+0x18];
		// LINE 4561:
			ret = ReadNextMIFFChunk(0x344, 0x608c28, 0x4155544f, miffReader);
		// LINE 4563:
			__asm        cmp    ret, 0;
			__asm        jne    _Ta8;

			__asm        cmp    i, 0x45;
			__asm        je     _Ta8;
		// LINE 4564:
			return 0x0;
		// LINE 4565:
		_Ta8:
	}
// LINE 4566:
_Tad:
	return 0x1;
// LINE 4567:
}

// FUNCTION: COPTER_D 0x005090fb
int32_t AutomobileClass::MIFFSave(void * __ptr32 miffWriter) {
	/*bp-0x4*/   int32_t ret;
	/*bp-0x8*/   int32_t i;

// LINE 4580:
_FOR_15:
	for (i = 0x0; (i < 0x46); i++) {
		// LINE 4583:
			__asm        push   0x608C28;
			__asm        mov    eax, i;
			__asm        mov    ecx, i;
			__asm        mov    ecx, cars[0][ecx*4];
			__asm        mov    edx, [ecx];
			__asm        mov    ecx, cars[0][eax*4];
			__asm        call   dword ptr [edx+0x14];
		// LINE 4588:
			ret = WriteMIFFChunk(0x344, 0x608c28, 0x4155544f, miffWriter);
		// LINE 4589:
			__asm        cmp    ret, 0;
			__asm        jne    _T6f;
		// LINE 4590:
			return 0x0;
		// LINE 4591:
		_T6f:
	}
// LINE 4592:
_T74:
	return 0x1;
// LINE 4593:
}

// FUNCTION: COPTER_D 0x0050917e
void AutomobileClass::SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE *sd) {
// LINE 4605:
	sd->flags = this->flags;
// LINE 4606:
	__asm        mov    esi, this;
	__asm        mov    edi, sd;
	__asm        add    edi, 4;
	__asm        add    esi, 0xC;
	__asm        mov    ecx, 0x19;
	__asm        rep movsd;
// LINE 4607:
	__asm        mov    esi, this;
	__asm        mov    edi, sd;
	__asm        add    edi, 0x68;
	__asm        add    esi, 0x70;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 4608:
	sd->DeltaFromCenter = this->DeltaFromCenter;
// LINE 4609:
	sd->stalledTimer = this->stalledTimer;
// LINE 4610:
	__asm        mov    eax, this;
	__asm        add    eax, 0xA2;
	__asm        mov    ecx, sd;
	__asm        add    ecx, 0x9C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4611:
	sd->remainingTime = this->remainingTime;
// LINE 4612:
	sd->desiredSpeed = this->desiredSpeed;
// LINE 4613:
	sd->desiredHiwaySpeed = this->desiredHiwaySpeed;
// LINE 4614:
	sd->beamDelay = this->beamDelay;
// LINE 4615:
	sd->beamTimer = this->beamTimer;
// LINE 4616:
	sd->m_cellBaseY = this->m_cellBaseY;
// LINE 4617:
	sd->timePulledOver = this->timePulledOver;
// LINE 4618:
	sd->hiwaydir = this->hiwaydir;
// LINE 4619:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD2];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0xC8], ax;
// LINE 4620:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD4];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0xCA], ax;
// LINE 4621:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD6];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0xCC], ax;
// LINE 4622:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDA];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0xD0], ax;
// LINE 4623:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xDC];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0xD2], ax;
// LINE 4624:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD8];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0xCE], ax;
// LINE 4625:
	sd->speed = this->speed;
// LINE 4626:
	sd->prevDir = this->prevDir;
// LINE 4627:
	sd->turnIndex = this->turnIndex;
// LINE 4628:
	sd->currDist = this->currDist;
// LINE 4629:
	sd->legOfTurn = this->legOfTurn;
// LINE 4630:
	sd->personDone = this->personDone;
// LINE 4631:
	sd->personState = this->personState;
// LINE 4632:
	sd->personTimer = this->personTimer;
// LINE 4633:
	sd->timeToLive = this->timeToLive;
// LINE 4634:
	sd->fireTime = this->fireTime;
// LINE 4635:
	sd->fireSeq = this->fireSeq;
// LINE 4636:
	sd->missionId = this->missionId;
// LINE 4637:
	sd->spotlightHitCounter = this->spotlightHitCounter;
// LINE 4639:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T2ff;
// LINE 4641:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x70];
	__asm        mov    al, [eax];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x92], al;
// LINE 4642:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x70];
	__asm        mov    al, [eax+1];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x93], al;
// LINE 4643:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF2];
	__asm        mov    ecx, sd;
	__asm        add    ecx, 0x9C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4646:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 8;
	__asm        je     _T2ee;
// LINE 4648:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0xD2];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x108], ax;
// LINE 4650:
	__asm        jmp    _T2ff;
// LINE 4652:
_T2ee:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x7C];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x108], ax;
// LINE 4655:
_T2ff:
	return;
}

// FUNCTION: COPTER_D 0x00509489
void AutomobileClass::LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE *sd) {
	/*bp-0x4*/   unsigned char yindex;

// LINE 4670:
	__asm        mov    eax, sd;
	__asm        test   byte ptr [eax], 2;
	__asm        jne    _T1d;
// LINE 4672:
	return;
// LINE 4675:
_T1d:
	this->flags = sd->flags;
// LINE 4676:
	__asm        mov    esi, sd;
	__asm        mov    edi, this;
	__asm        add    edi, 0x70;
	__asm        add    esi, 0x68;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 4677:
	this->DeltaFromCenter = sd->DeltaFromCenter;
// LINE 4678:
	this->stalledTimer = sd->stalledTimer;
// LINE 4679:
	__asm        mov    eax, sd;
	__asm        add    eax, 0x9C;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0xA2;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4680:
	this->remainingTime = sd->remainingTime;
// LINE 4681:
	this->desiredSpeed = sd->desiredSpeed;
// LINE 4682:
	this->desiredHiwaySpeed = sd->desiredHiwaySpeed;
// LINE 4683:
	this->beamDelay = sd->beamDelay;
// LINE 4684:
	this->beamTimer = sd->beamTimer;
// LINE 4685:
	this->m_cellBaseY = sd->m_cellBaseY;
// LINE 4686:
	this->timePulledOver = sd->timePulledOver;
// LINE 4687:
	this->hiwaydir = sd->hiwaydir;
// LINE 4688:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0xC8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD2], ax;
// LINE 4689:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0xCA];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD4], ax;
// LINE 4690:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0xCC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD6], ax;
// LINE 4691:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0xD0];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDA], ax;
// LINE 4692:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0xD2];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDC], ax;
// LINE 4693:
	__asm        mov    eax, sd;
	__asm        mov    ax, [eax+0xCE];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xD8], ax;
// LINE 4694:
	this->speed = sd->speed;
// LINE 4695:
	this->prevDir = sd->prevDir;
// LINE 4696:
	this->turnIndex = sd->turnIndex;
// LINE 4697:
	this->currDist = sd->currDist;
// LINE 4698:
	this->legOfTurn = sd->legOfTurn;
// LINE 4699:
	this->personDone = sd->personDone;
// LINE 4700:
	this->personState = sd->personState;
// LINE 4701:
	this->personTimer = sd->personTimer;
// LINE 4702:
	this->timeToLive = sd->timeToLive;
// LINE 4703:
	this->fireTime = sd->fireTime;
// LINE 4704:
	this->fireSeq = sd->fireSeq;
// LINE 4705:
	this->missionId = sd->missionId;
// LINE 4706:
	this->spotlightHitCounter = sd->spotlightHitCounter;
// LINE 4708:
	__asm        mov    eax, sd;
	__asm        add    eax, 0x1C;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x24;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4709:
	__asm        mov    esi, sd;
	__asm        mov    edi, this;
	__asm        add    edi, 0x30;
	__asm        add    esi, 0x28;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 4711:
	this->pDirVector = (this + 0xa2);
// LINE 4714:
	__asm        mov    eax, sd;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x93];
	__asm        push   ecx;
	__asm        mov    eax, sd;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x92];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    yindex, al;
// LINE 4715:
	__asm        mov    eax, sd;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x92];
	__asm        mov    eax, gRoadGraph.RGArray[0][ecx*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x70], eax;
// LINE 4717:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 8;
	__asm        je     _T39c;
// LINE 4718:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD3];
	__asm        mov    [ebp-0xC], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0xD2];
	__asm        mov    [ebp-0x10], ecx;
// LINE 4719:
	__asm        mov    eax, [ebp-0xC];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x10];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T370;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T375;
_T370:
	__asm        jmp    _T375;
_T375:
	__asm        jmp    _T37a;
_T37a:
	__asm        mov    eax, [ebp-8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 4720:
	__asm        mov    eax, this;
	__asm        add    eax, 0xD2;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 4722:
	__asm        jmp    _T41b;
// LINE 4723:
_T39c:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0x18], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x1C], ecx;
// LINE 4724:
	__asm        mov    eax, [ebp-0x18];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, [ebp-0x1C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        jne    _T3f6;

	_assert(0xa0, 0x5b57c4, 0x5b57b8);
	__asm        jmp    _T3fb;
_T3f6:
	__asm        jmp    _T3fb;
_T3fb:
	__asm        jmp    _T400;
_T400:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 4725:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::LinkToCell;
// LINE 4727:
_T41b:
	return;
}

// FUNCTION: COPTER_D 0x005098b0
void AutomobileClass::HonkHorn() {
// LINE 4740:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+9], 2;
	__asm        je     _T3d;
// LINE 4743:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0xF;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T38;
// LINE 4744:
	return;
// LINE 4746:
_T38:
	__asm        jmp    _T5c;
// LINE 4749:
_T3d:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0x3F;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T5c;
// LINE 4750:
	return;
// LINE 4753:
_T5c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xCA];
	__asm        push   eax;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T91;
// LINE 4755:
	S3DSPlay(0x0, (this + 0x24), this->hornSoundId);
// LINE 4759:
_T91:
	return;
}

// FUNCTION: COPTER_D 0x0050994b
void S3AutoSoundDistReset() {
// LINE 4773:
	AutomobileClass::fireSirenDist = 0x7800000;
// LINE 4774:
	AutomobileClass::policeSirenDist = 0x7800000;
// LINE 4775:
	AutomobileClass::ambSirenDist = 0x7800000;
// LINE 4776:
	AutomobileClass::fireHoseDist = 0x7800000;
// LINE 4777:
	return;
}

// FUNCTION: COPTER_D 0x00509983
void S3AutoSoundDriver() {
	/*bp-0x4*/   int32_t dist;
	/*bp-0x10*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x14*/  int32_t vol_adj;

// LINE 4794:
	dist = AutomobileClass::fireSirenDist;
// LINE 4795:
	__asm        cmp    dist, 0x7800000;
	__asm        jge    _T99;
// LINE 4797:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x5C;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4798:
	loc.z += dist;
// LINE 4800:
	__asm        push   0x12;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T61;
// LINE 4802:
	S3DSPlay(0x1, loc.x, 0x12);
// LINE 4805:
_T61:
	__asm        push   0xF0600000;
	__asm        push   0x7800000;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        mov    vol_adj, eax;
// LINE 4807:
	S3SoundAdjVol(vol_adj, 0x12);
// LINE 4809:
	__asm        jmp    _Tb6;
// LINE 4811:
_T99:
	__asm        push   0x12;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _Tb6;
// LINE 4813:
	S3DSStopPlay(0x12);
// LINE 4818:
_Tb6:
	dist = AutomobileClass::policeSirenDist;
// LINE 4819:
	__asm        cmp    dist, 0x7800000;
	__asm        jge    _T146;
// LINE 4821:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x5C;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4822:
	loc.z += dist;
// LINE 4824:
	__asm        push   0x13;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T10e;
// LINE 4826:
	S3DSPlay(0x1, loc.x, 0x13);
// LINE 4829:
_T10e:
	__asm        push   0xF0600000;
	__asm        push   0x7800000;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        mov    vol_adj, eax;
// LINE 4831:
	S3SoundAdjVol(vol_adj, 0x13);
// LINE 4833:
	__asm        jmp    _T163;
// LINE 4835:
_T146:
	__asm        push   0x13;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T163;
// LINE 4837:
	S3DSStopPlay(0x13);
// LINE 4842:
_T163:
	dist = AutomobileClass::ambSirenDist;
// LINE 4843:
	__asm        cmp    dist, 0x7800000;
	__asm        jge    _T1f3;
// LINE 4845:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x5C;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4846:
	loc.z += dist;
// LINE 4848:
	__asm        push   0x11;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T1bb;
// LINE 4850:
	S3DSPlay(0x1, loc.x, 0x11);
// LINE 4853:
_T1bb:
	__asm        push   0xF0600000;
	__asm        push   0x7800000;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        mov    vol_adj, eax;
// LINE 4855:
	S3SoundAdjVol(vol_adj, 0x11);
// LINE 4857:
	__asm        jmp    _T210;
// LINE 4859:
_T1f3:
	__asm        push   0x11;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T210;
// LINE 4861:
	S3DSStopPlay(0x11);
// LINE 4866:
_T210:
	dist = AutomobileClass::fireHoseDist;
// LINE 4867:
	__asm        cmp    dist, 0x7800000;
	__asm        jge    _T2a0;
// LINE 4869:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x5C;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4870:
	loc.z += dist;
// LINE 4872:
	__asm        push   0x14;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T268;
// LINE 4874:
	S3DSPlay(0x1, loc.x, 0x14);
// LINE 4877:
_T268:
	__asm        push   0xF0600000;
	__asm        push   0x7800000;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        mov    vol_adj, eax;
// LINE 4879:
	S3SoundAdjVol(vol_adj, 0x14);
// LINE 4881:
	__asm        jmp    _T2bd;
// LINE 4883:
_T2a0:
	__asm        push   0x14;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T2bd;
// LINE 4885:
	S3DSStopPlay(0x14);
// LINE 4890:
_T2bd:
	dist = AutomobileClass::fireHoseDist;
// LINE 4891:
	__asm        cmp    dist, 0x7800000;
	__asm        jge    _T34d;
// LINE 4893:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x5C;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 4894:
	loc.z += dist;
// LINE 4896:
	__asm        push   0x14;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T315;
// LINE 4898:
	S3DSPlay(0x1, loc.x, 0x14);
// LINE 4901:
_T315:
	__asm        push   0xF0600000;
	__asm        push   0x7800000;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        mov    vol_adj, eax;
// LINE 4903:
	S3SoundAdjVol(vol_adj, 0x14);
// LINE 4905:
	__asm        jmp    _T36a;
// LINE 4907:
_T34d:
	__asm        push   0x14;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T36a;
// LINE 4909:
	S3DSStopPlay(0x14);
// LINE 4912:
_T36a:
	return;
}

// FUNCTION: COPTER_D 0x00509cf7
void AutomobileClass::ChangeAutoColor() {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  int32_t newbase;
	/*bp-0x2c*/  int32_t face;
	/*bp-0x30*/  int32_t color;
	/*bp-0x34*/  int32_t count;
	/*bp-0x54*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes
	/*bp-0x58*/  int32_t index;
	/*bp-0x5c*/  int32_t base;

// LINE 4935:
	__asm        call   rand;
	__asm        mov    ecx, 0xD;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 4;
	__asm        add    eax, 0x10;
	__asm        mov    newbase, eax;
// LINE 4938:
	__asm        cmp    newbase, 0x30;
	__asm        jne    _T4c;
// LINE 4939:
	__asm        call   rand;
	__asm        mov    ecx, 5;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 4;
	__asm        add    eax, 0x10;
	__asm        add    newbase, eax;
// LINE 4941:
_T4c:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 4942:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 4943:
_FOR_7d:
	for (count = 0x0; (oinfo.Faces > count); count++) {
		// LINE 4945:
			__asm        lea    eax, finfo.Face;
			__asm        push   eax;
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D6905;
			__asm        add    esp, 8;
		// LINE 4946:
			__asm        cmp    finfo.Plotter, 0xF;
			__asm        jne    _T29d;
		// LINE 4949:
			color = finfo.Bitmap;
		// LINE 4950:
			base = (color & -0x10);
		// LINE 4951:
			index = (color & 0xf);
		// LINE 4955:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    [ebp-0x64], eax;
			__asm        jmp    _T1ab;
		// LINE 4958:
		_Tcc:
			__asm        cmp    base, 0x80;
			__asm        jne    _Tec;
		// LINE 4959:
			VRFaceSetColor((newbase + index), face);
		// LINE 4960:
		_Tec:
			__asm        jmp    _T29d;
		// LINE 4962:
		_Tf1:
			__asm        cmp    base, 0x80;
			__asm        jne    _T111;
		// LINE 4963:
			VRFaceSetColor((newbase + index), face);
		// LINE 4964:
		_T111:
			__asm        jmp    _T29d;
		// LINE 4966:
		_T116:
			__asm        cmp    base, 0x50;
			__asm        jne    _T133;
		// LINE 4967:
			VRFaceSetColor((newbase + index), face);
		// LINE 4968:
		_T133:
			__asm        jmp    _T29d;
		// LINE 4970:
		_T138:
			__asm        cmp    base, 0x50;
			__asm        jne    _T155;
		// LINE 4971:
			VRFaceSetColor((newbase + index), face);
		// LINE 4972:
		_T155:
			__asm        jmp    _T29d;
		// LINE 4974:
		_T15a:
			__asm        cmp    base, 0xA0;
			__asm        jne    _T17a;
		// LINE 4975:
			VRFaceSetColor((newbase + index), face);
		// LINE 4976:
		_T17a:
			__asm        jmp    _T29d;
		// LINE 4978:
		_T17f:
			__asm        cmp    base, 0x30;
			__asm        jne    _T19c;
		// LINE 4979:
			VRFaceSetColor((newbase + index), face);
		// LINE 4980:
		_T19c:
			__asm        jmp    _T29d;
		// LINE 4982:
		_T1a1:
			__asm        jmp    _T29d;
		// LINE 4983:
			__asm        jmp    _T29d;
		_T1ab:
			__asm        sub    dword ptr [ebp-0x64], 0x7A;
			__asm        cmp    dword ptr [ebp-0x64], 0xB2;
			__asm        ja     _T29d;

			__asm        mov    eax, [ebp-0x64];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, _SwitchTable_1ea[0][eax];
			__asm        jmp    _Switch_1ce[0][ecx*4];
		// Switch pointers:
		//   _Tcc
		//   _T116
		//   _T15a
		//   _Tf1
		//   _T17f
		//   _T138
		//   _T1a1
		// Switch table
		//  [0, 6, 6, 1, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 5]
		// LINE 4986:
		_T29d:
			__asm        mov    eax, face;
			__asm        push   eax;
			__asm        call   0x004D85F8;
			__asm        add    esp, 4;
			__asm        mov    face, eax;
	}
// LINE 4988:
_T2b1:
	return;
}



// Contribution: 1:00108fc0-00108ff8 Module: 171, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00509fc0
// AutomobileClass::`scalar deleting destructor'



// Contribution: 2:00003cc0-00003d97 Module: 171, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x00592cc0
static const enum DirIndex2 TurnTable2[4][4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00592d00
static const enum DirectionTypes IndexToType[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00592d10
static const enum TurnIndex TILUT[4][4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00592d50
static const /*packed*/ struct _dPoint2d OT[4] = { 0 /* todo */ };



// Contribution: 2:00003d98-00003dbb Module: 171, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for AutomobileClass @ 0x00592d98
//   00: AutomobileClass::`scalar deleting destructor' @ 0x00509fc0
//   01: AutomobileClass::PullOver @ 0x005048cd
//   02: AutomobileClass::AdjustSpeed @ 0x0050409a
//   03: AutomobileClass::PickTurnDir @ 0x00502c92
//   04: AutomobileClass::ItterateFSM @ 0x005022b0
//   05: AutomobileClass::SetSaveData @ 0x0050917e
//   06: AutomobileClass::LoadSaveData @ 0x00509489
//   07: AutomobileClass::BeamToWithinCameraRange @ 0x00502f11
//   08: AutomobileClass::BeamToLocation @ 0x005030aa
//   9 entries



// Contribution: 3:0001e2c4-0001e7b5 Module: 171, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b52c4
static int32_t lastSpeederID = 32000;

// GLOBAL: COPTER_D 0x005b52c8
int32_t curAutos = 50;



// Contribution: 3:0001e7b8-0001e7c3 Module: 171, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "cellPointer"


// Contribution: 3:0001e7c4-0001e7e4 Module: 171, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "C:\Copter\source\game\S3MOBILE.H"


// Contribution: 3:0001e7e8-0001e9cf Module: 171, 8 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005b57e8
/*packed*/ struct CONNECTION_INFO_TYPE connections[61] = { 0 /* todo */ };



// Contribution: 3:00071c28-00072097 Module: 171, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00608c28
static /*packed*/ struct _AUTO_LOAD_SAVE S_autols;

// GLOBAL: COPTER_D 0x00608f6c
int32_t AutomobileClass::fireHoseDist;

// GLOBAL: COPTER_D 0x00608f70
int32_t AutomobileClass::ambSirenDist;

// GLOBAL: COPTER_D 0x00608f74
int32_t AutomobileClass::policeSirenDist;

// GLOBAL: COPTER_D 0x00608f78
int32_t AutomobileClass::fireSirenDist;

// GLOBAL: COPTER_D 0x00608f80
/*packed*/ class AutomobileClass *cars[70];
// has alternate definitions: (original TI: 0x3167)
//   /*packed*/ class AutomobileClass *cars[1] (TI: 0x4204)

