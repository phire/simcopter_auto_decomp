// Module: S3map.obj
// Source: C:\Copter\source\game\S3map.c
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: /*packed*/ struct Point2d;
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct _dPoint2d (forward reference);
struct _dPoint2d{ // packed(0x10 bytes) TI: 0x2766
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double z; // 0x8 bytes
};

// Type: /*packed*/ struct VRwindowType;
struct VRwindowType{ // packed(0x1c bytes) TI: 0x10a5
	/*+0x0*/   int32_t WindowX;
	/*+0x4*/   int32_t WindowY;
	/*+0x8*/   int32_t WindowWide;
	/*+0xc*/   int32_t WindowHigh;
	/*+0x10*/  int32_t RenderMode;
	/*+0x14*/  int32_t RenderWide;
	/*+0x18*/  int32_t RenderHigh;
};

// Type: long;

// Type: char *;

// Type: char;

// Type: /*packed*/ struct VRBmpHdr (forward reference);
struct VRBmpHdr{ // packed(0x10 bytes) TI: 0x2312
	/*+0x0*/   /*packed*/ struct VRBmpInfo info; // 0xc bytes
	/*+0xc*/   int32_t ScanOffset[1];
};

// Type: void;

// Type: unsigned short;

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: long *;

// Type: /*packed*/ struct _MAP_CARINFO (forward reference);
struct _MAP_CARINFO{ // packed(0x28 bytes) TI: 0x31c6
	/*+0x0*/   long flags;
	/*+0x4*/   long car_id;
	/*+0x8*/   long car_type;
	/*+0xc*/   long mission_id;
	/*+0x10*/  /*packed*/ struct _GridCoordinates *currpos;
	/*+0x14*/  /*packed*/ struct _GridCoordinates *disppos;
	/*+0x18*/  long top;
	/*+0x1c*/  long bottom;
	/*+0x20*/  long left;
	/*+0x24*/  long right;
};

// Type: /*packed*/ struct MISSION_DATA (forward reference);
struct MISSION_DATA{ // packed(0xd4 bytes) TI: 0x31c4
	/*+0x0*/   char mtext[32]; // 0x20 bytes
	/*+0x20*/  long type_ctr;
	/*+0x24*/  long key;
	/*+0x28*/  /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x30*/  /*packed*/ struct Point2d destmaploc; // 0x8 bytes
	/*+0x38*/  /*packed*/ struct Point2d pickuploc; // 0x8 bytes
	/*+0x40*/  int32_t timer;
	/*+0x44*/  long money_bonus;
	/*+0x48*/  long points_bonus;
	/*+0x4c*/  long flags;
	/*+0x50*/  long type;
	/*+0x54*/  long state;
	/*+0x58*/  /*packed*/ struct __unnamed mdata; // 0x7c bytes
};

// Type: /*packed*/ struct _GridCoordinates (forward reference);
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};



// Contribution: 1:000fd790-001005d5 Module: 172, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004fe790
void S3MapInit() {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   /*packed*/ struct VRBmpHdr *bhdr;
	/*bp-0xc*/   long i;

// LINE 192:
	S_mapmin.x = 0x40;
// LINE 193:
	S_mapmin.y = 0x16;
// LINE 194:
	S_mapmax.x = (S_mapmin.x + 0x68);
// LINE 195:
	S_mapmax.y = (S_mapmin.y + 0x50);
// LINE 199:
	S_dirlen = 0x14;
// LINE 202:
	S_mapdimx = (S_mapmax.x - S_mapmin.x);
// LINE 203:
	S_mapdimy = (S_mapmax.y - S_mapmin.y);
// LINE 206:
	S_bordermin.x = (S_mapmin.x - 0xa);
// LINE 207:
	S_bordermin.y = (S_mapmin.y - 0x9);
// LINE 208:
	S_bordermax.x = (S_mapmax.x + 0xa);
// LINE 209:
	S_bordermax.y = (S_mapmax.y + 0x9);
// LINE 212:
	S_borderdimx = (S_bordermax.x - S_bordermin.x);
// LINE 213:
	S_borderdimy = (S_bordermax.y - S_bordermin.y);
// LINE 215:
	S_borderbuf = S2AllocMem(MainPoolIndex, 0x5b529c, ((S_borderdimy * S_borderdimx) + 0x200));
// LINE 216:
	__asm        cmp    S_borderbuf, 0;
	__asm        jne    _Tf9;
// LINE 217:
	ERexit(0x5b52a4);
// LINE 219:
_Tf9:
	__asm        mov    eax, S_borderdimx;
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, S_borderbuf;
	__asm        add    eax, 0xA;
	__asm        mov    S_mapbuf, eax;
// LINE 221:
	__asm        mov    eax, S_borderdimy;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    ecx, eax;
	__asm        imul   ecx, S_borderdimx;
	__asm        mov    eax, S_borderdimx;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        add    ecx, eax;
	__asm        add    ecx, S_borderbuf;
	__asm        mov    S_mapbufctr, ecx;
// LINE 224:
	mwindow.WindowWide = S_mapdimx;
	mwindow.RenderWide = mwindow.WindowWide;
// LINE 225:
	mwindow.WindowHigh = S_mapdimy;
	mwindow.RenderHigh = mwindow.WindowHigh;
// LINE 228:
	bhdr = VRInt2BmpHdr(G_restex, 0x3);
// LINE 229:
	ptr = bhdr;
// LINE 230:
	ptr += ((bhdr->info.height << 0x2) + 0xc);
// LINE 234:
	S_icon_dim = bhdr->info.height;
// LINE 235:
	S_icon_pitch = bhdr->info.width;
// LINE 238:
_FOR_1ad:
	for (i = 0x0; (i < 0x8); i++) {
		// LINE 240:
			__asm        mov    eax, ptr;
			__asm        mov    ecx, i;
			__asm        mov    S_icons[ecx*4], eax;
		// LINE 241:
			ptr += S_icon_dim;
	}
// LINE 245:
_T1d4:
	bhdr = VRInt2BmpHdr(G_restex, 0xc);
// LINE 246:
	ptr = bhdr;
// LINE 247:
	ptr += ((bhdr->info.height << 0x2) + 0xc);
// LINE 251:
	S_dicon_dim = bhdr->info.height;
// LINE 252:
	S_dicon_pitch = bhdr->info.width;
// LINE 255:
_FOR_21d:
	for (i = 0x0; (i < 0x3); i++) {
		// LINE 257:
			__asm        mov    eax, ptr;
			__asm        mov    ecx, i;
			__asm        mov    S_dicons[ecx*4], eax;
		// LINE 258:
			ptr += S_dicon_dim;
	}
// LINE 262:
_FOR_250:
	for (i = 0x0; (i < 0x14); i++) {
		// LINE 264:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        mov    S_carinfo[0].flags[eax*8], 0;
	}
// LINE 267:
__RETURN:
}

// FUNCTION: COPTER_D 0x004fea08
void S3MapDestroy() {
// LINE 281:
}

// FUNCTION: COPTER_D 0x004fea13
void S3MapRender(long posx, long posy) {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   long x;
	/*bp-0xc*/   long y;
	/*bp-0x10*/  char texid;
	/*bp-0x14*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x18*/  unsigned short alt;
	/*bp-0x1c*/  char * lineptr;
	/*bp-0x20*/  long county;
	/*bp-0x24*/  long tile;
	/*bp-0x28*/  long countx;

// LINE 298:
	ptr = S_mapbuf;
// LINE 305:
	__asm        cmp    G_mapmode, 0;
	__asm        je     _T30;

	__asm        cmp    G_camera_mode, 3;
	__asm        je     _T30;
// LINE 306:
	return;
// LINE 308:
_T30:
	__asm        and    posy, 0xFF;
// LINE 309:
	__asm        and    posx, 0xFF;
// LINE 312:
	__asm        mov    edx, S_borderdimy;
	__asm        imul   edx, S_borderdimx;
	__asm        mov    edi, S_borderbuf;
	__asm        xor    eax, eax;
	__asm        mov    ecx, edx;
	__asm        shr    ecx, 2;
	__asm        rep stosd;
	__asm        mov    ecx, edx;
	__asm        and    ecx, 3;
	__asm        rep stosb;
// LINE 315:
	S_fire_cycle++;
// LINE 316:
	__asm        movsx  eax, S_fire_cycle;
	__asm        and    al, 0xF;
	__asm        mov    S_fire_cycle, al;
// LINE 318:
	__asm        mov    eax, S_mapzoom;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T176a;
// LINE 322:
_T82:
	S_ulc.x = (posx - (S_mapdimx >> 0x1));
// LINE 323:
	S_ulc.y = (posy - (S_mapdimy >> 0x1));
// LINE 324:
	__asm        mov    eax, S_ulc.x;
	__asm        add    eax, S_mapdimx;
	__asm        dec    eax;
	__asm        mov    S_lrc.x, eax;
// LINE 325:
	__asm        mov    eax, S_ulc.y;
	__asm        add    eax, S_mapdimy;
	__asm        dec    eax;
	__asm        mov    S_lrc.y, eax;
// LINE 327:
_FOR_de:
	y = S_ulc.y;
	county = 0x0;
	__asm        jmp    _FOR_COND_de;
_FOR_NEXT_de:
	county++;
	y++;
_FOR_COND_de:
	__asm        mov    eax, county;
	__asm        cmp    S_mapdimy, eax;
	__asm        jle    _T417;
// LINE 330:
	__asm        and    y, 0xFF;
// LINE 332:
_FOR_10e:
	x = S_ulc.x;
	countx = 0x0;
	__asm        jmp    _FOR_COND_10e;
_FOR_NEXT_10e:
	countx++;
	x++;
_FOR_COND_10e:
	__asm        mov    eax, countx;
	__asm        cmp    S_mapdimx, eax;
	__asm        jle    _T40e;
// LINE 335:
	__asm        and    x, 0xFF;
// LINE 338:
	__asm        cmp    x, 0x7F;
	__asm        jg     _T13e;

	__asm        cmp    y, 0x7F;
	__asm        jle    _T14a;
// LINE 340:
_T13e:
	tile = 0x0;
// LINE 342:
	__asm        jmp    _T15f;
// LINE 345:
_T14a:
	__asm        mov    eax, x;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, y;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        mov    tile, edx;
// LINE 351:
_T15f:
	__asm        mov    eax, x;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, y;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    cptr, eax;
// LINE 352:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _T1a2;
// LINE 354:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 355:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 358:
_T1a2:
	__asm        cmp    tile, 0xD1;
	__asm        jne    _T1bd;
// LINE 360:
	ptr[0] = 0xea;
	ptr++;
// LINE 361:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 363:
_T1bd:
	__asm        cmp    tile, 0xD2;
	__asm        jne    _T1d8;
// LINE 365:
	ptr[0] = 0x9a;
	ptr++;
// LINE 366:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 368:
_T1d8:
	__asm        cmp    tile, 0xD3;
	__asm        jne    _T1f3;
// LINE 370:
	ptr[0] = 0x1a;
	ptr++;
// LINE 371:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 374:
_T1f3:
	__asm        mov    eax, x;
	__asm        cmp    G_helibase.pad1.x, eax;
	__asm        jg     _T241;

	__asm        mov    eax, G_helibase.pad1.x;
	__asm        add    eax, 4;
	__asm        cmp    eax, x;
	__asm        jle    _T241;

	__asm        mov    eax, y;
	__asm        cmp    G_helibase.pad1.y, eax;
	__asm        jg     _T241;

	__asm        mov    eax, G_helibase.pad1.y;
	__asm        add    eax, 4;
	__asm        cmp    eax, y;
	__asm        jle    _T241;
// LINE 376:
	ptr[0] = 0xca;
	ptr++;
// LINE 377:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 381:
_T241:
	__asm        cmp    tile, 0xD;
	__asm        je     _T258;

	__asm        cmp    tile, 0xD5;
	__asm        jne    _T266;
// LINE 383:
_T258:
	ptr[0] = 0x5a;
	ptr++;
// LINE 384:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 388:
_T266:
	__asm        cmp    tile, 0x1D;
	__asm        jl     _T288;

	__asm        cmp    tile, 0x70;
	__asm        jge    _T288;
// LINE 390:
	ptr[0] = 0x33;
	ptr++;
// LINE 391:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 395:
_T288:
	__asm        cmp    tile, 0x70;
	__asm        jl     _T2a0;
// LINE 397:
	ptr[0] = 0x3a;
	ptr++;
// LINE 398:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 402:
_T2a0:
	__asm        mov    eax, y;
	__asm        mov    ecx, x;
	__asm        shl    ecx, 8;
	__asm        mov    al, G_texmap[0][eax+ecx];
	__asm        mov    texid, al;
// LINE 403:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jl     _T323;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x40;
	__asm        jge    _T323;
// LINE 405:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 406:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 407:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 409:
	__asm        jmp    _T409;
_T323:
	__asm        movsx  eax, texid;
	__asm        test   eax, eax;
	__asm        jl     _T34a;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0xA;
	__asm        jge    _T34a;
// LINE 411:
	ptr[0] = 0x90;
	ptr++;
// LINE 413:
	__asm        jmp    _T409;
_T34a:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x20;
	__asm        jl     _T3b8;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jge    _T3b8;
// LINE 415:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 416:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 417:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 419:
	__asm        jmp    _T409;
// LINE 421:
_T3b8:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 422:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 423:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 425:
_T409:
	__asm        jmp    _FOR_NEXT_10e;
// LINE 426:
_T40e:
	ptr += 0x14;
// LINE 427:
	__asm        jmp    _FOR_NEXT_de;
// LINE 428:
_T417:
	__asm        jmp    _T178e;
// LINE 432:
_T41c:
	S_ulc.x = (posx - (S_mapdimx >> 0x2));
// LINE 433:
	S_ulc.y = (posy - (S_mapdimy >> 0x2));
// LINE 434:
	__asm        mov    eax, S_ulc.x;
	__asm        mov    ecx, S_mapdimx;
	__asm        sar    ecx, 1;
	__asm        add    eax, ecx;
	__asm        dec    eax;
	__asm        mov    S_lrc.x, eax;
// LINE 435:
	__asm        mov    eax, S_ulc.y;
	__asm        mov    ecx, S_mapdimy;
	__asm        sar    ecx, 1;
	__asm        add    eax, ecx;
	__asm        dec    eax;
	__asm        mov    S_lrc.y, eax;
// LINE 437:
_FOR_482:
	y = S_ulc.y;
	county = 0x0;
	__asm        jmp    _FOR_COND_482;
_FOR_NEXT_482:
	county++;
	y++;
_FOR_COND_482:
	__asm        mov    eax, S_mapdimy;
	__asm        sar    eax, 1;
	__asm        cmp    eax, county;
	__asm        jle    _T87d;
// LINE 439:
	__asm        and    y, 0xFF;
// LINE 441:
	lineptr = ptr;
// LINE 443:
_FOR_4ba:
	x = S_ulc.x;
	countx = 0x0;
	__asm        jmp    _FOR_COND_4ba;
_FOR_NEXT_4ba:
	countx++;
	x++;
_FOR_COND_4ba:
	__asm        mov    eax, S_mapdimx;
	__asm        sar    eax, 1;
	__asm        cmp    eax, countx;
	__asm        jle    _T853;
// LINE 445:
	__asm        and    x, 0xFF;
// LINE 448:
	__asm        cmp    x, 0x7F;
	__asm        jg     _T4ec;

	__asm        cmp    y, 0x7F;
	__asm        jle    _T4f8;
// LINE 450:
_T4ec:
	tile = 0x0;
// LINE 452:
	__asm        jmp    _T50d;
// LINE 455:
_T4f8:
	__asm        mov    eax, x;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, y;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        mov    tile, edx;
// LINE 461:
_T50d:
	__asm        mov    eax, x;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, y;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    cptr, eax;
// LINE 462:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _T562;
// LINE 464:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 465:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 466:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 469:
_T562:
	__asm        cmp    tile, 0xD1;
	__asm        jne    _T586;
// LINE 471:
	ptr[0] = 0xea;
	ptr++;
// LINE 472:
	ptr[0] = 0xea;
	ptr++;
// LINE 473:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 475:
_T586:
	__asm        cmp    tile, 0xD2;
	__asm        jne    _T5aa;
// LINE 477:
	ptr[0] = 0x9a;
	ptr++;
// LINE 478:
	ptr[0] = 0x9a;
	ptr++;
// LINE 479:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 481:
_T5aa:
	__asm        cmp    tile, 0xD3;
	__asm        jne    _T5ce;
// LINE 483:
	ptr[0] = 0x1a;
	ptr++;
// LINE 484:
	ptr[0] = 0x1a;
	ptr++;
// LINE 485:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 488:
_T5ce:
	__asm        mov    eax, x;
	__asm        cmp    G_helibase.pad1.x, eax;
	__asm        jg     _T625;

	__asm        mov    eax, G_helibase.pad1.x;
	__asm        add    eax, 4;
	__asm        cmp    eax, x;
	__asm        jle    _T625;

	__asm        mov    eax, y;
	__asm        cmp    G_helibase.pad1.y, eax;
	__asm        jg     _T625;

	__asm        mov    eax, G_helibase.pad1.y;
	__asm        add    eax, 4;
	__asm        cmp    eax, y;
	__asm        jle    _T625;
// LINE 490:
	ptr[0] = 0xca;
	ptr++;
// LINE 491:
	ptr[0] = 0xca;
	ptr++;
// LINE 492:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 495:
_T625:
	__asm        cmp    tile, 0xD;
	__asm        je     _T63c;

	__asm        cmp    tile, 0xD5;
	__asm        jne    _T653;
// LINE 497:
_T63c:
	ptr[0] = 0x5a;
	ptr++;
// LINE 498:
	ptr[0] = 0x5a;
	ptr++;
// LINE 499:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 503:
_T653:
	__asm        cmp    tile, 0x1D;
	__asm        jl     _T67e;

	__asm        cmp    tile, 0x70;
	__asm        jge    _T67e;
// LINE 505:
	ptr[0] = 0x33;
	ptr++;
// LINE 506:
	ptr[0] = 0x33;
	ptr++;
// LINE 507:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 511:
_T67e:
	__asm        cmp    tile, 0x70;
	__asm        jl     _T69f;
// LINE 513:
	ptr[0] = 0x3a;
	ptr++;
// LINE 514:
	ptr[0] = 0x3a;
	ptr++;
// LINE 515:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 519:
_T69f:
	__asm        mov    eax, y;
	__asm        mov    ecx, x;
	__asm        shl    ecx, 8;
	__asm        mov    al, G_texmap[0][eax+ecx];
	__asm        mov    texid, al;
// LINE 520:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jl     _T737;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x40;
	__asm        jge    _T737;
// LINE 522:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 523:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 524:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 525:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 527:
	__asm        jmp    _T84e;
_T737:
	__asm        movsx  eax, texid;
	__asm        test   eax, eax;
	__asm        jl     _T767;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0xA;
	__asm        jge    _T767;
// LINE 529:
	ptr[0] = 0x90;
	ptr++;
// LINE 530:
	ptr[0] = 0x90;
	ptr++;
// LINE 532:
	__asm        jmp    _T84e;
_T767:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x20;
	__asm        jl     _T7e8;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jge    _T7e8;
// LINE 534:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 535:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 536:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 537:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 539:
	__asm        jmp    _T84e;
// LINE 541:
_T7e8:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 542:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 543:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 544:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 546:
_T84e:
	__asm        jmp    _FOR_NEXT_4ba;
// LINE 547:
_T853:
	ptr += 0x14;
// LINE 548:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 549:
	ptr += S_borderdimx;
// LINE 550:
	__asm        jmp    _FOR_NEXT_482;
// LINE 551:
_T87d:
	__asm        jmp    _T178e;
// LINE 555:
_T882:
	S_ulc.x = (posx - (S_mapdimx >> 0x3));
// LINE 556:
	S_ulc.y = (posy - (S_mapdimy >> 0x3));
// LINE 557:
	__asm        mov    eax, S_mapdimx;
	__asm        sar    eax, 2;
	__asm        add    eax, S_ulc.x;
	__asm        dec    eax;
	__asm        mov    S_lrc.x, eax;
// LINE 558:
	__asm        mov    eax, S_ulc.y;
	__asm        mov    ecx, S_mapdimy;
	__asm        sar    ecx, 2;
	__asm        add    eax, ecx;
	__asm        dec    eax;
	__asm        mov    S_lrc.y, eax;
// LINE 560:
_FOR_8e6:
	y = S_ulc.y;
	county = 0x0;
	__asm        jmp    _FOR_COND_8e6;
_FOR_NEXT_8e6:
	county++;
	y++;
_FOR_COND_8e6:
	__asm        mov    eax, S_mapdimy;
	__asm        sar    eax, 2;
	__asm        cmp    eax, county;
	__asm        jle    _Te6a;
// LINE 562:
	__asm        and    y, 0xFF;
// LINE 564:
	lineptr = ptr;
// LINE 566:
_FOR_91e:
	x = S_ulc.x;
	countx = 0x0;
	__asm        jmp    _FOR_COND_91e;
_FOR_NEXT_91e:
	countx++;
	x++;
_FOR_COND_91e:
	__asm        mov    eax, S_mapdimx;
	__asm        sar    eax, 2;
	__asm        cmp    eax, countx;
	__asm        jle    _Tdfb;
// LINE 568:
	__asm        and    x, 0xFF;
// LINE 570:
	__asm        mov    eax, posx;
	__asm        cmp    x, eax;
	__asm        jne    _T97d;

	__asm        mov    eax, posy;
	__asm        cmp    y, eax;
	__asm        jne    _T97d;
// LINE 572:
	ptr[0] = 0xe8;
	ptr++;
// LINE 573:
	ptr[0] = 0x70;
	ptr++;
// LINE 574:
	ptr[0] = 0x70;
	ptr++;
// LINE 575:
	ptr[0] = 0x70;
	ptr++;
// LINE 576:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 580:
_T97d:
	__asm        cmp    x, 0x7F;
	__asm        jg     _T991;

	__asm        cmp    y, 0x7F;
	__asm        jle    _T99d;
// LINE 582:
_T991:
	tile = 0x0;
// LINE 584:
	__asm        jmp    _T9b2;
// LINE 587:
_T99d:
	__asm        mov    eax, x;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, y;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        mov    tile, edx;
// LINE 593:
_T9b2:
	__asm        mov    eax, x;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, y;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    cptr, eax;
// LINE 594:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _Ta22;
// LINE 596:
	ptr[0] = 0xe8;
	ptr++;
// LINE 597:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 598:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 599:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 600:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 603:
_Ta22:
	__asm        cmp    tile, 0xD1;
	__asm        jne    _Ta58;
// LINE 605:
	ptr[0] = 0xe8;
	ptr++;
// LINE 606:
	ptr[0] = 0xea;
	ptr++;
// LINE 607:
	ptr[0] = 0xea;
	ptr++;
// LINE 608:
	ptr[0] = 0xea;
	ptr++;
// LINE 609:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 611:
_Ta58:
	__asm        cmp    tile, 0xD2;
	__asm        jne    _Ta8e;
// LINE 613:
	ptr[0] = 0xe8;
	ptr++;
// LINE 614:
	ptr[0] = 0x9a;
	ptr++;
// LINE 615:
	ptr[0] = 0x9a;
	ptr++;
// LINE 616:
	ptr[0] = 0x9a;
	ptr++;
// LINE 617:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 619:
_Ta8e:
	__asm        cmp    tile, 0xD3;
	__asm        jne    _Tac4;
// LINE 621:
	ptr[0] = 0xe8;
	ptr++;
// LINE 622:
	ptr[0] = 0x1a;
	ptr++;
// LINE 623:
	ptr[0] = 0x1a;
	ptr++;
// LINE 624:
	ptr[0] = 0x1a;
	ptr++;
// LINE 625:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 628:
_Tac4:
	__asm        mov    eax, x;
	__asm        cmp    G_helibase.pad1.x, eax;
	__asm        jg     _Tb2d;

	__asm        mov    eax, G_helibase.pad1.x;
	__asm        add    eax, 4;
	__asm        cmp    eax, x;
	__asm        jle    _Tb2d;

	__asm        mov    eax, y;
	__asm        cmp    G_helibase.pad1.y, eax;
	__asm        jg     _Tb2d;

	__asm        mov    eax, G_helibase.pad1.y;
	__asm        add    eax, 4;
	__asm        cmp    eax, y;
	__asm        jle    _Tb2d;
// LINE 630:
	ptr[0] = 0xe8;
	ptr++;
// LINE 631:
	ptr[0] = 0xca;
	ptr++;
// LINE 632:
	ptr[0] = 0xca;
	ptr++;
// LINE 633:
	ptr[0] = 0xca;
	ptr++;
// LINE 634:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 637:
_Tb2d:
	__asm        cmp    tile, 0xD;
	__asm        je     _Tb44;

	__asm        cmp    tile, 0xD5;
	__asm        jne    _Tb6d;
// LINE 639:
_Tb44:
	ptr[0] = 0xe8;
	ptr++;
// LINE 640:
	ptr[0] = 0x5a;
	ptr++;
// LINE 641:
	ptr[0] = 0x5a;
	ptr++;
// LINE 642:
	ptr[0] = 0x5a;
	ptr++;
// LINE 643:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 647:
_Tb6d:
	__asm        cmp    tile, 0x1D;
	__asm        jl     _Tbaa;

	__asm        cmp    tile, 0x70;
	__asm        jge    _Tbaa;
// LINE 649:
	ptr[0] = 0xe8;
	ptr++;
// LINE 650:
	ptr[0] = 0x33;
	ptr++;
// LINE 651:
	ptr[0] = 0x33;
	ptr++;
// LINE 652:
	ptr[0] = 0x33;
	ptr++;
// LINE 653:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 657:
_Tbaa:
	__asm        cmp    tile, 0x70;
	__asm        jl     _Tbdd;
// LINE 659:
	ptr[0] = 0xe8;
	ptr++;
// LINE 660:
	ptr[0] = 0x3a;
	ptr++;
// LINE 661:
	ptr[0] = 0x3a;
	ptr++;
// LINE 662:
	ptr[0] = 0x3a;
	ptr++;
// LINE 663:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 667:
_Tbdd:
	__asm        mov    eax, y;
	__asm        mov    ecx, x;
	__asm        shl    ecx, 8;
	__asm        mov    al, G_texmap[0][eax+ecx];
	__asm        mov    texid, al;
// LINE 668:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jl     _Tc93;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x40;
	__asm        jge    _Tc93;
// LINE 670:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 671:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 672:
	ptr[0] = 0xe8;
	ptr++;
// LINE 673:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 674:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 675:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 677:
	__asm        jmp    _Tdf6;
_Tc93:
	__asm        movsx  eax, texid;
	__asm        test   eax, eax;
	__asm        jl     _Tcd5;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0xA;
	__asm        jge    _Tcd5;
// LINE 679:
	ptr[0] = 0xe8;
	ptr++;
// LINE 680:
	ptr[0] = 0x90;
	ptr++;
// LINE 681:
	ptr[0] = 0x90;
	ptr++;
// LINE 682:
	ptr[0] = 0x90;
	ptr++;
// LINE 684:
	__asm        jmp    _Tdf6;
_Tcd5:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x20;
	__asm        jl     _Td72;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jge    _Td72;
// LINE 686:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 687:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 688:
	ptr[0] = 0xe8;
	ptr++;
// LINE 689:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 690:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 691:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 693:
	__asm        jmp    _Tdf6;
// LINE 695:
_Td72:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 696:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 697:
	ptr[0] = 0xe8;
	ptr++;
// LINE 698:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 699:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 700:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 702:
_Tdf6:
	__asm        jmp    _FOR_NEXT_91e;
// LINE 703:
_Tdfb:
	ptr += 0x14;
// LINE 704:
	__asm        mov    edx, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    eax, 0xE8E8E8E8;
	__asm        mov    ecx, edx;
	__asm        shr    ecx, 2;
	__asm        rep stosd;
	__asm        mov    ecx, edx;
	__asm        and    ecx, 3;
	__asm        rep stosb;
// LINE 705:
	ptr += S_borderdimx;
// LINE 706:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 707:
	ptr += S_borderdimx;
// LINE 708:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 709:
	ptr += S_borderdimx;
// LINE 710:
	__asm        jmp    _FOR_NEXT_8e6;
// LINE 711:
_Te6a:
	__asm        jmp    _T178e;
// LINE 715:
_Te6f:
	S_ulc.x = (posx - (S_mapdimx >> 0x4));
// LINE 716:
	S_ulc.y = (posy - (S_mapdimy >> 0x4));
// LINE 717:
	__asm        mov    eax, S_mapdimx;
	__asm        sar    eax, 3;
	__asm        add    eax, S_ulc.x;
	__asm        dec    eax;
	__asm        mov    S_lrc.x, eax;
// LINE 718:
	__asm        mov    eax, S_ulc.y;
	__asm        mov    ecx, S_mapdimy;
	__asm        sar    ecx, 3;
	__asm        add    eax, ecx;
	__asm        dec    eax;
	__asm        mov    S_lrc.y, eax;
// LINE 720:
_FOR_ed3:
	y = S_ulc.y;
	county = 0x0;
	__asm        jmp    _FOR_COND_ed3;
_FOR_NEXT_ed3:
	county++;
	y++;
_FOR_COND_ed3:
	__asm        mov    eax, S_mapdimy;
	__asm        sar    eax, 3;
	__asm        cmp    eax, county;
	__asm        jle    _T175b;
// LINE 722:
	__asm        and    y, 0xFF;
// LINE 724:
	lineptr = ptr;
// LINE 726:
_FOR_f0b:
	x = S_ulc.x;
	countx = 0x0;
	__asm        jmp    _FOR_COND_f0b;
_FOR_NEXT_f0b:
	countx++;
	x++;
_FOR_COND_f0b:
	__asm        mov    eax, S_mapdimx;
	__asm        sar    eax, 3;
	__asm        cmp    eax, countx;
	__asm        jle    _T1668;
// LINE 728:
	__asm        and    x, 0xFF;
// LINE 730:
	__asm        mov    eax, posx;
	__asm        cmp    x, eax;
	__asm        jne    _Tf8e;

	__asm        mov    eax, posy;
	__asm        cmp    y, eax;
	__asm        jne    _Tf8e;
// LINE 732:
	ptr[0] = 0xe8;
	ptr++;
// LINE 733:
	ptr[0] = 0x70;
	ptr++;
// LINE 734:
	ptr[0] = 0x70;
	ptr++;
// LINE 735:
	ptr[0] = 0x70;
	ptr++;
// LINE 736:
	ptr[0] = 0x70;
	ptr++;
// LINE 737:
	ptr[0] = 0x70;
	ptr++;
// LINE 738:
	ptr[0] = 0x70;
	ptr++;
// LINE 739:
	ptr[0] = 0x70;
	ptr++;
// LINE 740:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 745:
_Tf8e:
	__asm        cmp    x, 0x7F;
	__asm        jg     _Tfa2;

	__asm        cmp    y, 0x7F;
	__asm        jle    _Tfae;
// LINE 747:
_Tfa2:
	tile = 0x0;
// LINE 749:
	__asm        jmp    _Tfc3;
// LINE 752:
_Tfae:
	__asm        mov    eax, x;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, y;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        mov    tile, edx;
// LINE 758:
_Tfc3:
	__asm        mov    eax, x;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, y;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    cptr, eax;
// LINE 759:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _T107b;
// LINE 761:
	ptr[0] = 0xe8;
	ptr++;
// LINE 762:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 763:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 764:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 765:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 766:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 767:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 768:
	__asm        movsx  eax, S_fire_cycle;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 769:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 772:
_T107b:
	__asm        cmp    tile, 0xD1;
	__asm        jne    _T10d5;
// LINE 774:
	ptr[0] = 0xe8;
	ptr++;
// LINE 775:
	ptr[0] = 0xea;
	ptr++;
// LINE 776:
	ptr[0] = 0xea;
	ptr++;
// LINE 777:
	ptr[0] = 0xea;
	ptr++;
// LINE 778:
	ptr[0] = 0xea;
	ptr++;
// LINE 779:
	ptr[0] = 0xea;
	ptr++;
// LINE 780:
	ptr[0] = 0xea;
	ptr++;
// LINE 781:
	ptr[0] = 0xea;
	ptr++;
// LINE 782:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 784:
_T10d5:
	__asm        cmp    tile, 0xD2;
	__asm        jne    _T112f;
// LINE 786:
	ptr[0] = 0xe8;
	ptr++;
// LINE 787:
	ptr[0] = 0x9a;
	ptr++;
// LINE 788:
	ptr[0] = 0x9a;
	ptr++;
// LINE 789:
	ptr[0] = 0x9a;
	ptr++;
// LINE 790:
	ptr[0] = 0x9a;
	ptr++;
// LINE 791:
	ptr[0] = 0x9a;
	ptr++;
// LINE 792:
	ptr[0] = 0x9a;
	ptr++;
// LINE 793:
	ptr[0] = 0x9a;
	ptr++;
// LINE 794:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 796:
_T112f:
	__asm        cmp    tile, 0xD3;
	__asm        jne    _T1189;
// LINE 798:
	ptr[0] = 0xe8;
	ptr++;
// LINE 799:
	ptr[0] = 0x1a;
	ptr++;
// LINE 800:
	ptr[0] = 0x1a;
	ptr++;
// LINE 801:
	ptr[0] = 0x1a;
	ptr++;
// LINE 802:
	ptr[0] = 0x1a;
	ptr++;
// LINE 803:
	ptr[0] = 0x1a;
	ptr++;
// LINE 804:
	ptr[0] = 0x1a;
	ptr++;
// LINE 805:
	ptr[0] = 0x1a;
	ptr++;
// LINE 806:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 809:
_T1189:
	__asm        mov    eax, x;
	__asm        cmp    G_helibase.pad1.x, eax;
	__asm        jg     _T1216;

	__asm        mov    eax, G_helibase.pad1.x;
	__asm        add    eax, 4;
	__asm        cmp    eax, x;
	__asm        jle    _T1216;

	__asm        mov    eax, y;
	__asm        cmp    G_helibase.pad1.y, eax;
	__asm        jg     _T1216;

	__asm        mov    eax, G_helibase.pad1.y;
	__asm        add    eax, 4;
	__asm        cmp    eax, y;
	__asm        jle    _T1216;
// LINE 811:
	ptr[0] = 0xe8;
	ptr++;
// LINE 812:
	ptr[0] = 0xca;
	ptr++;
// LINE 813:
	ptr[0] = 0xca;
	ptr++;
// LINE 814:
	ptr[0] = 0xca;
	ptr++;
// LINE 815:
	ptr[0] = 0xca;
	ptr++;
// LINE 816:
	ptr[0] = 0xca;
	ptr++;
// LINE 817:
	ptr[0] = 0xca;
	ptr++;
// LINE 818:
	ptr[0] = 0xca;
	ptr++;
// LINE 819:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 823:
_T1216:
	__asm        cmp    tile, 0xD;
	__asm        je     _T122d;

	__asm        cmp    tile, 0xD5;
	__asm        jne    _T127a;
// LINE 825:
_T122d:
	ptr[0] = 0xe8;
	ptr++;
// LINE 826:
	ptr[0] = 0x5a;
	ptr++;
// LINE 827:
	ptr[0] = 0x5a;
	ptr++;
// LINE 828:
	ptr[0] = 0x5a;
	ptr++;
// LINE 829:
	ptr[0] = 0x5a;
	ptr++;
// LINE 830:
	ptr[0] = 0x5a;
	ptr++;
// LINE 831:
	ptr[0] = 0x5a;
	ptr++;
// LINE 832:
	ptr[0] = 0x5a;
	ptr++;
// LINE 833:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 837:
_T127a:
	__asm        cmp    tile, 0x1D;
	__asm        jl     _T12db;

	__asm        cmp    tile, 0x70;
	__asm        jge    _T12db;
// LINE 839:
	ptr[0] = 0xe8;
	ptr++;
// LINE 840:
	ptr[0] = 0x33;
	ptr++;
// LINE 841:
	ptr[0] = 0x33;
	ptr++;
// LINE 842:
	ptr[0] = 0x33;
	ptr++;
// LINE 843:
	ptr[0] = 0x33;
	ptr++;
// LINE 844:
	ptr[0] = 0x33;
	ptr++;
// LINE 845:
	ptr[0] = 0x33;
	ptr++;
// LINE 846:
	ptr[0] = 0x33;
	ptr++;
// LINE 847:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 851:
_T12db:
	__asm        cmp    tile, 0x70;
	__asm        jl     _T1332;
// LINE 853:
	ptr[0] = 0xe8;
	ptr++;
// LINE 854:
	ptr[0] = 0x3a;
	ptr++;
// LINE 855:
	ptr[0] = 0x3a;
	ptr++;
// LINE 856:
	ptr[0] = 0x3a;
	ptr++;
// LINE 857:
	ptr[0] = 0x3a;
	ptr++;
// LINE 858:
	ptr[0] = 0x3a;
	ptr++;
// LINE 859:
	ptr[0] = 0x3a;
	ptr++;
// LINE 860:
	ptr[0] = 0x3a;
	ptr++;
// LINE 861:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 865:
_T1332:
	__asm        mov    eax, y;
	__asm        mov    ecx, x;
	__asm        shl    ecx, 8;
	__asm        mov    al, G_texmap[0][eax+ecx];
	__asm        mov    texid, al;
// LINE 866:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jl     _T143c;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x40;
	__asm        jge    _T143c;
// LINE 868:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 869:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 870:
	ptr[0] = 0xe8;
	ptr++;
// LINE 871:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 872:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 873:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 874:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 875:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 876:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 877:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 879:
	__asm        jmp    _T1663;
_T143c:
	__asm        movsx  eax, texid;
	__asm        test   eax, eax;
	__asm        jl     _T14a2;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0xA;
	__asm        jge    _T14a2;
// LINE 881:
	ptr[0] = 0xe8;
	ptr++;
// LINE 882:
	ptr[0] = 0x90;
	ptr++;
// LINE 883:
	ptr[0] = 0x90;
	ptr++;
// LINE 884:
	ptr[0] = 0x90;
	ptr++;
// LINE 885:
	ptr[0] = 0x90;
	ptr++;
// LINE 886:
	ptr[0] = 0x90;
	ptr++;
// LINE 887:
	ptr[0] = 0x90;
	ptr++;
// LINE 888:
	ptr[0] = 0x90;
	ptr++;
// LINE 890:
	__asm        jmp    _T1663;
_T14a2:
	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x20;
	__asm        jl     _T158b;

	__asm        movsx  eax, texid;
	__asm        cmp    eax, 0x30;
	__asm        jge    _T158b;
// LINE 892:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 893:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 894:
	ptr[0] = 0xe8;
	ptr++;
// LINE 895:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 896:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 897:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 898:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 899:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 900:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 901:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 0x50;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 903:
	__asm        jmp    _T1663;
// LINE 905:
_T158b:
	__asm        mov    eax, y;
	__asm        and    eax, G_tmask;
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_tshift);
	__asm        shl    eax, cl;
	__asm        mov    ecx, x;
	__asm        and    ecx, G_tmask;
	__asm        add    ecx, ecx;
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    ecx, G_tmap;
	__asm        mov    ax, [eax+ecx];
	__asm        mov    alt, ax;
// LINE 906:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        shr    eax, 6;
	__asm        mov    alt, ax;
// LINE 907:
	ptr[0] = 0xe8;
	ptr++;
// LINE 908:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 909:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 910:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 911:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 912:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 913:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 914:
	__asm        mov    eax, reinterpret_cast<uint32_t>(alt);
	__asm        and    eax, 0xFFFF;
	__asm        sub    eax, 0x80;
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
	__asm        inc    ptr;
// LINE 916:
_T1663:
	__asm        jmp    _FOR_NEXT_f0b;
// LINE 924:
_T1668:
	ptr += 0x14;
// LINE 926:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 927:
	ptr += S_borderdimx;
// LINE 928:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 929:
	ptr += S_borderdimx;
// LINE 930:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 931:
	ptr += S_borderdimx;
// LINE 932:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 933:
	ptr += S_borderdimx;
// LINE 934:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 935:
	ptr += S_borderdimx;
// LINE 936:
	__asm        mov    eax, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    esi, lineptr;
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
// LINE 937:
	ptr += S_borderdimx;
// LINE 938:
	__asm        mov    edx, S_mapdimx;
	__asm        mov    edi, ptr;
	__asm        mov    eax, 0xE8E8E8E8;
	__asm        mov    ecx, edx;
	__asm        shr    ecx, 2;
	__asm        rep stosd;
	__asm        mov    ecx, edx;
	__asm        and    ecx, 3;
	__asm        rep stosb;
// LINE 939:
	ptr += S_borderdimx;
// LINE 940:
	__asm        jmp    _FOR_NEXT_ed3;
// LINE 941:
_T175b:
	__asm        jmp    _T178e;
// LINE 944:
	__asm        jmp    _T178e;
// LINE 946:
	__asm        jmp    _T178e;
_T176a:
	__asm        cmp    dword ptr [ebp-0x2C], 3;
	__asm        ja     _T178e;

	__asm        mov    eax, [ebp-0x2C];
	__asm        jmp    _Switch_177e[0][eax*4];
// Switch pointers:
//   _T82
//   _T41c
//   _T882
//   _Te6f
// LINE 949:
_T178e:
	S3MapDrawPosLines(posx, posy);
// LINE 950:
	S3MapDrawMissionIcons(posx, posy);
// LINE 951:
	S3MapDrawCarIcons();
// LINE 952:
}

// FUNCTION: COPTER_D 0x005001cb
void S3MapDrawPosLines(long posx, long posy) {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   long pickicon;
	/*bp-0xc*/   int32_t dist;
	/*bp-0x10*/  int32_t fx;
	/*bp-0x14*/  int32_t dfx;
	/*bp-0x18*/  int32_t fy;
	/*bp-0x1c*/  int32_t dfy;
	/*bp-0x20*/  long x;
	/*bp-0x24*/  long i;
	/*bp-0x28*/  long y;
	/*bp-0x2c*/  long desticon;
	/*bp-0x30*/  /*packed*/ struct Point2d *maploc;

// LINE 967:
	ptr = S_mapbuf;
// LINE 971:
	desticon = 0xffffffff;
// LINE 972:
	pickicon = 0xffffffff;
// LINE 974:
	__asm        and    posy, 0xFF;
// LINE 975:
	__asm        and    posx, 0xFF;
// LINE 987:
	maploc = S3MissionGetCurrDestMapLoc();
// LINE 988:
	__asm        cmp    maploc, 0;
	__asm        je     _Te6;
// LINE 990:
	S3MapGetDxDy(posx, posy, maploc->x, maploc->y, dfx, dfy);
// LINE 993:
	__asm        mov    eax, dfx;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        sar    eax, cl;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    fx, eax;
// LINE 994:
	__asm        mov    eax, dfy;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        sar    eax, cl;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    fy, eax;
// LINE 995:
	__asm        mov    eax, fx;
	__asm        cmp    fy, eax;
	__asm        jge    _Ta6;

	dist = ((fx + fx) + fy);
// LINE 996:
	__asm        jmp    _Tb1;
_Ta6:
	dist = ((fy + fy) + fx);
// LINE 997:
_Tb1:
	__asm        mov    ecx, 0x3F;
	__asm        mov    eax, dist;
	__asm        shl    eax, 4;
	__asm        mov    ebx, 0x184;
	__asm        cdq;
	__asm        idiv   ebx;
	__asm        sub    ecx, eax;
	__asm        mov    i, ecx;
// LINE 999:
	S3MapDrawLine(dfx, dfy, i, desticon);
// LINE 1001:
	__asm        jmp    _T19a;
// LINE 1003:
_Te6:
	maploc = S3MissionGetCurrMapLoc();
// LINE 1004:
	__asm        cmp    maploc, 0;
	__asm        je     _T19a;
// LINE 1006:
	S3MapGetDxDy(posx, posy, maploc->x, maploc->y, dfx, dfy);
// LINE 1009:
	__asm        mov    eax, dfx;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        sar    eax, cl;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    fx, eax;
// LINE 1010:
	__asm        mov    eax, dfy;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        sar    eax, cl;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    fy, eax;
// LINE 1011:
	__asm        mov    eax, fx;
	__asm        cmp    fy, eax;
	__asm        jge    _T15f;

	dist = ((fx + fx) + fy);
// LINE 1012:
	__asm        jmp    _T16a;
_T15f:
	dist = ((fy + fy) + fx);
// LINE 1013:
_T16a:
	__asm        mov    ecx, 0x3F;
	__asm        mov    eax, dist;
	__asm        shl    eax, 4;
	__asm        mov    ebx, 0x184;
	__asm        cdq;
	__asm        idiv   ebx;
	__asm        sub    ecx, eax;
	__asm        mov    i, ecx;
// LINE 1015:
	S3MapDrawLine(dfx, dfy, i, desticon);
// LINE 1019:
_T19a:
	maploc = S3MissionGetCurrPickupLoc();
// LINE 1020:
	__asm        cmp    maploc, 0;
	__asm        je     _T24e;
// LINE 1022:
	S3MapGetDxDy(posx, posy, maploc->x, maploc->y, dfx, dfy);
// LINE 1025:
	__asm        mov    eax, dfx;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        sar    eax, cl;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    fx, eax;
// LINE 1026:
	__asm        mov    eax, dfy;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        sar    eax, cl;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    fy, eax;
// LINE 1027:
	__asm        mov    eax, fx;
	__asm        cmp    fy, eax;
	__asm        jge    _T213;

	dist = ((fx + fx) + fy);
// LINE 1028:
	__asm        jmp    _T21e;
_T213:
	dist = ((fy + fy) + fx);
// LINE 1029:
_T21e:
	__asm        mov    ecx, 0x6F;
	__asm        mov    eax, dist;
	__asm        shl    eax, 4;
	__asm        mov    ebx, 0x184;
	__asm        cdq;
	__asm        idiv   ebx;
	__asm        sub    ecx, eax;
	__asm        mov    i, ecx;
// LINE 1031:
	S3MapDrawLine(dfx, dfy, i, desticon);
// LINE 1037:
_T24e:
	__asm        cmp    G_camera_mode, 3;
	__asm        je     _T27e;
// LINE 1039:
	fx = G_uheli->vector.x;
// LINE 1040:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x108];
	__asm        neg    eax;
	__asm        mov    fy, eax;
// LINE 1042:
	__asm        jmp    _T295;
// LINE 1044:
_T27e:
	__asm        call   GetAvatarVector;
	__asm        mov    eax, [eax];
	__asm        mov    fx, eax;
// LINE 1045:
	__asm        call   GetAvatarVector;
	__asm        mov    eax, [eax+8];
	__asm        neg    eax;
	__asm        mov    fy, eax;
// LINE 1048:
_T295:
	dfy = 0x0;
	dfx = dfy;
// LINE 1049:
_FOR_2ae:
	for (i = 0x0; (S_dirlen > i); i++) {
		// LINE 1052:
			x = (dfx >> 0x10);
		// LINE 1053:
			y = (dfy >> 0x10);
		// LINE 1054:
			dfx += fx;
		// LINE 1055:
			dfy += fy;
		// LINE 1056:
			ptr = (((y * S_borderdimx) + x) + S_mapbufctr);
		// LINE 1057:
			ptr[0] = 0x70;
	}
// LINE 1059:
__RETURN:
}

// FUNCTION: COPTER_D 0x005004cf
void S3MapDrawLine(int32_t dx, int32_t dy, char col, long icon_id) {
	/*bp-0x4*/   char * writeBuffer;
	/*bp-0x8*/   int32_t xpos;
	/*bp-0xc*/   int32_t ypos;
	/*bp-0x10*/  int32_t Yunit;
	/*bp-0x14*/  int32_t Xinc;
	/*bp-0x18*/  int32_t index;
	/*bp-0x1c*/  int32_t Yinc;
	/*bp-0x20*/  int32_t error;

// LINE 1076:
	error = 0x0;
// LINE 1080:
	xpos = (S_borderdimx >> 0x1);
// LINE 1081:
	ypos = (S_borderdimy >> 0x1);
// LINE 1084:
	writeBuffer = S_mapbufctr;
// LINE 1086:
	__asm        cmp    dx, 0;
	__asm        jl     _T44;
// LINE 1088:
	Xinc = 0x1;
// LINE 1090:
	__asm        jmp    _T53;
// LINE 1092:
_T44:
	Xinc = 0xffffffff;
// LINE 1093:
	__asm        mov    eax, dx;
	__asm        neg    eax;
	__asm        mov    dx, eax;
// LINE 1096:
_T53:
	__asm        cmp    dy, 0;
	__asm        jl     _T71;
// LINE 1098:
	Yinc = S_borderdimx;
// LINE 1099:
	Yunit = 0x1;
// LINE 1101:
	__asm        jmp    _T8a;
// LINE 1103:
_T71:
	__asm        mov    eax, S_borderdimx;
	__asm        neg    eax;
	__asm        mov    Yinc, eax;
// LINE 1104:
	__asm        mov    eax, dy;
	__asm        neg    eax;
	__asm        mov    dy, eax;
// LINE 1105:
	Yunit = 0xffffffff;
// LINE 1108:
_T8a:
	__asm        mov    eax, dx;
	__asm        cmp    dy, eax;
	__asm        jge    _FOR_144;
// LINE 1110:
_FOR_a2:
	for (index = 0x0; (index <= dx); index++) {
		// LINE 1112:
			__asm        movsx  eax, col;
			__asm        test   eax, eax;
			__asm        je     _Tc5;

			__asm        mov    al, col;
			__asm        mov    ecx, writeBuffer;
			__asm        mov    [ecx], al;
		// LINE 1113:
		_Tc5:
			error += dy;
		// LINE 1114:
			__asm        mov    eax, dx;
			__asm        cmp    error, eax;
			__asm        jle    _Ted;
		// LINE 1116:
			error -= dx;
		// LINE 1117:
			writeBuffer += Yinc;
		// LINE 1118:
			ypos += Yunit;
		// LINE 1120:
		_Ted:
			writeBuffer += Xinc;
		// LINE 1121:
			xpos += Xinc;
		// LINE 1123:
			__asm        cmp    ypos, 0;
			__asm        jl     _T129;

			__asm        cmp    xpos, 0;
			__asm        jl     _T129;

			__asm        mov    eax, S_borderdimy;
			__asm        cmp    ypos, eax;
			__asm        jge    _T129;

			__asm        mov    eax, S_borderdimx;
			__asm        cmp    xpos, eax;
			__asm        jl     _T12e;
		// LINE 1124:
		_T129:
			__asm        jmp    _T133;
		// LINE 1125:
		_T12e:
	}
// LINE 1127:
_T133:
	__asm        jmp    _T1d1;
// LINE 1129:
_FOR_144:
	for (index = 0x0; (index <= dy); index++) {
		// LINE 1131:
			__asm        movsx  eax, col;
			__asm        test   eax, eax;
			__asm        je     _T167;

			__asm        mov    al, col;
			__asm        mov    ecx, writeBuffer;
			__asm        mov    [ecx], al;
		// LINE 1132:
		_T167:
			error += dx;
		// LINE 1133:
			__asm        mov    eax, dy;
			__asm        cmp    error, eax;
			__asm        jle    _T18f;
		// LINE 1135:
			error -= dy;
		// LINE 1136:
			writeBuffer += Xinc;
		// LINE 1137:
			xpos += Xinc;
		// LINE 1139:
		_T18f:
			writeBuffer += Yinc;
		// LINE 1140:
			ypos += Yunit;
		// LINE 1141:
			__asm        js     _T1c7;

			__asm        cmp    xpos, 0;
			__asm        jl     _T1c7;

			__asm        mov    eax, S_borderdimy;
			__asm        cmp    ypos, eax;
			__asm        jge    _T1c7;

			__asm        mov    eax, S_borderdimx;
			__asm        cmp    xpos, eax;
			__asm        jl     _T1cc;
		// LINE 1142:
		_T1c7:
			__asm        jmp    _T1d1;
		// LINE 1143:
		_T1cc:
	}
// LINE 1146:
_T1d1:
	S3MapBlitIcon(icon_id, xpos, ypos);
// LINE 1148:
}

// FUNCTION: COPTER_D 0x005006b9
void S3MapBlit(char * destbuf, long destpitch) {
	/*bp-0x4*/   long * ptr;
	/*bp-0x8*/   long x;
	/*bp-0xc*/   long y;
	/*bp-0x10*/  char * cptr;
	/*bp-0x14*/  long * mptr;

// LINE 1163:
	cptr = destbuf;
// LINE 1169:
	cptr += ((S_bordermin.y * destpitch) + S_bordermin.x);
// LINE 1170:
	mptr = S_borderbuf;
// LINE 1172:
_FOR_35:
	for (y = 0x0; (S_borderdimy > y); y++) {
		// LINE 1173:
			ptr = cptr;
		// LINE 1174:
		_FOR_59:
			for (x = 0x0; ((S_borderdimx >> 0x2) > x); x++) {
				// LINE 1175:
					ptr[0] = mptr[0];
					mptr += 0x4;
					ptr += 0x4;
			}
		// LINE 1177:
		_T84:
			cptr += destpitch;
	}
// LINE 1179:
__RETURN:
}

// FUNCTION: COPTER_D 0x0050074d
void S3MapBlitPosition(char * destbuf, long destpitch, long xDestination, long yDestination) {
	/*bp-0x4*/   long * ptr;
	/*bp-0x8*/   long x;
	/*bp-0xc*/   long y;
	/*bp-0x10*/  char * cptr;
	/*bp-0x14*/  long * mptr;

// LINE 1191:
	cptr = destbuf;
// LINE 1193:
	cptr += ((destpitch * yDestination) + xDestination);
// LINE 1194:
	mptr = S_borderbuf;
// LINE 1196:
_FOR_30:
	for (y = 0x0; (S_borderdimy > y); y++) {
		// LINE 1197:
			ptr = cptr;
		// LINE 1198:
		_FOR_54:
			for (x = 0x0; ((S_borderdimx >> 0x2) > x); x++) {
				// LINE 1199:
					ptr[0] = mptr[0];
					mptr += 0x4;
					ptr += 0x4;
			}
		// LINE 1200:
		_T7f:
			cptr += destpitch;
	}
// LINE 1202:
__RETURN:
}

// FUNCTION: COPTER_D 0x005007dc
void S3MapSet3dRender() {
// LINE 1220:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T3a;
// LINE 1222:
	__asm        mov    esi, 0x598EC0;
	__asm        mov    edi, 0x5B5228;
	__asm        mov    ecx, 7;
	__asm        rep movsd;
// LINE 1223:
	__asm        mov    esi, 0x5B5208;
	__asm        mov    edi, 0x598EC0;
	__asm        mov    ecx, 7;
	__asm        rep movsd;
// LINE 1225:
	__asm        jmp    _T5c;
// LINE 1227:
_T3a:
	__asm        mov    esi, 0x598EE0;
	__asm        mov    edi, 0x5B5228;
	__asm        mov    ecx, 7;
	__asm        rep movsd;
// LINE 1228:
	__asm        mov    esi, 0x5B5208;
	__asm        mov    edi, 0x598EE0;
	__asm        mov    ecx, 7;
	__asm        rep movsd;
// LINE 1231:
_T5c:
	S_save_aspect = HALF_ASPECT;
// LINE 1232:
	S_save_width = HALF_WIDTH;
// LINE 1234:
	_VRSetWindow(0x5b5208);
// LINE 1236:
	__asm        shl    HALF_ASPECT, 1;
// LINE 1237:
	__asm        shl    HALF_WIDTH, 1;
// LINE 1240:
	S_savebuffer1 = buffer1;
// LINE 1241:
	buffer1 = S_mapbuf;
// LINE 1244:
}

// FUNCTION: COPTER_D 0x00500880
void S3MapRestore3dRender() {
// LINE 1258:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T29;
// LINE 1259:
	__asm        mov    esi, 0x5B5228;
	__asm        mov    edi, 0x598EC0;
	__asm        mov    ecx, 7;
	__asm        rep movsd;
// LINE 1260:
	__asm        jmp    _T3a;
// LINE 1261:
_T29:
	__asm        mov    esi, 0x5B5228;
	__asm        mov    edi, 0x598EE0;
	__asm        mov    ecx, 7;
	__asm        rep movsd;
// LINE 1263:
_T3a:
	_VRSetWindow(0x5b5228);
// LINE 1265:
	HALF_ASPECT = S_save_aspect;
// LINE 1266:
	HALF_WIDTH = S_save_width;
// LINE 1269:
	buffer1 = S_savebuffer1;
// LINE 1270:
}

// FUNCTION: COPTER_D 0x005008ea
int32_t S3MapCursorDown(long posx, long posy) {
	/*bp-0x4*/   long car_id;
	/*bp-0x8*/   long i;
	/*bp-0xc*/   /*packed*/ struct _MAP_CARINFO *ci;

// LINE 1286:
	car_id = 0xffffffff;
// LINE 1290:
_FOR_1c:
	for (i = 0x0; (i < 0x14); i++) {
		// LINE 1292:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, S_carinfo[0].flags[eax*8];
			__asm        mov    ci, eax;
		// LINE 1293:
			__asm        mov    eax, ci;
			__asm        test   byte ptr [eax], 3;
			__asm        jne    _T4a;
		// LINE 1294:
			__asm        jmp    _FOR_NEXT_1c;
		// LINE 1297:
		_T4a:
			__asm        mov    eax, ci;
			__asm        mov    ecx, posx;
			__asm        cmp    [eax+0x20], ecx;
			__asm        jg     _T8f;

			__asm        mov    eax, ci;
			__asm        mov    ecx, posx;
			__asm        cmp    [eax+0x24], ecx;
			__asm        jl     _T8f;

			__asm        mov    eax, ci;
			__asm        mov    ecx, posy;
			__asm        cmp    [eax+0x18], ecx;
			__asm        jg     _T8f;

			__asm        mov    eax, ci;
			__asm        mov    ecx, posy;
			__asm        cmp    [eax+0x1C], ecx;
			__asm        jl     _T8f;
		// LINE 1299:
			car_id = ci->car_id;
		// LINE 1303:
		_T8f:
	}
// LINE 1305:
_T94:
	return car_id;
// LINE 1306:
}

// FUNCTION: COPTER_D 0x0050098b
int32_t S3MapCursorUp(long posx, long posy) {
// LINE 1314:
	return 0xffffffff;
// LINE 1315:
}

// FUNCTION: COPTER_D 0x005009a0
void S3MapCommandZoomIn() {
// LINE 1323:
	__asm        cmp    S_mapzoom, 3;
	__asm        jge    __RETURN;
// LINE 1324:
	S_mapzoom++;
// LINE 1325:
__RETURN:
}

// FUNCTION: COPTER_D 0x005009be
void S3MapCommandZoomOut() {
// LINE 1333:
	__asm        cmp    S_mapzoom, 0;
	__asm        jle    __RETURN;
// LINE 1334:
	S_mapzoom--;
// LINE 1335:
__RETURN:
}

// FUNCTION: COPTER_D 0x005009dc
void S3MapCommandPreviousMission() {
// LINE 1342:
	S3MissionSetCurrPrev();
// LINE 1343:
}

// FUNCTION: COPTER_D 0x005009ec
void S3MapCommandNextMission() {
// LINE 1351:
	S3MissionSetCurrNext();
// LINE 1352:
}

// FUNCTION: COPTER_D 0x005009fc
void S3MapCommandCurrentMissionVehicleFilter(int32_t onOrOff) {
// LINE 1361:
}

// FUNCTION: COPTER_D 0x00500a07
void S3MapCommandOtherMissionVehicleFilter(int32_t onOrOff) {
// LINE 1370:
}

// FUNCTION: COPTER_D 0x00500a12
void S3MapBlitIcon(long icon_id, long x, long y) {
	/*bp-0x4*/   char * iptr;
	/*bp-0x8*/   long mapx;
	/*bp-0xc*/   long mapy;
	/*bp-0x10*/  char * bufptr;

// LINE 1389:
	__asm        cmp    icon_id, 0xFFFFFFFF;
	__asm        jne    _T18;
// LINE 1390:
	return;
// LINE 1393:
_T18:
	mapx = (x - (S_icon_dim >> 0x1));
// LINE 1394:
	mapy = (y - (S_icon_dim >> 0x1));
// LINE 1395:
	__asm        cmp    mapx, 0;
	__asm        jge    _T4b;

	mapx = 0x0;
// LINE 1396:
_T4b:
	__asm        cmp    mapy, 0;
	__asm        jge    _T5c;

	mapy = 0x0;
// LINE 1397:
_T5c:
	__asm        mov    eax, mapx;
	__asm        add    eax, S_icon_dim;
	__asm        cmp    eax, S_borderdimx;
	__asm        jle    _T7f;

	mapx = (S_borderdimx - S_icon_dim);
// LINE 1398:
_T7f:
	__asm        mov    eax, mapy;
	__asm        add    eax, S_icon_dim;
	__asm        cmp    eax, S_borderdimy;
	__asm        jle    _Ta2;

	mapy = (S_borderdimy - S_icon_dim);
// LINE 1400:
_Ta2:
	bufptr = (((mapy * S_borderdimx) + mapx) + S_borderbuf);
// LINE 1401:
	__asm        mov    eax, icon_id;
	__asm        mov    eax, S_icons[eax*4];
	__asm        mov    iptr, eax;
// LINE 1403:
_FOR_d1:
	for (mapy = 0x0; (mapy < S_icon_dim); mapy++) {
		// LINE 1405:
		_FOR_ee:
			for (mapx = 0x0; (mapx < S_icon_dim); mapx++) {
				// LINE 1407:
					__asm        mov    eax, iptr;
					__asm        movsx  eax, byte ptr [eax];
					__asm        test   eax, eax;
					__asm        je     _T122;
				// LINE 1409:
					__asm        mov    eax, iptr;
					__asm        mov    al, [eax];
					__asm        mov    ecx, bufptr;
					__asm        mov    [ecx], al;
					__asm        inc    iptr;
					__asm        inc    bufptr;
				// LINE 1411:
					__asm        jmp    _T128;
				// LINE 1413:
				_T122:
					bufptr++;
				// LINE 1414:
					iptr++;
				// LINE 1416:
				_T128:
			}
		// LINE 1417:
		_T12d:
			bufptr += (S_borderdimx - S_icon_dim);
		// LINE 1418:
			iptr += (S_icon_pitch - S_icon_dim);
	}
// LINE 1421:
__RETURN:
}

// FUNCTION: COPTER_D 0x00500b65
void S3MapGetMissionIcons(long mission_type, long * desticon, long * pickicon) {
// LINE 1432:
	__asm        mov    eax, mission_type;
	__asm        mov    [ebp-4], eax;
	__asm        jmp    _T12d;
// LINE 1435:
_T14:
	desticon[0] = 0x6;
// LINE 1436:
	pickicon[0] = 0xffffffff;
// LINE 1437:
	return;
// LINE 1442:
_T2b:
	desticon[0] = 0x4;
// LINE 1443:
	pickicon[0] = 0xffffffff;
// LINE 1444:
	return;
// LINE 1446:
_T42:
	desticon[0] = 0x1;
// LINE 1447:
	pickicon[0] = 0x4;
// LINE 1448:
	return;
// LINE 1450:
_T59:
	desticon[0] = 0x3;
// LINE 1451:
	pickicon[0] = 0x5;
// LINE 1452:
	return;
// LINE 1455:
_T70:
	desticon[0] = 0x7;
// LINE 1456:
	pickicon[0] = 0xffffffff;
// LINE 1457:
	return;
// LINE 1459:
_T87:
	desticon[0] = 0x3;
// LINE 1460:
	pickicon[0] = 0xffffffff;
// LINE 1461:
	return;
// LINE 1463:
_T9e:
	desticon[0] = 0x7;
// LINE 1464:
	pickicon[0] = 0x1;
// LINE 1465:
	return;
// LINE 1467:
_Tb5:
	desticon[0] = 0x7;
// LINE 1468:
	pickicon[0] = 0x1;
// LINE 1469:
	return;
// LINE 1476:
_Tcc:
	desticon[0] = 0x2;
// LINE 1477:
	pickicon[0] = 0xffffffff;
// LINE 1478:
	return;
// LINE 1480:
_Te3:
	desticon[0] = 0x7;
// LINE 1481:
	pickicon[0] = 0xffffffff;
// LINE 1482:
	return;
// LINE 1484:
_Tfa:
	desticon[0] = 0x5;
// LINE 1485:
	pickicon[0] = 0x5;
// LINE 1486:
	return;
// LINE 1488:
_T111:
	desticon[0] = 0xffffffff;
// LINE 1489:
	pickicon[0] = 0xffffffff;
// LINE 1490:
	return;
// LINE 1491:
	return;
_T12d:
	__asm        cmp    dword ptr [ebp-4], 9;
	__asm        jg     _T156;

	__asm        je     _T70;

	__asm        cmp    dword ptr [ebp-4], 1;
	__asm        je     _T70;

	__asm        cmp    dword ptr [ebp-4], 2;
	__asm        je     _T87;

	__asm        jmp    _T111;
_T156:
	__asm        cmp    dword ptr [ebp-4], 0x10;
	__asm        jg     _T175;

	__asm        je     _T2b;

	__asm        cmp    dword ptr [ebp-4], 0xC;
	__asm        je     _T9e;

	__asm        jmp    _T111;
_T175:
	__asm        cmp    dword ptr [ebp-4], 0x40;
	__asm        jg     _T194;

	__asm        je     _T59;

	__asm        cmp    dword ptr [ebp-4], 0x20;
	__asm        je     _T42;

	__asm        jmp    _T111;
_T194:
	__asm        cmp    dword ptr [ebp-4], 0x100;
	__asm        jg     _T1b9;

	__asm        je     _Tb5;

	__asm        cmp    dword ptr [ebp-4], 0x90;
	__asm        je     _T2b;

	__asm        jmp    _T111;
_T1b9:
	__asm        cmp    dword ptr [ebp-4], 0x200;
	__asm        jg     _T1de;

	__asm        je     _Tcc;

	__asm        cmp    dword ptr [ebp-4], 0x110;
	__asm        je     _T2b;

	__asm        jmp    _T111;
_T1de:
	__asm        cmp    dword ptr [ebp-4], 0x800;
	__asm        jg     _T203;

	__asm        je     _Tfa;

	__asm        cmp    dword ptr [ebp-4], 0x408;
	__asm        je     _Te3;

	__asm        jmp    _T111;
_T203:
	__asm        cmp    dword ptr [ebp-4], 0x2000;
	__asm        jg     _T228;

	__asm        je     _Tcc;

	__asm        cmp    dword ptr [ebp-4], 0x1000;
	__asm        je     _T14;

	__asm        jmp    _T111;
_T228:
	__asm        cmp    dword ptr [ebp-4], 0x10000;
	__asm        jg     _T24d;

	__asm        je     _Tcc;

	__asm        cmp    dword ptr [ebp-4], 0x4000;
	__asm        je     _Tcc;

	__asm        jmp    _T111;
_T24d:
	__asm        cmp    dword ptr [ebp-4], 0x20000;
	__asm        je     _Tcc;

	__asm        cmp    dword ptr [ebp-4], 0x40000;
	__asm        je     _Tcc;

	__asm        cmp    dword ptr [ebp-4], 0x80010;
	__asm        je     _T2b;

	__asm        jmp    _T111;
// LINE 1492:
}

// FUNCTION: COPTER_D 0x00500de3
void S3MapDrawMissionIcons(long posx, long posy) {
	/*bp-0x4*/   long pickicon;
	/*bp-0x8*/   /*packed*/ struct MISSION_DATA *currmd;
	/*bp-0xc*/   long i;
	/*bp-0x10*/  long desticon;
	/*bp-0x14*/  /*packed*/ struct MISSION_DATA *md;

// LINE 1508:
	currmd = S3MissionGetCurr();
// LINE 1510:
_FOR_1d:
	for (i = 0x0; (i < 0x1e); i++) {
		// LINE 1512:
			md = S3MissionGetDataByIndex(i);
		// LINE 1516:
			__asm        cmp    md, 0;
			__asm        je     _T69;

			__asm        mov    eax, md;
			__asm        test   byte ptr [eax+0x4C], 1;
			__asm        je     _T69;

			__asm        mov    eax, md;
			__asm        cmp    dword ptr [eax+0x54], 2;
			__asm        je     _T69;

			__asm        mov    eax, md;
			__asm        cmp    currmd, eax;
			__asm        jne    _T6e;
		// LINE 1518:
		_T69:
			__asm        jmp    _FOR_NEXT_1d;
		// LINE 1521:
		_T6e:
			S3MapGetMissionIcons(md->type, desticon, pickicon);
		// LINE 1523:
			__asm        mov    eax, md;
			__asm        cmp    dword ptr [eax+0x30], 0xFFFFFFFF;
			__asm        je     _Tc9;
		// LINE 1528:
			__asm        mov    eax, desticon;
			__asm        push   eax;
			__asm        push   0;
			__asm        mov    eax, md;
			__asm        mov    eax, [eax+0x34];
			__asm        sub    eax, posy;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        mov    eax, md;
			__asm        mov    eax, [eax+0x30];
			__asm        sub    eax, posx;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        call   S3MapDrawLine;
			__asm        add    esp, 0x10;
		// LINE 1530:
			__asm        jmp    _T108;
		// LINE 1532:
		_Tc9:
			__asm        mov    eax, md;
			__asm        cmp    dword ptr [eax+0x28], 0xFFFFFFFF;
			__asm        je     _T108;
		// LINE 1537:
			__asm        mov    eax, desticon;
			__asm        push   eax;
			__asm        push   0;
			__asm        mov    eax, md;
			__asm        mov    eax, [eax+0x2C];
			__asm        sub    eax, posy;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        mov    eax, md;
			__asm        mov    eax, [eax+0x28];
			__asm        sub    eax, posx;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        call   S3MapDrawLine;
			__asm        add    esp, 0x10;
		// LINE 1541:
		_T108:
			__asm        mov    eax, md;
			__asm        cmp    dword ptr [eax+0x38], 0xFFFFFFFF;
			__asm        je     _T147;
		// LINE 1546:
			__asm        mov    eax, pickicon;
			__asm        push   eax;
			__asm        push   0;
			__asm        mov    eax, md;
			__asm        mov    eax, [eax+0x3C];
			__asm        sub    eax, posy;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        mov    eax, md;
			__asm        mov    eax, [eax+0x38];
			__asm        sub    eax, posx;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    eax, cl;
			__asm        push   eax;
			__asm        call   S3MapDrawLine;
			__asm        add    esp, 0x10;
		// LINE 1548:
		_T147:
	}
// LINE 1549:
__RETURN:
}

// FUNCTION: COPTER_D 0x00500f34
void S3MapAddCarInfo(long car_id, long car_type, long mission_id, /*packed*/ struct _GridCoordinates *currpos, /*packed*/ struct _GridCoordinates *disppos) {
	/*bp-0x4*/   long i;
	/*bp-0x8*/   /*packed*/ struct _MAP_CARINFO *ci;

// LINE 1567:
_FOR_15:
	for (i = 0x0; (i < 0x14); i++) {
		// LINE 1569:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, S_carinfo[0].flags[eax*8];
			__asm        mov    ci, eax;
		// LINE 1570:
			__asm        mov    eax, ci;
			__asm        test   byte ptr [eax], 1;
			__asm        jne    _T43;
		// LINE 1571:
			__asm        jmp    _T48;
		// LINE 1572:
		_T43:
	}
// LINE 1575:
_T48:
	__asm        cmp    i, 0x14;
	__asm        jne    _T57;
// LINE 1576:
	return;
// LINE 1579:
_T57:
	ci->car_id = car_id;
// LINE 1580:
	ci->car_type = car_type;
// LINE 1581:
	ci->mission_id = mission_id;
// LINE 1582:
	ci->currpos = currpos;
// LINE 1583:
	ci->disppos = disppos;
// LINE 1584:
	__asm        mov    eax, ci;
	__asm        or     dword ptr [eax], 1;
// LINE 1585:
}

// FUNCTION: COPTER_D 0x00500fc3
void S3MapRemoveCarInfo(long car_id) {
	/*bp-0x4*/   long i;

// LINE 1601:
_FOR_15:
	for (i = 0x0; (i < 0x14); i++) {
		// LINE 1603:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        mov    ecx, car_id;
			__asm        cmp    S_carinfo[0].car_id[eax*8], ecx;
			__asm        jne    _T4b;
		// LINE 1605:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        and    S_carinfo[0].flags[eax*8], 0xFFFFFFFE;
		// LINE 1606:
			return;
		// LINE 1608:
		_T4b:
	}
// LINE 1610:
__RETURN:
}

// FUNCTION: COPTER_D 0x00501018
void S3MapDrawCarIcons() {
	/*bp-0x4*/   long color;
	/*bp-0x8*/   long i;
	/*bp-0xc*/   /*packed*/ struct _MAP_CARINFO *ci;
	/*bp-0x10*/  long dx;
	/*bp-0x14*/  long dy;

// LINE 1631:
_FOR_15:
	for (i = 0x0; (i < 0x14); i++) {
		// LINE 1633:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, S_carinfo[0].flags[eax*8];
			__asm        mov    ci, eax;
		// LINE 1634:
			__asm        mov    eax, ci;
			__asm        test   byte ptr [eax], 1;
			__asm        jne    _T43;
		// LINE 1635:
			__asm        jmp    _FOR_NEXT_15;
		// LINE 1641:
		_T43:
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax];
			__asm        cmp    ecx, S_ulc.x;
			__asm        jl     _T9d;

			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+1];
			__asm        cmp    ecx, S_ulc.y;
			__asm        jl     _T9d;

			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax];
			__asm        cmp    ecx, S_lrc.x;
			__asm        jg     _T9d;

			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+1];
			__asm        cmp    ecx, S_lrc.y;
			__asm        jle    _Ta8;
		// LINE 1643:
		_T9d:
			__asm        mov    eax, ci;
			__asm        and    dword ptr [eax], 0xFFFFFFFD;
		// LINE 1644:
			__asm        jmp    _FOR_NEXT_15;
		// LINE 1648:
		_Ta8:
			__asm        mov    eax, ci;
			__asm        or     dword ptr [eax], 2;
		// LINE 1651:
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+1];
			__asm        sub    edx, S_ulc.y;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    edx, cl;
			__asm        add    edx, 8;
			__asm        mov    eax, ci;
			__asm        mov    [eax+0x18], edx;
		// LINE 1652:
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax];
			__asm        sub    edx, S_ulc.x;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    edx, cl;
			__asm        add    edx, 9;
			__asm        mov    eax, ci;
			__asm        mov    [eax+0x20], edx;
		// LINE 1653:
			ci->bottom = (ci->top + S_dicon_dim);
		// LINE 1654:
			ci->right = (ci->left + S_dicon_dim);
		// LINE 1658:
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x14];
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax];
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax];
			__asm        sub    edx, ecx;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    edx, cl;
			__asm        mov    dx, edx;
		// LINE 1659:
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x14];
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+1];
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+0x10];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+1];
			__asm        sub    edx, ecx;
			__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
			__asm        shl    edx, cl;
			__asm        mov    dy, edx;
		// LINE 1660:
			__asm        mov    eax, ci;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ebp-0x18], eax;
			__asm        jmp    _T19c;
		// LINE 1663:
		_T167:
			color = 0x1a;
		// LINE 1664:
			__asm        jmp    _T1bf;
		// LINE 1666:
		_T173:
			color = 0xffffff9a;
		// LINE 1667:
			__asm        jmp    _T1bf;
		// LINE 1669:
		_T17f:
			color = 0xffffffea;
		// LINE 1670:
			__asm        jmp    _T1bf;
		// LINE 1672:
		_T18b:
			color = 0x70;
		// LINE 1673:
			__asm        jmp    _T1bf;
		// LINE 1674:
			__asm        jmp    _T1bf;
		_T19c:
			__asm        cmp    dword ptr [ebp-0x18], 0;
			__asm        je     _T167;

			__asm        cmp    dword ptr [ebp-0x18], 1;
			__asm        je     _T173;

			__asm        cmp    dword ptr [ebp-0x18], 2;
			__asm        je     _T17f;

			__asm        jmp    _T18b;
		// LINE 1680:
		_T1bf:
			S3MapDrawDispatchLine(ci->left, ci->top, dx, dy, color);
		// LINE 1682:
			S3MapBlitDIcon(ci->car_type, ci->left, ci->top);
	}
// LINE 1684:
__RETURN:
}

// FUNCTION: COPTER_D 0x00501220
void S3MapBlitDIcon(long icon_id, long x, long y) {
	/*bp-0x4*/   char * iptr;
	/*bp-0x8*/   long mapx;
	/*bp-0xc*/   long mapy;
	/*bp-0x10*/  char * bufptr;

// LINE 1701:
	__asm        cmp    icon_id, 0xFFFFFFFF;
	__asm        jne    _T18;
// LINE 1702:
	return;
// LINE 1707:
_T18:
	mapx = x;
// LINE 1708:
	mapy = y;
// LINE 1710:
	bufptr = (((mapy * S_borderdimx) + mapx) + S_borderbuf);
// LINE 1711:
	__asm        mov    eax, icon_id;
	__asm        mov    eax, S_dicons[eax*4];
	__asm        mov    iptr, eax;
// LINE 1713:
_FOR_53:
	for (mapy = 0x0; (mapy < S_dicon_dim); mapy++) {
		// LINE 1715:
		_FOR_70:
			for (mapx = 0x0; (mapx < S_dicon_dim); mapx++) {
				// LINE 1717:
					__asm        mov    eax, iptr;
					__asm        movsx  eax, byte ptr [eax];
					__asm        test   eax, eax;
					__asm        je     _Ta4;
				// LINE 1719:
					__asm        mov    eax, iptr;
					__asm        mov    al, [eax];
					__asm        mov    ecx, bufptr;
					__asm        mov    [ecx], al;
					__asm        inc    iptr;
					__asm        inc    bufptr;
				// LINE 1721:
					__asm        jmp    _Taa;
				// LINE 1723:
				_Ta4:
					bufptr++;
				// LINE 1724:
					iptr++;
				// LINE 1726:
				_Taa:
			}
		// LINE 1727:
		_Taf:
			bufptr += (S_borderdimx - S_dicon_dim);
		// LINE 1728:
			iptr += (S_dicon_pitch - S_dicon_dim);
	}
// LINE 1731:
__RETURN:
}

// FUNCTION: COPTER_D 0x005012f5
void S3MapDrawDispatchLine(int32_t xpos, int32_t ypos, int32_t dx, int32_t dy, char col) {
	/*bp-0x4*/   char * writeBuffer;
	/*bp-0x8*/   int32_t Yunit;
	/*bp-0xc*/   int32_t Xinc;
	/*bp-0x10*/  int32_t index;
	/*bp-0x14*/  int32_t Yinc;
	/*bp-0x18*/  int32_t error;

// LINE 1746:
	error = 0x0;
// LINE 1749:
	writeBuffer = (((S_borderdimx * ypos) + xpos) + S_borderbuf);
// LINE 1751:
	__asm        cmp    dx, 0;
	__asm        jl     _T3b;
// LINE 1753:
	Xinc = 0x1;
// LINE 1755:
	__asm        jmp    _T4a;
// LINE 1757:
_T3b:
	Xinc = 0xffffffff;
// LINE 1758:
	__asm        mov    eax, dx;
	__asm        neg    eax;
	__asm        mov    dx, eax;
// LINE 1761:
_T4a:
	__asm        cmp    dy, 0;
	__asm        jl     _T68;
// LINE 1763:
	Yinc = S_borderdimx;
// LINE 1764:
	Yunit = 0x1;
// LINE 1766:
	__asm        jmp    _T81;
// LINE 1768:
_T68:
	__asm        mov    eax, S_borderdimx;
	__asm        neg    eax;
	__asm        mov    Yinc, eax;
// LINE 1769:
	__asm        mov    eax, dy;
	__asm        neg    eax;
	__asm        mov    dy, eax;
// LINE 1770:
	Yunit = 0xffffffff;
// LINE 1773:
_T81:
	__asm        mov    eax, dx;
	__asm        cmp    dy, eax;
	__asm        jge    _FOR_13d;
// LINE 1775:
_FOR_99:
	for (index = 0x0; (index <= dx); index++) {
		// LINE 1777:
			__asm        movsx  eax, col;
			__asm        test   eax, eax;
			__asm        je     _Tbc;

			__asm        mov    al, col;
			__asm        mov    ecx, writeBuffer;
			__asm        mov    [ecx], al;
		// LINE 1778:
		_Tbc:
			error += dy;
		// LINE 1779:
			__asm        mov    eax, dx;
			__asm        cmp    error, eax;
			__asm        jle    _Te4;
		// LINE 1781:
			error -= dx;
		// LINE 1782:
			writeBuffer += Yinc;
		// LINE 1783:
			ypos += Yunit;
		// LINE 1785:
		_Te4:
			writeBuffer += Xinc;
		// LINE 1786:
			xpos += Xinc;
		// LINE 1788:
			__asm        cmp    ypos, 0;
			__asm        jl     _T122;

			__asm        cmp    xpos, 0;
			__asm        jl     _T122;

			__asm        mov    eax, ypos;
			__asm        cmp    S_borderdimy, eax;
			__asm        jle    _T122;

			__asm        mov    eax, xpos;
			__asm        cmp    S_borderdimx, eax;
			__asm        jg     _T127;
		// LINE 1789:
		_T122:
			__asm        jmp    _T12c;
		// LINE 1790:
		_T127:
	}
// LINE 1792:
_T12c:
	return;
// LINE 1794:
_FOR_13d:
	for (index = 0x0; (index <= dy); index++) {
		// LINE 1796:
			__asm        movsx  eax, col;
			__asm        test   eax, eax;
			__asm        je     _T160;

			__asm        mov    al, col;
			__asm        mov    ecx, writeBuffer;
			__asm        mov    [ecx], al;
		// LINE 1797:
		_T160:
			error += dx;
		// LINE 1798:
			__asm        mov    eax, dy;
			__asm        cmp    error, eax;
			__asm        jle    _T188;
		// LINE 1800:
			error -= dy;
		// LINE 1801:
			writeBuffer += Xinc;
		// LINE 1802:
			xpos += Xinc;
		// LINE 1804:
		_T188:
			writeBuffer += Yinc;
		// LINE 1805:
			ypos += Yunit;
		// LINE 1806:
			__asm        js     _T1c2;

			__asm        cmp    xpos, 0;
			__asm        jl     _T1c2;

			__asm        mov    eax, ypos;
			__asm        cmp    S_borderdimy, eax;
			__asm        jle    _T1c2;

			__asm        mov    eax, xpos;
			__asm        cmp    S_borderdimx, eax;
			__asm        jg     _T1c7;
		// LINE 1807:
		_T1c2:
			return;
		// LINE 1808:
		_T1c7:
	}
// LINE 1811:
__RETURN:
}

// FUNCTION: COPTER_D 0x005014c6
void S3MapGetDxDy(long x1, long y1, long x2, long y2, long * dx, long * dy) {
	/*bp-0x4*/   long dist1;
	/*bp-0x8*/   long dist2;
	/*bp-0x10*/  /*packed*/ struct Point2d to; // 0x8 bytes
	/*bp-0x18*/  /*packed*/ struct Point2d from; // 0x8 bytes

// LINE 1832:
	__asm        cmp    x1, 0x80;
	__asm        jge    _T4e;

	__asm        cmp    y1, 0x80;
	__asm        jge    _T4e;
// LINE 1834:
	__asm        mov    eax, x2;
	__asm        sub    eax, x1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        shl    eax, cl;
	__asm        mov    ecx, dx;
	__asm        mov    [ecx], eax;
// LINE 1835:
	__asm        mov    eax, y2;
	__asm        sub    eax, y1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        shl    eax, cl;
	__asm        mov    ecx, dy;
	__asm        mov    [ecx], eax;
// LINE 1836:
	return;
// LINE 1840:
_T4e:
	from.x = x1;
// LINE 1841:
	from.y = y1;
// LINE 1842:
	to.x = x2;
// LINE 1843:
	to.y = y2;
// LINE 1846:
	dist1 = MTCheapDist2D(from.x, to.x);
// LINE 1850:
	__asm        cmp    x1, 0x7F;
	__asm        jle    _T8a;

	from.x -= 0x100;
// LINE 1851:
_T8a:
	__asm        cmp    y1, 0x7F;
	__asm        jle    _T9b;

	from.y -= 0x100;
// LINE 1854:
_T9b:
	dist2 = MTCheapDist2D(from.x, to.x);
// LINE 1857:
	__asm        mov    eax, dist1;
	__asm        cmp    dist2, eax;
	__asm        jge    _Te5;
// LINE 1859:
	__asm        mov    eax, x2;
	__asm        sub    eax, from.x;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        shl    eax, cl;
	__asm        mov    ecx, dx;
	__asm        mov    [ecx], eax;
// LINE 1860:
	__asm        mov    eax, y2;
	__asm        sub    eax, from.y;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        shl    eax, cl;
	__asm        mov    ecx, dy;
	__asm        mov    [ecx], eax;
// LINE 1862:
	return;
// LINE 1864:
_Te5:
	__asm        mov    eax, x2;
	__asm        sub    eax, x1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        shl    eax, cl;
	__asm        mov    ecx, dx;
	__asm        mov    [ecx], eax;
// LINE 1865:
	__asm        mov    eax, y2;
	__asm        sub    eax, y1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(S_mapzoom);
	__asm        shl    eax, cl;
	__asm        mov    ecx, dy;
	__asm        mov    [ecx], eax;
// LINE 1867:
}



// Contribution: 2:00003ab0-00003cbf Module: 172, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x00592ab0
static const int32_t TurnTable3[4][8] = {{0, 1, 2, 3, 4, 5, 6, 7}, {2, 3, 4, 5, 6, 7, 0, 1}, {6, 7, 0, 1, 2, 3, 4, 5}, {4, 5, 6, 7, 0, 1, 2, 3}};

// GLOBAL: COPTER_D 0x00592b30
static const int32_t TurnTable2[4][4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {3, 0, 1, 2}, {2, 3, 0, 1}};

// GLOBAL: COPTER_D 0x00592b70
static const int32_t IndexToType[4] = {1, 2, 4, 8};

// GLOBAL: COPTER_D 0x00592b80
static const int32_t TypeToIndex2[16] = {-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1};

// GLOBAL: COPTER_D 0x00592bc0
static const int32_t TILUT[4][4] = {{0, 1, 3, 2}, {2, 0, 1, 3}, {3, 2, 0, 1}, {1, 3, 2, 0}};

// GLOBAL: COPTER_D 0x00592c00
static const /*packed*/ struct _dPoint2d OT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00592c40
static const /*packed*/ struct _dPoint2d RRT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00592c80
static const /*packed*/ struct _dPoint2d LRT[4] = { 0 /* todo */ };



// Contribution: 3:0001e200-0001e2c3 Module: 172, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b5200
int32_t G_mapmode = 1;

// GLOBAL: COPTER_D 0x005b5208
/*packed*/ struct VRwindowType mwindow = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5228
/*packed*/ struct VRwindowType save_window = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5248
/*packed*/ struct Point2d S_mapmin = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5250
/*packed*/ struct Point2d S_mapmax = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5258
/*packed*/ struct Point2d S_bordermin = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5260
/*packed*/ struct Point2d S_bordermax = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5268
static long S_borderdimx = 0;

// GLOBAL: COPTER_D 0x005b526c
static long S_borderdimy = 0;

// GLOBAL: COPTER_D 0x005b5270
static char * S_mapbuf = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5274
static char * S_borderbuf = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5278
static char * S_mapbufctr = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b527c
static long S_mapdimx = 0;

// GLOBAL: COPTER_D 0x005b5280
static long S_mapdimy = 0;

// GLOBAL: COPTER_D 0x005b5284
static char S_fire_cycle = 0;

// GLOBAL: COPTER_D 0x005b5288
static long S_dirlen = 20;

// GLOBAL: COPTER_D 0x005b528c
static char * S_savebuffer1 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b5290
static int32_t S_save_aspect = 0;

// GLOBAL: COPTER_D 0x005b5294
static int32_t S_save_width = 0;

// GLOBAL: COPTER_D 0x005b5298
static int32_t S_mapzoom = 3;



// Contribution: 3:00071bc8-00071c23 Module: 172, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00608bc8
static long S_dicon_dim;

// GLOBAL: COPTER_D 0x00608bd0
static char * S_icons[8];

// GLOBAL: COPTER_D 0x00608bf0
static long S_icon_dim;

// GLOBAL: COPTER_D 0x00608bf8
static /*packed*/ struct Point2d S_lrc;

// GLOBAL: COPTER_D 0x00608c00
static long S_dicon_pitch;

// GLOBAL: COPTER_D 0x00608c08
static /*packed*/ struct Point2d S_ulc;

// GLOBAL: COPTER_D 0x00608c10
static long S_icon_pitch;

// GLOBAL: COPTER_D 0x00608c18
static char * S_dicons[3];



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.

// WARNING: this global might actually belong to: C:\Copter\source\game\S3auto.cpp
// GLOBAL: COPTER_D 0x0067ed30
/*packed*/ struct _CELL_INFO *G_omap[256][256]; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\game\S3viewer.c
// GLOBAL: COPTER_D 0x006c1330
int32_t ViewYRot[4][4]; // Contrib missing

// GLOBAL: COPTER_D 0x006bed40
/*packed*/ struct _MAP_CARINFO S_carinfo[20]; // Contrib missing

