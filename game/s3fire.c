// Module: S3fire.obj
// Source: C:\Copter\source\game\S3fire.c
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: long;

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct _dPoint2d (forward reference);
struct _dPoint2d{ // packed(0x10 bytes) TI: 0x2766
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double z; // 0x8 bytes
};

// Type: /*packed*/ struct _FIRE_DATA;
struct _FIRE_DATA{ // packed(0xa0 bytes) TI: 0x3030
	/*+0x0*/   long flags;
	/*+0x4*/   int32_t timetolive;
	/*+0x8*/   int32_t douse_points;
	/*+0xc*/   int32_t hdelta;
	/*+0x10*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x1c*/  long elevation;
	/*+0x20*/  /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x24*/  /*packed*/ struct _DYOBJ_INST dyfire; // 0x64 bytes
	/*+0x88*/  int32_t dycheck_timer;
	/*+0x8c*/  /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*+0x94*/  int32_t building;
	/*+0x98*/  /*packed*/ struct _CELL_FIRE_DATA *cfd;
	/*+0x9c*/  long mission_id;
};

// Type: /*packed*/ struct _CELL_FIRE_DATA;
struct _CELL_FIRE_DATA{ // packed(0x8 bytes) TI: 0x303d
	/*+0x0*/   /*packed*/ struct _CELL_INFO *cptr;
	/*+0x4*/   long fire_count;
};

// Type: /*packed*/ struct _FIRE_DATA (forward reference);
struct _FIRE_DATA{ // packed(0xa0 bytes) TI: 0x3030
	/*+0x0*/   long flags;
	/*+0x4*/   int32_t timetolive;
	/*+0x8*/   int32_t douse_points;
	/*+0xc*/   int32_t hdelta;
	/*+0x10*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x1c*/  long elevation;
	/*+0x20*/  /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x24*/  /*packed*/ struct _DYOBJ_INST dyfire; // 0x64 bytes
	/*+0x88*/  int32_t dycheck_timer;
	/*+0x8c*/  /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*+0x94*/  int32_t building;
	/*+0x98*/  /*packed*/ struct _CELL_FIRE_DATA *cfd;
	/*+0x9c*/  long mission_id;
};

// Type: void;

// Type: char *;

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: /*packed*/ struct _CELL_FIRE_DATA (forward reference);
struct _CELL_FIRE_DATA{ // packed(0x8 bytes) TI: 0x303d
	/*+0x0*/   /*packed*/ struct _CELL_INFO *cptr;
	/*+0x4*/   long fire_count;
};

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct _MISSION_PARMS;
struct _MISSION_PARMS{ // packed(0x18 bytes) TI: 0x307d
	/*+0x0*/   long op;
	/*+0x4*/   long id;
	/*+0x8*/   /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x10*/  long i2num;
	/*+0x14*/  long flags;
};

// Type: /*packed*/ struct _STOBJ_INST (forward reference);
struct _STOBJ_INST{ // packed(0x10 bytes) TI: 0x193f
	/*+0x0*/   /*packed*/ struct _STOBJ_INST *next;
	/*+0x4*/   void * __ptr32 mesh;
	/*+0x8*/   long user1;
	/*+0xc*/   long user2;
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct _LZ_INFO (forward reference);
struct _LZ_INFO{ // packed(0x14 bytes) TI: 0x3152
	/*+0x0*/   int32_t flags;
	/*+0x4*/   int32_t ulx;
	/*+0x8*/   int32_t ulz;
	/*+0xc*/   int32_t dimx;
	/*+0x10*/  int32_t dimz;
};

// Type: /*packed*/ struct Point2d;
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: int32_t *;

// Type: short;

// Type: void * __ptr32;



// Contribution: 1:001235f0-00126462 Module: 165, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x005245f0
void S3FireReset() {
	/*bp-0x4*/   /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0x8*/   long i;

// LINE 105:
	S_fire_count = 0x0;
// LINE 111:
_FOR_26:
	i = 0x0;
	fd = 0x6666f0;
	__asm        jmp    _FOR_COND_26;
_FOR_NEXT_26:
	i++;
	fd += 0xa0;
_FOR_COND_26:
	__asm        cmp    i, 0x8C;
	__asm        jge    _FOR_57;
// LINE 114:
	fd->flags = 0x0;
// LINE 115:
	__asm        jmp    _FOR_NEXT_26;
// LINE 119:
_FOR_57:
	for (i = 0x0; (i < 0x8c); i++) {
		// LINE 121:
			__asm        mov    eax, i;
			__asm        mov    S_cfdata[0].cptr[eax*8], 0;
		// LINE 122:
			__asm        mov    eax, i;
			__asm        mov    S_cfdata[0].fire_count[eax*8], 0;
	}
// LINE 126:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052467d
void S3FireInit() {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  long size;
	/*bp-0x2c*/  /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0x30*/  long i;
	/*bp-0x34*/  char * mem;
	/*bp-0x38*/  int32_t height;

// LINE 143:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        push   0x120;
	__asm        call   _VRGetObject;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   _VRGetObjInfo;
	__asm        add    esp, 8;
// LINE 144:
	__asm        push   0x120;
	__asm        call   _VRGetObject;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRObjGetHeight;
	__asm        add    esp, 4;
	__asm        mov    height, eax;
// LINE 147:
	__asm        push   0x120;
	__asm        call   _VRGetObject;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRGetObjDupMemReq;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 154:
_FOR_68:
	i = 0x0;
	fd = 0x6666f0;
	__asm        jmp    _FOR_COND_68;
_FOR_NEXT_68:
	i++;
	fd += 0xa0;
_FOR_COND_68:
	__asm        cmp    i, 0x8C;
	__asm        jge    _FOR_176;
// LINE 157:
	fd->flags = 0x0;
// LINE 158:
	fd->timetolive = 0x0;
// LINE 159:
	fd->douse_points = 0x0;
// LINE 160:
	fd->loc.x = 0x0;
// LINE 161:
	fd->loc.y = 0x0;
// LINE 162:
	fd->loc.z = 0x0;
// LINE 163:
	fd->elevation = 0x0;
// LINE 165:
	fd->stptr = S2Alloc(G_dyobjmempool, 0x10);
// LINE 166:
	fd->stptr->user1 = 0x1;
// LINE 167:
	fd->stptr->user2 = fd;
// LINE 169:
	mem = S2Alloc(G_dyobjmempool, size);
// LINE 170:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x120;
	__asm        call   _VRGetObject;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRCreateObjDuplicate;
	__asm        add    esp, 8;
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x20];
	__asm        mov    [ecx+4], eax;
// LINE 171:
	_VRAddObjToMemPool(fd->stptr->mesh, G_main_mp);
// LINE 174:
	fd->dyfire.radius = 0x100000;
// LINE 175:
	fd->dyfire.height = height;
// LINE 176:
	fd->dyfire.mesh = fd->stptr->mesh;
// LINE 177:
	__asm        jmp    _FOR_NEXT_68;
// LINE 181:
_FOR_176:
	for (i = 0x0; (i < 0x8c); i++) {
		// LINE 183:
			__asm        mov    eax, i;
			__asm        mov    S_cfdata[0].cptr[eax*8], 0;
		// LINE 184:
			__asm        mov    eax, i;
			__asm        mov    S_cfdata[0].fire_count[eax*8], 0;
	}
// LINE 187:
__RETURN:
}

// FUNCTION: COPTER_D 0x00524829
int32_t S3FireStart(/*packed*/ struct _CELL_FIRE_DATA *cfd, long cellx, long celly, int32_t x, int32_t y, int32_t z, long side_flag, long mission_id, long flags) {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0x2c*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x30*/  int32_t maxradius;
	/*bp-0x34*/  long i;
	/*bp-0x4c*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x50*/  /*packed*/ struct _CELL_INFO *cptr;

// LINE 213:
_FOR_1c:
	i = 0x0;
	fd = 0x6666f0;
	__asm        jmp    _FOR_COND_1c;
_FOR_NEXT_1c:
	i++;
	fd += 0xa0;
_FOR_COND_1c:
	__asm        cmp    i, 0x8C;
	__asm        jge    _T49;
// LINE 215:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T44;
// LINE 216:
	__asm        jmp    _T49;
// LINE 217:
_T44:
	__asm        jmp    _FOR_NEXT_1c;
// LINE 220:
_T49:
	__asm        cmp    i, 0x8C;
	__asm        jne    _T5d;
// LINE 221:
	return 0x0;
// LINE 223:
_T5d:
	__asm        mov    eax, celly;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, cellx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 225:
	__asm        mov    eax, cptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T8f;
// LINE 226:
	return 0x0;
// LINE 228:
_T8f:
	fd->celloc.x = cellx;
// LINE 229:
	fd->celloc.y = celly;
// LINE 231:
	fd->mission_id = mission_id;
// LINE 234:
	fd->flags = (side_flag | 0x1);
// LINE 238:
	maxradius = 0x0;
// LINE 239:
	stobj = cptr->stptr;
// LINE 240:
	fd->building = 0x0;
// LINE 241:
__WHILE_db:
	while ((stobj != 0x0)) {
		// LINE 243:
			_VRGetObjInfo(stobj->mesh, oinfo.Faces);
		// LINE 244:
			__asm        mov    eax, stobj;
			__asm        test   byte ptr [eax+8], 4;
			__asm        je     _T11f;
		// LINE 246:
			fd->building = stobj->mesh;
		// LINE 247:
			maxradius = oinfo.Radius;
		// LINE 248:
			__asm        jmp    _T13e;
		// LINE 250:
		_T11f:
			__asm        mov    eax, maxradius;
			__asm        cmp    oinfo.Radius, eax;
			__asm        jle    _T131;

			maxradius = oinfo.Radius;
		// LINE 251:
		_T131:
			stobj = stobj->next;
	}
// LINE 254:
_T13e:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        cmp    eax, 1;
	__asm        jle    _T166;
// LINE 255:
	__asm        mov    eax, cptr;
	__asm        movsx  ecx, word ptr [eax+8];
	__asm        mov    eax, maxradius;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0xC], eax;
// LINE 256:
	__asm        jmp    _T170;
// LINE 257:
_T166:
	fd->hdelta = 0x200000;
// LINE 259:
_T170:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        dec    eax;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x1C], eax;
// LINE 260:
	__asm        mov    eax, G_diff_level;
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, S_ftwk_douse_points;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+8], eax;
// LINE 261:
	__asm        mov    eax, S_ftwk_time_to_live;
	__asm        mov    ecx, G_diff_level;
	__asm        lea    ecx, [ecx+ecx*4-5];
	__asm        shl    ecx, 0x12;
	__asm        sub    eax, ecx;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+4], eax;
// LINE 262:
	fd->cfd = cfd;
// LINE 263:
	cfd->fire_count++;
// LINE 270:
	VR3dObjLocate(fd->stptr->mesh, (x - fd->loc.x), (y - fd->loc.y), (z - fd->loc.z));
// LINE 272:
	fd->loc.x = x;
// LINE 273:
	fd->loc.y = y;
// LINE 274:
	fd->loc.z = z;
// LINE 277:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        add    eax, x;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x3C], eax;
// LINE 278:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        add    eax, y;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x40], eax;
// LINE 279:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        add    eax, z;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x44], eax;
// LINE 282:
	fd->dycheck_timer = 0x8000;
// LINE 285:
	fd->stptr->next = cptr->stptr;
// LINE 286:
	cptr->stptr = fd->stptr;
// LINE 288:
	mp.op = 0x1;
// LINE 289:
	mp.id = mission_id;
// LINE 290:
	mp.i2num = 0x1;
// LINE 291:
	mp.flags = flags;
// LINE 292:
	S3MissionUpdate(mp.op);
// LINE 294:
	S_fire_count++;
// LINE 295:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        or     eax, 0x20;
	__asm        mov    ecx, cptr;
	__asm        mov    [ecx], ax;
// LINE 297:
	return 0x1;
// LINE 299:
}

// FUNCTION: COPTER_D 0x00524adf
void S3FireDriver() {
	/*bp-0x4*/   long mindist;
	/*bp-0x8*/   /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0xc*/   long dist;
	/*bp-0x10*/  /*packed*/ struct _FIRE_DATA *nfd;
	/*bp-0x1c*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x20*/  /*packed*/ struct Point2d *missloc;
	/*bp-0x24*/  long i;
	/*bp-0x30*/  /*packed*/ struct Point3d floc; // 0xc bytes
	/*bp-0x48*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x4c*/  int32_t newcoord;
	/*bp-0x50*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x54*/  int32_t fireloopsound;
	/*bp-0x60*/  /*packed*/ struct Point3d minloc; // 0xc bytes
	/*bp-0x64*/  /*packed*/ struct _STOBJ_INST **stptrptr;

// LINE 322:
	fireloopsound = 0x0;
// LINE 325:
	fireloopsound = S3SoundIsPlaying(0xd);
// LINE 328:
	__asm        cmp    S_fire_count, 0;
	__asm        jne    _T43;
// LINE 330:
	__asm        cmp    fireloopsound, 1;
	__asm        jne    _T3e;
// LINE 332:
	S3DSStopPlay(0xd);
// LINE 335:
_T3e:
	return;
// LINE 338:
_T43:
	mindist = 0x7d00;
// LINE 341:
_FOR_5d:
	i = 0x0;
	fd = 0x6666f0;
	__asm        jmp    _FOR_COND_5d;
_FOR_NEXT_5d:
	i++;
	fd += 0xa0;
_FOR_COND_5d:
	__asm        cmp    i, 0x8C;
	__asm        jge    _T585;
// LINE 343:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T85;
// LINE 344:
	__asm        jmp    _FOR_NEXT_5d;
// LINE 346:
_T85:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        jne    _T9b;
// LINE 355:
_T9b:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    floc.x, eax;
// LINE 356:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    floc.y, eax;
// LINE 357:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    floc.z, eax;
// LINE 358:
	loc.x = (ViewState.world_pos.x - floc.x);
// LINE 359:
	loc.y = (ViewState.world_pos.y - floc.y);
// LINE 360:
	loc.z = (ViewState.world_pos.z - floc.z);
// LINE 361:
	dist = MTCheapDist2D(0x6bf188, (fd + 0x8c));
// LINE 362:
	__asm        mov    eax, dist;
	__asm        cmp    mindist, eax;
	__asm        jle    _T13c;
// LINE 364:
	mindist = dist;
// LINE 365:
	__asm        lea    eax, floc.x;
	__asm        lea    ecx, minloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 369:
_T13c:
	fd->timetolive -= G_AvLoopTime;
// LINE 370:
	__asm        mov    eax, fd;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jg     _T50d;
// LINE 375:
	__asm        mov    eax, fd;
	__asm        cmp    dword ptr [eax+0x1C], 0;
	__asm        jle    _T350;
// LINE 378:
	__asm        mov    eax, fd;
	__asm        cmp    dword ptr [eax+0x94], 0;
	__asm        jne    _T185;
// LINE 380:
	fd->elevation = 0x0;
// LINE 381:
	__asm        jmp    _FOR_NEXT_5d;
// LINE 385:
_T185:
	__asm        mov    eax, fd;
	__asm        add    eax, 0x10;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 388:
	loc.y += fd->hdelta;
// LINE 390:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 2;
	__asm        je     _T1e2;
// LINE 397:
	newcoord = VRGetObjZdist(fd->building, loc.x, loc.y, -0x1, 0x20000);
// LINE 398:
	loc.z = newcoord;
// LINE 400:
	__asm        jmp    _T28e;
_T1e2:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 4;
	__asm        je     _T21d;
// LINE 407:
	newcoord = VRGetObjZdist(fd->building, loc.x, loc.y, 0x1, 0x20000);
// LINE 408:
	loc.z = newcoord;
// LINE 410:
	__asm        jmp    _T28e;
_T21d:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 8;
	__asm        je     _T258;
// LINE 417:
	newcoord = VRGetObjXdist(fd->building, loc.y, loc.z, -0x1, 0x20000);
// LINE 418:
	loc.x = newcoord;
// LINE 420:
	__asm        jmp    _T28e;
_T258:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 0x10;
	__asm        je     _T28e;
// LINE 427:
	newcoord = VRGetObjXdist(fd->building, loc.y, loc.z, 0x1, 0x20000);
// LINE 428:
	loc.x = newcoord;
// LINE 431:
_T28e:
	__asm        cmp    newcoord, 0;
	__asm        jne    _T2a7;
// LINE 433:
	fd->elevation = 0x0;
// LINE 434:
	__asm        jmp    _FOR_NEXT_5d;
// LINE 437:
_T2a7:
	fd->elevation--;
// LINE 438:
	__asm        mov    eax, G_diff_level;
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, S_ftwk_douse_points;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+8], eax;
// LINE 439:
	__asm        mov    eax, S_ftwk_time_to_live;
	__asm        mov    ecx, G_diff_level;
	__asm        lea    ecx, [ecx+ecx*4-5];
	__asm        shl    ecx, 0x12;
	__asm        sub    eax, ecx;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+4], eax;
// LINE 443:
	VR3dObjLocate(fd->stptr->mesh, (loc.x - fd->loc.x), (loc.y - fd->loc.y), (loc.z - fd->loc.z));
// LINE 445:
	__asm        lea    eax, loc.x;
	__asm        mov    ecx, fd;
	__asm        add    ecx, 0x10;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 447:
	fd->dyfire.loc.x = (floc.x + loc.x);
// LINE 448:
	fd->dyfire.loc.y = (floc.y + loc.y);
// LINE 449:
	fd->dyfire.loc.z = (floc.z + loc.z);
// LINE 451:
	__asm        jmp    _T508;
// LINE 453:
_T350:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x90];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x8C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 455:
	stptrptr = (cptr + 0xc);
// LINE 456:
__WHILE_383:
	while ((stptrptr-> != 0x0)) {
		// LINE 458:
			__asm        mov    eax, fd;
			__asm        mov    ecx, stptrptr;
			__asm        mov    ecx, [ecx];
			__asm        cmp    [eax+0x20], ecx;
			__asm        jne    _T3b2;
		// LINE 460:
			stptrptr-> = fd->stptr->next;
		// LINE 461:
			__asm        jmp    _T3bf;
		// LINE 463:
		_T3b2:
			stptrptr = stptrptr->;
	}
// LINE 466:
_T3bf:
	fd->flags = (fd->flags & -0x2);
// LINE 469:
	fd->cfd->fire_count--;
// LINE 470:
	S_fire_count--;
// LINE 472:
	mp.op = 0x3;
// LINE 473:
	mp.id = fd->mission_id;
// LINE 474:
	mp.i2num = 0x1;
// LINE 475:
	mp.flags = 0x0;
// LINE 476:
	S3MissionUpdate(mp.op);
// LINE 480:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T508;
// LINE 483:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        and    eax, 0xFFDF;
	__asm        mov    ecx, cptr;
	__asm        mov    [ecx], ax;
// LINE 485:
	mp.op = 0x4;
// LINE 486:
	mp.id = fd->mission_id;
// LINE 487:
	mp.i2num = 0x1;
// LINE 488:
	mp.flags = 0x0;
// LINE 489:
	S3MissionUpdate(mp.op);
// LINE 491:
	missloc = S3MissionGetMapLoc(fd->mission_id);
// LINE 492:
	__asm        cmp    missloc, 0;
	__asm        je     _T4fc;

	__asm        mov    eax, fd;
	__asm        mov    ecx, missloc;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x8C], ecx;
	__asm        jne    _T4fc;

	__asm        mov    eax, missloc;
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x90];
	__asm        cmp    [eax+4], ecx;
	__asm        jne    _T4fc;
// LINE 494:
	nfd = S3FireGetByMission(fd->mission_id);
// LINE 495:
	__asm        cmp    nfd, 0;
	__asm        jne    _T4c8;
// LINE 500:
	__asm        jmp    _T4fc;
// LINE 502:
_T4c8:
	mp.op = 0x0;
// LINE 503:
	mp.id = nfd->mission_id;
// LINE 504:
	__asm        mov    eax, nfd;
	__asm        add    eax, 0x8C;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        lea    edx, mp.maploc.x;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 505:
	S3MissionUpdate(mp.op);
// LINE 509:
_T4fc:
	S3FireDestroyCell(fd);
// LINE 513:
_T508:
	__asm        jmp    _FOR_NEXT_5d;
// LINE 517:
_T50d:
	S3FireDyObjCollisionCheck(fd, 0x6);
// LINE 520:
	S_spread_time += G_AvLoopTime;
// LINE 521:
	__asm        mov    eax, S_ftwk_spread_interval;
	__asm        mov    ecx, G_diff_level;
	__asm        dec    ecx;
	__asm        shl    ecx, 0x12;
	__asm        sub    eax, ecx;
	__asm        cmp    eax, S_spread_time;
	__asm        jge    _T580;
// LINE 523:
	S_spread_time = 0x0;
// LINE 524:
	__asm        call   rand;
	__asm        mov    ecx, S_ftwk_spread_probability;
	__asm        mov    edx, G_diff_level;
	__asm        lea    edx, [edx+edx*4-5];
	__asm        add    edx, edx;
	__asm        sub    ecx, edx;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T580;
// LINE 525:
	S3FireSpread(fd);
// LINE 529:
_T580:
	__asm        jmp    _FOR_NEXT_5d;
// LINE 535:
_T585:
	__asm        cmp    fireloopsound, 1;
	__asm        jne    _T5bb;
// LINE 539:
	__asm        cmp    mindist, 0x32;
	__asm        jl     _T5a8;
// LINE 541:
	S3DSStopPlay(0xd);
// LINE 543:
	__asm        jmp    _T5b6;
// LINE 547:
_T5a8:
	S3SoundSetPosition(0xd, minloc.x);
// LINE 551:
_T5b6:
	__asm        jmp    _T5d5;
// LINE 554:
_T5bb:
	__asm        cmp    mindist, 0x32;
	__asm        jge    _T5d5;
// LINE 556:
	S3DSPlay(0xd, minloc.x, 0x1);
// LINE 562:
_T5d5:
	return;
// LINE 563:
}

// FUNCTION: COPTER_D 0x005250be
void S3FireSpread(/*packed*/ struct _FIRE_DATA *fd) {
	/*bp-0x4*/   /*packed*/ struct _CELL_FIRE_DATA *cfd;
	/*bp-0x8*/   long cellx;
	/*bp-0xc*/   long celly;
	/*bp-0x10*/  long i;
	/*bp-0x14*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x18*/  /*packed*/ struct _FIRE_DATA *tfd;

// LINE 582:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    i, eax;
// LINE 584:
	__asm        mov    eax, i;
	__asm        mov    eax, S_dirs[0].x[eax*8];
	__asm        mov    ecx, fd;
	__asm        add    eax, [ecx+0x8C];
	__asm        mov    cellx, eax;
// LINE 585:
	__asm        mov    eax, i;
	__asm        mov    eax, S_dirs[0].y[eax*8];
	__asm        mov    ecx, fd;
	__asm        add    eax, [ecx+0x90];
	__asm        mov    celly, eax;
// LINE 586:
	__asm        mov    eax, celly;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, cellx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 589:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _T7d;
// LINE 590:
	return;
// LINE 593:
_T7d:
	__asm        mov    eax, cptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _FOR_a2;
// LINE 594:
	return;
// LINE 599:
_FOR_a2:
	i = 0x0;
	tfd = 0x6666f0;
	__asm        jmp    _FOR_COND_a2;
_FOR_NEXT_a2:
	i++;
	tfd += 0xa0;
_FOR_COND_a2:
	__asm        cmp    i, 0x8C;
	__asm        jge    _Te3;
// LINE 601:
	__asm        mov    eax, tfd;
	__asm        test   byte ptr [eax], 1;
	__asm        je     _Tde;

	__asm        mov    eax, tfd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    ecx, cptr;
	__asm        cmp    [eax], ecx;
	__asm        jne    _Tde;
// LINE 602:
	return;
// LINE 603:
_Tde:
	__asm        jmp    _FOR_NEXT_a2;
// LINE 605:
_Te3:
	cfd = S3FireGetCellData();
// LINE 606:
	cfd->cptr = cptr;
// LINE 607:
	S3FireStartCell(cfd, cellx, celly, fd->mission_id, 0x0);
// LINE 608:
}

// FUNCTION: COPTER_D 0x005251d6
/*packed*/ struct _CELL_FIRE_DATA* S3FireGetCellData() {
	/*bp-0x4*/   long i;

// LINE 621:
_FOR_15:
	for (i = 0x0; (i < 0x8c); i++) {
		// LINE 623:
			__asm        mov    eax, i;
			__asm        cmp    S_cfdata[0].fire_count[eax*8], 0;
			__asm        jne    _T45;
		// LINE 624:
			__asm        mov    eax, i;
			__asm        lea    eax, S_cfdata[0].cptr[eax*8];
			__asm        jmp    __RETURN;
		// LINE 625:
		_T45:
	}
// LINE 627:
_T4a:
	return 0x0;
// LINE 628:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052522c
void S3FireDouse(/*packed*/ struct _CELL_INFO *cptr, /*packed*/ struct Point3d *wloc, int32_t water_timetolive) {
	/*bp-0x4*/   /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0xc*/   /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x10*/  /*packed*/ struct _FIRE_DATA *nfd;
	/*bp-0x1c*/  /*packed*/ struct Point3d dloc; // 0xc bytes
	/*bp-0x28*/  /*packed*/ struct Point3d center; // 0xc bytes
	/*bp-0x2c*/  /*packed*/ struct Point2d *missloc;
	/*bp-0x38*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x3c*/  int32_t dfactor;
	/*bp-0x54*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x58*/  int32_t radius;
	/*bp-0x5c*/  /*packed*/ struct _STOBJ_INST **stptrptr;

// LINE 651:
	radius = (S_ftwk_fire_radius - ((G_diff_level - 1) << 0x13));
// LINE 654:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        jne    _T30;
// LINE 655:
	__asm        jmp    check_dyobjs;
// LINE 658:
_T30:
	__asm        mov    eax, wloc;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.x, eax;
// LINE 659:
	__asm        mov    eax, wloc;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.y, eax;
// LINE 660:
	__asm        mov    eax, wloc;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.z, eax;
// LINE 664:
	stobj = cptr->stptr;
// LINE 665:
__WHILE_77:
	while ((stobj != 0x0)) {
		// LINE 667:
			__asm        mov    eax, stobj;
			__asm        test   byte ptr [eax+8], 1;
			__asm        jne    _T93;
		// LINE 668:
			__asm        jmp    next_obj;
		// LINE 671:
		_T93:
			fd = stobj->user2;
		// LINE 675:
			fd->timetolive += 0x30000;
		// LINE 678:
			_VRGetObjCenter(stobj->mesh, center.x);
		// LINE 684:
			__asm        mov    eax, center.x;
			__asm        add    eax, radius;
			__asm        cmp    eax, loc.x;
			__asm        jle    _Tf5;

			__asm        mov    eax, center.x;
			__asm        sub    eax, radius;
			__asm        cmp    eax, loc.x;
			__asm        jge    _Tf5;

			__asm        mov    eax, center.z;
			__asm        add    eax, radius;
			__asm        cmp    eax, loc.z;
			__asm        jle    _Tf5;

			__asm        mov    eax, center.z;
			__asm        sub    eax, radius;
			__asm        cmp    eax, loc.z;
			__asm        jl     _Tfa;
		// LINE 686:
		_Tf5:
			__asm        jmp    next_obj;
		// LINE 692:
		_Tfa:
			__asm        cmp    water_timetolive, 0;
			__asm        jg     _T109;
		// LINE 693:
			return;
		// LINE 696:
		_T109:
			__asm        push   0x50000;
			__asm        mov    eax, 0x50000;
			__asm        sub    eax, water_timetolive;
			__asm        push   eax;
			__asm        call   _FixedDiv;
			__asm        add    esp, 8;
			__asm        mov    dfactor, eax;
		// LINE 697:
			__asm        mov    eax, S_ftwk_douse_multiplier;
			__asm        mov    ecx, G_diff_level;
			__asm        lea    ecx, [ecx+ecx*4-5];
			__asm        sub    eax, ecx;
			__asm        imul   eax, dfactor;
			__asm        mov    dfactor, eax;
		// LINE 700:
			__asm        cmp    dfactor, 0;
			__asm        je     _T193;
		// LINE 702:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x98];
			__asm        mov    eax, [eax];
			__asm        movsx  eax, word ptr [eax+2];
			__asm        shl    eax, 0x10;
			__asm        mov    dloc.x, eax;
		// LINE 703:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x98];
			__asm        mov    eax, [eax];
			__asm        movsx  eax, word ptr [eax+4];
			__asm        shl    eax, 0x10;
			__asm        mov    dloc.y, eax;
		// LINE 704:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x98];
			__asm        mov    eax, [eax];
			__asm        movsx  eax, word ptr [eax+6];
			__asm        shl    eax, 0x10;
			__asm        mov    dloc.z, eax;
		// LINE 706:
			S3DSPlay(0xf, dloc.x, 0x0);
		// LINE 710:
		_T193:
			fd->douse_points -= dfactor;
		// LINE 711:
			__asm        mov    eax, fd;
			__asm        cmp    dword ptr [eax+8], 0;
			__asm        jge    _T334;
		// LINE 715:
			stptrptr = (cptr + 0xc);
		// LINE 716:
		__WHILE_1b6:
			while ((stptrptr-> != 0x0)) {
				// LINE 718:
					__asm        mov    eax, fd;
					__asm        mov    ecx, stptrptr;
					__asm        mov    ecx, [ecx];
					__asm        cmp    [eax+0x20], ecx;
					__asm        jne    _T1e5;
				// LINE 720:
					stptrptr-> = fd->stptr->next;
				// LINE 721:
					__asm        jmp    _T1f2;
				// LINE 723:
				_T1e5:
					stptrptr = stptrptr->;
			}
		// LINE 726:
		_T1f2:
			fd->flags = (fd->flags & -0x2);
		// LINE 729:
			fd->cfd->fire_count--;
		// LINE 731:
			mp.op = 0x2;
		// LINE 732:
			mp.id = fd->mission_id;
		// LINE 733:
			mp.i2num = 0x1;
		// LINE 734:
			mp.flags = 0x0;
		// LINE 735:
			S3MissionUpdate(mp.op);
		// LINE 739:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x98];
			__asm        cmp    dword ptr [eax+4], 0;
			__asm        jne    _T329;
		// LINE 742:
			__asm        mov    eax, cptr;
			__asm        movsx  eax, word ptr [eax];
			__asm        and    eax, 0xFFDF;
			__asm        mov    ecx, cptr;
			__asm        mov    [ecx], ax;
		// LINE 744:
			mp.op = 0x6;
		// LINE 745:
			mp.id = fd->mission_id;
		// LINE 746:
			mp.i2num = 0x1;
		// LINE 747:
			mp.flags = 0x0;
		// LINE 748:
			S3MissionUpdate(mp.op);
		// LINE 750:
			missloc = S3MissionGetMapLoc(fd->mission_id);
		// LINE 751:
			__asm        cmp    missloc, 0;
			__asm        je     _T329;

			__asm        mov    eax, missloc;
			__asm        mov    ecx, fd;
			__asm        mov    ecx, [ecx+0x8C];
			__asm        cmp    [eax], ecx;
			__asm        jne    _T329;

			__asm        mov    eax, missloc;
			__asm        mov    ecx, fd;
			__asm        mov    ecx, [ecx+0x90];
			__asm        cmp    [eax+4], ecx;
			__asm        jne    _T329;
		// LINE 753:
			nfd = S3FireGetByMission(fd->mission_id);
		// LINE 754:
			__asm        cmp    nfd, 0;
			__asm        jne    _T2f5;
		// LINE 758:
			__asm        jmp    _T329;
		// LINE 760:
		_T2f5:
			mp.op = 0x0;
		// LINE 761:
			mp.id = nfd->mission_id;
		// LINE 762:
			__asm        mov    eax, nfd;
			__asm        add    eax, 0x8C;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        lea    edx, mp.maploc.x;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 763:
			S3MissionUpdate(mp.op);
		// LINE 768:
		_T329:
			S_fire_count--;
		// LINE 769:
			return;
		// LINE 774:
		_T334:
			return;
		// LINE 777:
		next_obj:
			stobj = stobj->next;
	}
// LINE 786:
check_dyobjs:
	return;
// LINE 788:
	dyobj = cptr->dyptr;
// LINE 789:
__WHILE_354:
	while ((dyobj != 0x0)) {
		// LINE 792:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   ah, 0x10;
			__asm        je     _T3e6;
		// LINE 798:
			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x18];
			__asm        add    eax, radius;
			__asm        mov    ecx, wloc;
			__asm        cmp    eax, [ecx];
			__asm        jle    _T3e6;

			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x18];
			__asm        sub    eax, radius;
			__asm        mov    ecx, wloc;
			__asm        cmp    eax, [ecx];
			__asm        jge    _T3e6;

			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x20];
			__asm        add    eax, radius;
			__asm        mov    ecx, wloc;
			__asm        cmp    eax, [ecx+8];
			__asm        jle    _T3e6;

			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x20];
			__asm        sub    eax, radius;
			__asm        mov    ecx, wloc;
			__asm        cmp    eax, [ecx+8];
			__asm        jge    _T3e6;
		// LINE 804:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   ah, 4;
			__asm        je     _T3e1;
		// LINE 806:
			S3MissileDebrisDouse(dyobj);
		// LINE 808:
			__asm        jmp    _T3e1;
		// LINE 813:
		_T3e1:
			return;
		// LINE 817:
		_T3e6:
			dyobj = dyobj->next;
	}
// LINE 820:
__RETURN:
}

// FUNCTION: COPTER_D 0x00525624
int32_t S3FireStartCell(/*packed*/ struct _CELL_FIRE_DATA *cfd, long cellx, long celly, long mission_id, long flags) {
	/*bp-0x4*/   /*packed*/ struct _LZ_INFO *lz;
	/*bp-0x1c*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x20*/  int32_t retval;

// LINE 833:
	retval = 0x0;
// LINE 837:
	__asm        mov    eax, cfd;
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        je     _T27;
// LINE 838:
	return 0x0;
// LINE 841:
_T27:
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        call   S3FireCanCellBurn;
	__asm        add    esp, 8;
	__asm        test   eax, eax;
	__asm        jne    _T46;
// LINE 842:
	return 0x0;
// LINE 846:
_T46:
	__asm        mov    eax, cfd;
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+8];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T9e4;
// LINE 849:
_T57:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x300000;
	__asm        push   0;
	__asm        push   0xFFE00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 850:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _Tc9;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x300000;
	__asm        push   0;
	__asm        push   0x200000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 851:
_Tc9:
	__asm        call   rand;
	__asm        mov    ecx, 5;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T10e;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFFD00000;
	__asm        push   0;
	__asm        push   0xFFE00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 852:
_T10e:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T153;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFFD00000;
	__asm        push   0;
	__asm        push   0x200000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 853:
_T153:
	__asm        call   rand;
	__asm        mov    ecx, 7;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T198;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0x200000;
	__asm        push   0;
	__asm        push   0xFFD00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 854:
_T198:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T1dd;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0x200000;
	__asm        push   0;
	__asm        push   0x300000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 855:
_T1dd:
	__asm        call   rand;
	__asm        mov    ecx, 6;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T222;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0xFFE00000;
	__asm        push   0;
	__asm        push   0xFFD00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 856:
_T222:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T267;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0xFFE00000;
	__asm        push   0;
	__asm        push   0x300000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 857:
_T267:
	__asm        jmp    _Ta07;
// LINE 859:
_T26c:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0x400000;
	__asm        push   0;
	__asm        push   0x500000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 860:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T2db;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x500000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 861:
_T2db:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T320;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0xFFC00000;
	__asm        push   0;
	__asm        push   0x500000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 862:
_T320:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T365;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0x400000;
	__asm        push   0;
	__asm        push   0xFFB00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 863:
_T365:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T3a9;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0xFFB00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 864:
_T3a9:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T3ee;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0xFFC00000;
	__asm        push   0;
	__asm        push   0xFFB00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 865:
_T3ee:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T433;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x500000;
	__asm        push   0;
	__asm        push   0x400000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 866:
_T433:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 7;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T477;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x500000;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 867:
_T477:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T4bc;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x500000;
	__asm        push   0;
	__asm        push   0xFFC00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 868:
_T4bc:
	__asm        call   rand;
	__asm        mov    ecx, 9;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T501;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFFB00000;
	__asm        push   0;
	__asm        push   0x400000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 869:
_T501:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T543;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFFB00000;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 870:
_T543:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFFB00000;
	__asm        push   0;
	__asm        push   0xFFC00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 871:
	__asm        jmp    _Ta07;
// LINE 873:
_T575:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0x600000;
	__asm        push   0;
	__asm        push   0x700000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 874:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T5e7;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0x200000;
	__asm        push   0;
	__asm        push   0x700000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 875:
_T5e7:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0xFFE00000;
	__asm        push   0;
	__asm        push   0x700000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 876:
	__asm        call   rand;
	__asm        mov    ecx, 5;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T659;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   8;
	__asm        push   0xFFA00000;
	__asm        push   0;
	__asm        push   0x700000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 877:
_T659:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T69e;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0x600000;
	__asm        push   0;
	__asm        push   0xFF900000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 878:
_T69e:
	__asm        call   rand;
	__asm        mov    ecx, 7;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T6e3;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0x200000;
	__asm        push   0;
	__asm        push   0xFF900000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 879:
_T6e3:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0xFFE00000;
	__asm        push   0;
	__asm        push   0xFF900000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 880:
	__asm        call   rand;
	__asm        mov    ecx, 7;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T755;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0x10;
	__asm        push   0xFFA00000;
	__asm        push   0;
	__asm        push   0xFF900000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 881:
_T755:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 7;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T79c;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x700000;
	__asm        push   0;
	__asm        push   0x600000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 882:
_T79c:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T7e1;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x700000;
	__asm        push   0;
	__asm        push   0x200000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 883:
_T7e1:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T826;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x700000;
	__asm        push   0;
	__asm        push   0xFFE00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 884:
_T826:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T86d;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0x700000;
	__asm        push   0;
	__asm        push   0xFFA00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 885:
_T86d:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T8b2;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFF900000;
	__asm        push   0;
	__asm        push   0x600000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 886:
_T8b2:
	__asm        call   rand;
	__asm        mov    ecx, 6;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T8f7;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFF900000;
	__asm        push   0;
	__asm        push   0x200000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 887:
_T8f7:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T93c;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFF900000;
	__asm        push   0;
	__asm        push   0xFFE00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 888:
_T93c:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   4;
	__asm        push   0xFF900000;
	__asm        push   0;
	__asm        push   0xFFA00000;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 889:
	__asm        jmp    _Ta07;
// LINE 891:
_T96e:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T9b0;

	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0xFFF00000;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 892:
_T9b0:
	__asm        mov    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x100000;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, celly;
	__asm        push   eax;
	__asm        mov    eax, cellx;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStart;
	__asm        add    esp, 0x24;
	__asm        or     retval, eax;
// LINE 893:
	__asm        jmp    _Ta07;
// LINE 894:
	__asm        jmp    _Ta07;
_T9e4:
	__asm        cmp    dword ptr [ebp-0x24], 2;
	__asm        je     _T57;

	__asm        cmp    dword ptr [ebp-0x24], 3;
	__asm        je     _T26c;

	__asm        cmp    dword ptr [ebp-0x24], 4;
	__asm        je     _T575;

	__asm        jmp    _T96e;
// LINE 896:
_Ta07:
	__asm        cmp    retval, 0;
	__asm        jne    _Ta18;
// LINE 897:
	return 0x0;
// LINE 899:
_Ta18:
	mp.op = 0x5;
// LINE 900:
	mp.id = mission_id;
// LINE 901:
	mp.i2num = 0x1;
// LINE 902:
	mp.flags = flags;
// LINE 903:
	S3MissionUpdate(mp.op);
// LINE 907:
	__asm        test   reinterpret_cast<uint8_t>(flags), 1;
	__asm        je     _Taac;
// LINE 909:
	mp.op = 0x23;
// LINE 910:
	mp.id = mission_id;
// LINE 911:
	__asm        mov    eax, cfd;
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+8];
	__asm        imul   eax, S_money_mission_fire;
	__asm        mov    mp.i2num, eax;
// LINE 912:
	mp.flags = flags;
// LINE 913:
	S3MissionUpdate(mp.op);
// LINE 915:
	mp.op = 0x22;
// LINE 916:
	mp.id = mission_id;
// LINE 917:
	__asm        mov    eax, cfd;
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+8];
	__asm        imul   eax, S_pts_mission_fire;
	__asm        mov    mp.i2num, eax;
// LINE 918:
	mp.flags = flags;
// LINE 919:
	S3MissionUpdate(mp.op);
// LINE 926:
_Taac:
	__asm        mov    eax, cellx;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, celly;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        push   edx;
	__asm        call   S3ObjGetLandingZone;
	__asm        add    esp, 4;
	__asm        mov    lz, eax;
// LINE 927:
	__asm        cmp    lz, 0;
	__asm        je     _Taf5;

	__asm        mov    eax, lz;
	__asm        test   byte ptr [eax], 4;
	__asm        je     _Taf5;
// LINE 929:
	S3MissionStart(cellx, celly, 0x80010);
// LINE 933:
_Taf5:
	return 0x1;
// LINE 934:
}

// FUNCTION: COPTER_D 0x00526128
/*packed*/ struct _FIRE_DATA* S3FireGetByMission(long mission_id) {
	/*bp-0x4*/   /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0x8*/   long i;

// LINE 947:
_FOR_1c:
	i = 0x0;
	fd = 0x6666f0;
	__asm        jmp    _FOR_COND_1c;
_FOR_NEXT_1c:
	i++;
	fd += 0xa0;
_FOR_COND_1c:
	__asm        cmp    i, 0x8C;
	__asm        jge    _T5e;
// LINE 949:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 1;
	__asm        je     _T59;

	__asm        mov    eax, fd;
	__asm        mov    ecx, mission_id;
	__asm        cmp    [eax+0x9C], ecx;
	__asm        jne    _T59;
// LINE 950:
	return fd;
// LINE 951:
_T59:
	__asm        jmp    _FOR_NEXT_1c;
// LINE 953:
_T5e:
	return 0x0;
// LINE 954:
}

// FUNCTION: COPTER_D 0x00526192
int32_t S3FireGetAltitude(/*packed*/ struct _CELL_INFO *cptr, /*packed*/ struct Point3d *loc) {
	/*bp-0x4*/   /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0x8*/   /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0xc*/   int32_t radius;
	/*bp-0x10*/  int32_t height;

// LINE 972:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        jne    _T1e;
// LINE 973:
	return 0x0;
// LINE 976:
_T1e:
	radius = (S_ftwk_fire_radius - ((G_diff_level - 1) << 0x13));
// LINE 980:
	stobj = cptr->stptr;
// LINE 981:
__WHILE_3b:
	while ((stobj != 0x0)) {
		// LINE 983:
			__asm        mov    eax, stobj;
			__asm        test   byte ptr [eax+8], 1;
			__asm        jne    _T57;
		// LINE 984:
			__asm        jmp    next_obj;
		// LINE 987:
		_T57:
			fd = stobj->user2;
		// LINE 992:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x10];
			__asm        add    eax, radius;
			__asm        mov    ecx, loc;
			__asm        cmp    eax, [ecx];
			__asm        jle    _Tb2;

			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x10];
			__asm        sub    eax, radius;
			__asm        mov    ecx, loc;
			__asm        cmp    eax, [ecx];
			__asm        jge    _Tb2;

			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x18];
			__asm        add    eax, radius;
			__asm        mov    ecx, loc;
			__asm        cmp    eax, [ecx+8];
			__asm        jle    _Tb2;

			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x18];
			__asm        sub    eax, radius;
			__asm        mov    ecx, loc;
			__asm        cmp    eax, [ecx+8];
			__asm        jl     _Tb7;
		// LINE 994:
		_Tb2:
			__asm        jmp    next_obj;
		// LINE 999:
		_Tb7:
			height = (loc->y - (fd->loc.y + fd->douse_points));
		// LINE 1001:
			__asm        cmp    height, 0;
			__asm        jne    _Tdf;

			height = 0x1;
		// LINE 1004:
		_Tdf:
			return height;
		// LINE 1008:
		next_obj:
			stobj = stobj->next;
	}
// LINE 1012:
_Tf4:
	return 0x0;
// LINE 1013:
}

// FUNCTION: COPTER_D 0x00526292
int32_t S3FireTruckDouse(/*packed*/ struct _FIRE_DATA *fd, int32_t dist, /*packed*/ struct _DYOBJ_INST *dytruck, /*packed*/ struct Point3d *firevec) {
	/*bp-0x4*/   int32_t speed;
	/*bp-0x10*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x1c*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x24*/  /*packed*/ struct Point2d currpos; // 0x8 bytes

// LINE 1036:
	__asm        mov    eax, dytruck;
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1037:
	loc.y += 0x1e0000;
// LINE 1039:
	currpos.x = ((dytruck->loc.x + 0x20000000) >> 0x16);
// LINE 1040:
	currpos.y = ((0x20000000 - dytruck->loc.z) >> 0x16);
// LINE 1044:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T61;
// LINE 1045:
	return 0x1;
// LINE 1049:
_T61:
	__asm        call   rand;
	__asm        mov    ecx, 0x64;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, edx;
	__asm        shl    ecx, 0x10;
	__asm        mov    eax, dist;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        add    ecx, eax;
	__asm        mov    speed, ecx;
// LINE 1064:
	__asm        mov    eax, firevec;
	__asm        lea    ecx, vec.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1065:
	S_yval += S_yvaldelta;
// LINE 1066:
	__asm        cmp    S_yval, 0x40000;
	__asm        jle    _Tce;
// LINE 1068:
	S_yval = 0x40000;
// LINE 1069:
	S_yvaldelta = 0xffffe667;
// LINE 1071:
	__asm        jmp    _Tef;
_Tce:
	__asm        cmp    S_yval, 0;
	__asm        jge    _Tef;
// LINE 1073:
	S_yval = 0x0;
// LINE 1074:
	S_yvaldelta = 0x1999;
// LINE 1076:
_Tef:
	vec.y = S_yval;
// LINE 1077:
	MTNormalize(vec.x);
// LINE 1089:
	S3MissileStart(0x6, currpos.x, loc.x, vec.x, 0x1, dytruck, speed, -0x1);
// LINE 1093:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 7;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T14b;
// LINE 1095:
	return 0x0;
// LINE 1096:
	__asm        jmp    __RETURN;
// LINE 1097:
_T14b:
	return 0x1;
// LINE 1098:
__RETURN:
}

// FUNCTION: COPTER_D 0x005263ec
int32_t S3FireTruckDouseDyObj(/*packed*/ struct _DYOBJ_INST *dyobj, int32_t dist, /*packed*/ struct _DYOBJ_INST *dytruck, /*packed*/ struct Point3d *firevec) {
	/*bp-0x4*/   int32_t speed;
	/*bp-0x10*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x1c*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x24*/  /*packed*/ struct Point2d currpos; // 0x8 bytes

// LINE 1117:
	__asm        mov    eax, dytruck;
	__asm        add    eax, 0x18;
	__asm        lea    ecx, loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1118:
	loc.y += 0x1e0000;
// LINE 1120:
	currpos.x = ((dytruck->loc.x + 0x20000000) >> 0x16);
// LINE 1121:
	currpos.y = ((0x20000000 - dytruck->loc.z) >> 0x16);
// LINE 1125:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   ah, 0x10;
	__asm        jne    _T65;
// LINE 1126:
	return 0x1;
// LINE 1128:
_T65:
	__asm        call   rand;
	__asm        mov    ecx, 0x64;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, edx;
	__asm        shl    ecx, 0x10;
	__asm        mov    eax, dist;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        add    ecx, eax;
	__asm        mov    speed, ecx;
// LINE 1130:
	__asm        mov    eax, firevec;
	__asm        lea    ecx, vec.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1131:
	S_yval += S_yvaldelta;
// LINE 1132:
	__asm        cmp    S_yval, 0x40000;
	__asm        jle    _Td2;
// LINE 1134:
	S_yval = 0x40000;
// LINE 1135:
	S_yvaldelta = 0xffffe667;
// LINE 1137:
	__asm        jmp    _Tf3;
_Td2:
	__asm        cmp    S_yval, 0;
	__asm        jge    _Tf3;
// LINE 1139:
	S_yval = 0x0;
// LINE 1140:
	S_yvaldelta = 0x1999;
// LINE 1142:
_Tf3:
	vec.y = S_yval;
// LINE 1143:
	MTNormalize(vec.x);
// LINE 1155:
	S3MissileStart(0x6, currpos.x, loc.x, vec.x, 0x1, dytruck, speed, -0x1);
// LINE 1159:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 7;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        je     _T14f;
// LINE 1161:
	return 0x0;
// LINE 1162:
	__asm        jmp    __RETURN;
// LINE 1163:
_T14f:
	return 0x1;
// LINE 1164:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052654a
void S3FireTweakInit() {
	/*bp-0x28*/  int32_t * pvals[10]; // 0x28 bytes

// LINE 1178:
	pvals[0] = 0x5b7388;
// LINE 1179:
	pvals[1] = 0x5b738c;
// LINE 1180:
	pvals[2] = 0x5b7390;
// LINE 1181:
	pvals[3] = 0x5b7394;
// LINE 1182:
	pvals[4] = 0x5b7398;
// LINE 1183:
	pvals[5] = 0x5b739c;
// LINE 1185:
	TWKEnQueue(pvals[0], 0x6, 0x5b73dc);
// LINE 1186:
}

// FUNCTION: COPTER_D 0x00526595
int32_t S3FireCanCellBurn(long cellx, long celly) {
	/*bp-0x4*/   long tile;

// LINE 1200:
	__asm        cmp    cellx, 0;
	__asm        jl     _T31;

	__asm        cmp    celly, 0;
	__asm        jl     _T31;

	__asm        cmp    cellx, 0x7F;
	__asm        jg     _T31;

	__asm        cmp    celly, 0x7F;
	__asm        jle    _T38;
// LINE 1201:
_T31:
	return 0x0;
// LINE 1203:
_T38:
	__asm        mov    eax, cellx;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, celly;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        mov    tile, edx;
// LINE 1214:
	__asm        cmp    tile, 0x1D;
	__asm        jl     _T61;

	__asm        cmp    tile, 0x6B;
	__asm        jle    _Tb6;
_T61:
	__asm        cmp    tile, 0;
	__asm        jl     _T75;

	__asm        cmp    tile, 4;
	__asm        jle    _Tb6;
_T75:
	__asm        cmp    tile, 0xDE;
	__asm        je     _Tb6;

	__asm        cmp    tile, 0xF6;
	__asm        je     _Tb6;

	__asm        cmp    tile, 0xD2;
	__asm        je     _Tb6;

	__asm        cmp    tile, 0xD3;
	__asm        je     _Tb6;

	__asm        cmp    tile, 0xD1;
	__asm        jne    _Tbd;
// LINE 1215:
_Tb6:
	return 0x0;
// LINE 1217:
_Tbd:
	return 0x1;
// LINE 1218:
}

// FUNCTION: COPTER_D 0x00526661
void S3FireDestroyCell(/*packed*/ struct _FIRE_DATA *fd) {
	/*bp-0x4*/   int32_t speed;
	/*bp-0x44*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x48*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x54*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x58*/  long x;
	/*bp-0x5c*/  long y;
	/*bp-0x60*/  long i;
	/*bp-0x6c*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x70*/  long j;
	/*bp-0x74*/  long num_debris;
	/*bp-0x78*/  short tile;

// LINE 1241:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    loc.x, eax;
// LINE 1242:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    loc.y, eax;
// LINE 1243:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    loc.z, eax;
// LINE 1246:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x90];
	__asm        movzx  ax, byte ptr [eax+ecx];
	__asm        mov    tile, ax;
// LINE 1250:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+8];
	__asm        cmp    eax, 1;
	__asm        jle    _T18b;
// LINE 1253:
	x = fd->celloc.x;
// LINE 1254:
	y = fd->celloc.y;
// LINE 1255:
__WHILE_9a:
	__asm        dec    x;
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    edx, fd;
	__asm        mov    edx, [edx+0x98];
	__asm        mov    edx, [edx];
	__asm        cmp    G_omap[0][0][ecx+eax*4], edx;
	__asm        jne    _Tce;

	__asm        jmp    __WHILE_9a;
// LINE 1256:
_Tce:
	x++;
// LINE 1257:
__WHILE_d1:
	__asm        dec    y;
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    edx, fd;
	__asm        mov    edx, [edx+0x98];
	__asm        mov    edx, [edx];
	__asm        cmp    G_omap[0][0][ecx+eax*4], edx;
	__asm        jne    _T105;

	__asm        jmp    __WHILE_d1;
// LINE 1258:
_T105:
	y++;
// LINE 1261:
_FOR_113:
	i = x;
	__asm        jmp    _FOR_COND_113;
_FOR_NEXT_113:
	i++;
_FOR_COND_113:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+8];
	__asm        add    eax, x;
	__asm        cmp    eax, i;
	__asm        jle    _T186;
// LINE 1262:
_FOR_13c:
	j = y;
	__asm        jmp    _FOR_COND_13c;
_FOR_NEXT_13c:
	j++;
_FOR_COND_13c:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+8];
	__asm        add    eax, y;
	__asm        cmp    eax, j;
	__asm        jle    _T181;
// LINE 1264:
	__asm        mov    eax, i;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, j;
	__asm        mov    byte ptr [eax+ecx], 0;
// LINE 1265:
	__asm        mov    eax, j;
	__asm        mov    ecx, i;
	__asm        shl    ecx, 8;
	__asm        mov    G_texmap[0][eax+ecx], 0xA;
// LINE 1266:
	__asm        jmp    _FOR_NEXT_13c;
_T181:
	__asm        jmp    _FOR_NEXT_113;
// LINE 1268:
_T186:
	__asm        jmp    _T1c5;
// LINE 1270:
_T18b:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x90];
	__asm        mov    byte ptr [eax+ecx], 0;
// LINE 1271:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x8C];
	__asm        shl    ecx, 8;
	__asm        mov    G_texmap[0][eax+ecx], 0xA;
// LINE 1275:
_T1c5:
	__asm        movsx  eax, tile;
	__asm        cmp    eax, 6;
	__asm        jl     _T246;

	__asm        movsx  eax, tile;
	__asm        cmp    eax, 0xC;
	__asm        jg     _T246;
// LINE 1277:
	stobj = fd->cfd->cptr->stptr;
// LINE 1278:
__WHILE_1f0:
	while ((stobj != 0x0)) {
		// LINE 1280:
			__asm        mov    eax, stobj;
			__asm        test   byte ptr [eax+8], 8;
			__asm        je     _T21a;
		// LINE 1282:
			__asm        push   0x14E;
			__asm        call   _VRGetObject;
			__asm        add    esp, 4;
			__asm        mov    ecx, stobj;
			__asm        mov    [ecx+4], eax;
		// LINE 1285:
		_T21a:
			stobj = stobj->next;
	}
// LINE 1288:
_T227:
	S3ExplosionSmokeStart(fd->cfd->cptr, loc.x, 0x1);
// LINE 1290:
	return;
// LINE 1297:
_T246:
	S3DSPlay(0x4, loc.x, 0x0);
// LINE 1301:
	stobj = fd->cfd->cptr->stptr;
// LINE 1302:
__WHILE_267:
	while ((stobj != 0x0)) {
		// LINE 1304:
			__asm        mov    eax, stobj;
			__asm        test   byte ptr [eax+8], 4;
			__asm        je     _T37e;
		// LINE 1306:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x98];
			__asm        mov    eax, [eax];
			__asm        movsx  eax, word ptr [eax+8];
			__asm        mov    [ebp-0x7C], eax;
			__asm        jmp    _T352;
		// LINE 1309:
		_T295:
			__asm        push   0x14F;
			__asm        call   _VRGetObject;
			__asm        add    esp, 4;
			__asm        mov    ecx, stobj;
			__asm        mov    [ecx+4], eax;
		// LINE 1310:
			stobj->user1 = 0x400;
		// LINE 1311:
			stobj->next = 0x0;
		// LINE 1312:
			__asm        jmp    _T379;
		// LINE 1314:
		_T2c0:
			__asm        push   0x150;
			__asm        call   _VRGetObject;
			__asm        add    esp, 4;
			__asm        mov    ecx, stobj;
			__asm        mov    [ecx+4], eax;
		// LINE 1315:
			stobj->user1 = 0x400;
		// LINE 1316:
			stobj->next = 0x0;
		// LINE 1317:
			__asm        jmp    _T379;
		// LINE 1319:
		_T2eb:
			__asm        push   0x151;
			__asm        call   _VRGetObject;
			__asm        add    esp, 4;
			__asm        mov    ecx, stobj;
			__asm        mov    [ecx+4], eax;
		// LINE 1320:
			stobj->user1 = 0x400;
		// LINE 1321:
			stobj->next = 0x0;
		// LINE 1322:
			__asm        jmp    _T379;
		// LINE 1324:
		_T316:
			__asm        push   0x152;
			__asm        call   _VRGetObject;
			__asm        add    esp, 4;
			__asm        mov    ecx, stobj;
			__asm        mov    [ecx+4], eax;
		// LINE 1325:
			stobj->user1 = 0x400;
		// LINE 1326:
			stobj->next = 0x0;
		// LINE 1327:
			__asm        jmp    _T379;
		// LINE 1329:
		_T341:
			stobj = 0x0;
		// LINE 1330:
			__asm        jmp    _T379;
		// LINE 1331:
			__asm        jmp    _T379;
		_T352:
			__asm        dec    dword ptr [ebp-0x7C];
			__asm        cmp    dword ptr [ebp-0x7C], 3;
			__asm        ja     _T341;

			__asm        mov    eax, [ebp-0x7C];
			__asm        jmp    _Switch_369[0][eax*4];
		// Switch pointers:
		//   _T295
		//   _T2c0
		//   _T2eb
		//   _T316
		// LINE 1333:
		_T379:
			__asm        jmp    _T38b;
		// LINE 1336:
		_T37e:
			stobj = stobj->next;
	}
// LINE 1340:
_T38b:
	S3FireDyObjCollisionCheck(fd, 0x10);
// LINE 1342:
	fd->cfd->cptr->stptr = stobj;
// LINE 1344:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax];
	__asm        and    eax, 0xFFFE;
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    ecx, [ecx];
	__asm        mov    [ecx], ax;
// LINE 1345:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x8C];
	__asm        shl    ecx, 8;
	__asm        mov    G_texmap[0][eax+ecx], 0xA;
// LINE 1346:
	S3ExplosionStart(fd->cfd->cptr, 0x0, 0x200000, 0x0, 0x4, fd->mission_id);
// LINE 1348:
	loc.y += 0x300000;
// LINE 1351:
	__asm        call   rand;
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    ecx, [ecx];
	__asm        movsx  ecx, word ptr [ecx+8];
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+3];
	__asm        mov    num_debris, eax;
// LINE 1352:
_FOR_444:
	for (j = 0x0; (num_debris > j); j++) {
		// LINE 1354:
			__asm        call   rand;
			__asm        mov    ecx, 0x64;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        add    eax, 0x320000;
			__asm        mov    speed, eax;
		// LINE 1355:
			_VRIdentity4x4(mat[0][0]);
		// LINE 1356:
			__asm        lea    eax, mat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0xE10;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   _VRPostYRot;
			__asm        add    esp, 8;
		// LINE 1357:
			__asm        lea    eax, mat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0xC8;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        lea    eax, [edx+0x28A];
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   _VRPostXRot;
			__asm        add    esp, 8;
		// LINE 1358:
			_VRRotateP3d(0x59b518, vec.x, mat[0][0]);
		// LINE 1369:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x9C];
			__asm        push   eax;
			__asm        mov    eax, speed;
			__asm        push   eax;
			__asm        push   0;
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x98];
			__asm        mov    eax, [eax];
			__asm        movsx  eax, word ptr [eax+8];
			__asm        add    eax, eax;
			__asm        push   eax;
			__asm        lea    eax, vec.x;
			__asm        push   eax;
			__asm        lea    eax, loc.x;
			__asm        push   eax;
			__asm        mov    eax, fd;
			__asm        add    eax, 0x8C;
			__asm        push   eax;
			__asm        push   4;
			__asm        call   S3MissileStart;
			__asm        add    esp, 0x20;
	}
// LINE 1371:
__RETURN:
}

// FUNCTION: COPTER_D 0x00526b81
long S3FireGetCount() {
// LINE 1381:
	return S_fire_count;
// LINE 1382:
}

// FUNCTION: COPTER_D 0x00526b96
long S3FireAddToNearest(/*packed*/ struct _CELL_INFO *fcptr, /*packed*/ struct Point2d *loc) {
	/*bp-0x4*/   int32_t xdir;
	/*bp-0x8*/   /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0xc*/   int32_t ydir;
	/*bp-0x10*/  /*packed*/ struct _CELL_FIRE_DATA *cfd;
	/*bp-0x14*/  int32_t curr_dist;
	/*bp-0x18*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x1c*/  int32_t spiral_dist;
	/*bp-0x20*/  int32_t x;
	/*bp-0x24*/  int32_t i;
	/*bp-0x28*/  int32_t y;
	/*bp-0x2c*/  int32_t curr_dir;
	/*bp-0x30*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x34*/  int32_t stop_now;

// LINE 1397:
	spiral_dist = 0x5;
// LINE 1400:
	curr_dist = 0x0;
// LINE 1401:
	curr_dir = 0xffffffff;
// LINE 1404:
	stop_now = 0x0;
// LINE 1410:
	x = loc->x;
// LINE 1411:
	y = loc->y;
// LINE 1418:
_LOOP_36:
	for (;;) {
		// LINE 1418:
		_LOOP_36:
			curr_dir++;
		// LINE 1419:
			__asm        mov    eax, curr_dir;
			__asm        mov    [ebp-0x38], eax;
			__asm        jmp    _Ta2;
		// LINE 1423:
		_T44:
			curr_dir = 0x0;
		// LINE 1424:
			curr_dist++;
		// LINE 1425:
			xdir = 0x0;
		// LINE 1426:
			ydir = 0xffffffff;
		// LINE 1427:
			__asm        jmp    _Tca;
		// LINE 1429:
		_T61:
			xdir = 0x1;
		// LINE 1430:
			ydir = 0x0;
		// LINE 1431:
			__asm        jmp    _Tca;
		// LINE 1433:
		_T74:
			curr_dist++;
		// LINE 1434:
			xdir = 0x0;
		// LINE 1435:
			ydir = 0x1;
		// LINE 1436:
			__asm        jmp    _Tca;
		// LINE 1438:
		_T8a:
			xdir = 0xffffffff;
		// LINE 1439:
			ydir = 0x0;
		// LINE 1440:
			__asm        jmp    _Tca;
		// LINE 1441:
			__asm        jmp    _Tca;
		_Ta2:
			__asm        cmp    dword ptr [ebp-0x38], 4;
			__asm        ja     _Tca;

			__asm        mov    eax, [ebp-0x38];
			__asm        jmp    _Switch_b6[0][eax*4];
		// Switch pointers:
		//   _T44
		//   _T61
		//   _T74
		//   _T8a
		//   _T44
		// LINE 1445:
		_Tca:
			__asm        mov    eax, spiral_dist;
			__asm        cmp    curr_dist, eax;
			__asm        jne    _FOR_ec;
		// LINE 1447:
			curr_dist--;
		// LINE 1448:
			stop_now = 0x1;
		// LINE 1452:
		_FOR_ec:
			for (i = 0x0; (curr_dist > i); i++) {
				// LINE 1454:
					x += xdir;
				// LINE 1455:
					y += ydir;
				// LINE 1456:
					__asm        mov    eax, x;
					__asm        and    eax, 0xFF;
					__asm        shl    eax, 0xA;
					__asm        mov    ecx, y;
					__asm        and    ecx, 0xFF;
					__asm        mov    eax, G_omap[0][0][eax+ecx*4];
					__asm        mov    cptr, eax;
				// LINE 1457:
					__asm        mov    eax, cptr;
					__asm        movsx  eax, word ptr [eax];
					__asm        test   al, 0x20;
					__asm        je     _T138;
				// LINE 1458:
					__asm        jmp    FoundFire;
				// LINE 1459:
				_T138:
			}
		// LINE 1461:
		_T13d:
			__asm        cmp    stop_now, 1;
			__asm        jne    _T14c;
		// LINE 1463:
			__asm        jmp    _T151;
		// LINE 1465:
		_T14c:
	}
// LINE 1468:
_T151:
	return 0xffffffff;
// LINE 1474:
FoundFire:
	stobj = cptr->stptr;
// LINE 1475:
__WHILE_164:
	while ((stobj != 0x0)) {
		// LINE 1477:
			__asm        mov    eax, stobj;
			__asm        test   byte ptr [eax+8], 1;
			__asm        je     _T1cc;
		// LINE 1480:
			fd = stobj->user2;
		// LINE 1481:
			__asm        call   S3FireGetCellData;
			__asm        mov    cfd, eax;
			__asm        cmp    cfd, 0;
			__asm        je     _T1be;
		// LINE 1483:
			cfd->cptr = fcptr;
		// LINE 1484:
			S3FireStartCell(cfd, x, y, fd->mission_id, 0x0);
		// LINE 1486:
		_T1be:
			return fd->mission_id;
		// LINE 1490:
		_T1cc:
			stobj = stobj->next;
	}
// LINE 1493:
_T1d9:
	return 0xffffffff;
// LINE 1494:
}

// FUNCTION: COPTER_D 0x00526d7e
void S3FireDyObjCollisionCheck(/*packed*/ struct _FIRE_DATA *fd, long hit_type) {
	/*bp-0x4*/   int32_t ret_code;
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0x14*/  /*packed*/ struct Point3d loc; // 0xc bytes

// LINE 1506:
	ret_code = 0x0;
// LINE 1510:
	__asm        cmp    hit_type, 6;
	__asm        jne    _T42;
// LINE 1512:
	fd->dycheck_timer -= G_AvLoopTime;
// LINE 1513:
	__asm        mov    eax, fd;
	__asm        cmp    dword ptr [eax+0x88], 0;
	__asm        jle    _T42;
// LINE 1514:
	return;
// LINE 1517:
_T42:
	fd->dycheck_timer = 0x8000;
// LINE 1521:
	dyobj = fd->cfd->cptr->dyptr;
// LINE 1522:
__WHILE_60:
	while ((dyobj != 0x0)) {
		// LINE 1525:
			__asm        cmp    hit_type, 0x10;
			__asm        jne    _Tca;
		// LINE 1527:
			__asm        mov    eax, fd;
			__asm        add    eax, 0x3C;
			__asm        lea    ecx, loc.x;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 1531:
			__asm        mov    eax, fd;
			__asm        mov    eax, [eax+0x38];
			__asm        add    eax, loc.y;
			__asm        mov    ecx, dyobj;
			__asm        cmp    eax, [ecx+0x1C];
			__asm        jle    _Tc5;
		// LINE 1534:
			S3ObjHitDispatch(hit_type, (fd + 0x24), dyobj, fd->mission_id, 0x0);
		// LINE 1540:
		_Tc5:
			__asm        jmp    next_dyobj;
		// LINE 1545:
		_Tca:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 4;
			__asm        je     _Tf2;

			__asm        mov    eax, G_uheli;
			__asm        mov    ecx, dyobj;
			__asm        cmp    [eax+0xA4], ecx;
			__asm        jne    _Tf2;
		// LINE 1547:
			__asm        jmp    next_dyobj;
		// LINE 1552:
		_Tf2:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x20;
			__asm        je     _T106;
		// LINE 1554:
			__asm        jmp    next_dyobj;
		// LINE 1558:
		_T106:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x40;
			__asm        je     _T11a;
		// LINE 1560:
			__asm        jmp    next_dyobj;
		// LINE 1563:
		_T11a:
			__asm        mov    eax, fd;
			__asm        add    eax, 0x3C;
			__asm        lea    ecx, loc.x;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 1571:
			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x18];
			__asm        mov    ecx, dyobj;
			__asm        add    eax, [ecx+0x10];
			__asm        mov    ecx, loc.x;
			__asm        sub    ecx, 0xA0000;
			__asm        cmp    eax, ecx;
			__asm        jle    next_dyobj;

			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x18];
			__asm        mov    ecx, dyobj;
			__asm        sub    eax, [ecx+0x10];
			__asm        mov    ecx, loc.x;
			__asm        add    ecx, 0xA0000;
			__asm        cmp    eax, ecx;
			__asm        jge    next_dyobj;

			__asm        mov    eax, loc.y;
			__asm        sub    eax, 0xF0000;
			__asm        mov    ecx, dyobj;
			__asm        cmp    eax, [ecx+0x1C];
			__asm        jge    next_dyobj;

			__asm        mov    eax, loc.y;
			__asm        add    eax, 0x320000;
			__asm        mov    ecx, dyobj;
			__asm        cmp    eax, [ecx+0x1C];
			__asm        jle    next_dyobj;

			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x10];
			__asm        mov    ecx, dyobj;
			__asm        add    eax, [ecx+0x20];
			__asm        mov    ecx, loc.z;
			__asm        sub    ecx, 0xA0000;
			__asm        cmp    eax, ecx;
			__asm        jle    next_dyobj;

			__asm        mov    eax, dyobj;
			__asm        mov    eax, [eax+0x20];
			__asm        mov    ecx, dyobj;
			__asm        sub    eax, [ecx+0x10];
			__asm        mov    ecx, loc.z;
			__asm        add    ecx, 0xA0000;
			__asm        cmp    eax, ecx;
			__asm        jge    next_dyobj;
		// LINE 1574:
			S3ObjHitDispatch(hit_type, (fd + 0x24), dyobj, fd->mission_id, 0x0);
		// LINE 1590:
		next_dyobj:
			__asm        mov    eax, dyobj;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 4;
			__asm        je     _T220;
		// LINE 1592:
			dyobj = dyobj->next->next->next->next->next->next->next->next->next->next;
		// LINE 1594:
			__asm        jmp    _T228;
		// LINE 1595:
		_T220:
			dyobj = dyobj->next;
		// LINE 1596:
		_T228:
	}
// LINE 1598:
_T22d:
	return;
// LINE 1599:
}

// FUNCTION: COPTER_D 0x00526fb5
int32_t S3FireMIFFLoad(void * __ptr32 miffReader) {
	/*bp-0x4*/   /*packed*/ struct _FIRE_DATA *fd;
	/*bp-0x8*/   long ret;
	/*bp-0xc*/   long i;

// LINE 1626:
	ret = ReadFirstMIFFChunk(miffReader, FireMIFFID, 0x62b550, 0xa0);
// LINE 1627:
	__asm        cmp    ret, 0;
	__asm        jne    _FOR_45;
// LINE 1628:
	return 0x0;
// LINE 1631:
_FOR_45:
	for (i = 0x0; (i < 0x8c); i++) {
		// LINE 1633:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        shl    eax, 5;
			__asm        add    eax, 0x6666F0;
			__asm        mov    fd, eax;
		// LINE 1636:
			fd->flags = lsfire.flags;
		// LINE 1637:
			fd->timetolive = lsfire.timetolive;
		// LINE 1638:
			fd->douse_points = lsfire.douse_points;
		// LINE 1639:
			fd->hdelta = lsfire.hdelta;
		// LINE 1640:
			fd->elevation = lsfire.elevation;
		// LINE 1641:
			__asm        mov    eax, 0x62B550;
			__asm        add    eax, 0x3C;
			__asm        mov    ecx, fd;
			__asm        add    ecx, 0x3C;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 1642:
			fd->dycheck_timer = lsfire.dycheck_timer;
		// LINE 1643:
			fd->building = lsfire.building;
		// LINE 1644:
			fd->cfd = lsfire.cfd;
		// LINE 1645:
			fd->mission_id = lsfire.mission_id;
		// LINE 1646:
			__asm        mov    eax, 0x62B550;
			__asm        add    eax, 0x8C;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, fd;
			__asm        add    edx, 0x8C;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 1653:
			ret = ReadNextMIFFChunk(miffReader, FireMIFFID, 0x62b550, 0xa0);
		// LINE 1654:
			__asm        cmp    ret, 0;
			__asm        jne    _T14c;

			__asm        cmp    i, 0x8B;
			__asm        je     _T14c;
		// LINE 1655:
			return 0x0;
		// LINE 1656:
		_T14c:
	}
// LINE 1662:
_T151:
	ret = ReadFirstMIFFChunk(miffReader, CfdMIFFID, 0x62b548, 0x8);
// LINE 1663:
	__asm        cmp    ret, 0;
	__asm        jne    _FOR_18a;
// LINE 1664:
	return 0x0;
// LINE 1667:
_FOR_18a:
	for (i = 0x0; (i < 0x8c); i++) {
		// LINE 1671:
			__asm        mov    eax, lscfd.fire_count;
			__asm        mov    ecx, i;
			__asm        mov    S_cfdata[0].fire_count[ecx*8], eax;
		// LINE 1678:
			ret = ReadNextMIFFChunk(miffReader, CfdMIFFID, 0x62b548, 0x8);
		// LINE 1679:
			__asm        cmp    ret, 0;
			__asm        jne    _T1e3;

			__asm        cmp    i, 0x8B;
			__asm        je     _T1e3;
		// LINE 1680:
			return 0x0;
		// LINE 1681:
		_T1e3:
	}
// LINE 1685:
_T1e8:
	S_fire_count = 0x0;
// LINE 1686:
_FOR_205:
	i = 0x0;
	fd = 0x6666f0;
	__asm        jmp    _FOR_COND_205;
_FOR_NEXT_205:
	i++;
	fd += 0xa0;
_FOR_COND_205:
	__asm        cmp    i, 0x8C;
	__asm        jge    _T396;
// LINE 1688:
	__asm        mov    eax, fd;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T22d;
// LINE 1689:
	__asm        jmp    _FOR_NEXT_205;
// LINE 1692:
_T22d:
	S_fire_count++;
// LINE 1695:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        lea    eax, S_cfdata[0].cptr[eax*8];
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x98], eax;
// LINE 1697:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x94];
	__asm        push   eax;
	__asm        call   _VRGetObject;
	__asm        add    esp, 4;
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x94], eax;
// LINE 1699:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x90];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x8C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    [ecx], eax;
// LINE 1700:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax];
	__asm        or     eax, 0x20;
	__asm        mov    ecx, fd;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    ecx, [ecx];
	__asm        mov    [ecx], ax;
// LINE 1707:
	VR3dObjLocate(fd->stptr->mesh, (fd->dyfire.loc.x - fd->loc.x), (fd->dyfire.loc.y - fd->loc.y), (fd->dyfire.loc.z - fd->loc.z));
// LINE 1709:
	__asm        mov    eax, fd;
	__asm        add    eax, 0x3C;
	__asm        mov    ecx, fd;
	__asm        add    ecx, 0x10;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1712:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, fd;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x3C], eax;
// LINE 1713:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, fd;
	__asm        add    eax, [ecx+0x14];
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x40], eax;
// LINE 1714:
	__asm        mov    eax, fd;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    eax, [eax];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, fd;
	__asm        add    eax, [ecx+0x18];
	__asm        mov    ecx, fd;
	__asm        mov    [ecx+0x44], eax;
// LINE 1717:
	fd->stptr->next = fd->cfd->cptr->stptr;
// LINE 1718:
	fd->cfd->cptr->stptr = fd->stptr;
// LINE 1720:
	__asm        jmp    _FOR_NEXT_205;
// LINE 1722:
_T396:
	return 0x1;
// LINE 1723:
}

// FUNCTION: COPTER_D 0x0052735a
int32_t S3FireMIFFSave(void * __ptr32 miffWriter) {
	/*bp-0x4*/   long ret;
	/*bp-0x8*/   long i;

// LINE 1731:
_FOR_15:
	for (i = 0x0; (i < 0x8c); i++) {
		// LINE 1734:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*4];
			__asm        shl    eax, 5;
			__asm        mov    edi, 0x62B550;
			__asm        lea    esi, S_fires[0].flags[eax];
			__asm        mov    ecx, 0x28;
			__asm        rep movsd;
		// LINE 1739:
			__asm        test   reinterpret_cast<uint8_t>(lsfire.flags), 1;
			__asm        je     _T92;
		// LINE 1741:
			__asm        mov    eax, lsfire.building;
			__asm        push   eax;
			__asm        call   _VRGetObjectId;
			__asm        add    esp, 4;
			__asm        mov    lsfire.building, eax;
		// LINE 1742:
			lsfire.cfd = ((lsfire.cfd - 0x66be90) >> 0x3);
		// LINE 1743:
			__asm        mov    eax, 0x62B550;
			__asm        add    eax, 0x10;
			__asm        mov    ecx, 0x62B550;
			__asm        add    ecx, 0x3C;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 1749:
		_T92:
			ret = WriteMIFFChunk(miffWriter, FireMIFFID, 0x62b550, 0xa0);
		// LINE 1750:
			__asm        cmp    ret, 0;
			__asm        jne    _Tc2;
		// LINE 1751:
			return 0x0;
		// LINE 1757:
		_Tc2:
			__asm        push   8;
			__asm        mov    eax, i;
			__asm        lea    eax, S_cfdata[0].cptr[eax*8];
			__asm        push   eax;
			__asm        mov    eax, CfdMIFFID;
			__asm        push   eax;
			__asm        mov    eax, miffWriter;
			__asm        push   eax;
			__asm        call   WriteMIFFChunk;
			__asm        add    esp, 0x10;
			__asm        mov    ret, eax;
		// LINE 1758:
			__asm        cmp    ret, 0;
			__asm        jne    _Tf5;
		// LINE 1759:
			return 0x0;
		// LINE 1760:
		_Tf5:
	}
// LINE 1762:
_Tfa:
	return 0x1;
// LINE 1763:
}



// Contribution: 2:00003ff0-000041ff Module: 165, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x00592ff0
static const int32_t TurnTable3[4][8] = {{0, 1, 2, 3, 4, 5, 6, 7}, {2, 3, 4, 5, 6, 7, 0, 1}, {6, 7, 0, 1, 2, 3, 4, 5}, {4, 5, 6, 7, 0, 1, 2, 3}};

// GLOBAL: COPTER_D 0x00593070
static const int32_t TurnTable2[4][4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {3, 0, 1, 2}, {2, 3, 0, 1}};

// GLOBAL: COPTER_D 0x005930b0
static const int32_t IndexToType[4] = {1, 2, 4, 8};

// GLOBAL: COPTER_D 0x005930c0
static const int32_t TypeToIndex2[16] = {-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1};

// GLOBAL: COPTER_D 0x00593100
static const int32_t TILUT[4][4] = {{0, 1, 3, 2}, {2, 0, 1, 3}, {3, 2, 0, 1}, {1, 3, 2, 0}};

// GLOBAL: COPTER_D 0x00593140
static const /*packed*/ struct _dPoint2d OT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00593180
static const /*packed*/ struct _dPoint2d RRT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005931c0
static const /*packed*/ struct _dPoint2d LRT[4] = { 0 /* todo */ };



// Contribution: 3:00020388-000203e6 Module: 165, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b7388
int32_t S_ftwk_douse_points = 4194304;

// GLOBAL: COPTER_D 0x005b738c
int32_t S_ftwk_douse_multiplier = 10;

// GLOBAL: COPTER_D 0x005b7390
int32_t S_ftwk_time_to_live = 13107200;

// GLOBAL: COPTER_D 0x005b7394
int32_t S_ftwk_spread_interval = 557056;

// GLOBAL: COPTER_D 0x005b7398
int32_t S_ftwk_spread_probability = 256;

// GLOBAL: COPTER_D 0x005b739c
int32_t S_ftwk_fire_radius = 1572864;

// GLOBAL: COPTER_D 0x005b73a0
static long S_fire_count = 0;

// GLOBAL: COPTER_D 0x005b73a8
/*packed*/ struct Point2d S_dirs[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b73c8
int32_t S_spread_time = 0;

// GLOBAL: COPTER_D 0x005b73cc
static int32_t S_yval = 0;

// GLOBAL: COPTER_D 0x005b73d0
static int32_t S_yvaldelta = 6553;

// GLOBAL: COPTER_D 0x005b73d4
static long FireMIFFID = 1179210309;

// GLOBAL: COPTER_D 0x005b73d8
static long CfdMIFFID = 1128679748;



// Contribution: 3:00094548-000945ef Module: 165, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0062b548
static /*packed*/ struct _CELL_FIRE_DATA lscfd;

// GLOBAL: COPTER_D 0x0062b550
static /*packed*/ struct _FIRE_DATA lsfire;



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.
// GLOBAL: COPTER_D 0x0066be90
/*packed*/ struct _CELL_FIRE_DATA S_cfdata[140]; // Contrib missing

// GLOBAL: COPTER_D 0x0066be70
/*packed*/ struct VRBmpHdr *G_fireseq[6]; // Contrib missing

// GLOBAL: COPTER_D 0x006666f0
/*packed*/ struct _FIRE_DATA S_fires[140]; // Contrib missing

// GLOBAL: COPTER_D 0x006666d0
/*packed*/ struct VRBmpHdr *G_smokeseq[7]; // Contrib missing

// GLOBAL: COPTER_D 0x006666f0
/*packed*/ struct _FIRE_DATA S_fires[140]; // Contrib missing

// GLOBAL: COPTER_D 0x0066be90
/*packed*/ struct _CELL_FIRE_DATA S_cfdata[140]; // Contrib missing

