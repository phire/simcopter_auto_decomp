// Module: S3train.obj
// Source: C:\Copter\Source\Game\S3train.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ struct CONNECTION_INFO_TYPE (forward reference);
struct CONNECTION_INFO_TYPE{ // packed(0x8 bytes) TI: 0x30c5
	/*+0x0*/   enum RailTypes tile;
	/*+0x4*/   enum DirectionTypes connections;
};

// Type: /*packed*/ struct Point2d;
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ class TrainClass;
// VTABLE: COPTER_D 0x00593238
class TrainClass{ // packed(0x1d9 bytes) TI: 0x42ad
	enum /* __unnamed */ {
		TRAIN_TYPES = 1,
		PERCENTAGE_OF_TRAIN1 = 100,
		TOTAL_PERCENTAGE = 100,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		END_OF_RAIL = 4,
		INTERSECTION_FULL = 5,
	};
	enum RailTileOffsets {
		RL_CENTOFF = 0,
		RL_EDGEOFF = 131072,
	};
	enum /* __unnamed */ {
		COLLISION_SPACE = 655360,
		RAIL_SPEED = 5898240,
		RAIL_SLOWDOWN_FACTOR = 131072,
		SPEED_VARIANCE = 262144,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
	};
	enum flagEnums {
		INITIALIZED = 0,
		PLACED = 1,
		TURNING = 2,
		IN_INTERSECTION = 3,
		MAKING_UTURN = 4,
		AT_DEAD_END = 5,
		CRASH_WHEN_READY = 6,
		CRASHING = 7,
		ON_RESCUE = 8,
		NUMBER_OF_FLAGS = 9,
	};
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	static /*packed*/ class TrainClass lsTrain;
	/*+0x4*/   char flags[9]; // 0x9 bytes
	/*+0xd*/   int32_t stalledTimer;
	/*+0x11*/  enum DirectionTypes direction;
	/*+0x15*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0x21*/  int32_t remainingDist;
	/*+0x25*/  int32_t remainingTime;
	/*+0x29*/  enum DirectionTypes utdirection;
	/*+0x2d*/  int32_t speed;
	/*+0x31*/  int32_t desiredSpeed;
	/*+0x35*/  /*packed*/ struct Point2d currentLocation1; // 0x8 bytes
	/*+0x3d*/  /*packed*/ struct Point2d currentLocation2; // 0x8 bytes
	/*+0x45*/  /*packed*/ struct Point2d currentLocation3; // 0x8 bytes
	/*+0x4d*/  /*packed*/ struct Point2d currentCell; // 0x8 bytes
	/*+0x55*/  /*packed*/ struct Point2d nextLocation; // 0x8 bytes
	/*+0x5d*/  int32_t beamDelay;
	/*+0x61*/  int32_t beamTimer;
	/*+0x65*/  long utRotation;
	/*+0x69*/  long missionId;
	/*+0x6d*/  int32_t smokeTime;
	/*+0x71*/  int32_t timeToLive;
	/*+0x75*/  /*packed*/ struct Point2d northCell; // 0x8 bytes
	/*+0x7d*/  /*packed*/ struct Point2d southCell; // 0x8 bytes
	/*+0x85*/  /*packed*/ struct Point2d eastCell; // 0x8 bytes
	/*+0x8d*/  /*packed*/ struct Point2d westCell; // 0x8 bytes
protected:
	/*+0x95*/  long trainModel1;
	/*+0x99*/  long trainModel2;
	/*+0x9d*/  long trainModel3;
	/*+0xa1*/  /*packed*/ struct _DYOBJ_INST dyObj1; // 0x64 bytes
	/*+0x105*/ /*packed*/ struct _DYOBJ_INST dyObj2; // 0x64 bytes
	/*+0x169*/ /*packed*/ struct _DYOBJ_INST dyObj3; // 0x64 bytes
	/*+0x1cd*/ /*packed*/ struct _DYOBJ_INST *leadcar;
	/*+0x1d1*/ /*packed*/ struct _DYOBJ_INST *midcar;
	/*+0x1d5*/ /*packed*/ struct _DYOBJ_INST *endcar;
public:
	void TrainClass(const /*packed*/ class TrainClass&);
	void TrainClass(long, long);
	void TrainClass();
	virtual void ~TrainClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class TrainClass* CreateInstance(long, long, int32_t);
	// calltype: NearC
	static /*packed*/ class TrainClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class TrainClass* GetTrainPointer(long);
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t FindTrainToCrash(long);
	// calltype: NearC
	static int32_t FindTrainForRescue(long, int32_t);
protected:
	int32_t IsTrainInitialized();
	int32_t IsTrainPlaced();
	int32_t IsTrainAtDeadEnd();
	int32_t IsTrainTurning();
	int32_t IsTrainInIntersection();
	int32_t IsTrainMakingUturn();
	int32_t IsTrainMoving();
	int32_t IsTrainReadyToCrash();
	int32_t IsTrainCrashing();
	int32_t IsTrainOnRescue();
	long GetTrainModel();
	const const /*packed*/ struct _DYOBJ_INST* GetTrainDyObj();
	enum DirectionTypes GetDirection();
	int32_t AmIMovingNorth();
	int32_t AmIMovingSouth();
	int32_t AmIMovingEast();
	int32_t AmIMovingWest();
	const /*packed*/ struct Point3d& GetDirectionVector();
	int32_t GetSpeed();
	int32_t GetDesiredSpeed();
	const /*packed*/ struct Point2d& GetCurrentLocation1();
	const /*packed*/ struct Point2d& GetCurrentLocation2();
	const /*packed*/ struct Point2d& GetCurrentLocation3();
	const /*packed*/ struct Point2d& GetNextLocation();
	void SetCurrentLocation1(/*packed*/ struct Point2d&);
	void SetCurrentLocation2(/*packed*/ struct Point2d&);
	void SetCurrentLocation3(/*packed*/ struct Point2d&);
	void SetTrainReadyToCrash(long);
	int32_t CanTrainBePlacedOnTile(unsigned short);
	void SetSpeed(int32_t);
	int32_t Initialize(int32_t);
	void Itterate();
	virtual void ItterateFSM(); // vtable+0x4
	virtual void AdjustSpeed(); // vtable+0x8
	virtual enum TrainClass::StoppedReasons IsPathClear(); // vtable+0xc
	enum TrainClass::StoppedReasons CheckDynamicObjectsAt(const /*packed*/ struct Point2d&, const /*packed*/ struct Point3d&);
	int32_t IsTrainOutOfCameraRange();
	void SetTrainDirection(unsigned short);
	int32_t CheckForStop(short, short);
	int32_t FinishedUturn();
	void SlowDown();
	void Stop();
	void MoveForward();
	int32_t HaveIReachedNextLoc();
	int32_t AmIInANewCell();
	int32_t IsAnythingThere(const /*packed*/ struct Point2d&, /*packed*/ struct mv);
	void UnlinkFromCell(const /*packed*/ struct Point2d&, /*packed*/ struct _DYOBJ_INST*);
	void LinkToCell(const /*packed*/ struct Point2d&, /*packed*/ struct _DYOBJ_INST*);
	int32_t IsLocationAnIntersection(/*packed*/ struct Point2d&);
	virtual enum TrainClass::IntersectionTypes PickTurnDirection(const /*packed*/ struct Point2d&); // vtable+0x10
	int32_t DoRailTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void MakeATurn(enum TrainClass::IntersectionTypes);
	void GetNewPredictedLocation();
	void AdjustCurrentPosition();
	void AdjustNextPosition();
	enum TrainClass::StoppedReasons WhyAmIStopped();
	void GoStraight();
	void MakeUturn();
	void TurnLeft();
	void TurnRight();
	void UnPlaceTrain();
	void SetTrailingCars();
	void AdjustTrailingCars();
	void SetCrashWhenReady();
	void TrainCrashMovement();
	void TrainSoundDriver();
	void Reset();
	int32_t SetTrainForRescue(long, int32_t);
	// calltype: NearC
	static void InitArrays();
	// calltype: NearC
	static void SetTrainTypesAndLocations();
	// calltype: NearC
	static void PlaceInitialTrains();
	virtual void BeamToWithinCameraRange(); // vtable+0x14
	virtual int32_t BeamToLocation(long, long); // vtable+0x18
private:
	int32_t InitializeInstance(long, long, int32_t);
public:
	/*packed*/ class TrainClass operator=(const /*packed*/ class TrainClass&);
};

// Type: /*packed*/ class TrainClass (forward reference);
// VTABLE: COPTER_D 0x00593238
class TrainClass{ // packed(0x1d9 bytes) TI: 0x42ad
	enum /* __unnamed */ {
		TRAIN_TYPES = 1,
		PERCENTAGE_OF_TRAIN1 = 100,
		TOTAL_PERCENTAGE = 100,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		END_OF_RAIL = 4,
		INTERSECTION_FULL = 5,
	};
	enum RailTileOffsets {
		RL_CENTOFF = 0,
		RL_EDGEOFF = 131072,
	};
	enum /* __unnamed */ {
		COLLISION_SPACE = 655360,
		RAIL_SPEED = 5898240,
		RAIL_SLOWDOWN_FACTOR = 131072,
		SPEED_VARIANCE = 262144,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
	};
	enum flagEnums {
		INITIALIZED = 0,
		PLACED = 1,
		TURNING = 2,
		IN_INTERSECTION = 3,
		MAKING_UTURN = 4,
		AT_DEAD_END = 5,
		CRASH_WHEN_READY = 6,
		CRASHING = 7,
		ON_RESCUE = 8,
		NUMBER_OF_FLAGS = 9,
	};
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	static /*packed*/ class TrainClass lsTrain;
	/*+0x4*/   char flags[9]; // 0x9 bytes
	/*+0xd*/   int32_t stalledTimer;
	/*+0x11*/  enum DirectionTypes direction;
	/*+0x15*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0x21*/  int32_t remainingDist;
	/*+0x25*/  int32_t remainingTime;
	/*+0x29*/  enum DirectionTypes utdirection;
	/*+0x2d*/  int32_t speed;
	/*+0x31*/  int32_t desiredSpeed;
	/*+0x35*/  /*packed*/ struct Point2d currentLocation1; // 0x8 bytes
	/*+0x3d*/  /*packed*/ struct Point2d currentLocation2; // 0x8 bytes
	/*+0x45*/  /*packed*/ struct Point2d currentLocation3; // 0x8 bytes
	/*+0x4d*/  /*packed*/ struct Point2d currentCell; // 0x8 bytes
	/*+0x55*/  /*packed*/ struct Point2d nextLocation; // 0x8 bytes
	/*+0x5d*/  int32_t beamDelay;
	/*+0x61*/  int32_t beamTimer;
	/*+0x65*/  long utRotation;
	/*+0x69*/  long missionId;
	/*+0x6d*/  int32_t smokeTime;
	/*+0x71*/  int32_t timeToLive;
	/*+0x75*/  /*packed*/ struct Point2d northCell; // 0x8 bytes
	/*+0x7d*/  /*packed*/ struct Point2d southCell; // 0x8 bytes
	/*+0x85*/  /*packed*/ struct Point2d eastCell; // 0x8 bytes
	/*+0x8d*/  /*packed*/ struct Point2d westCell; // 0x8 bytes
protected:
	/*+0x95*/  long trainModel1;
	/*+0x99*/  long trainModel2;
	/*+0x9d*/  long trainModel3;
	/*+0xa1*/  /*packed*/ struct _DYOBJ_INST dyObj1; // 0x64 bytes
	/*+0x105*/ /*packed*/ struct _DYOBJ_INST dyObj2; // 0x64 bytes
	/*+0x169*/ /*packed*/ struct _DYOBJ_INST dyObj3; // 0x64 bytes
	/*+0x1cd*/ /*packed*/ struct _DYOBJ_INST *leadcar;
	/*+0x1d1*/ /*packed*/ struct _DYOBJ_INST *midcar;
	/*+0x1d5*/ /*packed*/ struct _DYOBJ_INST *endcar;
public:
	void TrainClass(const /*packed*/ class TrainClass&);
	void TrainClass(long, long);
	void TrainClass();
	virtual void ~TrainClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class TrainClass* CreateInstance(long, long, int32_t);
	// calltype: NearC
	static /*packed*/ class TrainClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class TrainClass* GetTrainPointer(long);
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t FindTrainToCrash(long);
	// calltype: NearC
	static int32_t FindTrainForRescue(long, int32_t);
protected:
	int32_t IsTrainInitialized();
	int32_t IsTrainPlaced();
	int32_t IsTrainAtDeadEnd();
	int32_t IsTrainTurning();
	int32_t IsTrainInIntersection();
	int32_t IsTrainMakingUturn();
	int32_t IsTrainMoving();
	int32_t IsTrainReadyToCrash();
	int32_t IsTrainCrashing();
	int32_t IsTrainOnRescue();
	long GetTrainModel();
	const const /*packed*/ struct _DYOBJ_INST* GetTrainDyObj();
	enum DirectionTypes GetDirection();
	int32_t AmIMovingNorth();
	int32_t AmIMovingSouth();
	int32_t AmIMovingEast();
	int32_t AmIMovingWest();
	const /*packed*/ struct Point3d& GetDirectionVector();
	int32_t GetSpeed();
	int32_t GetDesiredSpeed();
	const /*packed*/ struct Point2d& GetCurrentLocation1();
	const /*packed*/ struct Point2d& GetCurrentLocation2();
	const /*packed*/ struct Point2d& GetCurrentLocation3();
	const /*packed*/ struct Point2d& GetNextLocation();
	void SetCurrentLocation1(/*packed*/ struct Point2d&);
	void SetCurrentLocation2(/*packed*/ struct Point2d&);
	void SetCurrentLocation3(/*packed*/ struct Point2d&);
	void SetTrainReadyToCrash(long);
	int32_t CanTrainBePlacedOnTile(unsigned short);
	void SetSpeed(int32_t);
	int32_t Initialize(int32_t);
	void Itterate();
	virtual void ItterateFSM(); // vtable+0x4
	virtual void AdjustSpeed(); // vtable+0x8
	virtual enum TrainClass::StoppedReasons IsPathClear(); // vtable+0xc
	enum TrainClass::StoppedReasons CheckDynamicObjectsAt(const /*packed*/ struct Point2d&, const /*packed*/ struct Point3d&);
	int32_t IsTrainOutOfCameraRange();
	void SetTrainDirection(unsigned short);
	int32_t CheckForStop(short, short);
	int32_t FinishedUturn();
	void SlowDown();
	void Stop();
	void MoveForward();
	int32_t HaveIReachedNextLoc();
	int32_t AmIInANewCell();
	int32_t IsAnythingThere(const /*packed*/ struct Point2d&, /*packed*/ struct mv);
	void UnlinkFromCell(const /*packed*/ struct Point2d&, /*packed*/ struct _DYOBJ_INST*);
	void LinkToCell(const /*packed*/ struct Point2d&, /*packed*/ struct _DYOBJ_INST*);
	int32_t IsLocationAnIntersection(/*packed*/ struct Point2d&);
	virtual enum TrainClass::IntersectionTypes PickTurnDirection(const /*packed*/ struct Point2d&); // vtable+0x10
	int32_t DoRailTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void MakeATurn(enum TrainClass::IntersectionTypes);
	void GetNewPredictedLocation();
	void AdjustCurrentPosition();
	void AdjustNextPosition();
	enum TrainClass::StoppedReasons WhyAmIStopped();
	void GoStraight();
	void MakeUturn();
	void TurnLeft();
	void TurnRight();
	void UnPlaceTrain();
	void SetTrailingCars();
	void AdjustTrailingCars();
	void SetCrashWhenReady();
	void TrainCrashMovement();
	void TrainSoundDriver();
	void Reset();
	int32_t SetTrainForRescue(long, int32_t);
	// calltype: NearC
	static void InitArrays();
	// calltype: NearC
	static void SetTrainTypesAndLocations();
	// calltype: NearC
	static void PlaceInitialTrains();
	virtual void BeamToWithinCameraRange(); // vtable+0x14
	virtual int32_t BeamToLocation(long, long); // vtable+0x18
private:
	int32_t InitializeInstance(long, long, int32_t);
public:
	/*packed*/ class TrainClass operator=(const /*packed*/ class TrainClass&);
};

// Type: void ();

// Type: void;

// Type: long;

// Type: int32_t;

// Type: /*packed*/ struct VRview;
struct VRview{ // packed(0x58 bytes) TI: 0x2ecc
	/*+0x0*/   /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0xc*/   /*packed*/ struct Point3d scale; // 0xc bytes
	/*+0x18*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct _MISSION_PARMS;
struct _MISSION_PARMS{ // packed(0x18 bytes) TI: 0x307d
	/*+0x0*/   long op;
	/*+0x4*/   long id;
	/*+0x8*/   /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x10*/  long i2num;
	/*+0x14*/  long flags;
};

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: enum TrainClass::StoppedReasons;
enum StoppedReasons {
	NO_REASON = 0,
	TRAFFIC = 1,
	STOPPED_TRAFFIC = 2,
	PERSON_IN_WAY = 3,
	END_OF_RAIL = 4,
	INTERSECTION_FULL = 5,
};

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: unsigned short;

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: enum TrainClass::IntersectionTypes;
enum IntersectionTypes {
	DEAD_END = 0,
	STRAIGHT_AHEAD = 1,
	LEFT_ONLY = 2,
	RIGHT_ONLY = 4,
	LEFT_OR_STRAIGHT = 3,
	LEFT_OR_RIGHT = 6,
	RIGHT_OR_STRAIGHT = 5,
	LEFT_STRAIGHT_OR_RIGHT = 7,
};

// Type: enum DirectionTypes;
enum DirectionTypes {
	NO_DIRECTION = 0,
	NORTH = 1,
	EAST = 2,
	SOUTH = 4,
	WEST = 8,
	RISING = 16,
	RISING_NORTH = 17,
	RISING_SOUTH = 20,
	RISING_EAST = 18,
	RISING_WEST = 24,
	NORTH_EAST = 3,
	SOUTH_EAST = 6,
	SOUTH_WEST = 12,
	NORTH_WEST = 9,
};

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: short;

// Type: void * __ptr32;

// Type: uint32_t;



// Contribution: 1:0012cda0-00133970 Module: 162, 16 byte alignment, code, execute, read, 
// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x0052dda0
static void $E7() {

	$E3();
	$E6();
	__asm        jmp    __RETURN;
__RETURN:
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x0052ddba
static void $E3() {

	TrainClass::lsTrain<vftable> = 0x593238;
	__asm        jmp    _T15;
_T15:
	return;
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x0052ddd9
static void $E6() {

	atexit(0x52ddf6);
	__asm        jmp    __RETURN;
__RETURN:
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x0052ddf6
static void $E4() {

	__asm        xor    eax, eax;
	__asm        mov    al, ds:[0x62B998];
	__asm        test   al, 1;
	__asm        jne    _T2d;

	__asm        xor    eax, eax;
	__asm        mov    al, ds:[0x62B998];
	__asm        or     al, 1;
	__asm        mov    ds:[0x62B998], al;
	__asm        mov    ecx, 0x62B7B8;
	__asm        call   TrainClass::~TrainClass;
_T2d:
	return;
}

// FUNCTION: COPTER_D 0x0052de2d
void TrainClass::TrainClass(long mapx, long mapy) {
	/*bp-0x4*/   int32_t currentFlag;
	/*bp-0x8*/   long odds;


	this-><vftable> = 0x593238;
// LINE 183:
_FOR_21:
	for (currentFlag = 0x0; (currentFlag < 0x9); currentFlag++) {
		// LINE 185:
			__asm        mov    eax, currentFlag;
			__asm        mov    ecx, this;
			__asm        mov    byte ptr [eax+ecx+4], 0;
	}
// LINE 188:
_T3e:
	this->dyObj1.mesh = 0x0;
// LINE 189:
	this->dyObj2.mesh = 0x0;
// LINE 190:
	this->dyObj3.mesh = 0x0;
// LINE 191:
	this->stalledTimer = 0x0;
// LINE 192:
	this->beamTimer = 0x0;
// LINE 193:
	this->direction = 0x0;
// LINE 194:
	this->speed = 0x0;
// LINE 195:
	this->desiredSpeed = 0x0;
// LINE 196:
	this->currentLocation1.x = mapx;
// LINE 197:
	this->currentLocation1.y = mapy;
// LINE 198:
	this->currentLocation2.x = mapx;
// LINE 199:
	this->currentLocation2.y = mapy;
// LINE 200:
	this->currentLocation3.x = mapx;
// LINE 201:
	this->currentLocation3.y = mapy;
// LINE 202:
	this->currentCell.x = mapx;
// LINE 203:
	this->currentCell.y = mapy;
// LINE 204:
	this->nextLocation.x = mapx;
// LINE 205:
	this->nextLocation.y = mapy;
// LINE 211:
	__asm        call   rand;
	__asm        mov    ecx, 0x64;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    odds, edx;
// LINE 213:
	__asm        cmp    odds, 0x64;
	__asm        jge    _T13a;
// LINE 215:
	this->trainModel1 = 0x12d;
// LINE 216:
	this->trainModel2 = 0x14c;
// LINE 217:
	this->trainModel3 = 0x14d;
// LINE 219:
	__asm        jmp    _T15b;
// LINE 221:
_T13a:
	_assert(0xdd, 0x5b783c, 0x5b7860);
	__asm        jmp    _T15b;

	__asm        jmp    _T15b;
// LINE 224:
_T15b:
	this->currentLocation1.x = mapx;
// LINE 225:
	this->currentLocation1.y = mapy;
// LINE 226:
	this->currentLocation2.x = mapx;
// LINE 227:
	this->currentLocation2.y = mapy;
// LINE 228:
	this->currentLocation3.x = mapx;
// LINE 229:
	this->currentLocation3.y = mapy;
// LINE 230:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0052dfcd
void TrainClass::Reset() {
// LINE 248:
	this->TrainClass::UnPlaceTrain();
// LINE 250:
	this->flags[2] = 0x0;
// LINE 251:
	this->flags[3] = 0x0;
// LINE 252:
	this->flags[4] = 0x0;
// LINE 253:
	this->flags[5] = 0x0;
// LINE 254:
	this->flags[6] = 0x0;
// LINE 255:
	this->flags[7] = 0x0;
// LINE 256:
	this->flags[8] = 0x0;
// LINE 257:
	this->stalledTimer = 0x0;
// LINE 258:
	this->beamTimer = 0x0;
// LINE 259:
	this->direction = 0x0;
// LINE 260:
	this->speed = 0x0;
// LINE 261:
	this->currentLocation1.x = 0xffffffff;
// LINE 262:
	this->currentLocation1.y = 0xffffffff;
// LINE 263:
	this->currentLocation2.x = 0xffffffff;
// LINE 264:
	this->currentLocation2.y = 0xffffffff;
// LINE 265:
	this->currentLocation3.x = 0xffffffff;
// LINE 266:
	this->currentLocation3.y = 0xffffffff;
// LINE 267:
	this->currentCell.x = 0xffffffff;
// LINE 268:
	this->currentCell.y = 0xffffffff;
// LINE 269:
	this->nextLocation.x = 0xffffffff;
// LINE 270:
	this->nextLocation.y = 0xffffffff;
// LINE 271:
	return;
}

// FUNCTION: COPTER_D 0x0052e0a8
void TrainClass::~TrainClass() {

	this-><vftable> = 0x593238;
// LINE 296:
	__asm        jmp    _T1a;
_T1a:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        je     _T88;
// LINE 298:
	__asm        jmp    _T2e;
_T2e:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T88;
// LINE 300:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 301:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3D;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 302:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x45;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 314:
_T88:
	this->flags[0] = 0x0;
// LINE 315:
	return;
}

// FUNCTION: COPTER_D 0x0052e141
/*packed*/ class TrainClass* TrainClass::GetTrainPointer(long index) {
// LINE 335:
	__asm        cmp    index, 1;
	__asm        jl     _T17;
// LINE 336:
	return 0x0;
// LINE 338:
_T17:
	__asm        mov    eax, index;
	__asm        mov    eax, trains[0][eax*4];
	__asm        jmp    __RETURN;
// LINE 339:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052e16c
/*packed*/ class TrainClass* TrainClass::CreateInstance(int32_t instanceID) {
// LINE 362:
	return TrainClass::CreateInstance(instanceID, -0x1, -0x1);
// LINE 422:
}

// FUNCTION: COPTER_D 0x0052e18c
/*packed*/ class TrainClass* TrainClass::CreateInstance(long mapx, long mapy, int32_t instanceID) {
	/*bp-0x4*/   /*packed*/ class TrainClass *newtrain;

// LINE 447:
	__asm        push   0x1D9;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T3b;

	__asm        mov    eax, mapy;
	__asm        push   eax;
	__asm        mov    eax, mapx;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-8];
	__asm        call   TrainClass::TrainClass;
	__asm        mov    newtrain, eax;
	__asm        jmp    _T42;
_T3b:
	newtrain = 0x0;
// LINE 451:
_T42:
	__asm        cmp    newtrain, 0;
	__asm        je     _T94;
// LINE 455:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    ecx, newtrain;
	__asm        call   TrainClass::Initialize;
	__asm        test   eax, eax;
	__asm        je     _T6d;
// LINE 457:
	return newtrain;
// LINE 459:
	__asm        jmp    _T94;
// LINE 463:
_T6d:
	__asm        mov    eax, newtrain;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T94;

	__asm        push   1;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T94;
// LINE 470:
_T94:
	return 0x0;
// LINE 471:
}

// FUNCTION: COPTER_D 0x0052e22c
int32_t TrainClass::Initialize(int32_t instanceID) {
// LINE 547:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x39];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x35];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::InitializeInstance;
	__asm        jmp    __RETURN;
// LINE 548:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052e25e
void TrainClass::ResetAll() {
	/*bp-0x4*/   int32_t currentTrainIndex;

// LINE 592:
_FOR_15:
	for (currentTrainIndex = 0x0; (currentTrainIndex < 0x1); currentTrainIndex++) {
		// LINE 594:
			__asm        mov    eax, currentTrainIndex;
			__asm        mov    ecx, trains[0][eax*4];
			__asm        call   TrainClass::Reset;
	}
// LINE 597:
_T36:
	return;
}

// FUNCTION: COPTER_D 0x0052e29e
void TrainClass::ItterateAll() {
	/*bp-0x4*/   int32_t currentTrainIndex;

// LINE 641:
_FOR_15:
	for (currentTrainIndex = 0x0; (currentTrainIndex < 0x1); currentTrainIndex++) {
		// LINE 643:
			__asm        mov    eax, currentTrainIndex;
			__asm        mov    ecx, trains[0][eax*4];
			__asm        call   TrainClass::Itterate;
	}
// LINE 646:
_T36:
	return;
}

// FUNCTION: COPTER_D 0x0052e2de
int32_t TrainClass::FindTrainToCrash(long mission_id) {
	/*bp-0x4*/   int32_t currentTrainIndex;

// LINE 672:
_FOR_15:
	for (currentTrainIndex = 0x0; (currentTrainIndex < 0x1); currentTrainIndex++) {
		// LINE 675:
			__asm        jmp    _T27;
		_T27:
			__asm        mov    eax, currentTrainIndex;
			__asm        mov    eax, trains[0][eax*4];
			__asm        movsx  eax, byte ptr [eax+0xA];
			__asm        test   eax, eax;
			__asm        jne    _T84;

			__asm        jmp    _T42;
		_T42:
			__asm        mov    eax, currentTrainIndex;
			__asm        mov    eax, trains[0][eax*4];
			__asm        movsx  eax, byte ptr [eax+0xB];
			__asm        test   eax, eax;
			__asm        jne    _T84;
		// LINE 676:
			__asm        mov    eax, currentTrainIndex;
			__asm        mov    eax, trains[0][eax*4];
			__asm        mov    [ebp-8], eax;
		// LINE 677:
			__asm        mov    eax, [ebp-8];
			__asm        mov    byte ptr [eax+0xA], 1;
			__asm        mov    eax, mission_id;
			__asm        mov    ecx, [ebp-8];
			__asm        mov    [ecx+0x69], eax;
			__asm        jmp    _T7a;
		// LINE 678:
		_T7a:
			return 0x1;
		// LINE 680:
		_T84:
	}
// LINE 682:
_T89:
	return 0x0;
// LINE 683:
}

// FUNCTION: COPTER_D 0x0052e373
void TrainClass::Itterate() {
// LINE 707:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        je     _T182;
// LINE 710:
	this->beamTimer += LoopTime;
// LINE 711:
	__asm        jmp    _T30;
_T30:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        jne    _T70;

	__asm        jmp    _T44;
_T44:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB];
	__asm        test   eax, eax;
	__asm        jne    _T70;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x61];
	__asm        cmp    [eax+0x5D], ecx;
	__asm        jge    _T70;
// LINE 714:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
// LINE 717:
_T70:
	__asm        jmp    _T75;
_T75:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T175;
// LINE 723:
// Block start:
	/*bp-0x58*/  /*packed*/ struct VRview position; // 0x58 bytes
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 727:
	__asm        jmp    _T94;
_T94:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T175;
// LINE 730:
	__asm        mov    eax, this;
	__asm        add    eax, 0xB9;
	__asm        lea    ecx, position.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 732:
	__asm        mov    esi, this;
	__asm        lea    edi, position.matrix[0][0];
	__asm        add    esi, 0xC5;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 734:
	__asm        push   3;
	__asm        lea    eax, position.loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA9];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 736:
	__asm        mov    eax, this;
	__asm        add    eax, 0x11D;
	__asm        lea    ecx, position.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 738:
	__asm        mov    esi, this;
	__asm        lea    edi, position.matrix[0][0];
	__asm        add    esi, 0x129;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 740:
	__asm        push   3;
	__asm        lea    eax, position.loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10D];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 742:
	__asm        mov    eax, this;
	__asm        add    eax, 0x181;
	__asm        lea    ecx, position.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 744:
	__asm        mov    esi, this;
	__asm        lea    edi, position.matrix[0][0];
	__asm        add    esi, 0x18D;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 746:
	__asm        push   3;
	__asm        lea    eax, position.loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x171];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 751:
// Block end:
_T175:
	this->TrainClass::TrainSoundDriver();
// LINE 753:
	__asm        jmp    _T1b7;
// LINE 757:
_T182:
	__asm        jmp    _T187;
_T187:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        jne    _T1b2;

	_assert(0x2f5, 0x5b7868, 0x5b788c);
	__asm        jmp    _T1b7;
_T1b2:
	__asm        jmp    _T1b7;
// LINE 759:
_T1b7:
	return;
}

// FUNCTION: COPTER_D 0x0052e534
void TrainClass::TrainSoundDriver() {
	/*bp-0x4*/   int32_t dist;
	/*bp-0x10*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x14*/  int32_t vol_adj;

// LINE 783:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T46;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x2D], 0;
	__asm        je     _T37;

	__asm        jmp    _T68;

	__asm        jmp    _T37;
_T37:
	__asm        jmp    _T46;

	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        jne    _T68;
// LINE 785:
_T46:
	__asm        push   0x19;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T63;
// LINE 787:
	S3DSStopPlay(0x19);
// LINE 789:
_T63:
	return;
// LINE 793:
_T68:
	vec.x = (ViewState.world_pos.x - this->dyObj1.loc.x);
// LINE 794:
	vec.y = (ViewState.world_pos.y - this->dyObj1.loc.y);
// LINE 795:
	vec.z = (ViewState.world_pos.z - this->dyObj1.loc.z);
// LINE 796:
	dist = MTNormalize(vec.x);
// LINE 798:
	__asm        cmp    dist, 0x7800000;
	__asm        jge    _T116;
// LINE 800:
	__asm        push   0x19;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _Tde;
// LINE 802:
	S3DSPlay(0x1, (this + 0xb9), 0x19);
// LINE 806:
_Tde:
	__asm        push   0xF0600000;
	__asm        push   0x7800000;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sar    eax, 0x10;
	__asm        mov    vol_adj, eax;
// LINE 809:
	S3SoundAdjVol(vol_adj, 0x19);
// LINE 812:
	__asm        jmp    _T133;
// LINE 814:
_T116:
	__asm        push   0x19;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T133;
// LINE 816:
	S3DSStopPlay(0x19);
// LINE 819:
_T133:
	return;
}

// FUNCTION: COPTER_D 0x0052e671
void TrainClass::ItterateFSM() {
// LINE 843:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xC];
	__asm        test   eax, eax;
	__asm        je     _T6c;

	__asm        jmp    _T25;
_T25:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB];
	__asm        test   eax, eax;
	__asm        jne    _T6c;
// LINE 845:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x71], eax;
// LINE 846:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x71], 0;
	__asm        jge    _T6c;
// LINE 848:
	this->flags[7] = 0x1;
// LINE 850:
	this->smokeTime = 0x20000;
// LINE 851:
	this->utRotation = 0x0;
// LINE 855:
_T6c:
	__asm        mov    ecx, this;
	__asm        call   TrainClass::IsTrainOutOfCameraRange;
	__asm        test   eax, eax;
	__asm        je     _Tb1;

	__asm        jmp    _T81;
_T81:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB];
	__asm        test   eax, eax;
	__asm        jne    _Tb1;

	__asm        jmp    _T95;
_T95:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xC];
	__asm        test   eax, eax;
	__asm        jne    _Tb1;
// LINE 858:
	this->TrainClass::UnPlaceTrain();
// LINE 859:
	return;
// LINE 863:
_Tb1:
	__asm        jmp    _Tb6;
_Tb6:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xA];
	__asm        test   eax, eax;
	__asm        je     _Tcd;
// LINE 865:
	this->TrainClass::SetCrashWhenReady();
// LINE 868:
_Tcd:
	__asm        jmp    _Td2;
_Td2:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB];
	__asm        test   eax, eax;
	__asm        je     _Tee;
// LINE 870:
	this->TrainClass::TrainCrashMovement();
// LINE 871:
	return;
// LINE 874:
_Tee:
	__asm        jmp    _Tf3;
_Tf3:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+8];
	__asm        test   eax, eax;
	__asm        je     _T156;
// LINE 876:
	__asm        mov    ecx, this;
	__asm        call   TrainClass::FinishedUturn;
	__asm        test   eax, eax;
	__asm        jne    _T11f;
// LINE 878:
	this->TrainClass::AdjustTrailingCars();
// LINE 879:
	return;
// LINE 882:
_T11f:
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::MakeATurn;
// LINE 888:
	__asm        jmp    _T13f;
_T13f:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+8];
	__asm        test   eax, eax;
	__asm        jne    _T156;
// LINE 890:
	this->TrainClass::AdjustNextPosition();
// LINE 894:
_T156:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC];
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T27c;
// LINE 900:
_T169:
	this->TrainClass::MoveForward();
// LINE 901:
	this->TrainClass::AdjustTrailingCars();
// LINE 945:
	__asm        mov    ecx, this;
	__asm        call   TrainClass::HaveIReachedNextLoc;
	__asm        test   eax, eax;
	__asm        je     _T252;
// LINE 950:
// Block start:
	/*bp-0x18*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 951:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x55;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 952:
	__asm        mov    eax, this;
	__asm        add    eax, 0x55;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x35;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 955:
	__asm        jmp    _T1d6;
_T1d6:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xC];
	__asm        test   eax, eax;
	__asm        je     _T213;
// LINE 957:
	mp.op = 0x0;
// LINE 958:
	mp.id = this->missionId;
// LINE 959:
	mp.maploc.x = this->currentLocation1.x;
// LINE 960:
	mp.maploc.y = this->currentLocation1.y;
// LINE 961:
	S3MissionUpdate(mp.op);
// LINE 964:
_T213:
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::MakeATurn;
// LINE 970:
	__asm        jmp    _T233;
_T233:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+8];
	__asm        test   eax, eax;
	__asm        jne    _T252;
// LINE 972:
	this->TrainClass::AdjustNextPosition();
// LINE 973:
	this->TrainClass::AdjustTrailingCars();
// LINE 981:
// Block end:
_T252:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 983:
	__asm        jmp    _T295;
// LINE 993:
_T262:
	this->TrainClass::Stop();
// LINE 995:
	__asm        jmp    _T295;
// LINE 1001:
_T26f:
	this->TrainClass::Stop();
// LINE 1003:
	__asm        jmp    _T295;
_T27c:
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        je     _T169;

	__asm        cmp    dword ptr [ebp-0x20], 1;
	__asm        je     _T262;

	__asm        jmp    _T26f;
// LINE 1024:
_T295:
	return;
}

// FUNCTION: COPTER_D 0x0052e910
void TrainClass::SetCrashWhenReady() {
	/*bp-0x4*/   int32_t dist;
	/*bp-0x8*/   int32_t deltaX;
	/*bp-0xc*/   int32_t deltaY;

// LINE 1048:
	__asm        mov    eax, CameraCell.x;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x35];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    deltaX, eax;
// LINE 1049:
	__asm        mov    eax, CameraCell.y;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x39];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    deltaY, eax;
// LINE 1050:
	__asm        mov    eax, deltaX;
	__asm        cmp    deltaY, eax;
	__asm        jge    _T4e;
// LINE 1051:
	dist = ((deltaX + deltaX) + deltaY);
// LINE 1052:
	__asm        jmp    _T59;
// LINE 1053:
_T4e:
	dist = ((deltaY + deltaY) + deltaX);
// LINE 1056:
_T59:
	__asm        cmp    dist, 0x14;
	__asm        jle    _T68;
// LINE 1057:
	return;
// LINE 1059:
_T68:
	this->flags[6] = 0x0;
// LINE 1060:
	this->flags[7] = 0x1;
// LINE 1062:
	this->smokeTime = 0x20000;
// LINE 1063:
	this->utRotation = 0x0;
// LINE 1065:
	return;
}

// FUNCTION: COPTER_D 0x0052e9a4
void TrainClass::TrainCrashMovement() {
	/*bp-0x4*/   int32_t speed;
	/*bp-0x8*/   int32_t distance;
	/*bp-0x48*/  int32_t refmat[4][4]; // 0x40 bytes
	/*bp-0x54*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x60*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x78*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x7c*/  int32_t j;
	/*bp-0x80*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x84*/  int32_t num_debris;

// LINE 1086:
	__asm        mov    eax, LoopTime;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x2D];
	__asm        sar    eax, 1;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    distance, eax;
// LINE 1095:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x39];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x88], eax;
	__asm        cmp    dword ptr [ebp-0x88], 0;
	__asm        jne    _T86;

	_assert(0xd0, 0x5b780c, 0x5b57b8);
	__asm        jmp    _T8b;
_T86:
	__asm        jmp    _T8b;
_T8b:
	__asm        jmp    _T90;
_T90:
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    cptr, eax;
// LINE 1100:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x15];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    loc.x, eax;
// LINE 1101:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x19];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    loc.y, eax;
// LINE 1102:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    loc.z, eax;
// LINE 1105:
	this->leadcar->loc.x += loc.x;
// LINE 1106:
	this->leadcar->loc.y += loc.y;
// LINE 1107:
	this->leadcar->loc.z += loc.z;
// LINE 1108:
	this->midcar->loc.x += loc.x;
// LINE 1109:
	this->midcar->loc.y += loc.y;
// LINE 1110:
	this->midcar->loc.z += loc.z;
// LINE 1111:
	this->endcar->loc.x += loc.x;
// LINE 1112:
	this->endcar->loc.y += loc.y;
// LINE 1113:
	this->endcar->loc.z += loc.z;
// LINE 1115:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x640000;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 1116:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x500000;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 1117:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x320000;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 1119:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x6D], eax;
// LINE 1122:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x6D], 0;
	__asm        jle    _T2c4;
// LINE 1124:
	this->utRotation++;
// LINE 1125:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x65];
	__asm        and    eax, 3;
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T293;
// LINE 1128:
_T220:
	S3ExplosionSmokeStart(0x1, (this->leadcar + 0x18), cptr);
// LINE 1129:
	__asm        jmp    _T2bf;
// LINE 1131:
_T243:
	S3ExplosionSmokeStart(0x1, (this->midcar + 0x18), cptr);
// LINE 1132:
	__asm        jmp    _T2bf;
// LINE 1134:
_T266:
	S3ExplosionSmokeStart(0x1, (this->endcar + 0x18), cptr);
// LINE 1135:
	__asm        jmp    _T2bf;
// LINE 1137:
	__asm        jmp    _T2bf;
// LINE 1138:
	__asm        jmp    _T2bf;
_T293:
	__asm        cmp    dword ptr [ebp-0x90], 0;
	__asm        je     _T220;

	__asm        cmp    dword ptr [ebp-0x90], 1;
	__asm        je     _T243;

	__asm        cmp    dword ptr [ebp-0x90], 2;
	__asm        je     _T266;

	__asm        jmp    _T2bf;
// LINE 1140:
_T2bf:
	__asm        jmp    _T7a0;
// LINE 1144:
_T2c4:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.x, eax;
// LINE 1145:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.y, eax;
// LINE 1146:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.z, eax;
// LINE 1147:
	S3ExplosionStart(this->missionId, 0x4, loc.z, loc.y, loc.x, cptr);
// LINE 1149:
	S3DSPlay(0x0, (this->leadcar + 0x18), 0x1a);
// LINE 1192:
	num_debris = 0x3;
// LINE 1193:
_FOR_374:
	for (j = 0x0; (num_debris > j); j++) {
		// LINE 1195:
			__asm        call   rand;
			__asm        mov    ecx, 0x1E;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        add    eax, 0x190000;
			__asm        mov    speed, eax;
		// LINE 1196:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   0x004D1FF1;
			__asm        add    esp, 4;
		// LINE 1197:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0xE10;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   0x004D201C;
			__asm        add    esp, 8;
		// LINE 1198:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0x78;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        lea    eax, [edx+0x2EE];
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   0x004D2004;
			__asm        add    esp, 8;
		// LINE 1199:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        lea    eax, vec.x;
			__asm        push   eax;
			__asm        push   0x59B518;
			__asm        call   0x004D2094;
			__asm        add    esp, 0xC;
		// LINE 1210:
			S3MissileStart(this->missionId, speed, this->leadcar, 0x2, vec.x, (this->leadcar + 0x18), (this + 0x35), 0x4);
	}
// LINE 1214:
_T456:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.x, eax;
// LINE 1215:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.y, eax;
// LINE 1216:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.z, eax;
// LINE 1217:
	S3ExplosionStart(this->missionId, 0x4, loc.z, loc.y, loc.x, cptr);
// LINE 1226:
	num_debris = 0x3;
// LINE 1227:
_FOR_4ea:
	for (j = 0x0; (num_debris > j); j++) {
		// LINE 1229:
			__asm        call   rand;
			__asm        mov    ecx, 0x1E;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        add    eax, 0x190000;
			__asm        mov    speed, eax;
		// LINE 1230:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   0x004D1FF1;
			__asm        add    esp, 4;
		// LINE 1231:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0xE10;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   0x004D201C;
			__asm        add    esp, 8;
		// LINE 1232:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0x78;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        lea    eax, [edx+0x2EE];
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   0x004D2004;
			__asm        add    esp, 8;
		// LINE 1233:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        lea    eax, vec.x;
			__asm        push   eax;
			__asm        push   0x59B518;
			__asm        call   0x004D2094;
			__asm        add    esp, 0xC;
		// LINE 1244:
			S3MissileStart(this->missionId, speed, this->midcar, 0x2, vec.x, (this->midcar + 0x18), (this + 0x35), 0x4);
	}
// LINE 1248:
_T5cc:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.x, eax;
// LINE 1249:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.y, eax;
// LINE 1250:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    eax, [eax+0x20];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    loc.z, eax;
// LINE 1251:
	S3ExplosionStart(this->missionId, 0x4, loc.z, loc.y, loc.x, cptr);
// LINE 1260:
	num_debris = 0x3;
// LINE 1261:
_FOR_660:
	for (j = 0x0; (num_debris > j); j++) {
		// LINE 1263:
			__asm        call   rand;
			__asm        mov    ecx, 0x1E;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        add    eax, 0x190000;
			__asm        mov    speed, eax;
		// LINE 1264:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   0x004D1FF1;
			__asm        add    esp, 4;
		// LINE 1265:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0xE10;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        mov    eax, edx;
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   0x004D201C;
			__asm        add    esp, 8;
		// LINE 1266:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        call   rand;
			__asm        mov    ecx, 0x78;
			__asm        movsx  eax, ax;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        lea    eax, [edx+0x2EE];
			__asm        shl    eax, 0x10;
			__asm        push   eax;
			__asm        call   0x004D2004;
			__asm        add    esp, 8;
		// LINE 1267:
			__asm        lea    eax, refmat[0][0];
			__asm        push   eax;
			__asm        lea    eax, vec.x;
			__asm        push   eax;
			__asm        push   0x59B518;
			__asm        call   0x004D2094;
			__asm        add    esp, 0xC;
		// LINE 1278:
			S3MissileStart(this->missionId, speed, this->endcar, 0x2, vec.x, (this->endcar + 0x18), (this + 0x35), 0x4);
	}
// LINE 1281:
_T742:
	this->flags[7] = 0x0;
// LINE 1282:
	this->flags[8] = 0x0;
// LINE 1285:
	KillMissionPeople(this->missionId);
// LINE 1287:
	this->TrainClass::UnPlaceTrain();
// LINE 1290:
	mp.op = 0x1d;
// LINE 1291:
	mp.i2num = 0x0;
// LINE 1292:
	mp.id = this->missionId;
// LINE 1293:
	mp.flags = 0x0;
// LINE 1294:
	S3MissionUpdate(mp.op);
// LINE 1298:
_T7a0:
	return;
}

// FUNCTION: COPTER_D 0x0052f14e
void TrainClass::MakeUturn() {
// LINE 1321:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 0;
	__asm        jne    _T1e;
// LINE 1322:
	return;
// LINE 1326:
_T1e:
	this->flags[4] = 0x1;
// LINE 1327:
	this->utRotation = 0x0;
// LINE 1331:
	__asm        jmp    _T34;
_T34:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T7c;

	__asm        jmp    _T53;
_T53:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x12;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 2;
	__asm        or     eax, ecx;
	__asm        je     _T7c;
// LINE 1333:
	this->utdirection = 0xc;
// LINE 1335:
	__asm        jmp    _T23c;
_T7c:
	__asm        jmp    _T81;
_T81:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _Tc9;

	__asm        jmp    _Ta0;
_Ta0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _Tc9;
// LINE 1337:
	this->utdirection = 0x6;
// LINE 1339:
	__asm        jmp    _T23c;
_Tc9:
	__asm        jmp    _Tce;
_Tce:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T116;

	__asm        jmp    _Ted;
_Ted:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x12;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 2;
	__asm        or     eax, ecx;
	__asm        je     _T116;
// LINE 1341:
	this->utdirection = 0x9;
// LINE 1343:
	__asm        jmp    _T23c;
_T116:
	__asm        jmp    _T11b;
_T11b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T163;

	__asm        jmp    _T13a;
_T13a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T163;
// LINE 1345:
	this->utdirection = 0x3;
// LINE 1347:
	__asm        jmp    _T23c;
_T163:
	__asm        jmp    _T168;
_T168:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T191;
// LINE 1349:
	this->utdirection = 0x4;
// LINE 1351:
	__asm        jmp    _T23c;
_T191:
	__asm        jmp    _T196;
_T196:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T1bf;
// LINE 1353:
	this->utdirection = 0x1;
// LINE 1355:
	__asm        jmp    _T23c;
_T1bf:
	__asm        jmp    _T1c4;
_T1c4:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x12;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 2;
	__asm        or     eax, ecx;
	__asm        je     _T1ed;
// LINE 1357:
	this->utdirection = 0x8;
// LINE 1359:
	__asm        jmp    _T23c;
_T1ed:
	__asm        jmp    _T1f2;
_T1f2:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T21b;
// LINE 1361:
	this->utdirection = 0x2;
// LINE 1363:
	__asm        jmp    _T23c;
// LINE 1365:
_T21b:
	_assert(0x555, 0x5b78a4, 0x5b78c8);
	__asm        jmp    _T23c;

	__asm        jmp    _T23c;
// LINE 1368:
_T23c:
	return;
}

// FUNCTION: COPTER_D 0x0052f394
int32_t TrainClass::FinishedUturn() {
// LINE 1389:
	this->utRotation += 0xa;
// LINE 1390:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x65], 0xB4;
	__asm        jle    _T40;
// LINE 1392:
	this->flags[4] = 0x0;
// LINE 1393:
	this->direction = this->utdirection;
// LINE 1394:
	return 0x1;
// LINE 1397:
_T40:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x640000;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 1398:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x15;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 1400:
	return 0x0;
// LINE 1402:
}

// FUNCTION: COPTER_D 0x0052f41b
void TrainClass::AdjustSpeed() {
	// StaticLocal: 0x005b7838
	static int32_t speedAdjustor = 1;
	;

// LINE 1424:
	this->speed = this->desiredSpeed;
// LINE 1426:
	__asm        cmp    speedAdjustor, 0;
	__asm        jne    _T2f;
// LINE 1428:
	this->speed = 0x1;
// LINE 1430:
_T2f:
	return;
}

// FUNCTION: COPTER_D 0x0052f454
enum TrainClass::StoppedReasons TrainClass::IsPathClear() {
	/*bp-0xc*/   /*packed*/ struct Point3d trainHeading; // 0xc bytes
	/*bp-0x14*/  /*packed*/ struct Point2d trainLocation; // 0x8 bytes

// LINE 1456:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x15];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    trainHeading.x, ecx;
// LINE 1457:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x19];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    trainHeading.y, ecx;
// LINE 1458:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    trainHeading.z, ecx;
// LINE 1460:
	trainLocation.x = ((this->leadcar->loc.x + 0x20000000) >> 0x16);
// LINE 1461:
	trainLocation.y = ((0x20000000 - this->leadcar->loc.z) >> 0x16);
// LINE 1463:
	__asm        lea    eax, trainHeading.x;
	__asm        push   eax;
	__asm        lea    eax, trainLocation.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::CheckDynamicObjectsAt;
	__asm        jmp    __RETURN;
// LINE 1464:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052f52f
enum TrainClass::StoppedReasons TrainClass::CheckDynamicObjectsAt(const /*packed*/ struct Point2d& __formal, const /*packed*/ struct Point3d& collisionPoint) {
	/*bp-0x4*/   int32_t ydiff;
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST *currentObject;
	/*bp-0xc*/   /*packed*/ struct _CELL_INFO *currentCell;
	/*bp-0x10*/  unsigned short cellType;
	/*bp-0x14*/  int32_t zdiff;
	/*bp-0x18*/  int32_t xdiff;
	/*bp-0x1c*/  int32_t combinedradius;

// LINE 1486:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        test   eax, eax;
	__asm        jl     _T68;

	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, collisionPoint;
	__asm        sub    eax, [ecx+8];
	__asm        sar    eax, 0x16;
	__asm        test   eax, eax;
	__asm        jl     _T68;

	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        cmp    eax, 0x80;
	__asm        jge    _T68;

	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, collisionPoint;
	__asm        sub    eax, [ecx+8];
	__asm        sar    eax, 0x16;
	__asm        cmp    eax, 0x80;
	__asm        jl     _T73;
_T68:
	cellType = 0x0;
	__asm        jmp    _Td6;
_T73:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, 0x20000000;
	__asm        mov    edx, collisionPoint;
	__asm        sub    ecx, [edx+8];
	__asm        sar    ecx, 0x16;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, collisionPoint;
	__asm        mov    ecx, [ecx];
	__asm        add    ecx, 0x20000000;
	__asm        sar    ecx, 0x16;
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, 0x20000000;
	__asm        mov    ebx, collisionPoint;
	__asm        sub    edx, [ebx+8];
	__asm        sar    edx, 0x16;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    cellType, ax;
	__asm        jmp    _Td6;
// LINE 1487:
_Td6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x39];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x20], eax;
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        jne    _T120;

	_assert(0xd0, 0x5b780c, 0x5b57b8);
	__asm        jmp    _T125;
_T120:
	__asm        jmp    _T125;
_T125:
	__asm        jmp    _T12a;
_T12a:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    currentCell, eax;
// LINE 1490:
	__asm        cmp    currentCell, 0;
	__asm        jne    _T144;
// LINE 1492:
	return 0x4;
// LINE 1497:
_T144:
	currentObject = currentCell->dyptr;
// LINE 1500:
__WHILE_14d:
	while ((currentObject != 0x0)) {
		// LINE 1503:
			__asm        mov    eax, this;
			__asm        mov    ecx, currentObject;
			__asm        cmp    [eax+0x1CD], ecx;
			__asm        jne    _T17b;
		// LINE 1505:
			currentObject = currentObject->next;
		// LINE 1506:
			__asm        jmp    __WHILE_14d;
		// LINE 1508:
			__asm        jmp    _T1be;
		_T17b:
			__asm        mov    eax, this;
			__asm        mov    ecx, currentObject;
			__asm        cmp    [eax+0x1D1], ecx;
			__asm        jne    _T19f;
		// LINE 1510:
			currentObject = currentObject->next;
		// LINE 1511:
			__asm        jmp    __WHILE_14d;
		// LINE 1513:
			__asm        jmp    _T1be;
		_T19f:
			__asm        mov    eax, this;
			__asm        mov    ecx, currentObject;
			__asm        cmp    [eax+0x1D5], ecx;
			__asm        jne    _T1be;
		// LINE 1515:
			currentObject = currentObject->next;
		// LINE 1516:
			__asm        jmp    __WHILE_14d;
		// LINE 1520:
		_T1be:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x20;
			__asm        je     _T1da;
		// LINE 1522:
			currentObject = currentObject->next;
		// LINE 1523:
			__asm        jmp    __WHILE_14d;
		// LINE 1528:
		_T1da:
			__asm        mov    eax, collisionPoint;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x18];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    xdiff, eax;
		// LINE 1529:
			__asm        mov    eax, collisionPoint;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x1C];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    ydiff, eax;
		// LINE 1530:
			__asm        mov    eax, collisionPoint;
			__asm        mov    eax, [eax+8];
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x20];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    zdiff, eax;
		// LINE 1532:
			combinedradius = currentObject->radius;
		// LINE 1533:
			combinedradius += 0x50000;
		// LINE 1536:
			__asm        mov    eax, combinedradius;
			__asm        cmp    xdiff, eax;
			__asm        jg     _T276;

			__asm        mov    eax, combinedradius;
			__asm        cmp    ydiff, eax;
			__asm        jg     _T276;

			__asm        mov    eax, zdiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T276;
		// LINE 1540:
			__asm        jmp    _T24e;
		_T24e:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 8;
			__asm        je     _T26c;
		// LINE 1545:
			return 0x3;
		// LINE 1547:
			__asm        jmp    _T276;
		// LINE 1551:
		_T26c:
			return 0x1;
		// LINE 1556:
		_T276:
			currentObject = currentObject->next;
	}
// LINE 1560:
_T283:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x55];
	__asm        cmp    [eax+0x35], ecx;
	__asm        jne    _T2ae;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x59];
	__asm        cmp    [eax+0x39], ecx;
	__asm        jne    _T2ae;
// LINE 1561:
	return 0x0;
// LINE 1566:
_T2ae:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x59];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x55];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x24], eax;
	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        jne    _T2f8;

	_assert(0xd0, 0x5b780c, 0x5b57b8);
	__asm        jmp    _T2fd;
_T2f8:
	__asm        jmp    _T2fd;
_T2fd:
	__asm        jmp    _T302;
_T302:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    currentCell, eax;
// LINE 1568:
	__asm        cmp    currentCell, 0;
	__asm        jne    _T31c;
// LINE 1570:
	return 0x4;
// LINE 1574:
_T31c:
	currentObject = currentCell->dyptr;
// LINE 1577:
__WHILE_325:
	while ((currentObject != 0x0)) {
		// LINE 1580:
			__asm        mov    eax, this;
			__asm        mov    ecx, currentObject;
			__asm        cmp    [eax+0x1CD], ecx;
			__asm        jne    _T353;
		// LINE 1582:
			currentObject = currentObject->next;
		// LINE 1583:
			__asm        jmp    __WHILE_325;
		// LINE 1585:
			__asm        jmp    _T396;
		_T353:
			__asm        mov    eax, this;
			__asm        mov    ecx, currentObject;
			__asm        cmp    [eax+0x1D1], ecx;
			__asm        jne    _T377;
		// LINE 1587:
			currentObject = currentObject->next;
		// LINE 1588:
			__asm        jmp    __WHILE_325;
		// LINE 1590:
			__asm        jmp    _T396;
		_T377:
			__asm        mov    eax, this;
			__asm        mov    ecx, currentObject;
			__asm        cmp    [eax+0x1D5], ecx;
			__asm        jne    _T396;
		// LINE 1592:
			currentObject = currentObject->next;
		// LINE 1593:
			__asm        jmp    __WHILE_325;
		// LINE 1597:
		_T396:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 0x20;
			__asm        je     _T3b2;
		// LINE 1599:
			currentObject = currentObject->next;
		// LINE 1600:
			__asm        jmp    __WHILE_325;
		// LINE 1604:
		_T3b2:
			__asm        mov    eax, collisionPoint;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x18];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    xdiff, eax;
		// LINE 1605:
			__asm        mov    eax, collisionPoint;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x1C];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    ydiff, eax;
		// LINE 1606:
			__asm        mov    eax, collisionPoint;
			__asm        mov    eax, [eax+8];
			__asm        mov    ecx, currentObject;
			__asm        sub    eax, [ecx+0x20];
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        mov    zdiff, eax;
		// LINE 1609:
			combinedradius = currentObject->radius;
		// LINE 1610:
			combinedradius += 0x50000;
		// LINE 1613:
			__asm        mov    eax, combinedradius;
			__asm        cmp    xdiff, eax;
			__asm        jg     _T44e;

			__asm        mov    eax, combinedradius;
			__asm        cmp    ydiff, eax;
			__asm        jg     _T44e;

			__asm        mov    eax, zdiff;
			__asm        cmp    combinedradius, eax;
			__asm        jl     _T44e;
		// LINE 1616:
			__asm        jmp    _T426;
		_T426:
			__asm        mov    eax, currentObject;
			__asm        movsx  eax, word ptr [eax+0xC];
			__asm        test   al, 8;
			__asm        je     _T444;
		// LINE 1621:
			return 0x3;
		// LINE 1623:
			__asm        jmp    _T44e;
		// LINE 1627:
		_T444:
			return 0x1;
		// LINE 1632:
		_T44e:
			currentObject = currentObject->next;
	}
// LINE 1637:
_T45b:
	return 0x0;
// LINE 1638:
}

// FUNCTION: COPTER_D 0x0052f998
int32_t TrainClass::IsTrainOutOfCameraRange() {
	/*bp-0x4*/   int32_t deltaX;
	/*bp-0x8*/   int32_t deltaY;

// LINE 1661:
	deltaX = (CameraCell.x - this->currentLocation1.x);
// LINE 1662:
	deltaY = (CameraCell.y - this->currentLocation1.y);
// LINE 1667:
__WHILE_28:
	while ((deltaX > 0x80)) {
		// LINE 1669:
			deltaX -= 0x100;
	}
// LINE 1671:
__WHILE_41:
	while ((deltaX < -0x80)) {
		// LINE 1673:
			deltaX += 0x100;
	}
// LINE 1676:
__WHILE_57:
	while ((deltaY > 0x80)) {
		// LINE 1678:
			deltaY -= 0x100;
	}
// LINE 1680:
__WHILE_70:
	while ((deltaY < -0x80)) {
		// LINE 1682:
			deltaY += 0x100;
	}
// LINE 1685:
_T86:
	__asm        cmp    deltaX, 0;
	__asm        jge    _T98;
// LINE 1687:
	__asm        mov    eax, deltaX;
	__asm        neg    eax;
	__asm        mov    deltaX, eax;
// LINE 1689:
_T98:
	__asm        cmp    deltaY, 0;
	__asm        jge    _Taa;
// LINE 1691:
	__asm        mov    eax, deltaY;
	__asm        neg    eax;
	__asm        mov    deltaY, eax;
// LINE 1695:
_Taa:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        add    eax, 4;
	__asm        cmp    eax, deltaX;
	__asm        jl     _Td2;

	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        add    eax, 4;
	__asm        cmp    eax, deltaY;
	__asm        jge    _Te1;
// LINE 1697:
_Td2:
	return 0x1;
// LINE 1699:
	__asm        jmp    __RETURN;
// LINE 1701:
_Te1:
	return 0x0;
// LINE 1703:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052fa85
void TrainClass::SetTrainDirection(unsigned short tileType) {
// LINE 1723:
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1724:
	this->direction = 0x0;
// LINE 1726:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tileType);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T859;
// LINE 1730:
_T3c:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T61;
// LINE 1732:
	this->direction = 0x9;
// LINE 1733:
	this->nextLocation.y--;
// LINE 1735:
	__asm        jmp    _T71;
// LINE 1737:
_T61:
	this->direction = 0x6;
// LINE 1738:
	this->nextLocation.x++;
// LINE 1740:
_T71:
	__asm        jmp    _T93e;
// LINE 1744:
_T76:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T9b;
// LINE 1746:
	this->direction = 0x3;
// LINE 1747:
	this->nextLocation.x++;
// LINE 1749:
	__asm        jmp    _Tab;
// LINE 1751:
_T9b:
	this->direction = 0xc;
// LINE 1752:
	this->nextLocation.y++;
// LINE 1754:
_Tab:
	__asm        jmp    _T93e;
// LINE 1758:
_Tb0:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _Td5;
// LINE 1760:
	this->direction = 0x9;
// LINE 1761:
	this->nextLocation.x--;
// LINE 1763:
	__asm        jmp    _Te5;
// LINE 1765:
_Td5:
	this->direction = 0x6;
// LINE 1766:
	this->nextLocation.y++;
// LINE 1768:
_Te5:
	__asm        jmp    _T93e;
// LINE 1772:
_Tea:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T10f;
// LINE 1774:
	this->direction = 0x3;
// LINE 1775:
	this->nextLocation.y--;
// LINE 1777:
	__asm        jmp    _T11f;
// LINE 1779:
_T10f:
	this->direction = 0xc;
// LINE 1780:
	this->nextLocation.x--;
// LINE 1782:
_T11f:
	__asm        jmp    _T93e;
// LINE 1786:
_T124:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T149;
// LINE 1788:
	this->direction = 0x1;
// LINE 1789:
	this->nextLocation.y--;
// LINE 1791:
	__asm        jmp    _T159;
// LINE 1793:
_T149:
	this->direction = 0x4;
// LINE 1794:
	this->nextLocation.y++;
// LINE 1796:
_T159:
	__asm        jmp    _T93e;
// LINE 1800:
_T15e:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T183;
// LINE 1802:
	this->direction = 0x8;
// LINE 1803:
	this->nextLocation.x--;
// LINE 1805:
	__asm        jmp    _T193;
// LINE 1807:
_T183:
	this->direction = 0x2;
// LINE 1808:
	this->nextLocation.x++;
// LINE 1810:
_T193:
	__asm        jmp    _T93e;
// LINE 1814:
_T198:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T1bd;
// LINE 1816:
	this->direction = 0x1;
// LINE 1817:
	this->nextLocation.y--;
// LINE 1819:
	__asm        jmp    _T1cd;
// LINE 1821:
_T1bd:
	this->direction = 0x14;
// LINE 1822:
	this->nextLocation.y++;
// LINE 1824:
_T1cd:
	__asm        jmp    _T93e;
// LINE 1828:
_T1d2:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T1f7;
// LINE 1830:
	this->direction = 0x11;
// LINE 1831:
	this->nextLocation.y--;
// LINE 1833:
	__asm        jmp    _T207;
// LINE 1835:
_T1f7:
	this->direction = 0x4;
// LINE 1836:
	this->nextLocation.y++;
// LINE 1838:
_T207:
	__asm        jmp    _T93e;
// LINE 1842:
_T20c:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T231;
// LINE 1844:
	this->direction = 0x18;
// LINE 1845:
	this->nextLocation.x--;
// LINE 1847:
	__asm        jmp    _T241;
// LINE 1849:
_T231:
	this->direction = 0x2;
// LINE 1850:
	this->nextLocation.x++;
// LINE 1852:
_T241:
	__asm        jmp    _T93e;
// LINE 1856:
_T246:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T26b;
// LINE 1858:
	this->direction = 0x8;
// LINE 1859:
	this->nextLocation.x--;
// LINE 1861:
	__asm        jmp    _T27b;
// LINE 1863:
_T26b:
	this->direction = 0x12;
// LINE 1864:
	this->nextLocation.x++;
// LINE 1866:
_T27b:
	__asm        jmp    _T93e;
// LINE 1870:
_T280:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T2a5;
// LINE 1872:
	this->direction = 0x1;
// LINE 1873:
	this->nextLocation.y--;
// LINE 1875:
	__asm        jmp    _T2b5;
// LINE 1877:
_T2a5:
	this->direction = 0x14;
// LINE 1878:
	this->nextLocation.y++;
// LINE 1880:
_T2b5:
	__asm        jmp    _T93e;
// LINE 1884:
_T2ba:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T2df;
// LINE 1886:
	this->direction = 0x11;
// LINE 1887:
	this->nextLocation.y--;
// LINE 1889:
	__asm        jmp    _T2ef;
// LINE 1891:
_T2df:
	this->direction = 0x4;
// LINE 1892:
	this->nextLocation.y++;
// LINE 1894:
_T2ef:
	__asm        jmp    _T93e;
// LINE 1898:
_T2f4:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T319;
// LINE 1900:
	this->direction = 0x18;
// LINE 1901:
	this->nextLocation.x--;
// LINE 1903:
	__asm        jmp    _T329;
// LINE 1905:
_T319:
	this->direction = 0x2;
// LINE 1906:
	this->nextLocation.x++;
// LINE 1908:
_T329:
	__asm        jmp    _T93e;
// LINE 1912:
_T32e:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T353;
// LINE 1914:
	this->direction = 0x8;
// LINE 1915:
	this->nextLocation.x--;
// LINE 1917:
	__asm        jmp    _T363;
// LINE 1919:
_T353:
	this->direction = 0x12;
// LINE 1920:
	this->nextLocation.x++;
// LINE 1922:
_T363:
	__asm        jmp    _T93e;
// LINE 1926:
_T368:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x14], edx;
	__asm        jmp    _T3c4;
// LINE 1929:
_T380:
	this->direction = 0x1;
// LINE 1930:
	this->nextLocation.y--;
// LINE 1931:
	__asm        jmp    _T3e7;
// LINE 1933:
_T395:
	this->direction = 0x2;
// LINE 1934:
	this->nextLocation.x++;
// LINE 1935:
	__asm        jmp    _T3e7;
// LINE 1937:
_T3aa:
	this->direction = 0x8;
// LINE 1938:
	this->nextLocation.x--;
// LINE 1939:
	__asm        jmp    _T3e7;
// LINE 1940:
	__asm        jmp    _T3e7;
_T3c4:
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _T380;

	__asm        cmp    dword ptr [ebp-0x14], 1;
	__asm        je     _T395;

	__asm        cmp    dword ptr [ebp-0x14], 2;
	__asm        je     _T3aa;

	__asm        jmp    _T3e7;
// LINE 1941:
_T3e7:
	__asm        jmp    _T93e;
// LINE 1945:
_T3ec:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x18], edx;
	__asm        jmp    _T448;
// LINE 1948:
_T404:
	this->direction = 0x1;
// LINE 1949:
	this->nextLocation.y--;
// LINE 1950:
	__asm        jmp    _T46b;
// LINE 1952:
_T419:
	this->direction = 0x4;
// LINE 1953:
	this->nextLocation.y++;
// LINE 1954:
	__asm        jmp    _T46b;
// LINE 1956:
_T42e:
	this->direction = 0x2;
// LINE 1957:
	this->nextLocation.x++;
// LINE 1958:
	__asm        jmp    _T46b;
// LINE 1959:
	__asm        jmp    _T46b;
_T448:
	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        je     _T404;

	__asm        cmp    dword ptr [ebp-0x18], 1;
	__asm        je     _T419;

	__asm        cmp    dword ptr [ebp-0x18], 2;
	__asm        je     _T42e;

	__asm        jmp    _T46b;
// LINE 1960:
_T46b:
	__asm        jmp    _T93e;
// LINE 1964:
_T470:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x1C], edx;
	__asm        jmp    _T4cc;
// LINE 1967:
_T488:
	this->direction = 0x4;
// LINE 1968:
	this->nextLocation.y++;
// LINE 1969:
	__asm        jmp    _T4ef;
// LINE 1971:
_T49d:
	this->direction = 0x2;
// LINE 1972:
	this->nextLocation.x++;
// LINE 1973:
	__asm        jmp    _T4ef;
// LINE 1975:
_T4b2:
	this->direction = 0x8;
// LINE 1976:
	this->nextLocation.x--;
// LINE 1977:
	__asm        jmp    _T4ef;
// LINE 1978:
	__asm        jmp    _T4ef;
_T4cc:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T488;

	__asm        cmp    dword ptr [ebp-0x1C], 1;
	__asm        je     _T49d;

	__asm        cmp    dword ptr [ebp-0x1C], 2;
	__asm        je     _T4b2;

	__asm        jmp    _T4ef;
// LINE 1979:
_T4ef:
	__asm        jmp    _T93e;
// LINE 1983:
_T4f4:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x20], edx;
	__asm        jmp    _T550;
// LINE 1986:
_T50c:
	this->direction = 0x1;
// LINE 1987:
	this->nextLocation.y--;
// LINE 1988:
	__asm        jmp    _T573;
// LINE 1990:
_T521:
	this->direction = 0x4;
// LINE 1991:
	this->nextLocation.y++;
// LINE 1992:
	__asm        jmp    _T573;
// LINE 1994:
_T536:
	this->direction = 0x8;
// LINE 1995:
	this->nextLocation.x--;
// LINE 1996:
	__asm        jmp    _T573;
// LINE 1997:
	__asm        jmp    _T573;
_T550:
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        je     _T50c;

	__asm        cmp    dword ptr [ebp-0x20], 1;
	__asm        je     _T521;

	__asm        cmp    dword ptr [ebp-0x20], 2;
	__asm        je     _T536;

	__asm        jmp    _T573;
// LINE 1998:
_T573:
	__asm        jmp    _T93e;
// LINE 2002:
_T578:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        and    eax, 3;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T5e4;
// LINE 2005:
_T58b:
	this->direction = 0x1;
// LINE 2006:
	this->nextLocation.y--;
// LINE 2007:
	__asm        jmp    _T608;
// LINE 2009:
_T5a0:
	this->direction = 0x4;
// LINE 2010:
	this->nextLocation.y++;
// LINE 2011:
	__asm        jmp    _T608;
// LINE 2013:
_T5b5:
	this->direction = 0x8;
// LINE 2014:
	this->nextLocation.x--;
// LINE 2015:
	__asm        jmp    _T608;
// LINE 2017:
_T5ca:
	this->direction = 0x2;
// LINE 2018:
	this->nextLocation.x++;
// LINE 2019:
	__asm        jmp    _T608;
// LINE 2020:
	__asm        jmp    _T608;
_T5e4:
	__asm        cmp    dword ptr [ebp-0x24], 3;
	__asm        ja     _T608;

	__asm        mov    eax, [ebp-0x24];
	__asm        jmp    _Switch_5f8[0][eax*4];
// Switch pointers:
//   _T58b
//   _T5a0
//   _T5b5
//   _T5ca
// LINE 2021:
_T608:
	__asm        jmp    _T93e;
// LINE 2026:
_T60d:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T62f;
// LINE 2028:
	this->direction = 0x4;
// LINE 2029:
	this->nextLocation.y++;
// LINE 2031:
	__asm        jmp    _T63f;
// LINE 2033:
_T62f:
	this->direction = 0x1;
// LINE 2034:
	this->nextLocation.y--;
// LINE 2036:
_T63f:
	__asm        jmp    _T93e;
// LINE 2041:
_T644:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T666;
// LINE 2043:
	this->direction = 0x8;
// LINE 2044:
	this->nextLocation.x--;
// LINE 2046:
	__asm        jmp    _T676;
// LINE 2048:
_T666:
	this->direction = 0x2;
// LINE 2049:
	this->nextLocation.x++;
// LINE 2051:
_T676:
	__asm        jmp    _T93e;
// LINE 2056:
_T67b:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T69d;
// LINE 2058:
	this->direction = 0x4;
// LINE 2059:
	this->nextLocation.y++;
// LINE 2061:
	__asm        jmp    _T6ad;
// LINE 2063:
_T69d:
	this->direction = 0x1;
// LINE 2064:
	this->nextLocation.y--;
// LINE 2066:
_T6ad:
	__asm        jmp    _T93e;
// LINE 2071:
_T6b2:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T6d4;
// LINE 2073:
	this->direction = 0x8;
// LINE 2074:
	this->nextLocation.x--;
// LINE 2076:
	__asm        jmp    _T6e4;
// LINE 2078:
_T6d4:
	this->direction = 0x2;
// LINE 2079:
	this->nextLocation.x++;
// LINE 2081:
_T6e4:
	__asm        jmp    _T93e;
// LINE 2086:
_T6e9:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T70b;
// LINE 2088:
	this->direction = 0x4;
// LINE 2089:
	this->nextLocation.y++;
// LINE 2091:
	__asm        jmp    _T71b;
// LINE 2093:
_T70b:
	this->direction = 0x1;
// LINE 2094:
	this->nextLocation.y--;
// LINE 2096:
_T71b:
	__asm        jmp    _T93e;
// LINE 2101:
_T720:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T742;
// LINE 2103:
	this->direction = 0x8;
// LINE 2104:
	this->nextLocation.x--;
// LINE 2106:
	__asm        jmp    _T752;
// LINE 2108:
_T742:
	this->direction = 0x2;
// LINE 2109:
	this->nextLocation.x++;
// LINE 2111:
_T752:
	__asm        jmp    _T93e;
// LINE 2116:
_T757:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T779;
// LINE 2118:
	this->direction = 0x4;
// LINE 2119:
	this->nextLocation.y++;
// LINE 2121:
	__asm        jmp    _T789;
// LINE 2123:
_T779:
	this->direction = 0x1;
// LINE 2124:
	this->nextLocation.y--;
// LINE 2126:
_T789:
	__asm        jmp    _T93e;
// LINE 2131:
_T78e:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T7b0;
// LINE 2133:
	this->direction = 0x8;
// LINE 2134:
	this->nextLocation.x--;
// LINE 2136:
	__asm        jmp    _T7c0;
// LINE 2138:
_T7b0:
	this->direction = 0x2;
// LINE 2139:
	this->nextLocation.x++;
// LINE 2141:
_T7c0:
	__asm        jmp    _T93e;
// LINE 2146:
_T7c5:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T7e7;
// LINE 2148:
	this->direction = 0x4;
// LINE 2149:
	this->nextLocation.y++;
// LINE 2151:
	__asm        jmp    _T7f7;
// LINE 2153:
_T7e7:
	this->direction = 0x1;
// LINE 2154:
	this->nextLocation.y--;
// LINE 2156:
_T7f7:
	__asm        jmp    _T93e;
// LINE 2161:
_T7fc:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T81e;
// LINE 2163:
	this->direction = 0x8;
// LINE 2164:
	this->nextLocation.x--;
// LINE 2166:
	__asm        jmp    _T82e;
// LINE 2168:
_T81e:
	this->direction = 0x2;
// LINE 2169:
	this->nextLocation.x++;
// LINE 2171:
_T82e:
	__asm        jmp    _T93e;
// LINE 2175:
_T833:
	_assert(0x87f, 0x5b78d0, 0x5b78f4);
	__asm        jmp    _T854;

	__asm        jmp    _T854;
// LINE 2177:
_T854:
	__asm        jmp    _T93e;
_T859:
	__asm        cmp    dword ptr [ebp-0x10], 0x805A;
	__asm        jg     _T92c;

	__asm        je     _T78e;

	__asm        sub    dword ptr [ebp-0x10], 0x2C;
	__asm        cmp    dword ptr [ebp-0x10], 0x2F;
	__asm        ja     _T833;

	__asm        mov    eax, [ebp-0x10];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, _SwitchTable_8fc[0][eax];
	__asm        jmp    _Switch_88c[0][ecx*4];
// Switch pointers:
//   _T124
//   _T15e
//   _T20c
//   _T1d2
//   _T246
//   _T198
//   _T3c
//   _T76
//   _Tb0
//   _Tea
//   _T368
//   _T3ec
//   _T470
//   _T4f4
//   _T578
//   _T2f4
//   _T2ba
//   _T32e
//   _T280
//   _T6b2
//   _T67b
//   _T6e9
//   _T720
//   _T644
//   _T60d
//   _T757
//   _T7c5
//   _T833
// Switch table
//  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 27, 27, 27, 27, 27, 27, 19, 20, 21, 22, 27, 27, 27, 27, 23, 24, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 25, 26]
_T92c:
	__asm        cmp    dword ptr [ebp-0x10], 0x805B;
	__asm        je     _T7fc;

	__asm        jmp    _T833;
// LINE 2179:
_T93e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x55], 0;
	__asm        jl     _T978;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x59], 0;
	__asm        jl     _T978;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x55], 0x80;
	__asm        jge    _T978;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x59], 0x80;
	__asm        jl     _T983;
_T978:
	__asm        mov    word ptr [ebp-4], 0;
	__asm        jmp    _T9c7;
_T983:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x55];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x59];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x55];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x59];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-4], ax;
	__asm        jmp    _T9c7;
_T9c7:
	__asm        mov    eax, [ebp-4];
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _T9eb;

	__asm        jmp    _Ta6e;

	__asm        jmp    _Ta73;

	__asm        jmp    _Ta6e;

	__asm        jmp    _Ta64;
_T9eb:
	__asm        cmp    dword ptr [ebp-0x28], 0x48;
	__asm        jg     _Ta18;

	__asm        cmp    dword ptr [ebp-0x28], 0x45;
	__asm        jge    _Ta6e;

	__asm        cmp    dword ptr [ebp-0x28], 0x2C;
	__asm        jl     _Ta73;

	__asm        cmp    dword ptr [ebp-0x28], 0x3E;
	__asm        jle    _Ta6e;

	__asm        jmp    _Ta73;
_Ta18:
	__asm        cmp    dword ptr [ebp-0x28], 0x5B;
	__asm        jg     _Ta45;

	__asm        cmp    dword ptr [ebp-0x28], 0x5A;
	__asm        jge    _Ta6e;

	__asm        cmp    dword ptr [ebp-0x28], 0x4D;
	__asm        jl     _Ta73;

	__asm        cmp    dword ptr [ebp-0x28], 0x4E;
	__asm        jle    _Ta6e;

	__asm        jmp    _Ta73;
_Ta45:
	__asm        cmp    dword ptr [ebp-0x28], 0x805A;
	__asm        jl     _Ta73;

	__asm        cmp    dword ptr [ebp-0x28], 0x805B;
	__asm        jle    _Ta6e;

	__asm        jmp    _Ta73;
_Ta64:
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _Ta73;
// LINE 2180:
_Ta6e:
	return;
// LINE 2183:
_Ta73:
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 2184:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tileType);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T128c;
// LINE 2188:
_Ta99:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 6;
	__asm        jne    _Tabb;
// LINE 2190:
	this->direction = 0x9;
// LINE 2191:
	this->nextLocation.y--;
// LINE 2193:
	__asm        jmp    _Tacb;
// LINE 2195:
_Tabb:
	this->direction = 0x6;
// LINE 2196:
	this->nextLocation.x++;
// LINE 2198:
_Tacb:
	__asm        jmp    _T1371;
// LINE 2202:
_Tad0:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 0xC;
	__asm        jne    _Taf2;
// LINE 2204:
	this->direction = 0x3;
// LINE 2205:
	this->nextLocation.x++;
// LINE 2207:
	__asm        jmp    _Tb02;
// LINE 2209:
_Taf2:
	this->direction = 0xc;
// LINE 2210:
	this->nextLocation.y++;
// LINE 2212:
_Tb02:
	__asm        jmp    _T1371;
// LINE 2216:
_Tb07:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 6;
	__asm        jne    _Tb29;
// LINE 2218:
	this->direction = 0x9;
// LINE 2219:
	this->nextLocation.x--;
// LINE 2221:
	__asm        jmp    _Tb39;
// LINE 2223:
_Tb29:
	this->direction = 0x6;
// LINE 2224:
	this->nextLocation.y++;
// LINE 2226:
_Tb39:
	__asm        jmp    _T1371;
// LINE 2230:
_Tb3e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 0xC;
	__asm        jne    _Tb60;
// LINE 2232:
	this->direction = 0x3;
// LINE 2233:
	this->nextLocation.y--;
// LINE 2235:
	__asm        jmp    _Tb70;
// LINE 2237:
_Tb60:
	this->direction = 0xc;
// LINE 2238:
	this->nextLocation.x--;
// LINE 2240:
_Tb70:
	__asm        jmp    _T1371;
// LINE 2244:
_Tb75:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 1;
	__asm        jne    _Tb97;
// LINE 2246:
	this->direction = 0x1;
// LINE 2247:
	this->nextLocation.y--;
// LINE 2249:
	__asm        jmp    _Tba7;
// LINE 2251:
_Tb97:
	this->direction = 0x4;
// LINE 2252:
	this->nextLocation.y++;
// LINE 2254:
_Tba7:
	__asm        jmp    _T1371;
// LINE 2258:
_Tbac:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 2;
	__asm        jne    _Tbce;
// LINE 2260:
	this->direction = 0x8;
// LINE 2261:
	this->nextLocation.x--;
// LINE 2263:
	__asm        jmp    _Tbde;
// LINE 2265:
_Tbce:
	this->direction = 0x2;
// LINE 2266:
	this->nextLocation.x++;
// LINE 2268:
_Tbde:
	__asm        jmp    _T1371;
// LINE 2272:
_Tbe3:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 0x14;
	__asm        jne    _Tc05;
// LINE 2274:
	this->direction = 0x1;
// LINE 2275:
	this->nextLocation.y--;
// LINE 2277:
	__asm        jmp    _Tc15;
// LINE 2279:
_Tc05:
	this->direction = 0x14;
// LINE 2280:
	this->nextLocation.y++;
// LINE 2282:
_Tc15:
	__asm        jmp    _T1371;
// LINE 2286:
_Tc1a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 4;
	__asm        jne    _Tc3c;
// LINE 2288:
	this->direction = 0x11;
// LINE 2289:
	this->nextLocation.y--;
// LINE 2291:
	__asm        jmp    _Tc4c;
// LINE 2293:
_Tc3c:
	this->direction = 0x4;
// LINE 2294:
	this->nextLocation.y++;
// LINE 2296:
_Tc4c:
	__asm        jmp    _T1371;
// LINE 2300:
_Tc51:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 2;
	__asm        jne    _Tc73;
// LINE 2302:
	this->direction = 0x18;
// LINE 2303:
	this->nextLocation.x--;
// LINE 2305:
	__asm        jmp    _Tc83;
// LINE 2307:
_Tc73:
	this->direction = 0x2;
// LINE 2308:
	this->nextLocation.x++;
// LINE 2310:
_Tc83:
	__asm        jmp    _T1371;
// LINE 2314:
_Tc88:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 0x18;
	__asm        jne    _Tcaa;
// LINE 2316:
	this->direction = 0x8;
// LINE 2317:
	this->nextLocation.x--;
// LINE 2319:
	__asm        jmp    _Tcba;
// LINE 2321:
_Tcaa:
	this->direction = 0x12;
// LINE 2322:
	this->nextLocation.x++;
// LINE 2324:
_Tcba:
	__asm        jmp    _T1371;
// LINE 2328:
_Tcbf:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 0x14;
	__asm        jne    _Tce1;
// LINE 2330:
	this->direction = 0x1;
// LINE 2331:
	this->nextLocation.y--;
// LINE 2333:
	__asm        jmp    _Tcf1;
// LINE 2335:
_Tce1:
	this->direction = 0x14;
// LINE 2336:
	this->nextLocation.y++;
// LINE 2338:
_Tcf1:
	__asm        jmp    _T1371;
// LINE 2342:
_Tcf6:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 4;
	__asm        jne    _Td18;
// LINE 2344:
	this->direction = 0x11;
// LINE 2345:
	this->nextLocation.y--;
// LINE 2347:
	__asm        jmp    _Td28;
// LINE 2349:
_Td18:
	this->direction = 0x4;
// LINE 2350:
	this->nextLocation.y++;
// LINE 2352:
_Td28:
	__asm        jmp    _T1371;
// LINE 2356:
_Td2d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 2;
	__asm        jne    _Td4f;
// LINE 2358:
	this->direction = 0x18;
// LINE 2359:
	this->nextLocation.x--;
// LINE 2361:
	__asm        jmp    _Td5f;
// LINE 2363:
_Td4f:
	this->direction = 0x2;
// LINE 2364:
	this->nextLocation.x++;
// LINE 2366:
_Td5f:
	__asm        jmp    _T1371;
// LINE 2370:
_Td64:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11], 0x18;
	__asm        jne    _Td86;
// LINE 2372:
	this->direction = 0x8;
// LINE 2373:
	this->nextLocation.x--;
// LINE 2375:
	__asm        jmp    _Td96;
// LINE 2377:
_Td86:
	this->direction = 0x12;
// LINE 2378:
	this->nextLocation.x++;
// LINE 2380:
_Td96:
	__asm        jmp    _T1371;
// LINE 2384:
_Td9b:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x30], edx;
	__asm        jmp    _Tdf7;
// LINE 2387:
_Tdb3:
	this->direction = 0x1;
// LINE 2388:
	this->nextLocation.y--;
// LINE 2389:
	__asm        jmp    _Te1a;
// LINE 2391:
_Tdc8:
	this->direction = 0x2;
// LINE 2392:
	this->nextLocation.x++;
// LINE 2393:
	__asm        jmp    _Te1a;
// LINE 2395:
_Tddd:
	this->direction = 0x8;
// LINE 2396:
	this->nextLocation.x--;
// LINE 2397:
	__asm        jmp    _Te1a;
// LINE 2398:
	__asm        jmp    _Te1a;
_Tdf7:
	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        je     _Tdb3;

	__asm        cmp    dword ptr [ebp-0x30], 1;
	__asm        je     _Tdc8;

	__asm        cmp    dword ptr [ebp-0x30], 2;
	__asm        je     _Tddd;

	__asm        jmp    _Te1a;
// LINE 2399:
_Te1a:
	__asm        jmp    _T1371;
// LINE 2403:
_Te1f:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x34], edx;
	__asm        jmp    _Te7b;
// LINE 2406:
_Te37:
	this->direction = 0x1;
// LINE 2407:
	this->nextLocation.y--;
// LINE 2408:
	__asm        jmp    _Te9e;
// LINE 2410:
_Te4c:
	this->direction = 0x4;
// LINE 2411:
	this->nextLocation.y++;
// LINE 2412:
	__asm        jmp    _Te9e;
// LINE 2414:
_Te61:
	this->direction = 0x2;
// LINE 2415:
	this->nextLocation.x++;
// LINE 2416:
	__asm        jmp    _Te9e;
// LINE 2417:
	__asm        jmp    _Te9e;
_Te7b:
	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        je     _Te37;

	__asm        cmp    dword ptr [ebp-0x34], 1;
	__asm        je     _Te4c;

	__asm        cmp    dword ptr [ebp-0x34], 2;
	__asm        je     _Te61;

	__asm        jmp    _Te9e;
// LINE 2418:
_Te9e:
	__asm        jmp    _T1371;
// LINE 2422:
_Tea3:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x38], edx;
	__asm        jmp    _Teff;
// LINE 2425:
_Tebb:
	this->direction = 0x4;
// LINE 2426:
	this->nextLocation.y++;
// LINE 2427:
	__asm        jmp    _Tf22;
// LINE 2429:
_Ted0:
	this->direction = 0x2;
// LINE 2430:
	this->nextLocation.x++;
// LINE 2431:
	__asm        jmp    _Tf22;
// LINE 2433:
_Tee5:
	this->direction = 0x8;
// LINE 2434:
	this->nextLocation.x--;
// LINE 2435:
	__asm        jmp    _Tf22;
// LINE 2436:
	__asm        jmp    _Tf22;
_Teff:
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _Tebb;

	__asm        cmp    dword ptr [ebp-0x38], 1;
	__asm        je     _Ted0;

	__asm        cmp    dword ptr [ebp-0x38], 2;
	__asm        je     _Tee5;

	__asm        jmp    _Tf22;
// LINE 2437:
_Tf22:
	__asm        jmp    _T1371;
// LINE 2441:
_Tf27:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0x3C], edx;
	__asm        jmp    _Tf83;
// LINE 2444:
_Tf3f:
	this->direction = 0x1;
// LINE 2445:
	this->nextLocation.y--;
// LINE 2446:
	__asm        jmp    _Tfa6;
// LINE 2448:
_Tf54:
	this->direction = 0x4;
// LINE 2449:
	this->nextLocation.y++;
// LINE 2450:
	__asm        jmp    _Tfa6;
// LINE 2452:
_Tf69:
	this->direction = 0x8;
// LINE 2453:
	this->nextLocation.x--;
// LINE 2454:
	__asm        jmp    _Tfa6;
// LINE 2455:
	__asm        jmp    _Tfa6;
_Tf83:
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        je     _Tf3f;

	__asm        cmp    dword ptr [ebp-0x3C], 1;
	__asm        je     _Tf54;

	__asm        cmp    dword ptr [ebp-0x3C], 2;
	__asm        je     _Tf69;

	__asm        jmp    _Tfa6;
// LINE 2456:
_Tfa6:
	__asm        jmp    _T1371;
// LINE 2460:
_Tfab:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        and    eax, 3;
	__asm        mov    [ebp-0x40], eax;
	__asm        jmp    _T1017;
// LINE 2463:
_Tfbe:
	this->direction = 0x1;
// LINE 2464:
	this->nextLocation.y--;
// LINE 2465:
	__asm        jmp    _T103b;
// LINE 2467:
_Tfd3:
	this->direction = 0x4;
// LINE 2468:
	this->nextLocation.y++;
// LINE 2469:
	__asm        jmp    _T103b;
// LINE 2471:
_Tfe8:
	this->direction = 0x8;
// LINE 2472:
	this->nextLocation.x--;
// LINE 2473:
	__asm        jmp    _T103b;
// LINE 2475:
_Tffd:
	this->direction = 0x2;
// LINE 2476:
	this->nextLocation.x++;
// LINE 2477:
	__asm        jmp    _T103b;
// LINE 2478:
	__asm        jmp    _T103b;
_T1017:
	__asm        cmp    dword ptr [ebp-0x40], 3;
	__asm        ja     _T103b;

	__asm        mov    eax, [ebp-0x40];
	__asm        jmp    _Switch_102b[0][eax*4];
// Switch pointers:
//   _Tfbe
//   _Tfd3
//   _Tfe8
//   _Tffd
// LINE 2479:
_T103b:
	__asm        jmp    _T1371;
// LINE 2484:
_T1040:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T1062;
// LINE 2486:
	this->direction = 0x4;
// LINE 2487:
	this->nextLocation.y++;
// LINE 2489:
	__asm        jmp    _T1072;
// LINE 2491:
_T1062:
	this->direction = 0x1;
// LINE 2492:
	this->nextLocation.y--;
// LINE 2494:
_T1072:
	__asm        jmp    _T1371;
// LINE 2499:
_T1077:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T1099;
// LINE 2501:
	this->direction = 0x8;
// LINE 2502:
	this->nextLocation.x--;
// LINE 2504:
	__asm        jmp    _T10a9;
// LINE 2506:
_T1099:
	this->direction = 0x2;
// LINE 2507:
	this->nextLocation.x++;
// LINE 2509:
_T10a9:
	__asm        jmp    _T1371;
// LINE 2514:
_T10ae:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T10d0;
// LINE 2516:
	this->direction = 0x4;
// LINE 2517:
	this->nextLocation.y++;
// LINE 2519:
	__asm        jmp    _T10e0;
// LINE 2521:
_T10d0:
	this->direction = 0x1;
// LINE 2522:
	this->nextLocation.y--;
// LINE 2524:
_T10e0:
	__asm        jmp    _T1371;
// LINE 2529:
_T10e5:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T1107;
// LINE 2531:
	this->direction = 0x8;
// LINE 2532:
	this->nextLocation.x--;
// LINE 2534:
	__asm        jmp    _T1117;
// LINE 2536:
_T1107:
	this->direction = 0x2;
// LINE 2537:
	this->nextLocation.x++;
// LINE 2539:
_T1117:
	__asm        jmp    _T1371;
// LINE 2544:
_T111c:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T113e;
// LINE 2546:
	this->direction = 0x4;
// LINE 2547:
	this->nextLocation.y++;
// LINE 2549:
	__asm        jmp    _T114e;
// LINE 2551:
_T113e:
	this->direction = 0x1;
// LINE 2552:
	this->nextLocation.y--;
// LINE 2554:
_T114e:
	__asm        jmp    _T1371;
// LINE 2559:
_T1153:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T1175;
// LINE 2561:
	this->direction = 0x8;
// LINE 2562:
	this->nextLocation.x--;
// LINE 2564:
	__asm        jmp    _T1185;
// LINE 2566:
_T1175:
	this->direction = 0x2;
// LINE 2567:
	this->nextLocation.x++;
// LINE 2569:
_T1185:
	__asm        jmp    _T1371;
// LINE 2574:
_T118a:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T11ac;
// LINE 2576:
	this->direction = 0x4;
// LINE 2577:
	this->nextLocation.y++;
// LINE 2579:
	__asm        jmp    _T11bc;
// LINE 2581:
_T11ac:
	this->direction = 0x1;
// LINE 2582:
	this->nextLocation.y--;
// LINE 2584:
_T11bc:
	__asm        jmp    _T1371;
// LINE 2589:
_T11c1:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T11e3;
// LINE 2591:
	this->direction = 0x8;
// LINE 2592:
	this->nextLocation.x--;
// LINE 2594:
	__asm        jmp    _T11f3;
// LINE 2596:
_T11e3:
	this->direction = 0x2;
// LINE 2597:
	this->nextLocation.x++;
// LINE 2599:
_T11f3:
	__asm        jmp    _T1371;
// LINE 2604:
_T11f8:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x35], 1;
	__asm        jne    _T121a;
// LINE 2606:
	this->direction = 0x4;
// LINE 2607:
	this->nextLocation.y++;
// LINE 2609:
	__asm        jmp    _T122a;
// LINE 2611:
_T121a:
	this->direction = 0x1;
// LINE 2612:
	this->nextLocation.y--;
// LINE 2614:
_T122a:
	__asm        jmp    _T1371;
// LINE 2619:
_T122f:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x39], 1;
	__asm        jne    _T1251;
// LINE 2621:
	this->direction = 0x8;
// LINE 2622:
	this->nextLocation.x--;
// LINE 2624:
	__asm        jmp    _T1261;
// LINE 2626:
_T1251:
	this->direction = 0x2;
// LINE 2627:
	this->nextLocation.x++;
// LINE 2629:
_T1261:
	__asm        jmp    _T1371;
// LINE 2633:
_T1266:
	_assert(0xa49, 0x5b78fc, 0x5b7920);
	__asm        jmp    _T1287;

	__asm        jmp    _T1287;
// LINE 2635:
_T1287:
	__asm        jmp    _T1371;
_T128c:
	__asm        cmp    dword ptr [ebp-0x2C], 0x805A;
	__asm        jg     _T135f;

	__asm        je     _T1077;

	__asm        sub    dword ptr [ebp-0x2C], 0x2C;
	__asm        cmp    dword ptr [ebp-0x2C], 0x2F;
	__asm        ja     _T1266;

	__asm        mov    eax, [ebp-0x2C];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, _SwitchTable_132f[0][eax];
	__asm        jmp    _Switch_12bf[0][ecx*4];
// Switch pointers:
//   _Tb75
//   _Tbac
//   _Tc51
//   _Tc1a
//   _Tc88
//   _Tbe3
//   _Ta99
//   _Tad0
//   _Tb07
//   _Tb3e
//   _Td9b
//   _Te1f
//   _Tea3
//   _Tf27
//   _Tfab
//   _Td2d
//   _Tcf6
//   _Td64
//   _Tcbf
//   _T1153
//   _T111c
//   _T11f8
//   _T122f
//   _T11c1
//   _T118a
//   _T1040
//   _T10ae
//   _T1266
// Switch table
//  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 27, 27, 27, 27, 27, 27, 19, 20, 21, 22, 27, 27, 27, 27, 23, 24, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 25, 26]
_T135f:
	__asm        cmp    dword ptr [ebp-0x2C], 0x805B;
	__asm        je     _T10e5;

	__asm        jmp    _T1266;
// LINE 2638:
_T1371:
	return;
}

// FUNCTION: COPTER_D 0x00530e02
void TrainClass::SlowDown() {
// LINE 2657:
	this->speed -= 0x20000;
// LINE 2658:
	return;
}

// FUNCTION: COPTER_D 0x00530e22
void TrainClass::Stop() {
// LINE 2678:
	this->speed = 0x0;
// LINE 2679:
	return;
}

// FUNCTION: COPTER_D 0x00530e42
void TrainClass::MoveForward() {
	/*bp-0x4*/   int32_t distance;

// LINE 2701:
	__asm        mov    eax, LoopTime;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x2D];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    distance, eax;
// LINE 2703:
	__asm        mov    eax, this;
	__asm        mov    ecx, distance;
	__asm        cmp    [eax+0x21], ecx;
	__asm        jge    _T3c;
// LINE 2704:
	distance = this->remainingDist;
// LINE 2705:
_T3c:
	__asm        xor    eax, eax;
	__asm        sub    eax, distance;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x21], eax;
// LINE 2712:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x15];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        add    [ecx+0x18], eax;
// LINE 2713:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x19];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        add    [ecx+0x1C], eax;
// LINE 2714:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        add    [ecx+0x20], eax;
// LINE 2717:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x18];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        test   eax, eax;
	__asm        jl     _T11c;

	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        sub    eax, [ecx+0x20];
	__asm        sar    eax, 0x16;
	__asm        test   eax, eax;
	__asm        jl     _T11c;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x18];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        cmp    eax, 0x80;
	__asm        jge    _T11c;

	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        sub    eax, [ecx+0x20];
	__asm        sar    eax, 0x16;
	__asm        cmp    eax, 0x80;
	__asm        jl     _T127;
_T11c:
	__asm        mov    word ptr [ebp-8], 0;
	__asm        jmp    _T1a4;
_T127:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x18];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, 0x20000000;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x1CD];
	__asm        sub    ecx, [edx+0x20];
	__asm        sar    ecx, 0x16;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, 0x20000000;
	__asm        sar    ecx, 0x16;
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, 0x20000000;
	__asm        mov    ebx, this;
	__asm        mov    ebx, [ebx+0x1CD];
	__asm        sub    edx, [ebx+0x20];
	__asm        sar    edx, 0x16;
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-8], ax;
	__asm        jmp    _T1a4;
_T1a4:
	__asm        mov    eax, [ebp-8];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x36;
	__asm        jl     _T1d0;

	__asm        mov    eax, [ebp-8];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x3A;
	__asm        jg     _T1d0;

	__asm        jmp    _T1e4;

	__asm        jmp    _T1da;
_T1d0:
	__asm        jmp    _T1f0;

	__asm        jmp    _T1e4;
_T1da:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T1f0;
// LINE 2719:
_T1e4:
	this->flags[3] = 0x1;
// LINE 2721:
	__asm        jmp    _T1f7;
// LINE 2723:
_T1f0:
	this->flags[3] = 0x0;
// LINE 2728:
_T1f7:
	this->stalledTimer = 0x0;
// LINE 2729:
	return;
}

// FUNCTION: COPTER_D 0x0053104d
int32_t TrainClass::HaveIReachedNextLoc() {
// LINE 2750:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x21], 0;
	__asm        jg     _T28;
// LINE 2752:
	return 0x1;
// LINE 2754:
	__asm        jmp    __RETURN;
// LINE 2756:
_T28:
	return 0x0;
// LINE 2758:
__RETURN:
}

// FUNCTION: COPTER_D 0x00531081
int32_t TrainClass::AmIInANewCell() {
// LINE 2782:
	this->currentCell.x = ((this->leadcar->loc.x + 0x20000000) >> 0x16);
// LINE 2783:
	this->currentCell.y = ((0x20000000 - this->leadcar->loc.z) >> 0x16);
// LINE 2787:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x4D];
	__asm        cmp    [eax+0x35], ecx;
	__asm        jne    _T64;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x39];
	__asm        cmp    [eax+0x51], ecx;
	__asm        je     _T19e;
// LINE 2790:
_T64:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4D], 0;
	__asm        jl     _T9e;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x51], 0;
	__asm        jl     _T9e;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4D], 0x80;
	__asm        jge    _T9e;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x51], 0x80;
	__asm        jl     _Ta9;
_T9e:
	__asm        mov    word ptr [ebp-4], 0;
	__asm        jmp    _Ted;
_Ta9:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4D];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x51];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x4D];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x51];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-4], ax;
	__asm        jmp    _Ted;
_Ted:
	__asm        mov    eax, [ebp-4];
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T111;

	__asm        jmp    _T194;

	__asm        jmp    _T19e;

	__asm        jmp    _T194;

	__asm        jmp    _T18a;
_T111:
	__asm        cmp    dword ptr [ebp-0x10], 0x48;
	__asm        jg     _T13e;

	__asm        cmp    dword ptr [ebp-0x10], 0x45;
	__asm        jge    _T194;

	__asm        cmp    dword ptr [ebp-0x10], 0x2C;
	__asm        jl     _T19e;

	__asm        cmp    dword ptr [ebp-0x10], 0x3E;
	__asm        jle    _T194;

	__asm        jmp    _T19e;
_T13e:
	__asm        cmp    dword ptr [ebp-0x10], 0x5B;
	__asm        jg     _T16b;

	__asm        cmp    dword ptr [ebp-0x10], 0x5A;
	__asm        jge    _T194;

	__asm        cmp    dword ptr [ebp-0x10], 0x4D;
	__asm        jl     _T19e;

	__asm        cmp    dword ptr [ebp-0x10], 0x4E;
	__asm        jle    _T194;

	__asm        jmp    _T19e;
_T16b:
	__asm        cmp    dword ptr [ebp-0x10], 0x805A;
	__asm        jl     _T19e;

	__asm        cmp    dword ptr [ebp-0x10], 0x805B;
	__asm        jle    _T194;

	__asm        jmp    _T19e;
_T18a:
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T19e;
// LINE 2791:
_T194:
	return 0x1;
// LINE 2794:
_T19e:
	return 0x0;
// LINE 2795:
}

// FUNCTION: COPTER_D 0x0053122b
void TrainClass::UnlinkFromCell(const /*packed*/ struct Point2d& point, /*packed*/ struct _DYOBJ_INST *dyobj) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 2817:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, point;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T55;

	_assert(0xd0, 0x5b780c, 0x5b57b8);
	__asm        jmp    _T5a;
_T55:
	__asm        jmp    _T5a;
_T5a:
	__asm        jmp    _T5f;
_T5f:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    cellPointer, eax;
// LINE 2819:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T8b;

	_assert(0xb03, 0x5b7928, 0x5b794c);
	__asm        jmp    _T90;
_T8b:
	__asm        jmp    _T90;
// LINE 2821:
_T90:
	__asm        cmp    cellPointer, 0;
	__asm        je     _T106;
// LINE 2823:
// Block start:
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST **dyptrptr;
	dyptrptr = (cellPointer + 0x10);
// LINE 2825:
__WHILE_a3:
	while ((dyptrptr-> != 0x0)) {
		// LINE 2829:
			__asm        mov    eax, dyptrptr;
			__asm        mov    ecx, dyobj;
			__asm        cmp    [eax], ecx;
			__asm        jne    _Tcc;
		// LINE 2833:
			dyptrptr-> = dyobj->next;
		// LINE 2835:
			return;
		// LINE 2838:
		_Tcc:
			dyptrptr = dyptrptr->;
	}
// LINE 2841:
_Td9:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _T101;

	_assert(0xb19, 0x5b7958, 0x5b797c);
	__asm        jmp    _T106;
_T101:
	__asm        jmp    _T106;
// LINE 2843:
// Block end:
_T106:
	return;
}

// FUNCTION: COPTER_D 0x0053133d
void TrainClass::LinkToCell(const /*packed*/ struct Point2d& point, /*packed*/ struct _DYOBJ_INST *dyobj) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 2865:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, point;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T55;

	_assert(0xd0, 0x5b780c, 0x5b57b8);
	__asm        jmp    _T5a;
_T55:
	__asm        jmp    _T5a;
_T5a:
	__asm        jmp    _T5f;
_T5f:
	__asm        mov    eax, [ebp-8];
	__asm        mov    cellPointer, eax;
// LINE 2867:
	__asm        mov    eax, cellPointer;
	__asm        mov    ecx, dyobj;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T90;

	_assert(0xb33, 0x5b7988, 0x5b79ac);
	__asm        jmp    _T95;
_T90:
	__asm        jmp    _T95;
// LINE 2869:
_T95:
	dyobj->next = cellPointer->dyptr;
// LINE 2870:
	cellPointer->dyptr = dyobj;
// LINE 2872:
	return;
}

// FUNCTION: COPTER_D 0x005313f2
enum TrainClass::IntersectionTypes TrainClass::PickTurnDirection(const /*packed*/ struct Point2d& point) {
	/*bp-0x4*/   unsigned short northTile;
	/*bp-0x8*/   long intersection;
	/*bp-0xc*/   unsigned short eastTile;
	/*bp-0x10*/  unsigned short currentTile;
	/*bp-0x14*/  unsigned short westTile;
	/*bp-0x18*/  unsigned short southTile;

// LINE 2905:
	this->northCell.x = point.x;
// LINE 2906:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x79], eax;
// LINE 2907:
	this->southCell.x = point.x;
// LINE 2908:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        inc    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x81], eax;
// LINE 2909:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax];
	__asm        inc    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x85], eax;
// LINE 2910:
	this->eastCell.y = point.y;
// LINE 2911:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax];
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x8D], eax;
// LINE 2912:
	this->westCell.y = point.y;
// LINE 2915:
	__asm        mov    eax, point;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jl     _Tb3;

	__asm        mov    eax, point;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jl     _Tb3;

	__asm        mov    eax, point;
	__asm        cmp    dword ptr [eax], 0x80;
	__asm        jge    _Tb3;

	__asm        mov    eax, point;
	__asm        cmp    dword ptr [eax+4], 0x80;
	__asm        jl     _Tbe;
_Tb3:
	currentTile = 0x0;
	__asm        jmp    _T100;
_Tbe:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, point;
	__asm        mov    ecx, [ecx+4];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, point;
	__asm        mov    ecx, [ecx];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, point;
	__asm        mov    edx, [edx+4];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    currentTile, ax;
	__asm        jmp    _T100;
// LINE 2917:
_T100:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x75], 0;
	__asm        jl     _T13a;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x79], 0;
	__asm        jl     _T13a;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x75], 0x80;
	__asm        jge    _T13a;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x79], 0x80;
	__asm        jl     _T145;
_T13a:
	northTile = 0x0;
	__asm        jmp    _T189;
_T145:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x75];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x79];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x75];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x79];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    northTile, ax;
	__asm        jmp    _T189;
// LINE 2918:
_T189:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7D], 0;
	__asm        jl     _T1c9;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x81], 0;
	__asm        jl     _T1c9;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7D], 0x80;
	__asm        jge    _T1c9;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x81], 0x80;
	__asm        jl     _T1d4;
_T1c9:
	southTile = 0x0;
	__asm        jmp    _T21e;
_T1d4:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7D];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x81];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7D];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x81];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    southTile, ax;
	__asm        jmp    _T21e;
// LINE 2919:
_T21e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x85], 0;
	__asm        jl     _T264;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x89], 0;
	__asm        jl     _T264;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x85], 0x80;
	__asm        jge    _T264;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x89], 0x80;
	__asm        jl     _T26f;
_T264:
	eastTile = 0x0;
	__asm        jmp    _T2bf;
_T26f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x85];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x89];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x85];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x89];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    eastTile, ax;
	__asm        jmp    _T2bf;
// LINE 2920:
_T2bf:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x8D], 0;
	__asm        jl     _T305;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x91], 0;
	__asm        jl     _T305;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x8D], 0x80;
	__asm        jge    _T305;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x91], 0x80;
	__asm        jl     _T310;
_T305:
	westTile = 0x0;
	__asm        jmp    _T360;
_T310:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8D];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x91];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x8D];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x91];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    westTile, ax;
	__asm        jmp    _T360;
// LINE 2926:
_T360:
	intersection = 0x0;
// LINE 2928:
	__asm        jmp    _T36c;
_T36c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T407;

	__asm        jmp    _T38b;
_T38b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _T407;
// LINE 2930:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x34;
	__asm        jne    _T3d6;

	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x33;
	__asm        jne    _T3d6;
// LINE 2931:
	this->direction = 0x6;
// LINE 2932:
	__asm        jmp    _T402;
_T3d6:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x34;
	__asm        jne    _T402;

	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x35;
	__asm        jne    _T402;
// LINE 2933:
	this->direction = 0x9;
// LINE 2935:
_T402:
	__asm        jmp    _T5e2;
_T407:
	__asm        jmp    _T40c;
_T40c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T4a7;

	__asm        jmp    _T42b;
_T42b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T4a7;
// LINE 2937:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x33;
	__asm        jne    _T476;

	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x34;
	__asm        jne    _T476;
// LINE 2938:
	this->direction = 0xc;
// LINE 2939:
	__asm        jmp    _T4a2;
_T476:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x33;
	__asm        jne    _T4a2;

	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x32;
	__asm        jne    _T4a2;
// LINE 2940:
	this->direction = 0x3;
// LINE 2942:
_T4a2:
	__asm        jmp    _T5e2;
_T4a7:
	__asm        jmp    _T4ac;
_T4ac:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T547;

	__asm        jmp    _T4cb;
_T4cb:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _T547;
// LINE 2944:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x35;
	__asm        jne    _T516;

	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x32;
	__asm        jne    _T516;
// LINE 2945:
	this->direction = 0x3;
// LINE 2946:
	__asm        jmp    _T542;
_T516:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x35;
	__asm        jne    _T542;

	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x34;
	__asm        jne    _T542;
// LINE 2947:
	this->direction = 0xc;
// LINE 2949:
_T542:
	__asm        jmp    _T5e2;
_T547:
	__asm        jmp    _T54c;
_T54c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T5e2;

	__asm        jmp    _T56b;
_T56b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T5e2;
// LINE 2951:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x32;
	__asm        jne    _T5b6;

	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x35;
	__asm        jne    _T5b6;
// LINE 2952:
	this->direction = 0x9;
// LINE 2953:
	__asm        jmp    _T5e2;
_T5b6:
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x32;
	__asm        jne    _T5e2;

	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x33;
	__asm        jne    _T5e2;
// LINE 2954:
	this->direction = 0x6;
// LINE 2959:
_T5e2:
	__asm        jmp    _T5e7;
_T5e7:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T661;

	__asm        jmp    _T606;
_T606:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _T661;
// LINE 2962:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T63e;
// LINE 2964:
	__asm        or     intersection, 1;
// LINE 2966:
_T63e:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T65c;
// LINE 2968:
	__asm        or     intersection, 4;
// LINE 2971:
_T65c:
	__asm        jmp    _T9fe;
_T661:
	__asm        jmp    _T666;
_T666:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T6e0;

	__asm        jmp    _T685;
_T685:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T6e0;
// LINE 2974:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T6bd;
// LINE 2976:
	__asm        or     intersection, 1;
// LINE 2978:
_T6bd:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T6db;
// LINE 2980:
	__asm        or     intersection, 2;
// LINE 2983:
_T6db:
	__asm        jmp    _T9fe;
_T6e0:
	__asm        jmp    _T6e5;
_T6e5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T75f;

	__asm        jmp    _T704;
_T704:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _T75f;
// LINE 2986:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T73c;
// LINE 2988:
	__asm        or     intersection, 1;
// LINE 2990:
_T73c:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T75a;
// LINE 2992:
	__asm        or     intersection, 2;
// LINE 2995:
_T75a:
	__asm        jmp    _T9fe;
_T75f:
	__asm        jmp    _T764;
_T764:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T7de;

	__asm        jmp    _T783;
_T783:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T7de;
// LINE 2998:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T7bb;
// LINE 3000:
	__asm        or     intersection, 1;
// LINE 3002:
_T7bb:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T7d9;
// LINE 3004:
	__asm        or     intersection, 4;
// LINE 3007:
_T7d9:
	__asm        jmp    _T9fe;
_T7de:
	__asm        jmp    _T7e3;
_T7e3:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T85c;
// LINE 3010:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T81b;
// LINE 3012:
	__asm        or     intersection, 1;
// LINE 3014:
_T81b:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T839;
// LINE 3016:
	__asm        or     intersection, 2;
// LINE 3018:
_T839:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T857;
// LINE 3020:
	__asm        or     intersection, 4;
// LINE 3023:
_T857:
	__asm        jmp    _T9fe;
_T85c:
	__asm        jmp    _T861;
_T861:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T8da;
// LINE 3026:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T899;
// LINE 3028:
	__asm        or     intersection, 1;
// LINE 3030:
_T899:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T8b7;
// LINE 3032:
	__asm        or     intersection, 2;
// LINE 3034:
_T8b7:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T8d5;
// LINE 3036:
	__asm        or     intersection, 4;
// LINE 3039:
_T8d5:
	__asm        jmp    _T9fe;
_T8da:
	__asm        jmp    _T8df;
_T8df:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _T958;
// LINE 3042:
	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T917;
// LINE 3044:
	__asm        or     intersection, 1;
// LINE 3046:
_T917:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T935;
// LINE 3048:
	__asm        or     intersection, 2;
// LINE 3050:
_T935:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T953;
// LINE 3052:
	__asm        or     intersection, 4;
// LINE 3055:
_T953:
	__asm        jmp    _T9fe;
_T958:
	__asm        jmp    _T95d;
_T95d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T9d6;
// LINE 3058:
	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T995;
// LINE 3060:
	__asm        or     intersection, 1;
// LINE 3062:
_T995:
	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T9b3;
// LINE 3064:
	__asm        or     intersection, 2;
// LINE 3066:
_T9b3:
	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::DoRailTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T9d1;
// LINE 3068:
	__asm        or     intersection, 4;
// LINE 3071:
_T9d1:
	__asm        jmp    _T9fe;
// LINE 3073:
_T9d6:
	_assert(0xc01, 0x5b79c8, 0x5b79ec);
	__asm        jmp    _T9f7;

	__asm        jmp    _T9f7;
// LINE 3075:
_T9f7:
	return 0x0;
// LINE 3086:
_T9fe:
	return intersection;
// LINE 3087:
}

// FUNCTION: COPTER_D 0x00531dff
int32_t TrainClass::DoRailTilesConnect(unsigned short fromTile, unsigned short toTile, enum DirectionTypes direction) {
// LINE 3118:
	__asm        mov    dword ptr [ebp-0xC], 0x5B7BB8;
_LOOP_13:
	for (;;) {
		_LOOP_13:
			__asm        mov    eax, [ebp-0xC];
			__asm        mov    ecx, reinterpret_cast<uint32_t>(fromTile);
			__asm        and    ecx, 0xFFFF;
			__asm        cmp    [eax], ecx;
			__asm        jne    _T35;

			__asm        mov    eax, [ebp-0xC];
			__asm        mov    eax, [eax+4];
			__asm        mov    [ebp-8], eax;
			__asm        jmp    _T69;
		_T35:
			__asm        mov    eax, [ebp-0xC];
			__asm        cmp    dword ptr [eax], 0;
			__asm        je     _T54;

			__asm        mov    eax, 0x5B7BB8;
			__asm        add    eax, 0x780;
			__asm        cmp    eax, [ebp-0xC];
			__asm        jae    _T60;
		_T54:
			__asm        mov    dword ptr [ebp-8], 0;
			__asm        jmp    _T69;
		_T60:
			__asm        add    dword ptr [ebp-0xC], 8;
			__asm        jmp    _LOOP_13;
	}
_T69:
	__asm        mov    dword ptr [ebp-0x10], 0x5B7BB8;
_LOOP_70:
	for (;;) {
		_LOOP_70:
			__asm        mov    eax, [ebp-0x10];
			__asm        mov    ecx, reinterpret_cast<uint32_t>(toTile);
			__asm        and    ecx, 0xFFFF;
			__asm        cmp    [eax], ecx;
			__asm        jne    _T92;

			__asm        mov    eax, [ebp-0x10];
			__asm        mov    eax, [eax+4];
			__asm        mov    [ebp-4], eax;
			__asm        jmp    _Tc6;
		_T92:
			__asm        mov    eax, [ebp-0x10];
			__asm        cmp    dword ptr [eax], 0;
			__asm        je     _Tb1;

			__asm        mov    eax, 0x5B7BB8;
			__asm        add    eax, 0x780;
			__asm        cmp    eax, [ebp-0x10];
			__asm        jae    _Tbd;
		_Tb1:
			__asm        mov    dword ptr [ebp-4], 0;
			__asm        jmp    _Tc6;
		_Tbd:
			__asm        add    dword ptr [ebp-0x10], 8;
			__asm        jmp    _LOOP_70;
	}
_Tc6:
	__asm        test   reinterpret_cast<uint8_t>(direction), 1;
	__asm        je     _Tf0;

	__asm        test   byte ptr [ebp-8], 1;
	__asm        je     _Tf0;

	__asm        test   byte ptr [ebp-4], 4;
	__asm        je     _Tf0;

	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        jmp    _T17a;
_Tf0:
	__asm        test   reinterpret_cast<uint8_t>(direction), 4;
	__asm        je     _T11a;

	__asm        test   byte ptr [ebp-8], 4;
	__asm        je     _T11a;

	__asm        test   byte ptr [ebp-4], 1;
	__asm        je     _T11a;

	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        jmp    _T17a;
_T11a:
	__asm        test   reinterpret_cast<uint8_t>(direction), 8;
	__asm        je     _T144;

	__asm        test   byte ptr [ebp-8], 8;
	__asm        je     _T144;

	__asm        test   byte ptr [ebp-4], 2;
	__asm        je     _T144;

	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        jmp    _T17a;
_T144:
	__asm        test   reinterpret_cast<uint8_t>(direction), 2;
	__asm        je     _T16e;

	__asm        test   byte ptr [ebp-8], 2;
	__asm        je     _T16e;

	__asm        test   byte ptr [ebp-4], 8;
	__asm        je     _T16e;

	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        jmp    _T17a;
_T16e:
	__asm        mov    dword ptr [ebp-0x14], 0;
	__asm        jmp    _T17a;
_T17a:
	__asm        mov    eax, [ebp-0x14];
	__asm        jmp    __RETURN;
// LINE 3119:
__RETURN:
}

// FUNCTION: COPTER_D 0x00531f88
void TrainClass::MakeATurn(enum TrainClass::IntersectionTypes intersectionType) {
// LINE 3139:
	__asm        mov    eax, intersectionType;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T181;
// LINE 3143:
_T17:
	this->TrainClass::MakeUturn();
// LINE 3145:
	__asm        jmp    _T1b5;
// LINE 3155:
_T24:
	this->TrainClass::GoStraight();
// LINE 3157:
	__asm        jmp    _T1b5;
// LINE 3161:
_T31:
	this->TrainClass::TurnLeft();
// LINE 3163:
	__asm        jmp    _T1b5;
// LINE 3167:
_T3e:
	this->TrainClass::TurnRight();
// LINE 3169:
	__asm        jmp    _T1b5;
// LINE 3173:
_T4b:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T68;
// LINE 3175:
	this->TrainClass::TurnLeft();
// LINE 3177:
	__asm        jmp    _T70;
// LINE 3179:
_T68:
	this->TrainClass::GoStraight();
// LINE 3182:
_T70:
	__asm        jmp    _T1b5;
// LINE 3186:
_T75:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T92;
// LINE 3188:
	this->TrainClass::TurnLeft();
// LINE 3190:
	__asm        jmp    _T9a;
// LINE 3192:
_T92:
	this->TrainClass::TurnRight();
// LINE 3195:
_T9a:
	__asm        jmp    _T1b5;
// LINE 3199:
_T9f:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _Tbc;
// LINE 3201:
	this->TrainClass::TurnRight();
// LINE 3203:
	__asm        jmp    _Tc4;
// LINE 3205:
_Tbc:
	this->TrainClass::GoStraight();
// LINE 3208:
_Tc4:
	__asm        jmp    _T1b5;
// LINE 3212:
_Tc9:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0xC], edx;
	__asm        jmp    _T133;
// LINE 3214:
_Te1:
	this->TrainClass::GoStraight();
	__asm        jmp    _T156;
// LINE 3215:
_Tee:
	this->TrainClass::TurnLeft();
	__asm        jmp    _T156;
// LINE 3216:
_Tfb:
	this->TrainClass::TurnRight();
	__asm        jmp    _T156;
// LINE 3217:
_T108:
	_assert(0xc91, 0x5b79f4, 0x5b7a18);
	__asm        jmp    _T129;

	__asm        jmp    _T129;
_T129:
	__asm        jmp    _T156;
// LINE 3218:
	__asm        jmp    _T156;
_T133:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Te1;

	__asm        cmp    dword ptr [ebp-0xC], 1;
	__asm        je     _Tee;

	__asm        cmp    dword ptr [ebp-0xC], 2;
	__asm        je     _Tfb;

	__asm        jmp    _T108;
// LINE 3220:
_T156:
	__asm        jmp    _T1b5;
// LINE 3226:
_T15b:
	_assert(0xc9a, 0x5b7a20, 0x5b7a44);
	__asm        jmp    _T17c;

	__asm        jmp    _T17c;
// LINE 3228:
_T17c:
	__asm        jmp    _T1b5;
_T181:
	__asm        cmp    dword ptr [ebp-8], 7;
	__asm        ja     _T15b;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    _Switch_195[0][eax*4];
// Switch pointers:
//   _T17
//   _T24
//   _T31
//   _T4b
//   _T3e
//   _T9f
//   _T75
//   _Tc9
// LINE 3229:
_T1b5:
	return;
}

// FUNCTION: COPTER_D 0x00532149
enum TrainClass::StoppedReasons TrainClass::WhyAmIStopped() {
// LINE 3252:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0;
	__asm        jl     _T46;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0;
	__asm        jl     _T46;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0x80;
	__asm        jge    _T46;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0x80;
	__asm        jl     _T51;
_T46:
	__asm        mov    word ptr [ebp-4], 0;
	__asm        jmp    _T95;
_T51:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x35];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x39];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x39];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-4], ax;
	__asm        jmp    _T95;
_T95:
	__asm        mov    eax, [ebp-4];
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _Tb9;

	__asm        jmp    _T146;

	__asm        jmp    _T13c;

	__asm        jmp    _T13c;

	__asm        jmp    _T132;
_Tb9:
	__asm        cmp    dword ptr [ebp-0x10], 0x48;
	__asm        jg     _Te6;

	__asm        cmp    dword ptr [ebp-0x10], 0x45;
	__asm        jge    _T146;

	__asm        cmp    dword ptr [ebp-0x10], 0x2C;
	__asm        jl     _T13c;

	__asm        cmp    dword ptr [ebp-0x10], 0x3E;
	__asm        jle    _T146;

	__asm        jmp    _T13c;
_Te6:
	__asm        cmp    dword ptr [ebp-0x10], 0x5B;
	__asm        jg     _T113;

	__asm        cmp    dword ptr [ebp-0x10], 0x5A;
	__asm        jge    _T146;

	__asm        cmp    dword ptr [ebp-0x10], 0x4D;
	__asm        jl     _T13c;

	__asm        cmp    dword ptr [ebp-0x10], 0x4E;
	__asm        jle    _T146;

	__asm        jmp    _T13c;
_T113:
	__asm        cmp    dword ptr [ebp-0x10], 0x805A;
	__asm        jl     _T13c;

	__asm        cmp    dword ptr [ebp-0x10], 0x805B;
	__asm        jle    _T146;

	__asm        jmp    _T13c;
_T132:
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T146;
// LINE 3256:
_T13c:
	return 0x4;
// LINE 3261:
_T146:
	return 0x3;
// LINE 3262:
}

// FUNCTION: COPTER_D 0x0053229e
void TrainClass::SetTrailingCars() {
// LINE 3284:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    ebx, [eax+0x18];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        add    eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x15];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    [eax+0x18], ebx;
// LINE 3286:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    ebx, [eax+0x1C];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        add    eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x19];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    [eax+0x1C], ebx;
// LINE 3288:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    ebx, [eax+0x20];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        add    eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    [eax+0x20], ebx;
// LINE 3291:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    ebx, [eax+0x18];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1D5];
	__asm        add    eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x15];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    [eax+0x18], ebx;
// LINE 3293:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    ebx, [eax+0x1C];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1D5];
	__asm        add    eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x19];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    [eax+0x1C], ebx;
// LINE 3296:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    ebx, [eax+0x20];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1D5];
	__asm        add    eax, [ecx+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    [eax+0x20], ebx;
// LINE 3299:
	this->currentLocation2.x = ((this->midcar->loc.x + 0x20000000) >> 0x16);
// LINE 3300:
	this->currentLocation2.y = ((0x20000000 - this->midcar->loc.z) >> 0x16);
// LINE 3301:
	this->currentLocation3.x = ((this->endcar->loc.x + 0x20000000) >> 0x16);
// LINE 3302:
	this->currentLocation3.y = ((0x20000000 - this->endcar->loc.z) >> 0x16);
// LINE 3304:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3D;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 3305:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x45;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 3308:
	__asm        mov    eax, this;
	__asm        mov    esi, [eax+0x1CD];
	__asm        mov    eax, this;
	__asm        mov    edi, [eax+0x1D1];
	__asm        add    edi, 0x24;
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 3309:
	__asm        mov    eax, this;
	__asm        mov    esi, [eax+0x1CD];
	__asm        mov    eax, this;
	__asm        mov    edi, [eax+0x1D5];
	__asm        add    edi, 0x24;
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 3310:
	return;
}

// FUNCTION: COPTER_D 0x00532518
void TrainClass::AdjustTrailingCars() {
	/*bp-0xc*/   /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x14*/  /*packed*/ struct Point2d currloc; // 0x8 bytes
	/*bp-0x20*/  /*packed*/ struct Point3d loc; // 0xc bytes

// LINE 3334:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    ebx, [eax+0x18];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x15];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    loc.x, ebx;
// LINE 3335:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    ebx, [eax+0x1C];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x19];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    loc.y, ebx;
// LINE 3336:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    ebx, [eax+0x20];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    loc.z, ebx;
// LINE 3339:
	vec.x = (loc.x - this->midcar->loc.x);
// LINE 3340:
	vec.y = (loc.y - this->midcar->loc.y);
// LINE 3341:
	vec.z = (loc.z - this->midcar->loc.z);
// LINE 3344:
	MTNormalize(vec.x);
// LINE 3347:
	__asm        mov    ebx, loc.x;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.x;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    [eax+0x18], ebx;
// LINE 3348:
	__asm        mov    ebx, loc.y;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.y;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    [eax+0x1C], ebx;
// LINE 3349:
	__asm        mov    ebx, loc.z;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.z;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    [eax+0x20], ebx;
// LINE 3352:
	MTCreateDOF4x4(vec.x, (this->midcar + 0x24));
// LINE 3357:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    ebx, [eax+0x18];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.x;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    loc.x, ebx;
// LINE 3358:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    ebx, [eax+0x1C];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.y;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    loc.y, ebx;
// LINE 3359:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    ebx, [eax+0x20];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.z;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    loc.z, ebx;
// LINE 3362:
	vec.x = (loc.x - this->endcar->loc.x);
// LINE 3363:
	vec.y = (loc.y - this->endcar->loc.y);
// LINE 3364:
	vec.z = (loc.z - this->endcar->loc.z);
// LINE 3367:
	MTNormalize(vec.x);
// LINE 3370:
	__asm        mov    ebx, loc.x;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.x;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    [eax+0x18], ebx;
// LINE 3371:
	__asm        mov    ebx, loc.y;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.y;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    [eax+0x1C], ebx;
// LINE 3372:
	__asm        mov    ebx, loc.z;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, vec.z;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        mov    [eax+0x20], ebx;
// LINE 3375:
	currloc.x = ((this->midcar->loc.x + 0x20000000) >> 0x16);
// LINE 3376:
	currloc.y = ((0x20000000 - this->midcar->loc.z) >> 0x16);
// LINE 3377:
	__asm        mov    eax, this;
	__asm        mov    ecx, currloc.x;
	__asm        cmp    [eax+0x3D], ecx;
	__asm        jne    _T2f6;

	__asm        mov    eax, this;
	__asm        mov    ecx, currloc.y;
	__asm        cmp    [eax+0x41], ecx;
	__asm        je     _T339;
// LINE 3379:
_T2f6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3D;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 3380:
	__asm        mov    eax, currloc.x;
	__asm        mov    ecx, currloc.y;
	__asm        mov    edx, this;
	__asm        add    edx, 0x3D;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 3381:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3D;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 3384:
_T339:
	currloc.x = ((this->endcar->loc.x + 0x20000000) >> 0x16);
// LINE 3385:
	currloc.y = ((0x20000000 - this->endcar->loc.z) >> 0x16);
// LINE 3386:
	__asm        mov    eax, this;
	__asm        mov    ecx, currloc.x;
	__asm        cmp    [eax+0x45], ecx;
	__asm        jne    _T385;

	__asm        mov    eax, this;
	__asm        mov    ecx, currloc.y;
	__asm        cmp    [eax+0x49], ecx;
	__asm        je     _T3c8;
// LINE 3388:
_T385:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x45;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 3389:
	__asm        mov    eax, currloc.x;
	__asm        mov    ecx, currloc.y;
	__asm        mov    edx, this;
	__asm        add    edx, 0x45;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 3390:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x45;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 3394:
_T3c8:
	MTCreateDOF4x4(vec.x, (this->endcar + 0x24));
// LINE 3395:
	return;
}

// FUNCTION: COPTER_D 0x00532903
void TrainClass::AdjustCurrentPosition() {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 3416:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x39];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T56;

	_assert(0xd0, 0x5b780c, 0x5b57b8);
	__asm        jmp    _T5b;
_T56:
	__asm        jmp    _T5b;
_T5b:
	__asm        jmp    _T60;
_T60:
	__asm        mov    eax, [ebp-8];
	__asm        mov    cellPointer, eax;
// LINE 3418:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T8c;

	_assert(0xd5a, 0x5b7a4c, 0x5b7a70);
	__asm        jmp    _T91;
_T8c:
	__asm        jmp    _T91;
// LINE 3422:
_T91:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        mov    [ecx+0x18], eax;
// LINE 3423:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        mov    [ecx+0x1C], eax;
// LINE 3424:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CD];
	__asm        mov    [ecx+0x20], eax;
// LINE 3428:
	__asm        jmp    _Td8;
_Td8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T107;
// LINE 3431:
	this->leadcar->loc.z -= 0x1e0000;
// LINE 3433:
	__asm        jmp    _T19e;
_T107:
	__asm        jmp    _T10c;
_T10c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T13b;
// LINE 3436:
	this->leadcar->loc.z += 0x1e0000;
// LINE 3438:
	__asm        jmp    _T19e;
_T13b:
	__asm        jmp    _T140;
_T140:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _T16f;
// LINE 3440:
	this->leadcar->loc.x -= 0x1e0000;
// LINE 3443:
	__asm        jmp    _T19e;
_T16f:
	__asm        jmp    _T174;
_T174:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _T19e;
// LINE 3445:
	this->leadcar->loc.x += 0x1e0000;
// LINE 3449:
_T19e:
	return;
}

// FUNCTION: COPTER_D 0x00532aab
void TrainClass::AdjustNextPosition() {
	/*bp-0x4*/   int32_t ydiff;
	/*bp-0x8*/   int32_t xdiff;
	/*bp-0x14*/  /*packed*/ struct Point3d nextFineLocation; // 0xc bytes
	/*bp-0x18*/  unsigned short ntile;
	/*bp-0x1c*/  unsigned short tile;
	/*bp-0x20*/  /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 3470:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x59];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x55];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x28], eax;
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        jne    _T56;

	_assert(0xd0, 0x5b780c, 0x5b57b8);
	__asm        jmp    _T5b;
_T56:
	__asm        jmp    _T5b;
_T5b:
	__asm        jmp    _T60;
_T60:
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    cellPointer, eax;
// LINE 3473:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0;
	__asm        jl     _Ta0;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0;
	__asm        jl     _Ta0;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0x80;
	__asm        jge    _Ta0;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0x80;
	__asm        jl     _Tab;
_Ta0:
	tile = 0x0;
	__asm        jmp    _Tef;
_Tab:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x35];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x39];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x39];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    tile, ax;
	__asm        jmp    _Tef;
// LINE 3474:
_Tef:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x55], 0;
	__asm        jl     _T129;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x59], 0;
	__asm        jl     _T129;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x55], 0x80;
	__asm        jge    _T129;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x59], 0x80;
	__asm        jl     _T134;
_T129:
	ntile = 0x0;
	__asm        jmp    _T178;
_T134:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x55];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x59];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x55];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x59];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    ntile, ax;
	__asm        jmp    _T178;
// LINE 3476:
_T178:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T19e;

	_assert(0xd94, 0x5b7a7c, 0x5b7aa0);
	__asm        jmp    _T1a3;
_T19e:
	__asm        jmp    _T1a3;
// LINE 3478:
_T1a3:
	__asm        cmp    cellPointer, 0;
	__asm        je     _T5ef;
// LINE 3481:
// Block start:
	/*bp-0x24*/  enum DirectionTypes connectionType;
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    nextFineLocation.x, eax;
// LINE 3482:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    nextFineLocation.y, eax;
// LINE 3483:
	__asm        mov    eax, cellPointer;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    nextFineLocation.z, eax;
// LINE 3490:
	xdiff = (this->nextLocation.x - this->currentLocation1.x);
// LINE 3491:
	ydiff = (this->nextLocation.y - this->currentLocation1.y);
// LINE 3493:
	__asm        cmp    xdiff, 0;
	__asm        jge    _T27d;

	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jle    _T27d;
// LINE 3496:
	nextFineLocation.x += 0x1e0000;
// LINE 3498:
	this->direction = 0x8;
// LINE 3501:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T25f;
// LINE 3504:
_T237:
	this->direction = 0xc;
// LINE 3506:
	__asm        jmp    _T278;
// LINE 3508:
_T246:
	this->direction = 0x9;
// LINE 3509:
	__asm        jmp    _T278;
// LINE 3511:
	__asm        jmp    _T278;
// LINE 3512:
	__asm        jmp    _T278;
_T25f:
	__asm        cmp    dword ptr [ebp-0x34], 0x34;
	__asm        je     _T246;

	__asm        cmp    dword ptr [ebp-0x34], 0x35;
	__asm        je     _T237;

	__asm        jmp    _T278;
// LINE 3514:
_T278:
	__asm        jmp    _T41e;
_T27d:
	__asm        cmp    xdiff, 0;
	__asm        jle    _T308;

	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jle    _T308;
// LINE 3517:
	nextFineLocation.x -= 0x1e0000;
// LINE 3519:
	this->direction = 0x2;
// LINE 3521:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    _T2ea;
// LINE 3524:
_T2c2:
	this->direction = 0x6;
// LINE 3525:
	__asm        jmp    _T303;
// LINE 3527:
_T2d1:
	this->direction = 0x3;
// LINE 3528:
	__asm        jmp    _T303;
// LINE 3530:
	__asm        jmp    _T303;
// LINE 3531:
	__asm        jmp    _T303;
_T2ea:
	__asm        cmp    dword ptr [ebp-0x38], 0x32;
	__asm        je     _T2c2;

	__asm        cmp    dword ptr [ebp-0x38], 0x33;
	__asm        je     _T2d1;

	__asm        jmp    _T303;
// LINE 3533:
_T303:
	__asm        jmp    _T41e;
_T308:
	__asm        cmp    ydiff, 0;
	__asm        jle    _T393;

	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jle    _T393;
// LINE 3536:
	nextFineLocation.z += 0x1e0000;
// LINE 3538:
	this->direction = 0x4;
// LINE 3540:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    _T375;
// LINE 3543:
_T34d:
	this->direction = 0xc;
// LINE 3544:
	__asm        jmp    _T38e;
// LINE 3546:
_T35c:
	this->direction = 0x6;
// LINE 3547:
	__asm        jmp    _T38e;
// LINE 3549:
	__asm        jmp    _T38e;
// LINE 3550:
	__asm        jmp    _T38e;
_T375:
	__asm        cmp    dword ptr [ebp-0x3C], 0x33;
	__asm        je     _T34d;

	__asm        cmp    dword ptr [ebp-0x3C], 0x34;
	__asm        je     _T35c;

	__asm        jmp    _T38e;
// LINE 3552:
_T38e:
	__asm        jmp    _T41e;
_T393:
	__asm        cmp    ydiff, 0;
	__asm        jge    _T41e;

	__asm        mov    eax, ydiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ecx, eax;
	__asm        mov    eax, xdiff;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        cmp    ecx, eax;
	__asm        jle    _T41e;
// LINE 3555:
	nextFineLocation.z -= 0x1e0000;
// LINE 3557:
	this->direction = 0x1;
// LINE 3560:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x40], eax;
	__asm        jmp    _T400;
// LINE 3563:
_T3d8:
	this->direction = 0x9;
// LINE 3564:
	__asm        jmp    _T419;
// LINE 3566:
_T3e7:
	this->direction = 0x3;
// LINE 3567:
	__asm        jmp    _T419;
// LINE 3569:
	__asm        jmp    _T419;
// LINE 3570:
	__asm        jmp    _T419;
_T400:
	__asm        cmp    dword ptr [ebp-0x40], 0x32;
	__asm        je     _T3d8;

	__asm        cmp    dword ptr [ebp-0x40], 0x35;
	__asm        je     _T3e7;

	__asm        jmp    _T419;
// LINE 3572:
_T419:
	__asm        jmp    _T41e;
// LINE 3579:
_T41e:
	__asm        mov    dword ptr [ebp-0x2C], 0x5B7BB8;
_LOOP_425:
	for (;;) {
		_LOOP_425:
			__asm        mov    eax, [ebp-0x2C];
			__asm        mov    ecx, reinterpret_cast<uint32_t>(ntile);
			__asm        and    ecx, 0xFFFF;
			__asm        cmp    [eax], ecx;
			__asm        jne    _T447;

			__asm        mov    eax, [ebp-0x2C];
			__asm        mov    eax, [eax+4];
			__asm        mov    connectionType, eax;
			__asm        jmp    _T47b;
		_T447:
			__asm        mov    eax, [ebp-0x2C];
			__asm        cmp    dword ptr [eax], 0;
			__asm        je     _T466;

			__asm        mov    eax, 0x5B7BB8;
			__asm        add    eax, 0x780;
			__asm        cmp    eax, [ebp-0x2C];
			__asm        jae    _T472;
		_T466:
			connectionType = 0x0;
			__asm        jmp    _T47b;
		_T472:
			__asm        add    dword ptr [ebp-0x2C], 8;
			__asm        jmp    _LOOP_425;
	}
// LINE 3581:
_T47b:
	__asm        cmp    connectionType, 0;
	__asm        je     _T56a;
// LINE 3583:
	__asm        mov    eax, reinterpret_cast<uint32_t>(ntile);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x44], eax;
	__asm        jmp    _T50f;
// LINE 3586:
_T495:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x11], 1;
	__asm        je     _T4a9;
// LINE 3587:
	nextFineLocation.y += 0x1f0000;
// LINE 3588:
_T4a9:
	__asm        jmp    _T56a;
// LINE 3590:
_T4ae:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x11], 4;
	__asm        je     _T4c2;
// LINE 3591:
	nextFineLocation.y += 0x1f0000;
// LINE 3592:
_T4c2:
	__asm        jmp    _T56a;
// LINE 3594:
_T4c7:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x11], 2;
	__asm        je     _T4db;
// LINE 3595:
	nextFineLocation.y += 0x1f0000;
// LINE 3596:
_T4db:
	__asm        jmp    _T56a;
// LINE 3598:
_T4e0:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0x11], 8;
	__asm        je     _T4f4;
// LINE 3599:
	nextFineLocation.y += 0x1f0000;
// LINE 3600:
_T4f4:
	__asm        jmp    _T56a;
// LINE 3605:
_T4f9:
	nextFineLocation.y += 0x1f0000;
// LINE 3606:
	__asm        jmp    _T56a;
// LINE 3608:
	__asm        jmp    _T56a;
// LINE 3609:
	__asm        jmp    _T56a;
_T50f:
	__asm        cmp    dword ptr [ebp-0x44], 0x5B;
	__asm        jg     _T54b;

	__asm        cmp    dword ptr [ebp-0x44], 0x5A;
	__asm        jge    _T4f9;

	__asm        sub    dword ptr [ebp-0x44], 0x2E;
	__asm        cmp    dword ptr [ebp-0x44], 3;
	__asm        ja     _T56a;

	__asm        mov    eax, [ebp-0x44];
	__asm        jmp    _Switch_53b[0][eax*4];
// Switch pointers:
//   _T4c7
//   _T4ae
//   _T4e0
//   _T495
_T54b:
	__asm        cmp    dword ptr [ebp-0x44], 0x805A;
	__asm        jl     _T56a;

	__asm        cmp    dword ptr [ebp-0x44], 0x805B;
	__asm        jle    _T4f9;

	__asm        jmp    _T56a;
// LINE 3624:
_T56a:
	this->directionVector.x = (nextFineLocation.x - this->leadcar->loc.x);
// LINE 3625:
	this->directionVector.y = (nextFineLocation.y - this->leadcar->loc.y);
// LINE 3626:
	this->directionVector.z = (nextFineLocation.z - this->leadcar->loc.z);
// LINE 3627:
	this->remainingDist = MTNormalize((this + 0x15));
// LINE 3632:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 1;
	__asm        je     _T5ef;
// LINE 3634:
	MTCreateDOF4x4((this + 0x15), (this->leadcar + 0x24));
// LINE 3637:
// Block end:
_T5ef:
	return;
}

// FUNCTION: COPTER_D 0x005330a4
void TrainClass::GoStraight() {
// LINE 3659:
	this->flags[2] = 0x0;
// LINE 3663:
	__asm        jmp    _T18;
_T18:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T4d;
// LINE 3666:
	__asm        mov    eax, this;
	__asm        add    eax, 0x75;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3668:
	__asm        jmp    _T120;
_T4d:
	__asm        jmp    _T52;
_T52:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T87;
// LINE 3671:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7D;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3673:
	__asm        jmp    _T120;
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _Tc3;
// LINE 3676:
	__asm        mov    eax, this;
	__asm        add    eax, 0x85;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3678:
	__asm        jmp    _T120;
_Tc3:
	__asm        jmp    _Tc8;
_Tc8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _Tff;
// LINE 3681:
	__asm        mov    eax, this;
	__asm        add    eax, 0x8D;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3683:
	__asm        jmp    _T120;
// LINE 3685:
_Tff:
	_assert(0xe65, 0x5b7aac, 0x5b7ad0);
	__asm        jmp    _T120;

	__asm        jmp    _T120;
// LINE 3687:
_T120:
	return;
}

// FUNCTION: COPTER_D 0x005331ce
void TrainClass::TurnLeft() {
// LINE 3709:
	this->flags[2] = 0x1;
// LINE 3713:
	__asm        jmp    _T18;
_T18:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T4f;
// LINE 3716:
	__asm        mov    eax, this;
	__asm        add    eax, 0x8D;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3718:
	__asm        jmp    _T120;
_T4f:
	__asm        jmp    _T54;
_T54:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T8b;
// LINE 3721:
	__asm        mov    eax, this;
	__asm        add    eax, 0x85;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3723:
	__asm        jmp    _T120;
_T8b:
	__asm        jmp    _T90;
_T90:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _Tc5;
// LINE 3726:
	__asm        mov    eax, this;
	__asm        add    eax, 0x75;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3728:
	__asm        jmp    _T120;
_Tc5:
	__asm        jmp    _Tca;
_Tca:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _Tff;
// LINE 3731:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7D;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3733:
	__asm        jmp    _T120;
// LINE 3735:
_Tff:
	_assert(0xe97, 0x5b7ad8, 0x5b7afc);
	__asm        jmp    _T120;

	__asm        jmp    _T120;
// LINE 3738:
_T120:
	return;
}

// FUNCTION: COPTER_D 0x005332f8
void TrainClass::TurnRight() {
// LINE 3760:
	this->flags[2] = 0x1;
// LINE 3764:
	__asm        jmp    _T18;
_T18:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x11;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T4f;
// LINE 3767:
	__asm        mov    eax, this;
	__asm        add    eax, 0x85;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3770:
	__asm        jmp    _T120;
_T4f:
	__asm        jmp    _T54;
_T54:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x14;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _T8b;
// LINE 3773:
	__asm        mov    eax, this;
	__asm        add    eax, 0x8D;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3776:
	__asm        jmp    _T120;
_T8b:
	__asm        jmp    _T90;
_T90:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 0x12;
	__asm        or     eax, ecx;
	__asm        je     _Tc5;
// LINE 3779:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7D;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3782:
	__asm        jmp    _T120;
_Tc5:
	__asm        jmp    _Tca;
_Tca:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11];
	__asm        and    eax, 0x18;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x11];
	__asm        and    ecx, 8;
	__asm        or     eax, ecx;
	__asm        je     _Tff;
// LINE 3785:
	__asm        mov    eax, this;
	__asm        add    eax, 0x75;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x55;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3788:
	__asm        jmp    _T120;
// LINE 3790:
_Tff:
	_assert(0xece, 0x5b7b04, 0x5b7b28);
	__asm        jmp    _T120;

	__asm        jmp    _T120;
// LINE 3793:
_T120:
	return;
}

// FUNCTION: COPTER_D 0x00533422
void TrainClass::BeamToWithinCameraRange() {
	/*bp-0x4*/   int32_t xdir;
	/*bp-0x8*/   int32_t ydir;
	/*bp-0xc*/   int32_t curr_dist;
	/*bp-0x10*/  int32_t spiral_dist;
	/*bp-0x1c*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x24*/  /*packed*/ struct Point2d beampoint; // 0x8 bytes
	/*bp-0x28*/  int32_t x;
	/*bp-0x2c*/  int32_t y;
	/*bp-0x30*/  int32_t i;
	/*bp-0x34*/  int32_t curr_dir;
	/*bp-0x38*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x3c*/  int32_t stop_now;
	/*bp-0x40*/  int32_t foundcell;

// LINE 3815:
	curr_dist = 0x0;
// LINE 3816:
	curr_dir = 0xffffffff;
// LINE 3818:
	stop_now = 0x0;
// LINE 3819:
	spiral_dist = 0x7;
// LINE 3821:
	foundcell = 0x0;
// LINE 3825:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x14;
	__asm        lea    ecx, vec.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 3828:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0xF;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-0x58], eax;
	__asm        jmp    _T143;
// LINE 3832:
_T66:
	vec.y = vec.z;
// LINE 3833:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 3834:
	vec.x = vec.y;
// LINE 3836:
	vec.x = (vec.x * (G_ViewSize >> 0x1));
// LINE 3837:
	vec.z = (vec.z * (G_ViewSize >> 0x1));
// LINE 3838:
	__asm        jmp    _T166;
// LINE 3841:
_Ta3:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    vec.y, eax;
// LINE 3842:
	vec.z = vec.x;
// LINE 3843:
	vec.x = vec.y;
// LINE 3845:
	vec.x = (vec.x * (G_ViewSize >> 0x1));
// LINE 3846:
	vec.z = (vec.z * (G_ViewSize >> 0x1));
// LINE 3847:
	__asm        jmp    _T166;
// LINE 3850:
_Te0:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    vec.x, eax;
// LINE 3851:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 3853:
	vec.x = (vec.x * (G_ViewSize >> 0x1));
// LINE 3854:
	vec.z = (vec.z * (G_ViewSize >> 0x1));
// LINE 3855:
	__asm        jmp    _T166;
// LINE 3859:
_T119:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        inc    eax;
	__asm        imul   eax, vec.x;
	__asm        mov    vec.x, eax;
// LINE 3860:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        inc    eax;
	__asm        imul   eax, vec.z;
	__asm        mov    vec.z, eax;
// LINE 3861:
	__asm        jmp    _T166;
// LINE 3862:
	__asm        jmp    _T166;
_T143:
	__asm        cmp    dword ptr [ebp-0x58], 0;
	__asm        je     _T66;

	__asm        cmp    dword ptr [ebp-0x58], 1;
	__asm        je     _Ta3;

	__asm        cmp    dword ptr [ebp-0x58], 2;
	__asm        je     _Te0;

	__asm        jmp    _T119;
// LINE 3864:
_T166:
	__asm        shl    vec.x, 6;
// LINE 3865:
	__asm        shl    vec.z, 6;
// LINE 3867:
	x = (((ViewState.world_pos.x + vec.x) + 0x20000000) >> 0x16);
// LINE 3868:
	y = ((0x20000000 - (ViewState.world_pos.z + vec.z)) >> 0x16);
// LINE 3875:
_LOOP_197:
	for (;;) {
		// LINE 3875:
		_LOOP_197:
			curr_dir++;
		// LINE 3876:
			__asm        mov    eax, curr_dir;
			__asm        mov    [ebp-0x5C], eax;
			__asm        jmp    _T203;
		// LINE 3880:
		_T1a5:
			curr_dir = 0x0;
		// LINE 3881:
			curr_dist++;
		// LINE 3882:
			xdir = 0x0;
		// LINE 3883:
			ydir = 0xffffffff;
		// LINE 3884:
			__asm        jmp    _T22b;
		// LINE 3886:
		_T1c2:
			xdir = 0x1;
		// LINE 3887:
			ydir = 0x0;
		// LINE 3888:
			__asm        jmp    _T22b;
		// LINE 3890:
		_T1d5:
			curr_dist++;
		// LINE 3891:
			xdir = 0x0;
		// LINE 3892:
			ydir = 0x1;
		// LINE 3893:
			__asm        jmp    _T22b;
		// LINE 3895:
		_T1eb:
			xdir = 0xffffffff;
		// LINE 3896:
			ydir = 0x0;
		// LINE 3897:
			__asm        jmp    _T22b;
		// LINE 3898:
			__asm        jmp    _T22b;
		_T203:
			__asm        cmp    dword ptr [ebp-0x5C], 4;
			__asm        ja     _T22b;

			__asm        mov    eax, [ebp-0x5C];
			__asm        jmp    _Switch_217[0][eax*4];
		// Switch pointers:
		//   _T1a5
		//   _T1c2
		//   _T1d5
		//   _T1eb
		//   _T1a5
		// LINE 3902:
		_T22b:
			__asm        mov    eax, curr_dist;
			__asm        cmp    spiral_dist, eax;
			__asm        jne    _FOR_24d;
		// LINE 3904:
			curr_dist--;
		// LINE 3905:
			stop_now = 0x1;
		// LINE 3909:
		_FOR_24d:
			for (i = 0x0; (curr_dist > i); i++) {
				// LINE 3911:
				// Block start:
					/*bp-0x44*/  unsigned short tile;
					__asm        cmp    x, 0;
					__asm        jl     _T28a;

					__asm        cmp    y, 0;
					__asm        jl     _T28a;

					__asm        cmp    x, 0x80;
					__asm        jge    _T28a;

					__asm        cmp    y, 0x80;
					__asm        jl     _T295;
				_T28a:
					tile = 0x0;
					__asm        jmp    _T2cd;
				_T295:
					__asm        mov    eax, x;
					__asm        mov    eax, BitsMap[eax*4];
					__asm        mov    ecx, y;
					__asm        xor    edx, edx;
					__asm        mov    dl, [eax+ecx];
					__asm        and    edx, 2;
					__asm        movsx  eax, dx;
					__asm        shl    eax, 0xE;
					__asm        mov    ecx, x;
					__asm        mov    ecx, BuildMap[ecx*4];
					__asm        mov    edx, y;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ecx+edx];
					__asm        or     eax, ebx;
					__asm        mov    tile, ax;
					__asm        jmp    _T2cd;
				// LINE 3913:
				_T2cd:
					__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
					__asm        and    eax, 0xFFFF;
					__asm        mov    [ebp-0x60], eax;
					__asm        jmp    _T2f1;

					__asm        jmp    _T38d;

					__asm        jmp    _T401;

					__asm        jmp    _T38d;

					__asm        jmp    _T383;
				_T2f1:
					__asm        cmp    dword ptr [ebp-0x60], 0x3A;
					__asm        jg     _T31e;

					__asm        cmp    dword ptr [ebp-0x60], 0x32;
					__asm        jge    _T38d;

					__asm        cmp    dword ptr [ebp-0x60], 0x2C;
					__asm        jl     _T401;

					__asm        cmp    dword ptr [ebp-0x60], 0x2D;
					__asm        jle    _T38d;

					__asm        jmp    _T401;
				_T31e:
					__asm        cmp    dword ptr [ebp-0x60], 0x4E;
					__asm        jg     _T34b;

					__asm        cmp    dword ptr [ebp-0x60], 0x4D;
					__asm        jge    _T38d;

					__asm        cmp    dword ptr [ebp-0x60], 0x45;
					__asm        jl     _T401;

					__asm        cmp    dword ptr [ebp-0x60], 0x48;
					__asm        jle    _T38d;

					__asm        jmp    _T401;
				_T34b:
					__asm        cmp    dword ptr [ebp-0x60], 0x805B;
					__asm        jg     _T401;

					__asm        cmp    dword ptr [ebp-0x60], 0x805A;
					__asm        jge    _T38d;

					__asm        cmp    dword ptr [ebp-0x60], 0x5A;
					__asm        jl     _T401;

					__asm        cmp    dword ptr [ebp-0x60], 0x5B;
					__asm        jle    _T38d;

					__asm        jmp    _T401;

					__asm        jmp    _T401;
				_T383:
					__asm        cmp    dword ptr [ebp-0x4C], 0;
					__asm        je     _T401;
				// LINE 3915:
				_T38d:
					beampoint.x = x;
				// LINE 3916:
					beampoint.y = y;
				// LINE 3917:
					__asm        mov    eax, beampoint.y;
					__asm        and    eax, 0xFF;
					__asm        mov    ecx, beampoint.x;
					__asm        and    ecx, 0xFF;
					__asm        shl    ecx, 0xA;
					__asm        mov    eax, G_omap[0][0][ecx+eax*4];
					__asm        mov    [ebp-0x48], eax;
					__asm        cmp    dword ptr [ebp-0x48], 0;
					__asm        jne    _T3dd;

					_assert(0xd0, 0x5b780c, 0x5b57b8);
					__asm        jmp    _T3e2;
				_T3dd:
					__asm        jmp    _T3e2;
				_T3e2:
					__asm        jmp    _T3e7;
				_T3e7:
					__asm        mov    eax, [ebp-0x48];
					__asm        mov    cptr, eax;
				// LINE 3918:
					__asm        mov    eax, cptr;
					__asm        cmp    dword ptr [eax+0x10], 0;
					__asm        jne    _T401;
				// LINE 3920:
					foundcell = 0x1;
				// LINE 3923:
				_T401:
					__asm        cmp    foundcell, 0;
					__asm        je     _T415;

					__asm        jmp    _T584;

					__asm        jmp    foundCell;
				// LINE 3924:
				_T415:
					x += xdir;
				// LINE 3925:
					y += ydir;
			}
		// LINE 3928:
		_T426:
			__asm        cmp    stop_now, 1;
			__asm        jne    _T435;
		// LINE 3930:
			__asm        jmp    _T43a;
		// LINE 3932:
		_T435:
			__asm        jmp    _LOOP_197;
	}
// LINE 3935:
_T43a:
	return;
// LINE 3941:
foundCell:
	this->stalledTimer = 0x0;
// LINE 3942:
	this->direction = 0x0;
// LINE 3943:
	this->speed = 0x0;
// LINE 3944:
	this->flags[1] = 0x1;
// LINE 3945:
	this->flags[2] = 0x0;
// LINE 3946:
	this->flags[3] = 0x0;
// LINE 3947:
	this->flags[4] = 0x0;
// LINE 3948:
	this->flags[5] = 0x0;
// LINE 3949:
	this->flags[7] = 0x0;
// LINE 3950:
	this->flags[8] = 0x0;
// LINE 3955:
	this->currentLocation1.x = beampoint.x;
	this->currentLocation1.y = beampoint.y;
	__asm        jmp    _T4a5;
// LINE 3959:
_T4a5:
	__asm        jmp    _T4aa;
_T4aa:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 3963:
	__asm        jmp    _T4c8;
_T4c8:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0;
	__asm        jl     _T502;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0;
	__asm        jl     _T502;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0x80;
	__asm        jge    _T502;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0x80;
	__asm        jl     _T50d;
_T502:
	__asm        mov    word ptr [ebp-0x50], 0;
	__asm        jmp    _T551;
_T50d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x35];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x39];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x39];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-0x50], ax;
	__asm        jmp    _T551;
_T551:
	__asm        mov    eax, [ebp-0x50];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::SetTrainDirection;
// LINE 3964:
	this->TrainClass::AdjustCurrentPosition();
// LINE 3965:
	this->TrainClass::AdjustNextPosition();
// LINE 3966:
	this->TrainClass::SetTrailingCars();
// LINE 3967:
	this->beamTimer = 0x0;
// LINE 3969:
	return;
_T584:
	__asm        jmp    foundCell;
}

// FUNCTION: COPTER_D 0x005339b0
void TrainClass::UnPlaceTrain() {
// LINE 3992:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T81;
// LINE 3994:
	__asm        jmp    _T25;
_T25:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 3995:
	__asm        jmp    _T43;
_T43:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D1];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x3D;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 3996:
	__asm        jmp    _T61;
_T61:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D5];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x45;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::UnlinkFromCell;
// LINE 3997:
	this->flags[1] = 0x0;
// LINE 3999:
_T81:
	return;
}

// FUNCTION: COPTER_D 0x00533a3b
int32_t TrainClass::BeamToLocation(long mapx, long mapy) {
	/*bp-0x4*/   int32_t xdir;
	/*bp-0x8*/   int32_t ydir;
	/*bp-0xc*/   int32_t curr_dist;
	/*bp-0x10*/  int32_t spiral_dist;
	/*bp-0x18*/  /*packed*/ struct Point2d beampoint; // 0x8 bytes
	/*bp-0x1c*/  int32_t x;
	/*bp-0x20*/  int32_t y;
	/*bp-0x24*/  int32_t i;
	/*bp-0x28*/  int32_t curr_dir;
	/*bp-0x2c*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x30*/  int32_t stop_now;
	/*bp-0x34*/  int32_t foundcell;

// LINE 4021:
	curr_dist = 0x0;
// LINE 4022:
	curr_dir = 0xffffffff;
// LINE 4024:
	stop_now = 0x0;
// LINE 4025:
	spiral_dist = 0x15;
// LINE 4027:
	foundcell = 0x0;
// LINE 4031:
	x = mapx;
// LINE 4032:
	y = mapy;
// LINE 4039:
_LOOP_3b:
	for (;;) {
		// LINE 4039:
		_LOOP_3b:
			curr_dir++;
		// LINE 4040:
			__asm        mov    eax, curr_dir;
			__asm        mov    [ebp-0x4C], eax;
			__asm        jmp    _Ta7;
		// LINE 4044:
		_T49:
			curr_dir = 0x0;
		// LINE 4045:
			curr_dist++;
		// LINE 4046:
			xdir = 0x0;
		// LINE 4047:
			ydir = 0xffffffff;
		// LINE 4048:
			__asm        jmp    _Tcf;
		// LINE 4050:
		_T66:
			xdir = 0x1;
		// LINE 4051:
			ydir = 0x0;
		// LINE 4052:
			__asm        jmp    _Tcf;
		// LINE 4054:
		_T79:
			curr_dist++;
		// LINE 4055:
			xdir = 0x0;
		// LINE 4056:
			ydir = 0x1;
		// LINE 4057:
			__asm        jmp    _Tcf;
		// LINE 4059:
		_T8f:
			xdir = 0xffffffff;
		// LINE 4060:
			ydir = 0x0;
		// LINE 4061:
			__asm        jmp    _Tcf;
		// LINE 4062:
			__asm        jmp    _Tcf;
		_Ta7:
			__asm        cmp    dword ptr [ebp-0x4C], 4;
			__asm        ja     _Tcf;

			__asm        mov    eax, [ebp-0x4C];
			__asm        jmp    _Switch_bb[0][eax*4];
		// Switch pointers:
		//   _T49
		//   _T66
		//   _T79
		//   _T8f
		//   _T49
		// LINE 4066:
		_Tcf:
			__asm        mov    eax, spiral_dist;
			__asm        cmp    curr_dist, eax;
			__asm        jne    _FOR_f1;
		// LINE 4068:
			curr_dist--;
		// LINE 4069:
			stop_now = 0x1;
		// LINE 4073:
		_FOR_f1:
			for (i = 0x0; (curr_dist > i); i++) {
				// LINE 4075:
				// Block start:
					/*bp-0x38*/  unsigned short tile;
					__asm        cmp    x, 0;
					__asm        jl     _T12e;

					__asm        cmp    y, 0;
					__asm        jl     _T12e;

					__asm        cmp    x, 0x80;
					__asm        jge    _T12e;

					__asm        cmp    y, 0x80;
					__asm        jl     _T139;
				_T12e:
					tile = 0x0;
					__asm        jmp    _T171;
				_T139:
					__asm        mov    eax, x;
					__asm        mov    eax, BitsMap[eax*4];
					__asm        mov    ecx, y;
					__asm        xor    edx, edx;
					__asm        mov    dl, [eax+ecx];
					__asm        and    edx, 2;
					__asm        movsx  eax, dx;
					__asm        shl    eax, 0xE;
					__asm        mov    ecx, x;
					__asm        mov    ecx, BuildMap[ecx*4];
					__asm        mov    edx, y;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ecx+edx];
					__asm        or     eax, ebx;
					__asm        mov    tile, ax;
					__asm        jmp    _T171;
				// LINE 4077:
				_T171:
					__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
					__asm        and    eax, 0xFFFF;
					__asm        mov    [ebp-0x50], eax;
					__asm        jmp    _T195;

					__asm        jmp    _T231;

					__asm        jmp    _T2a5;

					__asm        jmp    _T231;

					__asm        jmp    _T227;
				_T195:
					__asm        cmp    dword ptr [ebp-0x50], 0x3A;
					__asm        jg     _T1c2;

					__asm        cmp    dword ptr [ebp-0x50], 0x32;
					__asm        jge    _T231;

					__asm        cmp    dword ptr [ebp-0x50], 0x2C;
					__asm        jl     _T2a5;

					__asm        cmp    dword ptr [ebp-0x50], 0x2D;
					__asm        jle    _T231;

					__asm        jmp    _T2a5;
				_T1c2:
					__asm        cmp    dword ptr [ebp-0x50], 0x4E;
					__asm        jg     _T1ef;

					__asm        cmp    dword ptr [ebp-0x50], 0x4D;
					__asm        jge    _T231;

					__asm        cmp    dword ptr [ebp-0x50], 0x45;
					__asm        jl     _T2a5;

					__asm        cmp    dword ptr [ebp-0x50], 0x48;
					__asm        jle    _T231;

					__asm        jmp    _T2a5;
				_T1ef:
					__asm        cmp    dword ptr [ebp-0x50], 0x805B;
					__asm        jg     _T2a5;

					__asm        cmp    dword ptr [ebp-0x50], 0x805A;
					__asm        jge    _T231;

					__asm        cmp    dword ptr [ebp-0x50], 0x5A;
					__asm        jl     _T2a5;

					__asm        cmp    dword ptr [ebp-0x50], 0x5B;
					__asm        jle    _T231;

					__asm        jmp    _T2a5;

					__asm        jmp    _T2a5;
				_T227:
					__asm        cmp    dword ptr [ebp-0x40], 0;
					__asm        je     _T2a5;
				// LINE 4079:
				_T231:
					beampoint.x = x;
				// LINE 4080:
					beampoint.y = y;
				// LINE 4081:
					__asm        mov    eax, beampoint.y;
					__asm        and    eax, 0xFF;
					__asm        mov    ecx, beampoint.x;
					__asm        and    ecx, 0xFF;
					__asm        shl    ecx, 0xA;
					__asm        mov    eax, G_omap[0][0][ecx+eax*4];
					__asm        mov    [ebp-0x3C], eax;
					__asm        cmp    dword ptr [ebp-0x3C], 0;
					__asm        jne    _T281;

					_assert(0xd0, 0x5b780c, 0x5b57b8);
					__asm        jmp    _T286;
				_T281:
					__asm        jmp    _T286;
				_T286:
					__asm        jmp    _T28b;
				_T28b:
					__asm        mov    eax, [ebp-0x3C];
					__asm        mov    cptr, eax;
				// LINE 4082:
					__asm        mov    eax, cptr;
					__asm        cmp    dword ptr [eax+0x10], 0;
					__asm        jne    _T2a5;
				// LINE 4084:
					foundcell = 0x1;
				// LINE 4087:
				_T2a5:
					__asm        cmp    foundcell, 0;
					__asm        je     _T2b9;

					__asm        jmp    _T42f;

					__asm        jmp    foundCell;
				// LINE 4088:
				_T2b9:
					x += xdir;
				// LINE 4089:
					y += ydir;
			}
		// LINE 4092:
		_T2ca:
			__asm        cmp    stop_now, 1;
			__asm        jne    _T2d9;
		// LINE 4094:
			__asm        jmp    _T2de;
		// LINE 4096:
		_T2d9:
			__asm        jmp    _LOOP_3b;
	}
// LINE 4099:
_T2de:
	return 0x0;
// LINE 4106:
foundCell:
	this->stalledTimer = 0x0;
// LINE 4107:
	this->direction = 0x0;
// LINE 4108:
	this->speed = 0x0;
// LINE 4109:
	this->flags[1] = 0x1;
// LINE 4110:
	this->flags[2] = 0x0;
// LINE 4111:
	this->flags[3] = 0x0;
// LINE 4112:
	this->flags[4] = 0x0;
// LINE 4113:
	this->flags[5] = 0x0;
// LINE 4114:
	this->flags[7] = 0x0;
// LINE 4115:
	this->flags[8] = 0x0;
// LINE 4120:
	this->currentLocation1.x = beampoint.x;
	this->currentLocation1.y = beampoint.y;
	__asm        jmp    _T34b;
// LINE 4124:
_T34b:
	__asm        jmp    _T350;
_T350:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 4128:
	__asm        jmp    _T36e;
_T36e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0;
	__asm        jl     _T3a8;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0;
	__asm        jl     _T3a8;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0x80;
	__asm        jge    _T3a8;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0x80;
	__asm        jl     _T3b3;
_T3a8:
	__asm        mov    word ptr [ebp-0x44], 0;
	__asm        jmp    _T3f7;
_T3b3:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x35];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x39];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x39];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-0x44], ax;
	__asm        jmp    _T3f7;
_T3f7:
	__asm        mov    eax, [ebp-0x44];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::SetTrainDirection;
// LINE 4129:
	this->TrainClass::AdjustCurrentPosition();
// LINE 4130:
	this->TrainClass::AdjustNextPosition();
// LINE 4131:
	this->TrainClass::SetTrailingCars();
// LINE 4132:
	this->beamTimer = 0x0;
// LINE 4134:
	return 0x1;
// LINE 4136:
_T42f:
	__asm        jmp    foundCell;
}

// FUNCTION: COPTER_D 0x00533e76
int32_t TrainClass::InitializeInstance(long mapx, long mapy, int32_t instanceID) {
	/*bp-0x4*/   int32_t object2;
	/*bp-0x8*/   int32_t object1;
	/*bp-0xc*/   int32_t object3;
	/*bp-0x30*/  /*packed*/ struct VRObjInfo objectInfo; // 0x24 bytes

// LINE 4396:
	this->dyObj1.mesh = 0x0;
// LINE 4397:
	this->dyObj2.mesh = 0x0;
// LINE 4398:
	this->dyObj3.mesh = 0x0;
// LINE 4420:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x95];
	__asm        push   eax;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    object1, eax;
// LINE 4421:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x99];
	__asm        push   eax;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    object2, eax;
// LINE 4422:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x9D];
	__asm        push   eax;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    object3, eax;
// LINE 4424:
	__asm        cmp    object1, 0;
	__asm        je     _T90;

	__asm        cmp    object2, 0;
	__asm        je     _T90;

	__asm        cmp    object3, 0;
	__asm        jne    _T118;
// LINE 4427:
_T90:
	__asm        cmp    object1, 0;
	__asm        jne    _Tb6;

	_assert(0x114b, 0x5b7b30, 0x5b7b54);
	__asm        jmp    _Tbb;
_Tb6:
	__asm        jmp    _Tbb;
// LINE 4428:
_Tbb:
	__asm        cmp    object2, 0;
	__asm        jne    _Te1;

	_assert(0x114c, 0x5b7b5c, 0x5b7b80);
	__asm        jmp    _Te6;
_Te1:
	__asm        jmp    _Te6;
// LINE 4429:
_Te6:
	__asm        cmp    object3, 0;
	__asm        jne    _T10c;

	_assert(0x114d, 0x5b7b88, 0x5b7bac);
	__asm        jmp    _T111;
_T10c:
	__asm        jmp    _T111;
// LINE 4431:
_T111:
	return 0x0;
// LINE 4435:
_T118:
	__asm        cmp    instanceID, 0;
	__asm        jne    _T14b;
// LINE 4439:
	this->dyObj1.mesh = object1;
// LINE 4440:
	this->dyObj2.mesh = object2;
// LINE 4441:
	this->dyObj3.mesh = object3;
// LINE 4443:
	__asm        jmp    _T152;
// LINE 4446:
_T14b:
	return 0x0;
// LINE 4490:
_T152:
	__asm        mov    eax, instanceID;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xAF], ax;
// LINE 4491:
	this->dyObj1.flags = 0x81;
// LINE 4492:
	__asm        mov    eax, instanceID;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x113], ax;
// LINE 4493:
	this->dyObj2.flags = 0x81;
// LINE 4494:
	__asm        mov    eax, instanceID;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x177], ax;
// LINE 4495:
	this->dyObj3.flags = 0x81;
// LINE 4497:
	__asm        mov    eax, this;
	__asm        add    eax, 0xC5;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 4498:
	__asm        mov    eax, this;
	__asm        add    eax, 0x129;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 4499:
	__asm        mov    eax, this;
	__asm        add    eax, 0x18D;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 4500:
	__asm        lea    eax, objectInfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, object1;
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 4501:
	this->dyObj1.radius = objectInfo.Radius;
// LINE 4502:
	this->dyObj2.radius = objectInfo.Radius;
// LINE 4503:
	this->dyObj3.radius = objectInfo.Radius;
// LINE 4504:
	this->dyObj1.height = VRObjGetHeight(object1);
// LINE 4505:
	this->dyObj2.height = VRObjGetHeight(object2);
// LINE 4506:
	this->dyObj3.height = VRObjGetHeight(object3);
// LINE 4507:
	this->leadcar = (this + 0xa1);
// LINE 4508:
	this->midcar = (this + 0x105);
// LINE 4509:
	this->endcar = (this + 0x169);
// LINE 4512:
	this->dyObj1.next = 0x0;
// LINE 4513:
	this->dyObj2.next = 0x0;
// LINE 4514:
	this->dyObj3.next = 0x0;
// LINE 4518:
	this->flags[2] = 0x0;
// LINE 4519:
	this->stalledTimer = 0x0;
// LINE 4520:
	this->beamTimer = 0x0;
// LINE 4521:
	this->beamDelay = 0x0;
// LINE 4522:
	this->currentLocation1.x = mapx;
// LINE 4523:
	this->currentLocation1.y = mapy;
// LINE 4524:
	this->currentLocation2.x = mapx;
// LINE 4525:
	this->currentLocation2.y = mapy;
// LINE 4526:
	this->currentLocation3.x = mapx;
// LINE 4527:
	this->currentLocation3.y = mapy;
// LINE 4528:
	this->currentCell.x = mapx;
// LINE 4529:
	this->currentCell.y = mapy;
// LINE 4530:
	this->nextLocation.x = mapx;
// LINE 4531:
	this->nextLocation.y = mapy;
// LINE 4532:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        shl    eax, 0x11;
	__asm        add    eax, 0x560000;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x31], eax;
// LINE 4533:
	this->beamDelay = 0x1e0000;
// LINE 4538:
	__asm        cmp    mapx, 0xFFFFFFFF;
	__asm        je     _T439;

	__asm        cmp    mapy, 0xFFFFFFFF;
	__asm        je     _T439;
// LINE 4542:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CD];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x35;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::LinkToCell;
// LINE 4546:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0;
	__asm        jl     _T3af;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0;
	__asm        jl     _T3af;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x35], 0x80;
	__asm        jge    _T3af;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x39], 0x80;
	__asm        jl     _T3ba;
_T3af:
	__asm        mov    word ptr [ebp-0x34], 0;
	__asm        jmp    _T3fe;
_T3ba:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x35];
	__asm        mov    eax, BitsMap[eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x39];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        and    edx, 2;
	__asm        movsx  eax, dx;
	__asm        shl    eax, 0xE;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x35];
	__asm        mov    ecx, BuildMap[ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x39];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx];
	__asm        or     eax, ebx;
	__asm        mov    [ebp-0x34], ax;
	__asm        jmp    _T3fe;
_T3fe:
	__asm        mov    eax, [ebp-0x34];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   TrainClass::SetTrainDirection;
// LINE 4547:
	this->TrainClass::AdjustCurrentPosition();
// LINE 4548:
	this->TrainClass::AdjustNextPosition();
// LINE 4549:
	this->TrainClass::SetTrailingCars();
// LINE 4553:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 4557:
	this->flags[1] = 0x1;
// LINE 4559:
	__asm        jmp    _T440;
// LINE 4563:
_T439:
	this->flags[1] = 0x0;
// LINE 4572:
_T440:
	__asm        mov    eax, this;
	__asm        mov    ecx, instanceID;
	__asm        mov    trains[0][ecx*4], eax;
// LINE 4575:
	this->flags[0] = 0x1;
// LINE 4577:
	return 0x1;
// LINE 4578:
}

// FUNCTION: COPTER_D 0x005342db
short GetMaximumNumberOfTrains() {
// LINE 4603:
	return 0x1;
// LINE 4604:
}

// FUNCTION: COPTER_D 0x005342ef
int32_t CreateTrainInstance(int32_t instanceID) {
// LINE 4626:
_T24:
_T26:
	return (TrainClass::CreateInstance(instanceID) == 0x0);
// LINE 4627:
}

// FUNCTION: COPTER_D 0x0053431f
void ResetAllTrains() {
// LINE 4645:
	TrainClass::ResetAll();
// LINE 4646:
	return;
}

// FUNCTION: COPTER_D 0x00534334
void ItterateAllTrains() {
// LINE 4668:
	TrainClass::ItterateAll();
// LINE 4669:
	return;
}

// FUNCTION: COPTER_D 0x00534349
int32_t S3TrainCrashWhenReady(long mission_id) {
// LINE 4689:
	return TrainClass::FindTrainToCrash(mission_id);
// LINE 4690:
}

// FUNCTION: COPTER_D 0x00534365
int32_t S3TrainStartRescue(long mission_id, int32_t timetolive) {
// LINE 4710:
	return TrainClass::FindTrainForRescue(timetolive, mission_id);
// LINE 4711:
}

// FUNCTION: COPTER_D 0x00534385
int32_t TrainClass::FindTrainForRescue(long mission_id, int32_t timetolive) {
	/*bp-0x4*/   long totalpersons;
	/*bp-0x8*/   /*packed*/ class TrainClass *t;
	/*bp-0xc*/   long count;
	/*bp-0x10*/  long x;
	/*bp-0x14*/  long y;
	/*bp-0x2c*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x30*/  long numtostart;
	/*bp-0x34*/  int32_t currentTrainIndex;

// LINE 4743:
	currentTrainIndex = 0x0;
	__asm        jmp    _T18;
_T15:
	currentTrainIndex++;
_T18:
	__asm        cmp    currentTrainIndex, 1;
	__asm        jge    _T1d1;
// LINE 4745:
	__asm        mov    eax, currentTrainIndex;
	__asm        mov    eax, trains[0][eax*4];
	__asm        mov    t, eax;
// LINE 4750:
	__asm        jmp    _T34;
_T34:
	__asm        mov    eax, t;
	__asm        movsx  eax, byte ptr [eax+0xA];
	__asm        test   eax, eax;
	__asm        jne    _T6b;

	__asm        jmp    _T48;
_T48:
	__asm        mov    eax, t;
	__asm        movsx  eax, byte ptr [eax+0xB];
	__asm        test   eax, eax;
	__asm        jne    _T6b;

	__asm        jmp    _T5c;
_T5c:
	__asm        mov    eax, t;
	__asm        movsx  eax, byte ptr [eax+0xC];
	__asm        test   eax, eax;
	__asm        je     _T72;
// LINE 4752:
_T6b:
	return 0x0;
// LINE 4756:
_T72:
	__asm        jmp    _T77;
_T77:
	__asm        mov    eax, t;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        jne    _Td6;
// LINE 4759:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0x7F;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    x, eax;
// LINE 4760:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0x7F;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    y, eax;
// LINE 4763:
	__asm        mov    eax, y;
	__asm        push   eax;
	__asm        mov    eax, x;
	__asm        push   eax;
	__asm        mov    eax, t;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, t;
	__asm        call   dword ptr [eax+0x18];
	__asm        test   eax, eax;
	__asm        jne    _Td6;
// LINE 4764:
	return 0x0;
// LINE 4768:
_Td6:
	t->missionId = mission_id;
// LINE 4769:
	t->timeToLive = timetolive;
// LINE 4772:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+1];
	__asm        mov    numtostart, eax;
// LINE 4773:
	totalpersons = 0x0;
// LINE 4774:
_FOR_111:
	for (count = 0x0; (count < numtostart); count++) {
		// LINE 4781:
			__asm        push   0;
			__asm        mov    eax, t;
			__asm        add    eax, 0xA1;
			__asm        push   eax;
			__asm        mov    eax, mission_id;
			__asm        push   eax;
			__asm        mov    eax, t;
			__asm        movzx  ax, byte ptr [eax+0x39];
			__asm        push   eax;
			__asm        mov    eax, t;
			__asm        movzx  ax, byte ptr [eax+0x35];
			__asm        push   eax;
			__asm        push   1;
			__asm        push   0xFFFFFFFF;
			__asm        call   StartPerson;
			__asm        add    esp, 0x1C;
			__asm        movsx  eax, ax;
			__asm        cmp    eax, 0xFFFFFFFF;
			__asm        jle    _T15c;
		// LINE 4783:
			totalpersons++;
		// LINE 4785:
		_T15c:
	}
// LINE 4788:
_T161:
	__asm        cmp    totalpersons, 0;
	__asm        jne    _T179;
// LINE 4790:
	t->flags[8] = 0x0;
// LINE 4791:
	return 0x0;
// LINE 4795:
_T179:
	mp.op = 0x0;
// LINE 4796:
	mp.id = t->missionId;
// LINE 4797:
	mp.maploc.x = t->currentLocation1.x;
// LINE 4798:
	mp.maploc.y = t->currentLocation1.y;
// LINE 4799:
	S3MissionUpdate(mp.op);
// LINE 4801:
	mp.op = 0xe;
// LINE 4802:
	mp.i2num = totalpersons;
// LINE 4803:
	mp.flags = 0x1;
// LINE 4804:
	S3MissionUpdate(mp.op);
// LINE 4806:
	__asm        jmp    _T1d1;
// LINE 4808:
	__asm        jmp    _T15;
// LINE 4810:
_T1d1:
	t->flags[8] = 0x1;
// LINE 4811:
	return 0x1;
// LINE 4812:
}

// FUNCTION: COPTER_D 0x0053456c
int32_t S3TrainMIFFLoad(void * __ptr32 miffReader) {
// LINE 4826:
	return TrainClass::MIFFLoad(miffReader);
// LINE 4827:
}

// FUNCTION: COPTER_D 0x00534588
int32_t S3TrainMIFFSave(void * __ptr32 miffWriter) {
// LINE 4839:
	return TrainClass::MIFFSave(miffWriter);
// LINE 4840:
}

// FUNCTION: COPTER_D 0x005345a4
int32_t TrainClass::MIFFLoad(void * __ptr32 miffReader) {
	/*bp-0x4*/   /*packed*/ class TrainClass *t;
	/*bp-0x8*/   int32_t ret;
	/*bp-0xc*/   int32_t i;

// LINE 4858:
	ret = ReadFirstMIFFChunk(0x1d9, 0x62b7b8, 0x5452414e, miffReader);
// LINE 4859:
	__asm        cmp    ret, 0;
	__asm        jne    _FOR_44;
// LINE 4860:
	return 0x0;
// LINE 4862:
_FOR_44:
	for (i = 0x0; (i < 0x1); i++) {
		// LINE 4865:
			__asm        mov    eax, i;
			__asm        mov    eax, trains[0][eax*4];
			__asm        mov    t, eax;
		// LINE 4866:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 4;
			__asm        mov    ecx, t;
			__asm        add    ecx, 4;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    al, [eax+8];
			__asm        mov    [ecx+8], al;
		// LINE 4867:
			t->stalledTimer = TrainClass::lsTrain.stalledTimer;
		// LINE 4868:
			t->direction = TrainClass::lsTrain.direction;
		// LINE 4869:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x15;
			__asm        mov    ecx, t;
			__asm        add    ecx, 0x15;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 4870:
			t->remainingDist = TrainClass::lsTrain.remainingDist;
		// LINE 4871:
			t->remainingTime = TrainClass::lsTrain.remainingTime;
		// LINE 4872:
			t->utdirection = TrainClass::lsTrain.utdirection;
		// LINE 4873:
			t->speed = TrainClass::lsTrain.speed;
		// LINE 4874:
			t->desiredSpeed = TrainClass::lsTrain.desiredSpeed;
		// LINE 4875:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x35;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x35;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4876:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x3D;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x3D;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4877:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x45;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x45;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4878:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x4D;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x4D;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4879:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x55;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x55;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4880:
			t->beamDelay = TrainClass::lsTrain.beamDelay;
		// LINE 4881:
			t->beamTimer = TrainClass::lsTrain.beamTimer;
		// LINE 4882:
			t->utRotation = TrainClass::lsTrain.utRotation;
		// LINE 4883:
			t->missionId = TrainClass::lsTrain.missionId;
		// LINE 4884:
			t->smokeTime = TrainClass::lsTrain.smokeTime;
		// LINE 4885:
			t->timeToLive = TrainClass::lsTrain.timeToLive;
		// LINE 4886:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x75;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x75;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4887:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x85;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x85;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4888:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x8D;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x8D;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4889:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x7D;
			__asm        mov    ecx, [eax];
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, t;
			__asm        add    edx, 0x7D;
			__asm        mov    [edx], ecx;
			__asm        mov    [edx+4], eax;
		// LINE 4891:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0xB9;
			__asm        mov    ecx, t;
			__asm        add    ecx, 0xB9;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 4892:
			__asm        mov    edi, t;
			__asm        add    edi, 0xC5;
			__asm        lea    esi, TrainClass::lsTrain.dyObj1.matrix[0][0];
			__asm        mov    ecx, 0x10;
			__asm        rep movsd;
		// LINE 4893:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x11D;
			__asm        mov    ecx, t;
			__asm        add    ecx, 0x11D;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 4894:
			__asm        mov    edi, t;
			__asm        add    edi, 0x129;
			__asm        lea    esi, TrainClass::lsTrain.dyObj2.matrix[0][0];
			__asm        mov    ecx, 0x10;
			__asm        rep movsd;
		// LINE 4895:
			__asm        mov    eax, 0x62B7B8;
			__asm        add    eax, 0x181;
			__asm        mov    ecx, t;
			__asm        add    ecx, 0x181;
			__asm        mov    edx, [eax];
			__asm        mov    [ecx], edx;
			__asm        mov    edx, [eax+4];
			__asm        mov    [ecx+4], edx;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ecx+8], eax;
		// LINE 4896:
			__asm        mov    edi, t;
			__asm        add    edi, 0x18D;
			__asm        lea    esi, TrainClass::lsTrain.dyObj3.matrix[0][0];
			__asm        mov    ecx, 0x10;
			__asm        rep movsd;
		// LINE 4898:
			__asm        jmp    _T2bb;
		_T2bb:
			__asm        mov    eax, t;
			__asm        movsx  eax, byte ptr [eax+5];
			__asm        test   eax, eax;
			__asm        je     _T315;
		// LINE 4900:
			__asm        mov    eax, t;
			__asm        mov    eax, [eax+0x1CD];
			__asm        push   eax;
			__asm        mov    eax, t;
			__asm        add    eax, 0x35;
			__asm        push   eax;
			__asm        mov    ecx, t;
			__asm        call   TrainClass::LinkToCell;
		// LINE 4901:
			__asm        mov    eax, t;
			__asm        mov    eax, [eax+0x1D1];
			__asm        push   eax;
			__asm        mov    eax, t;
			__asm        add    eax, 0x3D;
			__asm        push   eax;
			__asm        mov    ecx, t;
			__asm        call   TrainClass::LinkToCell;
		// LINE 4902:
			__asm        mov    eax, t;
			__asm        mov    eax, [eax+0x1D5];
			__asm        push   eax;
			__asm        mov    eax, t;
			__asm        add    eax, 0x45;
			__asm        push   eax;
			__asm        mov    ecx, t;
			__asm        call   TrainClass::LinkToCell;
		// LINE 4909:
		_T315:
			ret = ReadNextMIFFChunk(0x1d9, 0x62b7b8, 0x5452414e, miffReader);
		// LINE 4911:
			__asm        cmp    ret, 0;
			__asm        jne    _T34e;

			__asm        cmp    i, 0;
			__asm        je     _T34e;
		// LINE 4912:
			return 0x0;
		// LINE 4913:
		_T34e:
	}
// LINE 4914:
_T353:
	return 0x1;
// LINE 4915:
}

// FUNCTION: COPTER_D 0x00534906
int32_t TrainClass::MIFFSave(void * __ptr32 miffWriter) {
	/*bp-0x4*/   int32_t ret;
	/*bp-0x8*/   int32_t i;

// LINE 4928:
_FOR_15:
	for (i = 0x0; (i < 0x1); i++) {
		// LINE 4933:
			__asm        push   0x1D9;
			__asm        mov    eax, i;
			__asm        mov    eax, trains[0][eax*4];
			__asm        push   eax;
			__asm        push   0x5452414E;
			__asm        mov    eax, miffWriter;
			__asm        push   eax;
			__asm        call   WriteMIFFChunk;
			__asm        add    esp, 0x10;
			__asm        mov    ret, eax;
		// LINE 4934:
			__asm        cmp    ret, 0;
			__asm        jne    _T57;
		// LINE 4935:
			return 0x0;
		// LINE 4936:
		_T57:
	}
// LINE 4937:
_T5c:
	return 0x1;
// LINE 4938:
}



// Contribution: 1:00133980-001339b8 Module: 162, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00534980
// TrainClass::`scalar deleting destructor'



// Contribution: 2:00004238-00004253 Module: 162, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for TrainClass @ 0x00593238
//   00: TrainClass::`scalar deleting destructor' @ 0x00534980
//   01: TrainClass::ItterateFSM @ 0x0052e671
//   02: TrainClass::AdjustSpeed @ 0x0052f41b
//   03: TrainClass::IsPathClear @ 0x0052f454
//   04: TrainClass::PickTurnDirection @ 0x005313f2
//   05: TrainClass::BeamToWithinCameraRange @ 0x00533422
//   06: TrainClass::BeamToLocation @ 0x00533a3b
//   7 entries



// Contribution: 3:000000ac-000000af Module: 162, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005970ac
static void (*$S8)() = { 0 /* todo */ };



// Contribution: 3:00020830-00020bb3 Module: 162, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b7830
/*packed*/ struct Point2d TrainClass::lastScannedLocation = { 0 /* todo */ };



// Contribution: 3:00020bb8-00020ca7 Module: 162, 8 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005b7bb8
/*packed*/ struct CONNECTION_INFO_TYPE connections[30] = { 0 /* todo */ };



// Contribution: 3:000947b8-00094998 Module: 162, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0062b7b8
/*packed*/ class TrainClass TrainClass::lsTrain;

// GLOBAL: COPTER_D 0x0062b994
/*packed*/ class TrainClass *trains[1];

// GLOBAL: COPTER_D 0x0062b998
// $S5


// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.
// GLOBAL: COPTER_D 0x006bf188
/*packed*/ struct Point2d CameraCell; // Contrib missing

// GLOBAL: COPTER_D 0x006bf188
/*packed*/ struct Point2d CameraCell; // Contrib missing

