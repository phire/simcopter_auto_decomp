// Module: S3msl.obj
// Source: C:\Copter\source\game\S3msl.c
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ struct _MISSILE_DATA;
struct _MISSILE_DATA{ // packed(0x48 bytes) TI: 0x2a6c
	/*+0x0*/   long flags;
	/*+0x4*/   int32_t timetolive;
	/*+0x8*/   int32_t smoketime;
	/*+0xc*/   int32_t speed;
	/*+0x10*/  /*packed*/ struct Point3d vector; // 0xc bytes
	/*+0x1c*/  /*packed*/ struct Point3d targloc; // 0xc bytes
	/*+0x28*/  /*packed*/ struct _DYOBJ_INST *dymissile;
	/*+0x2c*/  /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*+0x34*/  long animseq;
	/*+0x38*/  int32_t gas_on;
	/*+0x3c*/  /*packed*/ struct _DYOBJ_INST *dystarter;
	/*+0x40*/  long mission_id;
	/*+0x44*/  long scale;
};

// Type: long;

// Type: short;

// Type: int32_t;

// Type: /*packed*/ struct _MISSILE_DATA (forward reference);
struct _MISSILE_DATA{ // packed(0x48 bytes) TI: 0x2a6c
	/*+0x0*/   long flags;
	/*+0x4*/   int32_t timetolive;
	/*+0x8*/   int32_t smoketime;
	/*+0xc*/   int32_t speed;
	/*+0x10*/  /*packed*/ struct Point3d vector; // 0xc bytes
	/*+0x1c*/  /*packed*/ struct Point3d targloc; // 0xc bytes
	/*+0x28*/  /*packed*/ struct _DYOBJ_INST *dymissile;
	/*+0x2c*/  /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*+0x34*/  long animseq;
	/*+0x38*/  int32_t gas_on;
	/*+0x3c*/  /*packed*/ struct _DYOBJ_INST *dystarter;
	/*+0x40*/  long mission_id;
	/*+0x44*/  long scale;
};

// Type: void;

// Type: char *;

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct VRview;
struct VRview{ // packed(0x58 bytes) TI: 0x2ecc
	/*+0x0*/   /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0xc*/   /*packed*/ struct Point3d scale; // 0xc bytes
	/*+0x18*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct _MISSION_PARMS;
struct _MISSION_PARMS{ // packed(0x18 bytes) TI: 0x307d
	/*+0x0*/   long op;
	/*+0x4*/   long id;
	/*+0x8*/   /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x10*/  long i2num;
	/*+0x14*/  long flags;
};

// Type: /*packed*/ struct VRFaceInfo;
struct VRFaceInfo{ // packed(0x20 bytes) TI: 0x30c0
	/*+0x0*/   int32_t Face;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Plotter;
	/*+0x10*/  /*packed*/ struct VRBmpHdr *Bitmap;
	/*+0x14*/  int32_t * VertList;
	/*+0x18*/  /*packed*/ struct MapVert *MapVList;
	/*+0x1c*/  /*packed*/ struct MapVert *BarryPtr;
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct Point2d;
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct _CELL_FIRE_DATA (forward reference);
struct _CELL_FIRE_DATA{ // packed(0x8 bytes) TI: 0x303d
	/*+0x0*/   /*packed*/ struct _CELL_INFO *cptr;
	/*+0x4*/   long fire_count;
};

// Type: /*packed*/ struct _STOBJ_INST (forward reference);
struct _STOBJ_INST{ // packed(0x10 bytes) TI: 0x193f
	/*+0x0*/   /*packed*/ struct _STOBJ_INST *next;
	/*+0x4*/   void * __ptr32 mesh;
	/*+0x8*/   long user1;
	/*+0xc*/   long user2;
};

// Type: /*packed*/ struct FP3D;
struct FP3D{ // packed(0x18 bytes) TI: 0x3170
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double y; // 0x8 bytes
	/*+0x10*/  double z; // 0x8 bytes
};

// Type: double;

// Type: /*packed*/ struct VRBlit (forward reference);
struct VRBlit{ // packed(0x10 bytes) TI: 0x3182
	/*+0x0*/   int32_t nverts;
	/*+0x4*/   /*packed*/ struct Proj2d *verts;
	/*+0x8*/   int32_t notused;
	/*+0xc*/   int32_t user1;
};

// Type: long *;

// Type: void * __ptr32;



// Contribution: 1:0011d770-0012290d Module: 167, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0051e770
void S3MissileReset() {
	/*bp-0x4*/   long i;
	/*bp-0x8*/   /*packed*/ struct _MISSILE_DATA *md;

// LINE 116:
	S_num_active_missiles = 0x0;
// LINE 117:
	S_num_active_bullets = 0x0;
// LINE 118:
	S_num_active_teargas = 0x0;
// LINE 119:
	S_num_active_debris = 0x0;
// LINE 120:
	S_num_active_traj = 0x0;
// LINE 121:
	S_num_active_lasers = 0x0;
// LINE 128:
_FOR_52:
	i = 0x0;
	md = 0x66c2f0;
	__asm        jmp    _FOR_COND_52;
_FOR_NEXT_52:
	i++;
	md += 0x48;
_FOR_COND_52:
	__asm        cmp    i, 0xA;
	__asm        jge    _FOR_84;
// LINE 131:
	md->flags = 0x2;
// LINE 132:
	__asm        jmp    _FOR_NEXT_52;
// LINE 138:
_FOR_84:
	i = 0x0;
	md = 0x66c5c0;
	__asm        jmp    _FOR_COND_84;
_FOR_NEXT_84:
	i++;
	md += 0x48;
_FOR_COND_84:
	__asm        cmp    i, 0xA;
	__asm        jge    _FOR_b6;
// LINE 141:
	md->flags = 0x8;
// LINE 142:
	__asm        jmp    _FOR_NEXT_84;
// LINE 149:
_FOR_b6:
	i = 0x0;
	md = 0x66e270;
	__asm        jmp    _FOR_COND_b6;
_FOR_NEXT_b6:
	i++;
	md += 0x48;
_FOR_COND_b6:
	__asm        cmp    i, 0x1E;
	__asm        jge    _FOR_e8;
// LINE 151:
	md->flags = 0x10;
// LINE 152:
	__asm        jmp    _FOR_NEXT_b6;
// LINE 159:
_FOR_e8:
	i = 0x0;
	md = 0x66dfa0;
	__asm        jmp    _FOR_COND_e8;
_FOR_NEXT_e8:
	i++;
	md += 0x48;
_FOR_COND_e8:
	__asm        cmp    i, 0xA;
	__asm        jge    _FOR_11a;
// LINE 161:
	md->flags = 0x100;
// LINE 162:
	__asm        jmp    _FOR_NEXT_e8;
// LINE 169:
_FOR_11a:
	i = 0x0;
	md = 0x66c890;
	__asm        jmp    _FOR_COND_11a;
_FOR_NEXT_11a:
	i++;
	md += 0x48;
_FOR_COND_11a:
	__asm        cmp    i, 2;
	__asm        jge    _FOR_14c;
// LINE 171:
	md->flags = 0x800;
// LINE 172:
	__asm        jmp    _FOR_NEXT_11a;
// LINE 179:
_FOR_14c:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_14c;
_FOR_NEXT_14c:
	i++;
	md += 0x48;
_FOR_COND_14c:
	__asm        cmp    i, 0x50;
	__asm        jge    __RETURN;
// LINE 181:
	md->flags = 0x4;
// LINE 182:
	__asm        jmp    _FOR_NEXT_14c;
// LINE 184:
__RETURN:
}

// FUNCTION: COPTER_D 0x0051e8e0
void S3MissileInit() {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x28*/  long size;
	/*bp-0x2c*/  /*packed*/ struct Point3d *verts;
	/*bp-0x30*/  long i;
	/*bp-0x34*/  char * mem;
	/*bp-0x38*/  long j;
	/*bp-0x3c*/  int32_t obj;
	/*bp-0x40*/  /*packed*/ struct _MISSILE_DATA *md;

// LINE 203:
	__asm        push   0x7C;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 210:
_FOR_32:
	i = 0x0;
	md = 0x66c890;
	__asm        jmp    _FOR_COND_32;
_FOR_NEXT_32:
	i++;
	md += 0x48;
_FOR_COND_32:
	__asm        cmp    i, 2;
	__asm        jge    _Tee;
// LINE 213:
	md->flags = 0x800;
// LINE 214:
	md->timetolive = 0x0;
// LINE 215:
	md->speed = 0x0;
// LINE 217:
	md->dymissile = S2Alloc(0x64, G_dyobjmempool);
// LINE 218:
	__asm        mov    eax, i;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xE], ax;
// LINE 219:
	md->dymissile->flags = 0x21;
// LINE 220:
	md->dymissile->radius = 0x60000;
// LINE 222:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 223:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x7C;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+8], eax;
// LINE 224:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 225:
	__asm        jmp    _FOR_NEXT_32;
// LINE 229:
_Tee:
	__asm        push   0xAE;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 236:
_FOR_11a:
	i = 0x0;
	md = 0x66c2f0;
	__asm        jmp    _FOR_COND_11a;
_FOR_NEXT_11a:
	i++;
	md += 0x48;
_FOR_COND_11a:
	__asm        cmp    i, 0xA;
	__asm        jge    _T1d9;
// LINE 239:
	md->flags = 0x2;
// LINE 240:
	md->timetolive = 0x0;
// LINE 241:
	md->speed = 0x0;
// LINE 243:
	md->dymissile = S2Alloc(0x64, G_dyobjmempool);
// LINE 244:
	__asm        mov    eax, i;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xE], ax;
// LINE 245:
	md->dymissile->flags = 0x21;
// LINE 246:
	md->dymissile->radius = 0x60000;
// LINE 248:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 249:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0xAE;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+8], eax;
// LINE 250:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 251:
	__asm        jmp    _FOR_NEXT_11a;
// LINE 254:
_T1d9:
	__asm        push   0x147;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 261:
_FOR_205:
	i = 0x0;
	md = 0x66c5c0;
	__asm        jmp    _FOR_COND_205;
_FOR_NEXT_205:
	i++;
	md += 0x48;
_FOR_COND_205:
	__asm        cmp    i, 0xA;
	__asm        jge    _FOR_2d7;
// LINE 264:
	md->flags = 0x8;
// LINE 265:
	md->timetolive = 0x0;
// LINE 266:
	md->speed = 0x0;
// LINE 268:
	md->dymissile = S2Alloc(0x64, G_dyobjmempool);
// LINE 269:
	__asm        mov    eax, i;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xE], ax;
// LINE 270:
	md->dymissile->flags = 0x21;
// LINE 271:
	md->dymissile->radius = 0x30000;
// LINE 273:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 274:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x147;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+8], eax;
// LINE 275:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 276:
	__asm        jmp    _FOR_NEXT_205;
// LINE 283:
_FOR_2d7:
	i = 0x0;
	md = 0x66e270;
	__asm        jmp    _FOR_COND_2d7;
_FOR_NEXT_2d7:
	i++;
	md += 0x48;
_FOR_COND_2d7:
	__asm        cmp    i, 0x1E;
	__asm        jge    _FOR_3d4;
// LINE 286:
	__asm        mov    eax, i;
	__asm        cdq;
	__asm        idiv   S_num_debris_types;
	__asm        mov    eax, S_debris_types[edx*4];
	__asm        mov    j, eax;
// LINE 289:
	__asm        mov    eax, j;
	__asm        push   eax;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 292:
	md->flags = 0x10;
// LINE 293:
	md->timetolive = 0x0;
// LINE 294:
	md->speed = 0x0;
// LINE 296:
	md->dymissile = S2Alloc(0x64, G_dyobjmempool);
// LINE 297:
	__asm        mov    eax, i;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xE], ax;
// LINE 298:
	md->dymissile->flags = 0x401;
// LINE 299:
	md->dymissile->radius = 0x30000;
// LINE 301:
	mem = S2Alloc(size, G_dyobjmempool);
// LINE 302:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        mov    eax, j;
	__asm        push   eax;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+8], eax;
// LINE 303:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 304:
	__asm        jmp    _FOR_NEXT_2d7;
// LINE 311:
_FOR_3d4:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_3d4;
_FOR_NEXT_3d4:
	i++;
	md += 0x48;
_FOR_COND_3d4:
	__asm        cmp    i, 0x50;
	__asm        jge    _FOR_527;
// LINE 314:
	md->animseq = 0x0;
// LINE 315:
	md->flags = 0x4;
// LINE 316:
	md->timetolive = 0x0;
// LINE 317:
	md->speed = 0x0;
// LINE 319:
	md->dymissile = S2Alloc(0x64, G_dyobjmempool);
// LINE 320:
	__asm        mov    eax, i;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xE], ax;
// LINE 321:
	md->dymissile->flags = 0x21;
// LINE 322:
	md->dymissile->height = 0x10000;
// LINE 323:
	md->dymissile->radius = 0x140000;
// LINE 326:
	obj = VRObjCreatePoint(0x17, 0x3);
// LINE 327:
	__asm        cmp    obj, 0;
	__asm        jne    _T47b;
// LINE 328:
	ERexit(0x5b7344);
// LINE 333:
_T47b:
	__asm        push   2;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 334:
	__asm        push   0;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 335:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 338:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 339:
	verts = oinfo.VertsPtr;
// LINE 342:
_FOR_4cb:
	j = 0x0;
	__asm        jmp    _FOR_COND_4cb;
_FOR_NEXT_4cb:
	j++;
_FOR_COND_4cb:
	__asm        cmp    j, 3;
	__asm        jge    _T503;
// LINE 344:
	verts->x = 0x0;
// LINE 345:
	verts->y = 0x0;
// LINE 346:
	__asm        mov    eax, j;
	__asm        lea    eax, [eax+eax*4];
	__asm        shl    eax, 0x11;
	__asm        mov    ecx, verts;
	__asm        mov    [ecx+8], eax;
// LINE 347:
	verts += 0xc;
// LINE 348:
	__asm        jmp    _FOR_NEXT_4cb;
// LINE 349:
_T503:
	md->dymissile->mesh = obj;
// LINE 350:
	__asm        jmp    _FOR_NEXT_3d4;
// LINE 357:
_FOR_527:
	i = 0x0;
	md = 0x66dfa0;
	__asm        jmp    _FOR_COND_527;
_FOR_NEXT_527:
	i++;
	md += 0x48;
_FOR_COND_527:
	__asm        cmp    i, 0xA;
	__asm        jge    __RETURN;
// LINE 360:
	md->animseq = 0x0;
// LINE 361:
	md->flags = 0x100;
// LINE 362:
	md->timetolive = 0x0;
// LINE 363:
	md->speed = 0x0;
// LINE 365:
	md->dymissile = S2Alloc(0x64, G_dyobjmempool);
// LINE 366:
	__asm        mov    eax, i;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xE], ax;
// LINE 367:
	md->dymissile->flags = 0x21;
// LINE 368:
	md->dymissile->radius = 0x10000;
// LINE 371:
	obj = VRObjCreatePoint(0x17, 0x1);
// LINE 372:
	__asm        cmp    obj, 0;
	__asm        jne    _T5c1;
// LINE 373:
	ERexit(0x5b7360);
// LINE 378:
_T5c1:
	__asm        push   2;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 379:
	__asm        push   1;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 380:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 382:
	md->dymissile->mesh = obj;
// LINE 383:
	__asm        jmp    _FOR_NEXT_527;
// LINE 385:
__RETURN:
}

// FUNCTION: COPTER_D 0x0051eee5
/*packed*/ struct _MISSILE_DATA* S3MissileStart(long msl_type, /*packed*/ struct Point2d *celloc, /*packed*/ struct Point3d *loc, /*packed*/ struct Point3d *vect, long scale, /*packed*/ struct _DYOBJ_INST *dystarter, int32_t speed, long mission_id) {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x30*/  /*packed*/ struct Point3d sloc; // 0xc bytes
	/*bp-0x34*/  int32_t face;
	/*bp-0x54*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes
	/*bp-0x58*/  long smoke_size;
	/*bp-0x5c*/  long i;
	/*bp-0x74*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x78*/  int32_t rdist;
	/*bp-0x7c*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0xd4*/  /*packed*/ struct VRview pos; // 0x58 bytes
	/*bp-0xd8*/  /*packed*/ struct _MISSILE_DATA *md;

// LINE 416:
	__asm        cmp    msl_type, 1;
	__asm        jne    _Tab;
// LINE 418:
	__asm        cmp    S_msl_fire_delay, 0;
	__asm        jle    _T2a;
// LINE 419:
	return 0x0;
// LINE 421:
_T2a:
	S_msl_fire_delay = 0x3333;
// LINE 424:
_FOR_4a:
	i = 0x0;
	md = 0x66c2f0;
	__asm        jmp    _FOR_COND_4a;
_FOR_NEXT_4a:
	i++;
	md += 0x48;
_FOR_COND_4a:
	__asm        cmp    i, 0xA;
	__asm        jge    _T77;
// LINE 426:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T72;
// LINE 427:
	__asm        jmp    _T77;
// LINE 428:
_T72:
	__asm        jmp    _FOR_NEXT_4a;
// LINE 431:
_T77:
	__asm        cmp    i, 0xA;
	__asm        jne    _T88;
// LINE 432:
	return 0x0;
// LINE 435:
_T88:
	S3DSPlay(0x0, loc, 0x6);
// LINE 438:
	smoke_size = 0x1;
// LINE 440:
	S_num_active_missiles++;
// LINE 443:
	__asm        jmp    _Tab6;
_Tab:
	__asm        cmp    msl_type, 0xB;
	__asm        jne    _T12c;
// LINE 446:
_FOR_cb:
	i = 0x0;
	md = 0x66c890;
	__asm        jmp    _FOR_COND_cb;
_FOR_NEXT_cb:
	i++;
	md += 0x48;
_FOR_COND_cb:
	__asm        cmp    i, 2;
	__asm        jge    _Tf8;
// LINE 448:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _Tf3;
// LINE 449:
	__asm        jmp    _Tf8;
// LINE 450:
_Tf3:
	__asm        jmp    _FOR_NEXT_cb;
// LINE 453:
_Tf8:
	__asm        cmp    i, 2;
	__asm        jne    _T109;
// LINE 454:
	return 0x0;
// LINE 457:
_T109:
	S3DSPlay(0x0, loc, 0x2a);
// LINE 460:
	smoke_size = 0x1;
// LINE 462:
	S_num_active_lasers++;
// LINE 465:
	__asm        jmp    _Tab6;
_T12c:
	__asm        cmp    msl_type, 2;
	__asm        jne    _T29b;
// LINE 468:
_FOR_14c:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_14c;
_FOR_NEXT_14c:
	i++;
	md += 0x48;
_FOR_COND_14c:
	__asm        cmp    i, 0x50;
	__asm        jge    _T179;
// LINE 470:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T174;
// LINE 471:
	__asm        jmp    _T179;
// LINE 472:
_T174:
	__asm        jmp    _FOR_NEXT_14c;
// LINE 475:
_T179:
	__asm        cmp    i, 0x50;
	__asm        jne    _T18a;
// LINE 476:
	return 0x0;
// LINE 481:
_T18a:
	__asm        push   5;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T1ac;
// LINE 483:
	S3DSPlay(0x1, loc, 0x5);
// LINE 486:
_T1ac:
	smoke_size = 0x4;
// LINE 488:
	md->flags = 0x4;
// LINE 493:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 494:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 495:
_FOR_1fc:
	i = 0x0;
	__asm        jmp    _FOR_COND_1fc;
_FOR_NEXT_1fc:
	i++;
_FOR_COND_1fc:
	__asm        mov    eax, i;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T28f;
// LINE 497:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 498:
	finfo.Plotter = 0x17;
// LINE 499:
	__asm        cmp    G_daynight, 0;
	__asm        jne    _T23b;
// LINE 501:
	finfo.Bitmap = 0x0;
// LINE 503:
	__asm        jmp    _T260;
// LINE 505:
_T23b:
	finfo.Bitmap = S_tracer;
	S_tracer++;
// LINE 506:
	__asm        cmp    S_tracer, 0x20;
	__asm        jl     _T260;

	S_tracer = 0x10;
// LINE 508:
_T260:
	finfo.Attribute = (finfo.Attribute & 0x7fffffff);
// LINE 509:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 510:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 511:
	__asm        jmp    _FOR_NEXT_1fc;
// LINE 513:
_T28f:
	S_num_active_bullets++;
// LINE 515:
	__asm        jmp    _Tab6;
_T29b:
	__asm        cmp    msl_type, 5;
	__asm        jne    _T3d3;
// LINE 518:
_FOR_2bb:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_2bb;
_FOR_NEXT_2bb:
	i++;
	md += 0x48;
_FOR_COND_2bb:
	__asm        cmp    i, 0x50;
	__asm        jge    _T2e8;
// LINE 520:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T2e3;
// LINE 521:
	__asm        jmp    _T2e8;
// LINE 522:
_T2e3:
	__asm        jmp    _FOR_NEXT_2bb;
// LINE 525:
_T2e8:
	__asm        cmp    i, 0x50;
	__asm        jne    _T2f9;
// LINE 526:
	return 0x0;
// LINE 531:
_T2f9:
	__asm        push   0x25;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T31b;
// LINE 533:
	S3DSPlay(0x1, loc, 0x25);
// LINE 536:
_T31b:
	smoke_size = 0x8;
// LINE 538:
	md->flags = 0x20;
// LINE 542:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 543:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 544:
_FOR_36b:
	i = 0x0;
	__asm        jmp    _FOR_COND_36b;
_FOR_NEXT_36b:
	i++;
_FOR_COND_36b:
	__asm        mov    eax, i;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T3c7;
// LINE 546:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 547:
	finfo.Plotter = 0x1a;
// LINE 548:
	finfo.Bitmap = 0x3;
// LINE 549:
	finfo.Attribute = (finfo.Attribute & 0x7fffffff);
// LINE 550:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 551:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 552:
	__asm        jmp    _FOR_NEXT_36b;
// LINE 554:
_T3c7:
	S_num_active_bullets++;
// LINE 556:
	__asm        jmp    _Tab6;
_T3d3:
	__asm        cmp    msl_type, 6;
	__asm        jne    _T4e9;
// LINE 559:
_FOR_3f3:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_3f3;
_FOR_NEXT_3f3:
	i++;
	md += 0x48;
_FOR_COND_3f3:
	__asm        cmp    i, 0x50;
	__asm        jge    _T420;
// LINE 561:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T41b;
// LINE 562:
	__asm        jmp    _T420;
// LINE 563:
_T41b:
	__asm        jmp    _FOR_NEXT_3f3;
// LINE 566:
_T420:
	__asm        cmp    i, 0x50;
	__asm        jne    _T431;
// LINE 567:
	return 0x0;
// LINE 569:
_T431:
	smoke_size = 0x8;
// LINE 571:
	md->flags = 0x40;
// LINE 575:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 576:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 577:
_FOR_481:
	i = 0x0;
	__asm        jmp    _FOR_COND_481;
_FOR_NEXT_481:
	i++;
_FOR_COND_481:
	__asm        mov    eax, i;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T4dd;
// LINE 579:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 580:
	finfo.Plotter = 0x1a;
// LINE 581:
	finfo.Bitmap = 0x0;
// LINE 582:
	finfo.Attribute = (finfo.Attribute & 0x7fffffff);
// LINE 583:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 584:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 585:
	__asm        jmp    _FOR_NEXT_481;
// LINE 587:
_T4dd:
	S_num_active_bullets++;
// LINE 589:
	__asm        jmp    _Tab6;
_T4e9:
	__asm        cmp    msl_type, 7;
	__asm        jne    _T5ff;
// LINE 592:
_FOR_509:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_509;
_FOR_NEXT_509:
	i++;
	md += 0x48;
_FOR_COND_509:
	__asm        cmp    i, 0x50;
	__asm        jge    _T536;
// LINE 594:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T531;
// LINE 595:
	__asm        jmp    _T536;
// LINE 596:
_T531:
	__asm        jmp    _FOR_NEXT_509;
// LINE 599:
_T536:
	__asm        cmp    i, 0x50;
	__asm        jne    _T547;
// LINE 600:
	return 0x0;
// LINE 602:
_T547:
	smoke_size = 0x3;
// LINE 604:
	md->flags = 0x80;
// LINE 608:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 609:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 610:
_FOR_597:
	i = 0x0;
	__asm        jmp    _FOR_COND_597;
_FOR_NEXT_597:
	i++;
_FOR_COND_597:
	__asm        mov    eax, i;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T5f3;
// LINE 612:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 613:
	finfo.Plotter = 0x1a;
// LINE 614:
	finfo.Bitmap = 0x3;
// LINE 615:
	finfo.Attribute = (finfo.Attribute & 0x7fffffff);
// LINE 616:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 617:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 618:
	__asm        jmp    _FOR_NEXT_597;
// LINE 620:
_T5f3:
	S_num_active_bullets++;
// LINE 622:
	__asm        jmp    _Tab6;
_T5ff:
	__asm        cmp    msl_type, 9;
	__asm        jne    _T792;
// LINE 625:
_FOR_61f:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_61f;
_FOR_NEXT_61f:
	i++;
	md += 0x48;
_FOR_COND_61f:
	__asm        cmp    i, 0x50;
	__asm        jge    _T64c;
// LINE 627:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T647;
// LINE 628:
	__asm        jmp    _T64c;
// LINE 629:
_T647:
	__asm        jmp    _FOR_NEXT_61f;
// LINE 632:
_T64c:
	__asm        cmp    i, 0x50;
	__asm        jne    _T65d;
// LINE 633:
	return 0x0;
// LINE 635:
_T65d:
	smoke_size = 0x4;
// LINE 637:
	md->flags = 0x200;
// LINE 641:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 642:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 643:
_FOR_6ad:
	i = 0x0;
	__asm        jmp    _FOR_COND_6ad;
_FOR_NEXT_6ad:
	i++;
_FOR_COND_6ad:
	__asm        mov    eax, i;
	__asm        cmp    oinfo.Faces, eax;
	__asm        jle    _T786;
// LINE 645:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 646:
	finfo.Plotter = 0x1a;
// LINE 647:
	finfo.Bitmap = 0x5;
// LINE 648:
	finfo.Attribute = (finfo.Attribute & 0x7fffffff);
// LINE 649:
	__asm        cmp    scale, 0;
	__asm        jne    _T6ff;
// LINE 651:
	finfo.Attribute = (finfo.Attribute | 0x80000000);
// LINE 653:
	__asm        jmp    _T762;
_T6ff:
	__asm        cmp    i, 1;
	__asm        jne    _T733;
// LINE 655:
	__asm        cmp    scale, 1;
	__asm        jg     _T723;
// LINE 656:
	finfo.Attribute = (finfo.Attribute | 0x80000000);
// LINE 657:
	__asm        jmp    _T72e;
// LINE 658:
_T723:
	finfo.Attribute = (finfo.Attribute & 0x7fffffff);
// LINE 660:
_T72e:
	__asm        jmp    _T762;
_T733:
	__asm        cmp    i, 1;
	__asm        jle    _T762;
// LINE 662:
	__asm        cmp    scale, 3;
	__asm        jg     _T757;
// LINE 663:
	finfo.Attribute = (finfo.Attribute | 0x80000000);
// LINE 664:
	__asm        jmp    _T762;
// LINE 665:
_T757:
	finfo.Attribute = (finfo.Attribute & 0x7fffffff);
// LINE 667:
_T762:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 668:
	__asm        mov    eax, face;
	__asm        push   eax;
	__asm        call   0x004D85F8;
	__asm        add    esp, 4;
	__asm        mov    face, eax;
// LINE 669:
	__asm        jmp    _FOR_NEXT_6ad;
// LINE 671:
_T786:
	S_num_active_bullets++;
// LINE 673:
	__asm        jmp    _Tab6;
_T792:
	__asm        cmp    msl_type, 3;
	__asm        jne    _T879;
// LINE 675:
	__asm        cmp    S_msl_fire_delay, 0;
	__asm        jle    _T7b0;
// LINE 676:
	return 0x0;
// LINE 678:
_T7b0:
	S_msl_fire_delay = 0x3333;
// LINE 681:
_FOR_7d0:
	i = 0x0;
	md = 0x66c5c0;
	__asm        jmp    _FOR_COND_7d0;
_FOR_NEXT_7d0:
	i++;
	md += 0x48;
_FOR_COND_7d0:
	__asm        cmp    i, 0xA;
	__asm        jge    _T7fd;
// LINE 683:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T7f8;
// LINE 684:
	__asm        jmp    _T7fd;
// LINE 685:
_T7f8:
	__asm        jmp    _FOR_NEXT_7d0;
// LINE 688:
_T7fd:
	__asm        cmp    i, 0xA;
	__asm        jne    _T80e;
// LINE 689:
	return 0x0;
// LINE 691:
_T80e:
	md->gas_on = 0x0;
// LINE 694:
	S3DSPlay(0x0, loc, 0x17);
// LINE 696:
	smoke_size = 0x4;
// LINE 698:
	S_num_active_teargas++;
// LINE 699:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        mov    [ebp-0xDC], eax;
	__asm        mov    eax, [ebp-0xDC];
	__asm        dec    dword ptr [eax+0x54];
// LINE 700:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jge    _T874;
// LINE 701:
	__asm        call   GetCurrentUserPersonalInfo;
	__asm        mov    [ebp-0xE0], eax;
	__asm        mov    eax, [ebp-0xE0];
	__asm        mov    dword ptr [eax+0x54], 0;
// LINE 703:
_T874:
	__asm        jmp    _Tab6;
_T879:
	__asm        cmp    msl_type, 4;
	__asm        jne    _T96d;
// LINE 706:
_FOR_899:
	i = 0x0;
	md = 0x66e270;
	__asm        jmp    _FOR_COND_899;
_FOR_NEXT_899:
	i++;
	md += 0x48;
_FOR_COND_899:
	__asm        cmp    i, 0x1E;
	__asm        jge    _T8c6;
// LINE 708:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T8c1;
// LINE 709:
	__asm        jmp    _T8c6;
// LINE 710:
_T8c1:
	__asm        jmp    _FOR_NEXT_899;
// LINE 713:
_T8c6:
	__asm        cmp    i, 0x1E;
	__asm        jne    _T8d7;
// LINE 714:
	return 0x0;
// LINE 716:
_T8d7:
	md->flags = 0x10;
// LINE 717:
	md->gas_on = 0x0;
// LINE 718:
	__asm        cmp    scale, 2;
	__asm        jle    _T906;
// LINE 719:
	smoke_size = 0x1;
// LINE 720:
	__asm        jmp    _T90d;
// LINE 721:
_T906:
	smoke_size = 0x4;
// LINE 724:
_T90d:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 725:
	md->dymissile->radius = (oinfo.Radius * scale);
// LINE 727:
	S_num_active_debris++;
// LINE 730:
	mp.op = 0x7;
// LINE 731:
	mp.id = reinterpret_cast<int16_t>(reinterpret_cast<uint16_t>(mission_id));
// LINE 732:
	mp.i2num = 0x1;
// LINE 733:
	mp.flags = 0x0;
// LINE 734:
	S3MissionUpdate(mp.op);
// LINE 736:
	__asm        jmp    _Tab6;
_T96d:
	__asm        cmp    msl_type, 0xA;
	__asm        jne    _Ta39;
// LINE 739:
_FOR_98d:
	i = 0x0;
	md = 0x66e270;
	__asm        jmp    _FOR_COND_98d;
_FOR_NEXT_98d:
	i++;
	md += 0x48;
_FOR_COND_98d:
	__asm        cmp    i, 0x1E;
	__asm        jge    _T9ba;
// LINE 741:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T9b5;
// LINE 742:
	__asm        jmp    _T9ba;
// LINE 743:
_T9b5:
	__asm        jmp    _FOR_NEXT_98d;
// LINE 746:
_T9ba:
	__asm        cmp    i, 0x1E;
	__asm        jne    _T9cb;
// LINE 747:
	return 0x0;
// LINE 749:
_T9cb:
	md->flags = 0x400;
// LINE 750:
	md->gas_on = 0x0;
// LINE 751:
	__asm        cmp    scale, 2;
	__asm        jle    _T9fa;
// LINE 752:
	smoke_size = 0x1;
// LINE 753:
	__asm        jmp    _Ta01;
// LINE 754:
_T9fa:
	smoke_size = 0x4;
// LINE 757:
_Ta01:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 758:
	md->dymissile->radius = (oinfo.Radius * scale);
// LINE 760:
	S_num_active_debris++;
// LINE 770:
	__asm        jmp    _Tab6;
_Ta39:
	__asm        cmp    msl_type, 8;
	__asm        jne    _Taaf;
// LINE 773:
_FOR_a59:
	i = 0x0;
	md = 0x66dfa0;
	__asm        jmp    _FOR_COND_a59;
_FOR_NEXT_a59:
	i++;
	md += 0x48;
_FOR_COND_a59:
	__asm        cmp    i, 0xA;
	__asm        jge    _Ta86;
// LINE 775:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _Ta81;
// LINE 776:
	__asm        jmp    _Ta86;
// LINE 777:
_Ta81:
	__asm        jmp    _FOR_NEXT_a59;
// LINE 780:
_Ta86:
	__asm        cmp    i, 0xA;
	__asm        jne    _Ta97;
// LINE 781:
	return 0x0;
// LINE 783:
_Ta97:
	md->flags = 0x100;
// LINE 785:
	S_num_active_traj++;
// LINE 787:
	__asm        jmp    _Tab6;
// LINE 789:
_Taaf:
	return 0x0;
// LINE 792:
_Tab6:
	__asm        mov    eax, celloc;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, celloc;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 793:
	__asm        mov    eax, celloc;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 794:
	md->dystarter = dystarter;
// LINE 795:
	md->scale = scale;
// LINE 796:
	md->mission_id = mission_id;
// LINE 799:
	__asm        mov    eax, md;
	__asm        or     dword ptr [eax], 1;
// LINE 800:
	md->animseq = 0x0;
// LINE 803:
	__asm        mov    eax, loc;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 804:
	__asm        mov    eax, vect;
	__asm        mov    ecx, md;
	__asm        add    ecx, 0x10;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 805:
	md->timetolive = 0x50000;
// LINE 806:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, sloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 807:
	md->speed = speed;
// LINE 808:
	__asm        cmp    msl_type, 1;
	__asm        jne    _Tbc4;
// LINE 810:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 812:
	__asm        jmp    _Te79;
_Tbc4:
	__asm        cmp    msl_type, 0xB;
	__asm        jne    _Tbe8;
// LINE 814:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 816:
	__asm        jmp    _Te79;
_Tbe8:
	__asm        cmp    msl_type, 3;
	__asm        jne    _Tc19;
// LINE 818:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 819:
	md->timetolive = 0x50000;
// LINE 821:
	__asm        jmp    _Te79;
_Tc19:
	__asm        cmp    msl_type, 4;
	__asm        jne    _Tc4e;
// LINE 823:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 824:
	md->timetolive = 0x1e0000;
// LINE 826:
	__asm        jmp    _Te79;
_Tc4e:
	__asm        cmp    msl_type, 0xA;
	__asm        jne    _Tc83;
// LINE 828:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 829:
	md->timetolive = 0x40000;
// LINE 831:
	__asm        jmp    _Te79;
_Tc83:
	__asm        cmp    msl_type, 5;
	__asm        jne    _Td1c;
// LINE 833:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 835:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0x1F;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        neg    eax;
	__asm        mov    rdist, eax;
// LINE 836:
	md->dymissile->loc.x += (md->vector.x * rdist);
// LINE 837:
	md->dymissile->loc.y += (md->vector.y * rdist);
// LINE 838:
	md->dymissile->loc.z += (md->vector.z * rdist);
// LINE 839:
	md->timetolive = 0x50000;
// LINE 841:
	__asm        jmp    _Te79;
_Td1c:
	__asm        cmp    msl_type, 6;
	__asm        jne    _Td51;
// LINE 843:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 844:
	md->timetolive = 0x50000;
// LINE 846:
	__asm        jmp    _Te79;
_Td51:
	__asm        cmp    msl_type, 7;
	__asm        jne    _Td86;
// LINE 848:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 849:
	md->timetolive = 0x1cccc;
// LINE 851:
	__asm        jmp    _Te79;
_Td86:
	__asm        cmp    msl_type, 9;
	__asm        jne    _Tdc7;
// LINE 853:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 854:
	md->timetolive = 0xe666;
// LINE 855:
	__asm        mov    eax, md;
	__asm        mov    cl, reinterpret_cast<uint8_t>(scale);
	__asm        shl    dword ptr [eax+0xC], cl;
// LINE 857:
	__asm        jmp    _Te79;
_Tdc7:
	__asm        cmp    msl_type, 8;
	__asm        jne    _Tdfc;
// LINE 859:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 860:
	md->timetolive = 0x60000;
// LINE 862:
	__asm        jmp    _Te79;
// LINE 864:
_Tdfc:
	MTCreateDOF4x4(vect, (md->dymissile + 0x24));
// LINE 866:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0x1F;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        neg    eax;
	__asm        mov    rdist, eax;
// LINE 867:
	md->dymissile->loc.x += (md->vector.x * rdist);
// LINE 868:
	md->dymissile->loc.y += (md->vector.y * rdist);
// LINE 869:
	md->dymissile->loc.z += (md->vector.z * rdist);
// LINE 876:
_Te79:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax+1], 1;
	__asm        je     _Te94;
// LINE 877:
	return md;
// LINE 881:
_Te94:
	__asm        cmp    msl_type, 7;
	__asm        je     _Tee5;
// LINE 883:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        add    sloc.x, eax;
// LINE 884:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        add    sloc.y, eax;
// LINE 885:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        add    sloc.z, eax;
// LINE 886:
	S3ExplosionSmokeStart(smoke_size, sloc.x, cptr);
// LINE 891:
_Tee5:
	md->smoketime = 0x8000;
// LINE 894:
	md->dymissile->next = cptr->dyptr;
// LINE 895:
	cptr->dyptr = md->dymissile;
// LINE 897:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 898:
	pos.scale.z = (md->scale << 0x10);
	pos.scale.y = pos.scale.z;
	pos.scale.x = pos.scale.y;
// LINE 899:
	__asm        mov    eax, md;
	__asm        mov    esi, [eax+0x28];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 900:
	__asm        push   1;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 902:
	return md;
// LINE 904:
}

// FUNCTION: COPTER_D 0x0051fe8a
void S3MissileDriver() {
	/*bp-0x4*/   /*packed*/ struct _CELL_FIRE_DATA *cfd;
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0xc*/   int32_t dist;
	/*bp-0x18*/  /*packed*/ struct Point3d tmploc; // 0xc bytes
	/*bp-0x24*/  /*packed*/ struct Point3d newloc; // 0xc bytes
	/*bp-0x2c*/  /*packed*/ struct Point2d newpos; // 0x8 bytes
	/*bp-0x30*/  long i;
	/*bp-0x48*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x4c*/  int32_t alt;
	/*bp-0x50*/  /*packed*/ struct _CELL_INFO *lcptr;
	/*bp-0x54*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x58*/  /*packed*/ struct _DYOBJ_INST **dyptrptr;
	/*bp-0xb0*/  /*packed*/ struct VRview pos; // 0x58 bytes
	/*bp-0xb4*/  /*packed*/ struct _MISSILE_DATA *md;
	/*bp-0xb8*/  /*packed*/ struct _CELL_INFO *tmpcptr;

// LINE 926:
	__asm        cmp    S_msl_fire_delay, 0;
	__asm        jle    _T29;
// LINE 927:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        sub    S_msl_fire_delay, eax;
// LINE 931:
_T29:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+0x14C], 5;
	__asm        je     _T58;
// LINE 933:
	__asm        push   0x25;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _T58;
// LINE 935:
	S3DSStopPlay(0x25);
// LINE 939:
_T58:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+0x14C], 2;
	__asm        je     _FOR_9d;
// LINE 941:
	__asm        push   5;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        cmp    eax, 1;
	__asm        jne    _FOR_9d;
// LINE 943:
	S3DSStopPlay(0x5);
// LINE 948:
_FOR_9d:
	i = 0x0;
	md = 0x66e270;
	__asm        jmp    _FOR_COND_9d;
_FOR_NEXT_9d:
	i++;
	md += 0x48;
_FOR_COND_9d:
	__asm        cmp    i, 0x1E;
	__asm        jge    _FOR_a3c;

	__asm        movsx  eax, S_num_active_debris;
	__asm        test   eax, eax;
	__asm        jle    _FOR_a3c;
// LINE 950:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _Td4;
// LINE 951:
	__asm        jmp    _FOR_NEXT_9d;
// LINE 955:
_Td4:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0xC], 0x40000;
	__asm        jle    _T16d;
// LINE 957:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0x1C2;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 958:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0x1C2;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 959:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0x1C2;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 961:
	__asm        jmp    _T4c1;
// LINE 963:
_T16d:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 969:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0x38], 1;
	__asm        jne    _T44d;
// LINE 971:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+4], eax;
// LINE 972:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+8], eax;
// LINE 973:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 976:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jg     _T222;
// LINE 978:
	md->smoketime = 0x3333;
// LINE 979:
	S3MissileDebrisFire((md + 0x34), (md->dymissile + 0x18), cptr);
// LINE 982:
_T222:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jg     _T448;
// LINE 987:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x10;
	__asm        je     _T383;

	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        jne    _T383;

	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x2C];
	__asm        push   eax;
	__asm        call   S3FireCanCellBurn;
	__asm        add    esp, 8;
	__asm        cmp    eax, 1;
	__asm        jne    _T383;
// LINE 990:
	__asm        push   1;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        call   S3MissionIsType;
	__asm        add    esp, 8;
	__asm        test   eax, eax;
	__asm        je     _T2f4;
// LINE 992:
	__asm        call   S3FireGetCellData;
	__asm        mov    cfd, eax;
	__asm        cmp    cfd, 0;
	__asm        je     _T2ef;
// LINE 994:
	cfd->cptr = cptr;
// LINE 995:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T2ef;
// LINE 996:
	__asm        push   0;
	__asm        mov    eax, md;
	__asm        movsx  eax, word ptr [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x2C];
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStartCell;
	__asm        add    esp, 0x14;
// LINE 999:
_T2ef:
	__asm        jmp    _T383;
// LINE 1002:
_T2f4:
	__asm        call   S3FireGetCount;
	__asm        test   eax, eax;
	__asm        jne    _T324;
// LINE 1004:
	S3MissionStart(0x1, md->celloc.y, md->celloc.x);
// LINE 1006:
	__asm        jmp    _T383;
// LINE 1009:
_T324:
	__asm        call   S3FireGetCellData;
	__asm        mov    cfd, eax;
	__asm        cmp    cfd, 0;
	__asm        je     _T383;
// LINE 1011:
	cfd->cptr = cptr;
// LINE 1012:
	__asm        call   rand;
	__asm        mov    ecx, 0xA;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        test   edx, edx;
	__asm        jne    _T383;
// LINE 1013:
	__asm        push   0;
	__asm        mov    eax, md;
	__asm        movsx  eax, word ptr [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x2C];
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStartCell;
	__asm        add    esp, 0x14;
// LINE 1020:
_T383:
	dyptrptr = (cptr + 0x10);
// LINE 1021:
__WHILE_38c:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T3ce;
// LINE 1023:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T3c1;
// LINE 1025:
	dyptrptr-> = md->dymissile->next;
// LINE 1026:
	__asm        jmp    _T3ce;
// LINE 1028:
_T3c1:
	dyptrptr = dyptrptr->;
// LINE 1029:
	__asm        jmp    __WHILE_38c;
// LINE 1032:
_T3ce:
	S_num_active_debris--;
// LINE 1035:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x10;
	__asm        je     _T411;
// LINE 1037:
	mp.op = 0x8;
// LINE 1038:
	mp.id = md->mission_id;
// LINE 1039:
	mp.i2num = 0x1;
// LINE 1040:
	mp.flags = 0x0;
// LINE 1041:
	S3MissionUpdate(mp.op);
// LINE 1044:
_T411:
	md->flags = (md->flags & -0x2);
// LINE 1045:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        and    eax, 0xEFFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xC], ax;
// LINE 1047:
	__asm        jmp    _FOR_NEXT_9d;
// LINE 1050:
_T448:
	__asm        jmp    _T4c1;
// LINE 1052:
_T44d:
	md->speed = 0x0;
// LINE 1053:
	md->gas_on = 0x1;
// LINE 1054:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x10;
	__asm        je     _T488;
// LINE 1055:
	md->timetolive = 0x3c0000;
// LINE 1056:
	__asm        jmp    _T495;
// LINE 1057:
_T488:
	md->timetolive = 0x0;
// LINE 1058:
_T495:
	md->smoketime = 0x8000;
// LINE 1059:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        or     eax, 0x1000;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xC], ax;
// LINE 1063:
_T4c1:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jle    _T90b;
// LINE 1067:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0x28F;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, md;
	__asm        sub    [eax+0xC], ebx;
// LINE 1069:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x10], eax;
// LINE 1071:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x280000;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, md;
	__asm        mov    [eax+0x14], ebx;
// LINE 1072:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x18], eax;
// LINE 1073:
	md->speed = MTNormalize((md + 0x10));
// LINE 1076:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dist, eax;
// LINE 1077:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    newloc.x, ecx;
// LINE 1078:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    newloc.y, ecx;
// LINE 1079:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    newloc.z, ecx;
// LINE 1081:
	newpos.x = ((newloc.x + 0x20000000) >> 0x16);
// LINE 1082:
	newpos.y = ((0x20000000 - newloc.z) >> 0x16);
// LINE 1083:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    lcptr, eax;
// LINE 1084:
	__asm        mov    eax, newpos.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, newpos.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1087:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+8], eax;
// LINE 1089:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jge    _T729;

	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        jne    _T729;
// LINE 1091:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0x44], 2;
	__asm        jle    _T6f8;
// LINE 1093:
	S3ExplosionSmokeStart(0x1, newloc.x, cptr);
// LINE 1094:
	S3ExplosionSmokeStart(0x5, newloc.x, cptr);
// LINE 1096:
	__asm        jmp    _T71c;
// LINE 1098:
_T6f8:
	S3ExplosionSmokeStart(0x4, newloc.x, cptr);
// LINE 1099:
	S3ExplosionSmokeStart(0x5, newloc.x, cptr);
// LINE 1101:
_T71c:
	md->smoketime = 0x8000;
// LINE 1106:
_T729:
	__asm        mov    eax, lcptr;
	__asm        push   eax;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissileCollisionCheck;
	__asm        add    esp, 0xC;
	__asm        cmp    eax, 1;
	__asm        jne    _T7ae;
// LINE 1108:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T75d;
// LINE 1110:
	__asm        jmp    debris_unlink_next;
// LINE 1113:
_T75d:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0xC20C;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0xC], eax;
// LINE 1115:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0xC], 0x140000;
	__asm        jle    _T7a9;
// LINE 1116:
	S3DSPlay(0x0, (md->dymissile + 0x18), 0x16);
// LINE 1119:
_T7a9:
	__asm        jmp    _T83a;
_T7ae:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T83a;
// LINE 1121:
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissileCollisionCheck;
	__asm        add    esp, 0xC;
	__asm        cmp    eax, 1;
	__asm        jne    _T83a;
// LINE 1123:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T7ee;
// LINE 1125:
	__asm        jmp    debris_unlink_next;
// LINE 1128:
_T7ee:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0xC20C;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0xC], eax;
// LINE 1130:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0xC], 0x140000;
	__asm        jle    _T83a;
// LINE 1131:
	S3DSPlay(0x0, (md->dymissile + 0x18), 0x16);
// LINE 1137:
_T83a:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T8b1;
// LINE 1139:
	dyptrptr = (lcptr + 0x10);
// LINE 1140:
__WHILE_84f:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T891;
// LINE 1142:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T884;
// LINE 1144:
	dyptrptr-> = md->dymissile->next;
// LINE 1145:
	__asm        jmp    _T891;
// LINE 1147:
_T884:
	dyptrptr = dyptrptr->;
// LINE 1148:
	__asm        jmp    __WHILE_84f;
// LINE 1150:
_T891:
	md->dymissile->next = cptr->dyptr;
// LINE 1151:
	cptr->dyptr = md->dymissile;
// LINE 1156:
_T8b1:
	alt = S3TerrPrecisionAlt(0x0, newloc.z, newloc.x);
// LINE 1157:
	__asm        mov    eax, alt;
	__asm        cmp    newloc.y, eax;
	__asm        jge    _T8d8;

	newloc.y = alt;
// LINE 1158:
_T8d8:
	__asm        mov    eax, newpos.x;
	__asm        mov    ecx, newpos.y;
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 1159:
	__asm        lea    eax, newloc.x;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1161:
_T90b:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1162:
	pos.scale.z = (md->scale << 0x10);
	pos.scale.y = pos.scale.z;
	pos.scale.x = pos.scale.y;
// LINE 1163:
	__asm        mov    eax, md;
	__asm        mov    esi, [eax+0x28];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1164:
	__asm        push   1;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1166:
	__asm        jmp    _FOR_NEXT_9d;
// LINE 1168:
debris_unlink_next:
	S_num_active_debris--;
// LINE 1172:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x10;
	__asm        je     _T9d6;
// LINE 1174:
	mp.op = 0x20;
// LINE 1175:
	mp.id = md->mission_id;
// LINE 1176:
	mp.i2num = 0x1;
// LINE 1177:
	mp.flags = 0x0;
// LINE 1178:
	S3MissionUpdate(mp.op);
// LINE 1181:
_T9d6:
	dyptrptr = (lcptr + 0x10);
// LINE 1182:
__WHILE_9df:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Ta21;
// LINE 1184:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _Ta14;
// LINE 1186:
	dyptrptr-> = md->dymissile->next;
// LINE 1187:
	__asm        jmp    _Ta21;
// LINE 1189:
_Ta14:
	dyptrptr = dyptrptr->;
// LINE 1190:
	__asm        jmp    __WHILE_9df;
// LINE 1191:
_Ta21:
	__asm        jmp    _FOR_NEXT_9d;
// LINE 1194:
_FOR_a3c:
	i = 0x0;
	md = 0x66c5c0;
	__asm        jmp    _FOR_COND_a3c;
_FOR_NEXT_a3c:
	i++;
	md += 0x48;
_FOR_COND_a3c:
	__asm        cmp    i, 0xA;
	__asm        jge    _FOR_1137;

	__asm        movsx  eax, S_num_active_teargas;
	__asm        test   eax, eax;
	__asm        jle    _FOR_1137;
// LINE 1196:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _Ta73;
// LINE 1197:
	__asm        jmp    _FOR_NEXT_a3c;
// LINE 1201:
_Ta73:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+4], eax;
// LINE 1202:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jg     _Tb7f;
// LINE 1204:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0x38], 1;
	__asm        jne    _Tb3f;
// LINE 1206:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1208:
	dyptrptr = (cptr + 0x10);
// LINE 1209:
__WHILE_ad9:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Tb1b;
// LINE 1211:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _Tb0e;
// LINE 1213:
	dyptrptr-> = md->dymissile->next;
// LINE 1214:
	__asm        jmp    _Tb1b;
// LINE 1216:
_Tb0e:
	dyptrptr = dyptrptr->;
// LINE 1217:
	__asm        jmp    __WHILE_ad9;
// LINE 1219:
_Tb1b:
	S_num_active_teargas--;
// LINE 1220:
	md->flags = (md->flags & -0x2);
// LINE 1222:
	__asm        jmp    _FOR_NEXT_a3c;
// LINE 1224:
	__asm        jmp    _Tb7f;
// LINE 1226:
_Tb3f:
	md->gas_on = 0x1;
// LINE 1227:
	md->timetolive = 0x1e0000;
// LINE 1228:
	md->smoketime = 0x0;
// LINE 1230:
	S3DSPlay(0x0, (md->dymissile + 0x18), 0x18);
// LINE 1236:
_Tb7f:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0x28F;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, md;
	__asm        sub    [eax+0xC], ebx;
// LINE 1238:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x10], eax;
// LINE 1240:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x280000;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, md;
	__asm        mov    [eax+0x14], ebx;
// LINE 1241:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x18], eax;
// LINE 1242:
	md->speed = MTNormalize((md + 0x10));
// LINE 1245:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dist, eax;
// LINE 1246:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    newloc.x, ecx;
// LINE 1247:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    newloc.y, ecx;
// LINE 1248:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    newloc.z, ecx;
// LINE 1250:
	newpos.x = ((newloc.x + 0x20000000) >> 0x16);
// LINE 1251:
	newpos.y = ((0x20000000 - newloc.z) >> 0x16);
// LINE 1252:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    lcptr, eax;
// LINE 1253:
	__asm        mov    eax, newpos.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, newpos.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1256:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+8], eax;
// LINE 1259:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jge    _Te8a;
// LINE 1261:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        jne    _Td91;
// LINE 1263:
	S3ExplosionSmokeStart(0x4, newloc.x, cptr);
// LINE 1264:
	md->smoketime = 0x8000;
// LINE 1266:
	__asm        jmp    _Te8a;
// LINE 1268:
_Td91:
	__asm        lea    eax, newloc.x;
	__asm        lea    ecx, tmploc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1269:
	__asm        mov    ebx, 0x14;
	__asm        call   rand;
	__asm        mov    ecx, 0x28;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        shl    ebx, 0x10;
	__asm        add    tmploc.x, ebx;
// LINE 1270:
	__asm        mov    ebx, 0x14;
	__asm        call   rand;
	__asm        mov    ecx, 0x28;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        sub    ebx, edx;
	__asm        shl    ebx, 0x10;
	__asm        add    tmploc.z, ebx;
// LINE 1272:
	__asm        mov    eax, tmploc.x;
	__asm        add    eax, 0x20000000;
	__asm        shr    eax, 0x16;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, 0x20000000;
	__asm        sub    ecx, tmploc.z;
	__asm        shr    ecx, 0x16;
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    tmpcptr, eax;
// LINE 1273:
	S3ExplosionSmokeStart(0x9, tmploc.x, tmpcptr);
// LINE 1274:
	md->smoketime = 0x4ccc;
// LINE 1278:
	dyobj = tmpcptr->dyptr;
// LINE 1279:
__WHILE_e40:
	__asm        cmp    dyobj, 0;
	__asm        je     _Te8a;
// LINE 1281:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _Te7d;
// LINE 1283:
	S3ObjHitDispatch(0x0, md->mission_id, dyobj, md->dymissile, 0x5);
// LINE 1285:
_Te7d:
	dyobj = dyobj->next;
// LINE 1286:
	__asm        jmp    __WHILE_e40;
// LINE 1293:
_Te8a:
	__asm        mov    eax, lcptr;
	__asm        push   eax;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissileCollisionCheck;
	__asm        add    esp, 0xC;
	__asm        cmp    eax, 1;
	__asm        jne    _Tf0f;
// LINE 1295:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _Tebe;
// LINE 1297:
	__asm        jmp    teargas_unlink_next;
// LINE 1300:
_Tebe:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0xC20C;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0xC], eax;
// LINE 1302:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0xC], 0x140000;
	__asm        jle    _Tf0a;
// LINE 1303:
	S3DSPlay(0x0, (md->dymissile + 0x18), 0x16);
// LINE 1306:
_Tf0a:
	__asm        jmp    _Tf9b;
_Tf0f:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _Tf9b;
// LINE 1308:
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissileCollisionCheck;
	__asm        add    esp, 0xC;
	__asm        cmp    eax, 1;
	__asm        jne    _Tf9b;
// LINE 1310:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _Tf4f;
// LINE 1312:
	__asm        jmp    teargas_unlink_next;
// LINE 1315:
_Tf4f:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0xC20C;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0xC], eax;
// LINE 1317:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0xC], 0x140000;
	__asm        jle    _Tf9b;
// LINE 1318:
	S3DSPlay(0x0, (md->dymissile + 0x18), 0x16);
// LINE 1324:
_Tf9b:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T1012;
// LINE 1326:
	dyptrptr = (lcptr + 0x10);
// LINE 1327:
__WHILE_fb0:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Tff2;
// LINE 1329:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _Tfe5;
// LINE 1331:
	dyptrptr-> = md->dymissile->next;
// LINE 1332:
	__asm        jmp    _Tff2;
// LINE 1334:
_Tfe5:
	dyptrptr = dyptrptr->;
// LINE 1335:
	__asm        jmp    __WHILE_fb0;
// LINE 1337:
_Tff2:
	md->dymissile->next = cptr->dyptr;
// LINE 1338:
	cptr->dyptr = md->dymissile;
// LINE 1342:
_T1012:
	alt = S3TerrPrecisionAlt(0x0, newloc.z, newloc.x);
// LINE 1343:
	__asm        mov    eax, alt;
	__asm        cmp    newloc.y, eax;
	__asm        jge    _T1039;

	newloc.y = alt;
// LINE 1344:
_T1039:
	__asm        mov    eax, newpos.x;
	__asm        mov    ecx, newpos.y;
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 1345:
	__asm        lea    eax, newloc.x;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1346:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1347:
	__asm        mov    eax, md;
	__asm        mov    esi, [eax+0x28];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1348:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1350:
	__asm        jmp    _FOR_NEXT_a3c;
// LINE 1353:
teargas_unlink_next:
	S_num_active_teargas--;
// LINE 1354:
	dyptrptr = (lcptr + 0x10);
// LINE 1355:
__WHILE_10da:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T111c;
// LINE 1357:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T110f;
// LINE 1359:
	dyptrptr-> = md->dymissile->next;
// LINE 1360:
	__asm        jmp    _T111c;
// LINE 1362:
_T110f:
	dyptrptr = dyptrptr->;
// LINE 1363:
	__asm        jmp    __WHILE_10da;
// LINE 1365:
_T111c:
	__asm        jmp    _FOR_NEXT_a3c;
// LINE 1368:
_FOR_1137:
	i = 0x0;
	md = 0x66c2f0;
	__asm        jmp    _FOR_COND_1137;
_FOR_NEXT_1137:
	i++;
	md += 0x48;
_FOR_COND_1137:
	__asm        cmp    i, 0xA;
	__asm        jge    _FOR_1532;

	__asm        movsx  eax, S_num_active_missiles;
	__asm        test   eax, eax;
	__asm        jle    _FOR_1532;
// LINE 1370:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T116e;
// LINE 1371:
	__asm        jmp    _FOR_NEXT_1137;
// LINE 1374:
_T116e:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+4], eax;
// LINE 1375:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jg     _T1225;
// LINE 1377:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1379:
	dyptrptr = (cptr + 0x10);
// LINE 1380:
__WHILE_11c4:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T1206;
// LINE 1382:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T11f9;
// LINE 1384:
	dyptrptr-> = md->dymissile->next;
// LINE 1385:
	__asm        jmp    _T1206;
// LINE 1387:
_T11f9:
	dyptrptr = dyptrptr->;
// LINE 1388:
	__asm        jmp    __WHILE_11c4;
// LINE 1390:
_T1206:
	S_num_active_missiles--;
// LINE 1391:
	md->flags = (md->flags & -0x2);
// LINE 1393:
	__asm        jmp    _FOR_NEXT_1137;
// LINE 1397:
_T1225:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dist, eax;
// LINE 1398:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    newloc.x, ecx;
// LINE 1399:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    newloc.y, ecx;
// LINE 1400:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    newloc.z, ecx;
// LINE 1402:
	newpos.x = ((newloc.x + 0x20000000) >> 0x16);
// LINE 1403:
	newpos.y = ((0x20000000 - newloc.z) >> 0x16);
// LINE 1404:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    lcptr, eax;
// LINE 1405:
	__asm        mov    eax, newpos.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, newpos.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1408:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+8], eax;
// LINE 1411:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jge    _T135b;
// LINE 1413:
	S3ExplosionSmokeStart(0x4, newloc.x, cptr);
// LINE 1414:
	md->smoketime = 0x3333;
// LINE 1418:
_T135b:
	S3MissileCollisionCheck(lcptr, dist, md);
// LINE 1419:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T1386;
// LINE 1421:
	__asm        jmp    missile_unlink_next;
// LINE 1425:
_T1386:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T13bd;
// LINE 1427:
	S3MissileCollisionCheck(cptr, dist, md);
// LINE 1428:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T13bd;
// LINE 1429:
	__asm        jmp    missile_unlink_next;
// LINE 1433:
_T13bd:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T1434;
// LINE 1435:
	dyptrptr = (lcptr + 0x10);
// LINE 1436:
__WHILE_13d2:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T1414;
// LINE 1438:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T1407;
// LINE 1440:
	dyptrptr-> = md->dymissile->next;
// LINE 1441:
	__asm        jmp    _T1414;
// LINE 1443:
_T1407:
	dyptrptr = dyptrptr->;
// LINE 1444:
	__asm        jmp    __WHILE_13d2;
// LINE 1446:
_T1414:
	md->dymissile->next = cptr->dyptr;
// LINE 1447:
	cptr->dyptr = md->dymissile;
// LINE 1451:
_T1434:
	__asm        mov    eax, newpos.x;
	__asm        mov    ecx, newpos.y;
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 1452:
	__asm        lea    eax, newloc.x;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1453:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1454:
	__asm        mov    eax, md;
	__asm        mov    esi, [eax+0x28];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1455:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1458:
	__asm        jmp    _FOR_NEXT_1137;
// LINE 1463:
missile_unlink_next:
	S_num_active_missiles--;
// LINE 1464:
	dyptrptr = (lcptr + 0x10);
// LINE 1465:
__WHILE_14d5:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T1517;
// LINE 1467:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T150a;
// LINE 1469:
	dyptrptr-> = md->dymissile->next;
// LINE 1470:
	__asm        jmp    _T1517;
// LINE 1472:
_T150a:
	dyptrptr = dyptrptr->;
// LINE 1473:
	__asm        jmp    __WHILE_14d5;
// LINE 1474:
_T1517:
	__asm        jmp    _FOR_NEXT_1137;
// LINE 1477:
_FOR_1532:
	i = 0x0;
	md = 0x66c890;
	__asm        jmp    _FOR_COND_1532;
_FOR_NEXT_1532:
	i++;
	md += 0x48;
_FOR_COND_1532:
	__asm        cmp    i, 2;
	__asm        jge    _FOR_18eb;

	__asm        movsx  eax, S_num_active_lasers;
	__asm        test   eax, eax;
	__asm        jle    _FOR_18eb;
// LINE 1479:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T1569;
// LINE 1480:
	__asm        jmp    _FOR_NEXT_1532;
// LINE 1483:
_T1569:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+4], eax;
// LINE 1484:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jg     _T1620;
// LINE 1486:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1488:
	dyptrptr = (cptr + 0x10);
// LINE 1489:
__WHILE_15bf:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T1601;
// LINE 1491:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T15f4;
// LINE 1493:
	dyptrptr-> = md->dymissile->next;
// LINE 1494:
	__asm        jmp    _T1601;
// LINE 1496:
_T15f4:
	dyptrptr = dyptrptr->;
// LINE 1497:
	__asm        jmp    __WHILE_15bf;
// LINE 1499:
_T1601:
	S_num_active_lasers--;
// LINE 1500:
	md->flags = (md->flags & -0x2);
// LINE 1502:
	__asm        jmp    _FOR_NEXT_1532;
// LINE 1506:
_T1620:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dist, eax;
// LINE 1507:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    newloc.x, ecx;
// LINE 1508:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    newloc.y, ecx;
// LINE 1509:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    newloc.z, ecx;
// LINE 1511:
	newpos.x = ((newloc.x + 0x20000000) >> 0x16);
// LINE 1512:
	newpos.y = ((0x20000000 - newloc.z) >> 0x16);
// LINE 1513:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    lcptr, eax;
// LINE 1514:
	__asm        mov    eax, newpos.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, newpos.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1517:
	S3MissileCollisionCheck(lcptr, dist, md);
// LINE 1518:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T173f;
// LINE 1520:
	__asm        jmp    laser_unlink_next;
// LINE 1524:
_T173f:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T1776;
// LINE 1526:
	S3MissileCollisionCheck(cptr, dist, md);
// LINE 1527:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T1776;
// LINE 1528:
	__asm        jmp    laser_unlink_next;
// LINE 1532:
_T1776:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T17ed;
// LINE 1534:
	dyptrptr = (lcptr + 0x10);
// LINE 1535:
__WHILE_178b:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T17cd;
// LINE 1537:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T17c0;
// LINE 1539:
	dyptrptr-> = md->dymissile->next;
// LINE 1540:
	__asm        jmp    _T17cd;
// LINE 1542:
_T17c0:
	dyptrptr = dyptrptr->;
// LINE 1543:
	__asm        jmp    __WHILE_178b;
// LINE 1545:
_T17cd:
	md->dymissile->next = cptr->dyptr;
// LINE 1546:
	cptr->dyptr = md->dymissile;
// LINE 1550:
_T17ed:
	__asm        mov    eax, newpos.x;
	__asm        mov    ecx, newpos.y;
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 1551:
	__asm        lea    eax, newloc.x;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1552:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1553:
	__asm        mov    eax, md;
	__asm        mov    esi, [eax+0x28];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1554:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1557:
	__asm        jmp    _FOR_NEXT_1532;
// LINE 1562:
laser_unlink_next:
	S_num_active_lasers--;
// LINE 1563:
	dyptrptr = (lcptr + 0x10);
// LINE 1564:
__WHILE_188e:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T18d0;
// LINE 1566:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T18c3;
// LINE 1568:
	dyptrptr-> = md->dymissile->next;
// LINE 1569:
	__asm        jmp    _T18d0;
// LINE 1571:
_T18c3:
	dyptrptr = dyptrptr->;
// LINE 1572:
	__asm        jmp    __WHILE_188e;
// LINE 1573:
_T18d0:
	__asm        jmp    _FOR_NEXT_1532;
// LINE 1576:
_FOR_18eb:
	i = 0x0;
	md = 0x66c920;
	__asm        jmp    _FOR_COND_18eb;
_FOR_NEXT_18eb:
	i++;
	md += 0x48;
_FOR_COND_18eb:
	__asm        cmp    i, 0x50;
	__asm        jge    _FOR_1ea4;

	__asm        movsx  eax, S_num_active_bullets;
	__asm        test   eax, eax;
	__asm        jle    _FOR_1ea4;
// LINE 1578:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T1922;
// LINE 1579:
	__asm        jmp    _FOR_NEXT_18eb;
// LINE 1582:
_T1922:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+4], eax;
// LINE 1583:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jg     _T19d9;
// LINE 1585:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1587:
	dyptrptr = (cptr + 0x10);
// LINE 1588:
__WHILE_1978:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T19ba;
// LINE 1590:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T19ad;
// LINE 1592:
	dyptrptr-> = md->dymissile->next;
// LINE 1593:
	__asm        jmp    _T19ba;
// LINE 1595:
_T19ad:
	dyptrptr = dyptrptr->;
// LINE 1596:
	__asm        jmp    __WHILE_1978;
// LINE 1598:
_T19ba:
	S_num_active_bullets--;
// LINE 1599:
	md->flags = (md->flags & -0x2);
// LINE 1601:
	__asm        jmp    _FOR_NEXT_18eb;
// LINE 1605:
_T19d9:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x20;
	__asm        je     _T1ab4;
// LINE 1607:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0x51E;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, md;
	__asm        sub    [eax+0xC], ebx;
// LINE 1609:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x10], eax;
// LINE 1611:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x280000;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, md;
	__asm        mov    [eax+0x14], ebx;
// LINE 1612:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x18], eax;
// LINE 1613:
	md->speed = MTNormalize((md + 0x10));
// LINE 1615:
	__asm        jmp    _T1bd9;
_T1ab4:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x40;
	__asm        je     _T1b8f;
// LINE 1617:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0x28F;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, md;
	__asm        sub    [eax+0xC], ebx;
// LINE 1619:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x10], eax;
// LINE 1621:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x280000;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, md;
	__asm        mov    [eax+0x14], ebx;
// LINE 1622:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x18], eax;
// LINE 1623:
	md->speed = MTNormalize((md + 0x10));
// LINE 1625:
	__asm        jmp    _T1bd9;
_T1b8f:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x80;
	__asm        je     _T1ba3;
// LINE 1638:
	__asm        jmp    _T1bd9;
_T1ba3:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax+1], 2;
	__asm        je     _T1bd9;
// LINE 1640:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0xA3C;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, md;
	__asm        sub    [eax+0xC], ebx;
// LINE 1645:
_T1bd9:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dist, eax;
// LINE 1646:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    newloc.x, ecx;
// LINE 1647:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    newloc.y, ecx;
// LINE 1648:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    newloc.z, ecx;
// LINE 1650:
	newpos.x = ((newloc.x + 0x20000000) >> 0x16);
// LINE 1651:
	newpos.y = ((0x20000000 - newloc.z) >> 0x16);
// LINE 1652:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    lcptr, eax;
// LINE 1653:
	__asm        mov    eax, newpos.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, newpos.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1656:
	S3MissileCollisionCheck(lcptr, dist, md);
// LINE 1657:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T1cf8;
// LINE 1659:
	__asm        jmp    bullet_unlink_next;
// LINE 1662:
_T1cf8:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T1d2f;
// LINE 1664:
	S3MissileCollisionCheck(cptr, dist, md);
// LINE 1665:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T1d2f;
// LINE 1666:
	__asm        jmp    bullet_unlink_next;
// LINE 1670:
_T1d2f:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T1da6;
// LINE 1672:
	dyptrptr = (lcptr + 0x10);
// LINE 1673:
__WHILE_1d44:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T1d86;
// LINE 1675:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T1d79;
// LINE 1677:
	dyptrptr-> = md->dymissile->next;
// LINE 1678:
	__asm        jmp    _T1d86;
// LINE 1680:
_T1d79:
	dyptrptr = dyptrptr->;
// LINE 1681:
	__asm        jmp    __WHILE_1d44;
// LINE 1683:
_T1d86:
	md->dymissile->next = cptr->dyptr;
// LINE 1684:
	cptr->dyptr = md->dymissile;
// LINE 1688:
_T1da6:
	__asm        mov    eax, newpos.x;
	__asm        mov    ecx, newpos.y;
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 1689:
	__asm        lea    eax, newloc.x;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1690:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1691:
	__asm        mov    eax, md;
	__asm        mov    esi, [eax+0x28];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 1692:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 1693:
	__asm        jmp    _FOR_NEXT_18eb;
// LINE 1698:
bullet_unlink_next:
	S_num_active_bullets--;
// LINE 1699:
	dyptrptr = (lcptr + 0x10);
// LINE 1700:
__WHILE_1e47:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T1e89;
// LINE 1702:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T1e7c;
// LINE 1704:
	dyptrptr-> = md->dymissile->next;
// LINE 1705:
	__asm        jmp    _T1e89;
// LINE 1707:
_T1e7c:
	dyptrptr = dyptrptr->;
// LINE 1708:
	__asm        jmp    __WHILE_1e47;
// LINE 1709:
_T1e89:
	__asm        jmp    _FOR_NEXT_18eb;
// LINE 1712:
_FOR_1ea4:
	i = 0x0;
	md = 0x66dfa0;
	__asm        jmp    _FOR_COND_1ea4;
_FOR_NEXT_1ea4:
	i++;
	md += 0x48;
_FOR_COND_1ea4:
	__asm        cmp    i, 0xA;
	__asm        jge    _T2202;

	__asm        movsx  eax, S_num_active_traj;
	__asm        test   eax, eax;
	__asm        jle    _T2202;
// LINE 1714:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T1edb;
// LINE 1715:
	__asm        jmp    _FOR_NEXT_1ea4;
// LINE 1719:
_T1edb:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+4], eax;
// LINE 1720:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jg     _T1f1d;
// LINE 1722:
	S_num_active_traj--;
// LINE 1723:
	md->flags = (md->flags & -0x2);
// LINE 1724:
	__asm        jmp    _FOR_NEXT_1ea4;
// LINE 1728:
_T1f1d:
	__asm        xor    ebx, ebx;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0x28F;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    eax, md;
	__asm        sub    [eax+0xC], ebx;
// LINE 1730:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x10], eax;
// LINE 1732:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        push   0x280000;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        sub    ebx, eax;
	__asm        mov    eax, md;
	__asm        mov    [eax+0x14], ebx;
// LINE 1733:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0x18], eax;
// LINE 1734:
	md->speed = MTNormalize((md + 0x10));
// LINE 1737:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    dist, eax;
// LINE 1738:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    newloc.x, ecx;
// LINE 1739:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    newloc.y, ecx;
// LINE 1740:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    newloc.z, ecx;
// LINE 1742:
	newpos.x = ((newloc.x + 0x20000000) >> 0x16);
// LINE 1743:
	newpos.y = ((0x20000000 - newloc.z) >> 0x16);
// LINE 1744:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    lcptr, eax;
// LINE 1745:
	__asm        mov    eax, newpos.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, newpos.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 1748:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, md;
	__asm        sub    [ecx+8], eax;
// LINE 1751:
	md->gas_on = 0x0;
// LINE 1754:
	__asm        mov    eax, lcptr;
	__asm        push   eax;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissileCollisionCheck;
	__asm        add    esp, 0xC;
	__asm        cmp    eax, 1;
	__asm        jne    _T214a;
// LINE 1757:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0xC20C;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0xC], eax;
// LINE 1758:
	md->gas_on = 0x1;
// LINE 1760:
	__asm        jmp    _T21a3;
_T214a:
	__asm        mov    eax, lcptr;
	__asm        cmp    cptr, eax;
	__asm        je     _T21a3;
// LINE 1762:
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissileCollisionCheck;
	__asm        add    esp, 0xC;
	__asm        cmp    eax, 1;
	__asm        jne    _T21a3;
// LINE 1765:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        push   0xC20C;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    [ecx+0xC], eax;
// LINE 1766:
	md->gas_on = 0x1;
// LINE 1769:
_T21a3:
	alt = S3TerrPrecisionAlt(0x0, newloc.z, newloc.x);
// LINE 1770:
	__asm        mov    eax, alt;
	__asm        cmp    newloc.y, eax;
	__asm        jge    _T21ca;

	newloc.y = alt;
// LINE 1771:
_T21ca:
	__asm        mov    eax, newpos.x;
	__asm        mov    ecx, newpos.y;
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 1772:
	__asm        lea    eax, newloc.x;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1774:
	__asm        jmp    _FOR_NEXT_1ea4;
// LINE 1776:
_T2202:
	return;
// LINE 1777:
}

// FUNCTION: COPTER_D 0x00522096
int32_t S3MissileCollisionCheck(/*packed*/ struct _MISSILE_DATA *md, int32_t dist, /*packed*/ struct _CELL_INFO *cptr) {
	/*bp-0x4*/   /*packed*/ struct Point3d *norm;
	/*bp-0x28*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x2c*/  /*packed*/ struct _CELL_FIRE_DATA *cfd;
	/*bp-0x30*/  long hit_type;
	/*bp-0x3c*/  /*packed*/ struct Point3d sloc; // 0xc bytes
	/*bp-0x48*/  /*packed*/ struct Point3d cloc; // 0xc bytes
	/*bp-0x4c*/  /*packed*/ struct _DYOBJ_INST *dyobj;
	/*bp-0x50*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x90*/  int32_t refmat[4][4]; // 0x40 bytes
	/*bp-0x9c*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0xa8*/  /*packed*/ struct Point3d center; // 0xc bytes
	/*bp-0xb0*/  /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*bp-0xbc*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0xc0*/  long j;
	/*bp-0xcc*/  /*packed*/ struct Point3d oloc; // 0xc bytes
	/*bp-0xd0*/  int32_t newdist;
	/*bp-0xdc*/  /*packed*/ struct Point3d newvector; // 0xc bytes
	/*bp-0xe0*/  long num_debris;

// LINE 1807:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        mov    cloc.x, eax;
// LINE 1808:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        mov    cloc.y, eax;
// LINE 1809:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        mov    cloc.z, eax;
// LINE 1810:
	celloc.x = ((cloc.x + 0x20000000) >> 0x16);
// LINE 1811:
	celloc.y = ((0x20000000 - cloc.z) >> 0x16);
// LINE 1814:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax+1], 9;
	__asm        je     _T67;
// LINE 1815:
	__asm        jmp    skip_dynamic_objs;
// LINE 1817:
_T67:
	hit_type = 0xffffffff;
// LINE 1818:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x802;
	__asm        je     _T89;
// LINE 1820:
	hit_type = 0x3;
// LINE 1822:
	__asm        jmp    _T100;
_T89:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 4;
	__asm        je     _Ta1;
// LINE 1824:
	hit_type = 0x7;
// LINE 1826:
	__asm        jmp    _T100;
_Ta1:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 8;
	__asm        je     _Tb9;
// LINE 1828:
	hit_type = 0xe;
// LINE 1830:
	__asm        jmp    _T100;
_Tb9:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x410;
	__asm        je     _Td4;
// LINE 1832:
	hit_type = 0x0;
// LINE 1834:
	__asm        jmp    _T100;
_Td4:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0xE0;
	__asm        je     _Tec;
// LINE 1836:
	hit_type = 0x4;
// LINE 1838:
	__asm        jmp    _T100;
_Tec:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax+1], 2;
	__asm        je     _T100;
// LINE 1840:
	hit_type = 0xf;
// LINE 1844:
_T100:
	dyobj = cptr->dyptr;
// LINE 1845:
__WHILE_109:
	__asm        cmp    dyobj, 0;
	__asm        je     skip_dynamic_objs;
// LINE 1848:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyobj;
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _T12f;
// LINE 1850:
	dyobj = dyobj->next;
// LINE 1851:
	__asm        jmp    __WHILE_109;
// LINE 1855:
_T12f:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyobj;
	__asm        cmp    [eax+0x3C], ecx;
	__asm        jne    _T189;
// LINE 1857:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0x3C], 0;
	__asm        je     _T17c;

	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x3C];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T17c;
// LINE 1858:
	dyobj = dyobj->next->next->next->next->next->next->next->next->next->next;
// LINE 1859:
	__asm        jmp    _T184;
// LINE 1860:
_T17c:
	dyobj = dyobj->next;
// LINE 1861:
_T184:
	__asm        jmp    __WHILE_109;
// LINE 1865:
_T189:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x20;
	__asm        je     _T1a5;
// LINE 1867:
	dyobj = dyobj->next;
// LINE 1868:
	__asm        jmp    __WHILE_109;
// LINE 1872:
_T1a5:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x40;
	__asm        je     _T1c1;
// LINE 1874:
	dyobj = dyobj->next;
// LINE 1875:
	__asm        jmp    __WHILE_109;
// LINE 1881:
_T1c1:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _T1fc;

	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        cmp    eax, 0x7D00;
	__asm        jne    _T1fc;

	__asm        cmp    G_camera_mode, 3;
	__asm        je     _T1fc;
// LINE 1883:
	dyobj = dyobj->next;
// LINE 1884:
	__asm        jmp    __WHILE_109;
// LINE 1893:
_T1fc:
	__asm        cmp    hit_type, 4;
	__asm        jne    _T251;

	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   ah, 0x10;
	__asm        je     _T251;
// LINE 1914:
	newdist = S3MissileSphereHit((dyobj->radius + 0xf0000), (dyobj + 0x18), dist, (md + 0x10), (md->dymissile + 0x18));
// LINE 1916:
	__asm        jmp    _T282;
// LINE 1923:
_T251:
	newdist = S3MissileSphereHit(dyobj->radius, (dyobj + 0x18), dist, (md + 0x10), (md->dymissile + 0x18));
// LINE 1926:
_T282:
	__asm        cmp    newdist, 0;
	__asm        jl     _T41b;
// LINE 1930:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    loc.x, ecx;
// LINE 1931:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    loc.y, ecx;
// LINE 1932:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    loc.z, ecx;
// LINE 1933:
	__asm        lea    eax, loc.x;
	__asm        lea    ecx, sloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1934:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.x;
	__asm        neg    eax;
	__asm        sub    loc.x, eax;
// LINE 1935:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.y;
	__asm        neg    eax;
	__asm        sub    loc.y, eax;
// LINE 1936:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.z;
	__asm        neg    eax;
	__asm        sub    loc.z, eax;
// LINE 1939:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x802;
	__asm        je     _T392;
// LINE 1941:
	S3ExplosionStart(md->mission_id, 0x4, loc.z, loc.y, loc.x, cptr);
// LINE 1942:
	S3DSPlay(0x0, sloc.x, 0x7);
// LINE 1944:
	__asm        jmp    _T3d8;
_T392:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 4;
	__asm        je     _T3d8;
// LINE 1946:
	S3ExplosionStart(md->mission_id, 0x1, loc.z, loc.y, loc.x, cptr);
// LINE 1947:
	S3DSPlay(0x0, sloc.x, 0x7);
// LINE 1951:
_T3d8:
	S3ObjHitDispatch(0x0, md->mission_id, dyobj, md->dymissile, hit_type);
// LINE 1972:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 6;
	__asm        je     _T41b;
// LINE 1974:
	md->flags = (md->flags & -0x2);
// LINE 1975:
	return 0x1;
// LINE 1981:
_T41b:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 4;
	__asm        je     _T449;
// LINE 1983:
	dyobj = dyobj->next->next->next->next->next->next->next->next->next->next;
// LINE 1985:
	__asm        jmp    _T451;
// LINE 1986:
_T449:
	dyobj = dyobj->next;
// LINE 1987:
_T451:
	__asm        jmp    __WHILE_109;
// LINE 1992:
skip_dynamic_objs:
	stobj = cptr->stptr;
// LINE 1994:
__WHILE_45f:
	__asm        cmp    stobj, 0;
	__asm        je     _T990;
// LINE 1998:
	__asm        lea    eax, oinfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, stobj;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 1999:
	__asm        lea    eax, center.x;
	__asm        push   eax;
	__asm        mov    eax, stobj;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D88C3;
	__asm        add    esp, 8;
// LINE 2002:
	__asm        lea    eax, cloc.x;
	__asm        lea    ecx, oloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2003:
	oloc.x += center.x;
// LINE 2004:
	oloc.y += center.y;
// LINE 2005:
	oloc.z += center.z;
// LINE 2011:
	newdist = S3MissileSphereHit(oinfo.Radius, oloc.x, dist, (md + 0x10), (md->dymissile + 0x18));
// LINE 2015:
	__asm        cmp    newdist, 0;
	__asm        jl     _T53c;
// LINE 2022:
	newdist = VRStObjPolyHit(norm, stobj->mesh, cloc.x, dist, (md + 0x10), (md->dymissile + 0x18));
// LINE 2025:
_T53c:
	__asm        cmp    newdist, 0;
	__asm        jle    _T983;
// LINE 2029:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    loc.x, ecx;
// LINE 2030:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    loc.y, ecx;
// LINE 2031:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    loc.z, ecx;
// LINE 2032:
	__asm        lea    eax, loc.x;
	__asm        lea    ecx, sloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2033:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.x;
	__asm        neg    eax;
	__asm        sub    loc.x, eax;
// LINE 2034:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.y;
	__asm        neg    eax;
	__asm        sub    loc.y, eax;
// LINE 2035:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.z;
	__asm        neg    eax;
	__asm        sub    loc.z, eax;
// LINE 2036:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x798;
	__asm        je     _T65e;
// LINE 2040:
	MTCreateReflection4x4(norm, refmat[0][0]);
// LINE 2041:
	__asm        lea    eax, refmat[0][0];
	__asm        push   eax;
	__asm        lea    eax, newvector.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        add    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 2042:
	__asm        lea    eax, newvector.x;
	__asm        mov    ecx, md;
	__asm        add    ecx, 0x10;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2044:
	__asm        jmp    _T979;
// LINE 2046:
_T65e:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x802;
	__asm        je     _T873;

	__asm        mov    eax, celloc.y;
	__asm        push   eax;
	__asm        mov    eax, celloc.x;
	__asm        push   eax;
	__asm        call   S3FireCanCellBurn;
	__asm        add    esp, 8;
	__asm        cmp    eax, 1;
	__asm        jne    _T873;

	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        jne    _T873;
// LINE 2049:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax+1], 8;
	__asm        je     _T6d7;
// LINE 2051:
	__asm        call   S3FireGetCount;
	__asm        test   eax, eax;
	__asm        jne    _T6d2;
// LINE 2053:
	md->mission_id = S3MissionStart(0x1, celloc.y, celloc.x);
// LINE 2056:
_T6d2:
	__asm        jmp    _T72f;
// LINE 2059:
_T6d7:
	__asm        call   S3FireGetCellData;
	__asm        mov    cfd, eax;
	__asm        cmp    cfd, 0;
	__asm        je     _T72f;
// LINE 2061:
	cfd->cptr = cptr;
// LINE 2062:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        jne    _T72f;
// LINE 2063:
	__asm        push   0;
	__asm        mov    eax, md;
	__asm        movsx  eax, word ptr [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, celloc.y;
	__asm        push   eax;
	__asm        mov    eax, celloc.x;
	__asm        push   eax;
	__asm        mov    eax, cfd;
	__asm        push   eax;
	__asm        call   S3FireStartCell;
	__asm        add    esp, 0x14;
// LINE 2067:
_T72f:
	S3ExplosionStart(md->mission_id, 0x4, loc.z, loc.y, loc.x, cptr);
// LINE 2069:
	S3DSPlay(0x0, sloc.x, 0x7);
// LINE 2071:
	md->flags = (md->flags & -0x2);
// LINE 2074:
	__asm        call   rand;
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+8];
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+3];
	__asm        mov    num_debris, eax;
// LINE 2075:
_FOR_7a0:
	j = 0x0;
	__asm        jmp    _FOR_COND_7a0;
_FOR_NEXT_7a0:
	j++;
_FOR_COND_7a0:
	__asm        mov    eax, num_debris;
	__asm        cmp    j, eax;
	__asm        jge    _T86e;
// LINE 2077:
	__asm        lea    eax, refmat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 2078:
	__asm        lea    eax, refmat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0xE10;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    eax, edx;
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D201C;
	__asm        add    esp, 8;
// LINE 2079:
	__asm        lea    eax, refmat[0][0];
	__asm        push   eax;
	__asm        call   rand;
	__asm        mov    ecx, 0x78;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+0x2EE];
	__asm        shl    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 2080:
	__asm        lea    eax, refmat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 2091:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        push   0x640000;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        lea    eax, sloc.x;
	__asm        push   eax;
	__asm        lea    eax, celloc.x;
	__asm        push   eax;
	__asm        push   4;
	__asm        call   S3MissileStart;
	__asm        add    esp, 0x20;
// LINE 2092:
	__asm        jmp    _FOR_NEXT_7a0;
// LINE 2094:
_T86e:
	__asm        jmp    _T979;
// LINE 2097:
_T873:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x802;
	__asm        je     _T8c1;
// LINE 2099:
	S3ExplosionStart(md->mission_id, 0x4, loc.z, loc.y, loc.x, cptr);
// LINE 2101:
	S3DSPlay(0x0, sloc.x, 0x7);
// LINE 2104:
	__asm        jmp    _T96c;
_T8c1:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x60;
	__asm        je     _T932;
// LINE 2106:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0x20000;
	__asm        jge    _T8f4;
// LINE 2107:
	S3ExplosionSmokeStart(0x8, sloc.x, cptr);
// LINE 2108:
	__asm        jmp    _T906;
// LINE 2109:
_T8f4:
	S3ExplosionSmokeStart(0x9, sloc.x, cptr);
// LINE 2110:
_T906:
	S3FireDouse(md->timetolive, sloc.x, cptr);
// LINE 2112:
	S3DSPlay(0x0, sloc.x, 0xa);
// LINE 2115:
	__asm        jmp    _T96c;
// LINE 2117:
_T932:
	S3ExplosionStart(md->mission_id, 0x0, loc.z, loc.y, loc.x, cptr);
// LINE 2119:
	S3DSPlay(0x0, sloc.x, 0x9);
// LINE 2122:
_T96c:
	md->flags = (md->flags & -0x2);
// LINE 2145:
_T979:
	return 0x1;
// LINE 2150:
_T983:
	stobj = stobj->next;
// LINE 2151:
	__asm        jmp    __WHILE_45f;
// LINE 2157:
_T990:
	newdist = S3MissileGroundHit(cloc.x, dist, (md + 0x10), (md->dymissile + 0x18));
// LINE 2158:
	__asm        cmp    newdist, 0;
	__asm        jle    _Td1a;
// LINE 2162:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    loc.x, ecx;
// LINE 2163:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x1C];
	__asm        add    ecx, eax;
	__asm        mov    loc.y, ecx;
// LINE 2164:
	__asm        mov    eax, newdist;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    loc.z, ecx;
// LINE 2165:
	__asm        lea    eax, loc.x;
	__asm        lea    ecx, sloc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2166:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.x;
	__asm        neg    eax;
	__asm        sub    loc.x, eax;
// LINE 2167:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.y;
	__asm        neg    eax;
	__asm        sub    loc.y, eax;
// LINE 2168:
	__asm        xor    eax, eax;
	__asm        sub    eax, cloc.z;
	__asm        neg    eax;
	__asm        sub    loc.z, eax;
// LINE 2171:
	__asm        mov    eax, celloc.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, celloc.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        mov    j, edx;
// LINE 2172:
	__asm        cmp    j, 0;
	__asm        jl     _Tabc;

	__asm        cmp    j, 5;
	__asm        jl     _Tad6;
_Tabc:
	__asm        cmp    j, 5;
	__asm        jl     _Tb25;

	__asm        cmp    j, 0xA;
	__asm        jge    _Tb25;
_Tad6:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x380;
	__asm        jne    _Tb25;
// LINE 2174:
	S3ExplosionSmokeStart(0x8, sloc.x, cptr);
// LINE 2176:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x80;
	__asm        jne    _Tb13;
// LINE 2177:
	S3DSPlay(0x0, sloc.x, 0xf);
// LINE 2179:
_Tb13:
	md->flags = (md->flags & -0x2);
// LINE 2181:
	__asm        jmp    _Td10;
_Tb25:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x798;
	__asm        je     _Tb93;
// LINE 2184:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        jge    _Tb8e;
// LINE 2188:
	MTCreateReflection4x4(0x59b508, refmat[0][0]);
// LINE 2189:
	__asm        lea    eax, refmat[0][0];
	__asm        push   eax;
	__asm        lea    eax, newvector.x;
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        add    eax, 0x10;
	__asm        push   eax;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 2190:
	__asm        lea    eax, newvector.x;
	__asm        mov    ecx, md;
	__asm        add    ecx, 0x10;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2193:
_Tb8e:
	__asm        jmp    _Td10;
_Tb93:
	__asm        mov    eax, md;
	__asm        test   dword ptr [eax], 0x802;
	__asm        je     _Tc4b;
// LINE 2196:
	__asm        mov    eax, celloc.y;
	__asm        push   eax;
	__asm        mov    eax, celloc.x;
	__asm        push   eax;
	__asm        call   S3FireCanCellBurn;
	__asm        add    esp, 8;
	__asm        cmp    eax, 1;
	__asm        jne    _Tbff;

	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax];
	__asm        test   al, 0x20;
	__asm        jne    _Tbff;
// LINE 2199:
	__asm        call   S3FireGetCount;
	__asm        test   eax, eax;
	__asm        jne    _Tbff;
// LINE 2201:
	md->mission_id = S3MissionStart(0x1, celloc.y, celloc.x);
// LINE 2203:
	__asm        jmp    _Tbff;
// LINE 2208:
_Tbff:
	S3ExplosionStart(md->mission_id, 0x4, loc.z, loc.y, loc.x, cptr);
// LINE 2210:
	S3DSPlay(0x0, sloc.x, 0x7);
// LINE 2212:
	md->flags = (md->flags & -0x2);
// LINE 2214:
	__asm        jmp    _Td10;
_Tc4b:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 0x60;
	__asm        je     _Tcc9;
// LINE 2216:
	__asm        mov    eax, md;
	__asm        cmp    dword ptr [eax+4], 0x20000;
	__asm        jge    _Tc7e;
// LINE 2217:
	S3ExplosionSmokeStart(0x8, sloc.x, cptr);
// LINE 2218:
	__asm        jmp    _Tc90;
// LINE 2219:
_Tc7e:
	S3ExplosionSmokeStart(0x9, sloc.x, cptr);
// LINE 2220:
_Tc90:
	S3FireDouse(md->timetolive, sloc.x, cptr);
// LINE 2222:
	S3DSPlay(0x0, sloc.x, 0xa);
// LINE 2224:
	md->flags = (md->flags & -0x2);
// LINE 2226:
	__asm        jmp    _Td10;
// LINE 2228:
_Tcc9:
	S3ExplosionStart(md->mission_id, 0x0, loc.z, loc.y, loc.x, cptr);
// LINE 2230:
	S3DSPlay(0x0, sloc.x, 0x9);
// LINE 2232:
	md->flags = (md->flags & -0x2);
// LINE 2235:
_Td10:
	return 0x1;
// LINE 2238:
_Td1a:
	return 0x0;
// LINE 2239:
}

// FUNCTION: COPTER_D 0x00522dbc
int32_t S3MissileGroundHit(/*packed*/ struct Point3d *sp, /*packed*/ struct Point3d *sv, int32_t dist, /*packed*/ struct Point3d *cloc) {
	/*bp-0x4*/   int32_t alt2;
	/*bp-0x10*/  /*packed*/ struct Point3d endp; // 0xc bytes
	/*bp-0x14*/  int32_t alt;

// LINE 2262:
	alt = S3TerrPrecisionAlt(0x0, sp->z, sp->x);
// LINE 2263:
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, 0x40000;
	__asm        cmp    eax, alt;
	__asm        jg     _T41;
// LINE 2264:
	return 0x64;
// LINE 2268:
_T41:
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, alt;
	__asm        cmp    eax, 0x640000;
	__asm        jle    _T5f;
// LINE 2269:
	return 0xffffffff;
// LINE 2273:
_T5f:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, sv;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, sp;
	__asm        mov    ecx, [ecx];
	__asm        add    ecx, eax;
	__asm        mov    endp.x, ecx;
// LINE 2274:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, sv;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, sp;
	__asm        mov    ecx, [ecx+4];
	__asm        add    ecx, eax;
	__asm        mov    endp.y, ecx;
// LINE 2275:
	__asm        mov    eax, dist;
	__asm        push   eax;
	__asm        mov    eax, sv;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, sp;
	__asm        mov    ecx, [ecx+8];
	__asm        add    ecx, eax;
	__asm        mov    endp.z, ecx;
// LINE 2278:
	alt2 = S3TerrPrecisionAlt(0x0, endp.z, endp.x);
// LINE 2283:
	__asm        mov    eax, endp.y;
	__asm        sub    eax, 0x40000;
	__asm        cmp    eax, alt2;
	__asm        jg     _Te8;
// LINE 2285:
	return (dist >> 0x1);
// LINE 2289:
_Te8:
	return 0xffffffff;
// LINE 2290:
}

// FUNCTION: COPTER_D 0x00522eb3
int32_t S3MissileSphereHit(/*packed*/ struct Point3d *sp, /*packed*/ struct Point3d *sv, int32_t dist, /*packed*/ struct Point3d *tc, int32_t r) {
	/*bp-0x8*/   double fr; // 0x8 bytes
	/*bp-0x10*/  double d_squared; // 0x8 bytes
	/*bp-0x18*/  double dotp1; // 0x8 bytes
	/*bp-0x20*/  double dotp2; // 0x8 bytes
	/*bp-0x38*/  /*packed*/ struct FP3D fsp; // 0x18 bytes
	/*bp-0x50*/  /*packed*/ struct FP3D fsv; // 0x18 bytes
	/*bp-0x58*/  double newdist; // 0x8 bytes
	/*bp-0x70*/  /*packed*/ struct FP3D ftc; // 0x18 bytes
	/*bp-0x88*/  /*packed*/ struct FP3D s_to_t; // 0x18 bytes

// LINE 2525:
	__asm        mov    eax, tc;
	__asm        mov    eax, [eax];
	__asm        sub    eax, r;
	__asm        mov    ecx, sp;
	__asm        cmp    eax, [ecx];
	__asm        jl     _T8d;

	__asm        mov    eax, tc;
	__asm        mov    eax, [eax];
	__asm        add    eax, r;
	__asm        mov    ecx, sp;
	__asm        cmp    eax, [ecx];
	__asm        jg     _T8d;

	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, r;
	__asm        mov    ecx, sp;
	__asm        cmp    eax, [ecx+4];
	__asm        jl     _T8d;

	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, r;
	__asm        mov    ecx, sp;
	__asm        cmp    eax, [ecx+4];
	__asm        jg     _T8d;

	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+8];
	__asm        sub    eax, r;
	__asm        mov    ecx, sp;
	__asm        cmp    eax, [ecx+8];
	__asm        jl     _T8d;

	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+8];
	__asm        add    eax, r;
	__asm        mov    ecx, sp;
	__asm        cmp    eax, [ecx+8];
	__asm        jg     _T8d;
// LINE 2527:
	return 0x0;
// LINE 2533:
_T8d:
	__asm        mov    eax, tc;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x8C], eax;
	__asm        fild   dword ptr [ebp-0x8C];
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x90], eax;
	__asm        fisub  dword ptr [ebp-0x90];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   s_to_t.x;
// LINE 2534:
	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x94], eax;
	__asm        fild   dword ptr [ebp-0x94];
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x98], eax;
	__asm        fisub  dword ptr [ebp-0x98];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   s_to_t.y;
// LINE 2535:
	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0x9C], eax;
	__asm        fild   dword ptr [ebp-0x9C];
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0xA0], eax;
	__asm        fisub  dword ptr [ebp-0xA0];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   s_to_t.z;
// LINE 2536:
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xA4], eax;
	__asm        fild   dword ptr [ebp-0xA4];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   fsp.x;
// LINE 2537:
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xA8], eax;
	__asm        fild   dword ptr [ebp-0xA8];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   fsp.y;
// LINE 2538:
	__asm        mov    eax, sp;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0xAC], eax;
	__asm        fild   dword ptr [ebp-0xAC];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   fsp.z;
// LINE 2539:
	__asm        mov    eax, sv;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xB0], eax;
	__asm        fild   dword ptr [ebp-0xB0];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   fsv.x;
// LINE 2540:
	__asm        mov    eax, sv;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xB4], eax;
	__asm        fild   dword ptr [ebp-0xB4];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   fsv.y;
// LINE 2541:
	__asm        mov    eax, sv;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0xB8], eax;
	__asm        fild   dword ptr [ebp-0xB8];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   fsv.z;
// LINE 2542:
	__asm        mov    eax, tc;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xBC], eax;
	__asm        fild   dword ptr [ebp-0xBC];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   ftc.x;
// LINE 2543:
	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xC0], eax;
	__asm        fild   dword ptr [ebp-0xC0];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   ftc.y;
// LINE 2544:
	__asm        mov    eax, tc;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0xC4], eax;
	__asm        fild   dword ptr [ebp-0xC4];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   ftc.z;
// LINE 2545:
	__asm        mov    eax, r;
	__asm        mov    [ebp-0xC8], eax;
	__asm        fild   dword ptr [ebp-0xC8];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fstp   fr;
// LINE 2551:
	__asm        fld    fsv.y;
	__asm        fmul   s_to_t.y;
	__asm        fld    fsv.z;
	__asm        fmul   s_to_t.z;
	__asm        faddp;
	__asm        fld    fsv.x;
	__asm        fmul   s_to_t.x;
	__asm        faddp;
// LINE 2560:
	__asm        fcom   qword ptr ds:[0x592FE0];
	__asm        fstp   dotp1;
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T254;
// LINE 2561:
	return 0xffffffff;
// LINE 2564:
_T254:
	__asm        fld    s_to_t.y;
	__asm        fmul   s_to_t.y;
	__asm        fld    s_to_t.x;
	__asm        fmul   s_to_t.x;
	__asm        faddp;
	__asm        fld    s_to_t.z;
	__asm        fmul   s_to_t.z;
	__asm        faddp;
	__asm        fstp   dotp2;
// LINE 2566:
	__asm        fld    dotp1;
	__asm        fmul   dotp1;
	__asm        fsubr  dotp2;
	__asm        fld    fr;
	__asm        fmul   fr;
	__asm        fsubrp;
// LINE 2568:
	__asm        fcom   qword ptr ds:[0x592FE0];
	__asm        fstp   d_squared;
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T2a2;
// LINE 2569:
	return 0xffffffff;
// LINE 2578:
_T2a2:
	__asm        fld    dotp1;
	__asm        fsub   fr;
// LINE 2579:
	__asm        fcom   qword ptr ds:[0x592FE0];
	__asm        fstp   newdist;
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T2ca;

	reinterpret_cast<uint32_t>(newdist) = 0x0;
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&newdist) + 4) = 0x3fe00000;
// LINE 2580:
_T2ca:
	__asm        mov    eax, dist;
	__asm        mov    [ebp-0xCC], eax;
	__asm        fild   dword ptr [ebp-0xCC];
	__asm        fdiv   qword ptr ds:[0x592FD8];
	__asm        fcomp  newdist;
	__asm        fnstsw ax;
	__asm        test   ah, 1;
	__asm        je     _T2f7;
// LINE 2581:
	return 0xffffffff;
// LINE 2586:
_T2f7:
	__asm        fld    newdist;
	__asm        fmul   qword ptr ds:[0x592FD8];
	__asm        call   0x0056EBE8;
	__asm        jmp    __RETURN;
// LINE 2587:
__RETURN:
}

// FUNCTION: COPTER_D 0x005231c2
void S3DrawPoint(/*packed*/ struct VRBlit *blit) {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   long winwidth;
	/*bp-0xc*/   long bufwidth;
	/*bp-0x10*/  int32_t x;
	/*bp-0x14*/  int32_t y;
	/*bp-0x18*/  long winheight;

// LINE 2609:
	bufwidth = 0x140;
// LINE 2610:
	winwidth = 0x13f;
// LINE 2611:
	winheight = 0xc7;
// LINE 2625:
	__asm        cmp    G_video_mode, 0x10;
	__asm        jne    _T4a;
// LINE 2627:
	bufwidth = swindow.RenderWide;
// LINE 2628:
	__asm        mov    eax, swindow.WindowWide;
	__asm        dec    eax;
	__asm        mov    winwidth, eax;
// LINE 2629:
	__asm        mov    eax, swindow.WindowHigh;
	__asm        dec    eax;
	__asm        mov    winheight, eax;
// LINE 2631:
	__asm        jmp    _T64;
// LINE 2634:
_T4a:
	bufwidth = qwindow.RenderWide;
// LINE 2635:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        dec    eax;
	__asm        mov    winwidth, eax;
// LINE 2636:
	__asm        mov    eax, qwindow.WindowHigh;
	__asm        dec    eax;
	__asm        mov    winheight, eax;
// LINE 2644:
_T64:
	x = (blit->verts->x >> 0xc);
// LINE 2645:
	y = (blit->verts->y >> 0xc);
// LINE 2647:
	ptr = (((bufwidth * y) + x) + buffer1);
// LINE 2649:
	__asm        jmp    _T9e;

	return;
// LINE 2651:
_T9e:
	__asm        mov    eax, blit;
	__asm        mov    al, [eax+0xC];
	__asm        mov    ecx, ptr;
	__asm        mov    [ecx], al;
// LINE 2653:
}

// FUNCTION: COPTER_D 0x00523270
/*packed*/ struct _MISSILE_DATA* S3DebrisGetByMission(long mission_id) {
	/*bp-0x4*/   long i;
	/*bp-0x8*/   /*packed*/ struct _MISSILE_DATA *md;

// LINE 2667:
_FOR_1c:
	i = 0x0;
	md = 0x66e270;
	__asm        jmp    _FOR_COND_1c;
_FOR_NEXT_1c:
	i++;
	md += 0x48;
_FOR_COND_1c:
	__asm        cmp    i, 0x1E;
	__asm        jge    _T55;
// LINE 2669:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        je     _T50;

	__asm        mov    eax, md;
	__asm        mov    ecx, mission_id;
	__asm        cmp    [eax+0x40], ecx;
	__asm        jne    _T50;
// LINE 2670:
	return md;
// LINE 2671:
_T50:
	__asm        jmp    _FOR_NEXT_1c;
// LINE 2673:
_T55:
	return 0x0;
// LINE 2674:
}

// FUNCTION: COPTER_D 0x005232d1
void S3MissileDebrisDouse(/*packed*/ struct _DYOBJ_INST *dyobj) {
	/*bp-0x18*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x1c*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x20*/  /*packed*/ struct _DYOBJ_INST **dyptrptr;
	/*bp-0x24*/  /*packed*/ struct _MISSILE_DATA *md;

// LINE 2693:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        test   eax, eax;
	__asm        jl     _T28;

	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        cmp    eax, 0x1E;
	__asm        jl     _T2d;
// LINE 2696:
_T28:
	return;
// LINE 2699:
_T2d:
	__asm        mov    eax, dyobj;
	__asm        movsx  eax, word ptr [eax+0xE];
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, 0x66E270;
	__asm        mov    md, eax;
// LINE 2701:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T53;
// LINE 2704:
	return;
// LINE 2707:
_T53:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 2710:
	dyptrptr = (cptr + 0x10);
// LINE 2711:
__WHILE_80:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Tbc;
// LINE 2713:
	__asm        mov    eax, md;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jne    _Taf;
// LINE 2715:
	dyptrptr-> = md->dymissile->next;
// LINE 2716:
	__asm        jmp    _Tbc;
// LINE 2718:
_Taf:
	dyptrptr = dyptrptr->;
// LINE 2719:
	__asm        jmp    __WHILE_80;
// LINE 2721:
_Tbc:
	S_num_active_debris--;
// LINE 2724:
	mp.op = 0x9;
// LINE 2725:
	mp.id = md->mission_id;
// LINE 2726:
	mp.i2num = 0x1;
// LINE 2727:
	mp.flags = 0x0;
// LINE 2728:
	S3MissionUpdate(mp.op);
// LINE 2730:
	md->flags = (md->flags & -0x2);
// LINE 2731:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        and    eax, 0xEFFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        mov    [ecx+0xC], ax;
// LINE 2734:
	S3DSPlay(0x0, (md->dymissile + 0x18), 0xf);
// LINE 2736:
}

// FUNCTION: COPTER_D 0x005233ff
void S3MissileDebrisFire(/*packed*/ struct _CELL_INFO *cptr, /*packed*/ struct Point3d *loc, long * seq) {
	/*bp-0xc*/   /*packed*/ struct Point3d tmploc; // 0xc bytes

// LINE 2751:
	seq[0]++;
// LINE 2752:
	__asm        mov    eax, seq;
	__asm        and    dword ptr [eax], 7;
// LINE 2754:
	__asm        mov    eax, loc;
	__asm        lea    ecx, tmploc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2755:
	__asm        mov    eax, seq;
	__asm        mov    eax, [eax];
	__asm        mov    eax, S_debris_firealt[eax*4];
	__asm        add    tmploc.y, eax;
// LINE 2757:
	__asm        mov    eax, seq;
	__asm        mov    eax, [eax];
	__asm        mov    eax, S_debris_fireseq[eax*4];
	__asm        push   eax;
	__asm        lea    eax, tmploc.x;
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        call   S3ExplosionSmokeStart;
	__asm        add    esp, 0xC;
// LINE 2758:
}

// FUNCTION: COPTER_D 0x0052345a
int32_t S3MissileMIFFLoad(void * __ptr32 miffReader) {
	/*bp-0x4*/   long ret;
	/*bp-0x8*/   long i;
	/*bp-0xc*/   /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x10*/  /*packed*/ struct _MISSILE_DATA *md;

// LINE 2785:
	ret = ReadFirstMIFFChunk(0x48, 0x62a530, tgMIFFID, miffReader);
// LINE 2786:
	__asm        cmp    ret, 0;
	__asm        jne    _T36;
// LINE 2787:
	return 0x0;
// LINE 2789:
_T36:
	S_num_active_teargas = 0x0;
// LINE 2791:
_FOR_4b:
	i = 0x0;
	__asm        jmp    _FOR_COND_4b;
_FOR_NEXT_4b:
	i++;
_FOR_COND_4b:
	__asm        cmp    i, 0xA;
	__asm        jge    _T1c7;
// LINE 2793:
	__asm        mov    eax, i;
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, 0x66C5C0;
	__asm        mov    md, eax;
// LINE 2796:
	md->flags = lsmsl.flags;
// LINE 2797:
	md->smoketime = lsmsl.smoketime;
// LINE 2798:
	md->speed = lsmsl.speed;
// LINE 2799:
	__asm        mov    eax, 0x62A530;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, md;
	__asm        add    ecx, 0x10;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2800:
	__asm        mov    eax, 0x62A530;
	__asm        add    eax, 0x2C;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 2801:
	md->animseq = lsmsl.animseq;
// LINE 2802:
	md->gas_on = lsmsl.gas_on;
// LINE 2803:
	md->mission_id = lsmsl.mission_id;
// LINE 2804:
	md->scale = lsmsl.scale;
// LINE 2805:
	__asm        mov    eax, 0x62A530;
	__asm        add    eax, 0x1C;
	__asm        mov    ecx, md;
	__asm        add    ecx, 0x1C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2806:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 2809:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        je     _T18b;
// LINE 2811:
	__asm        mov    eax, md;
	__asm        add    eax, 0x1C;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2812:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 2813:
	md->dymissile->next = cptr->dyptr;
// LINE 2814:
	cptr->dyptr = md->dymissile;
// LINE 2815:
	S_num_active_teargas++;
// LINE 2822:
_T18b:
	ret = ReadNextMIFFChunk(0x48, 0x62a530, tgMIFFID, miffReader);
// LINE 2823:
	__asm        cmp    ret, 0;
	__asm        jne    _T1c2;

	__asm        cmp    i, 9;
	__asm        je     _T1c2;
// LINE 2824:
	return 0x0;
// LINE 2825:
_T1c2:
	__asm        jmp    _FOR_NEXT_4b;
// LINE 2831:
_T1c7:
	ret = ReadFirstMIFFChunk(0x48, 0x62a530, dbMIFFID, miffReader);
// LINE 2832:
	__asm        cmp    ret, 0;
	__asm        jne    _T1f4;
// LINE 2833:
	return 0x0;
// LINE 2836:
_T1f4:
	S_num_active_debris = 0x0;
// LINE 2837:
_FOR_209:
	i = 0x0;
	__asm        jmp    _FOR_COND_209;
_FOR_NEXT_209:
	i++;
_FOR_COND_209:
	__asm        cmp    i, 0x1E;
	__asm        jge    _T385;
// LINE 2839:
	__asm        mov    eax, i;
	__asm        shl    eax, 3;
	__asm        lea    eax, [eax+eax*8];
	__asm        add    eax, 0x66E270;
	__asm        mov    md, eax;
// LINE 2842:
	md->flags = lsmsl.flags;
// LINE 2843:
	md->smoketime = lsmsl.smoketime;
// LINE 2844:
	md->speed = lsmsl.speed;
// LINE 2845:
	__asm        mov    eax, 0x62A530;
	__asm        add    eax, 0x10;
	__asm        mov    ecx, md;
	__asm        add    ecx, 0x10;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2846:
	__asm        mov    eax, 0x62A530;
	__asm        add    eax, 0x2C;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, md;
	__asm        add    edx, 0x2C;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 2847:
	md->animseq = lsmsl.animseq;
// LINE 2848:
	md->gas_on = lsmsl.gas_on;
// LINE 2849:
	md->mission_id = lsmsl.mission_id;
// LINE 2850:
	md->scale = lsmsl.scale;
// LINE 2851:
	__asm        mov    eax, 0x62A530;
	__asm        add    eax, 0x1C;
	__asm        mov    ecx, md;
	__asm        add    ecx, 0x1C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2852:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x28];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 2855:
	__asm        mov    eax, md;
	__asm        test   byte ptr [eax], 1;
	__asm        je     _T349;
// LINE 2857:
	__asm        mov    eax, md;
	__asm        add    eax, 0x1C;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x28];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2858:
	__asm        mov    eax, md;
	__asm        mov    eax, [eax+0x30];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, md;
	__asm        mov    ecx, [ecx+0x2C];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 2859:
	md->dymissile->next = cptr->dyptr;
// LINE 2860:
	cptr->dyptr = md->dymissile;
// LINE 2861:
	S_num_active_debris++;
// LINE 2868:
_T349:
	ret = ReadNextMIFFChunk(0x48, 0x62a530, dbMIFFID, miffReader);
// LINE 2869:
	__asm        cmp    ret, 0;
	__asm        jne    _T380;

	__asm        cmp    i, 0x1D;
	__asm        je     _T380;
// LINE 2870:
	return 0x0;
// LINE 2871:
_T380:
	__asm        jmp    _FOR_NEXT_209;
// LINE 2872:
_T385:
	return 0x1;
// LINE 2873:
}

// FUNCTION: COPTER_D 0x005237ee
int32_t S3MissileMIFFSave(void * __ptr32 miffWriter) {
	/*bp-0x4*/   long ret;
	/*bp-0x8*/   long i;

// LINE 2881:
_FOR_15:
	i = 0x0;
	__asm        jmp    _FOR_COND_15;
_FOR_NEXT_15:
	i++;
_FOR_COND_15:
	__asm        cmp    i, 0xA;
	__asm        jge    _FOR_99;
// LINE 2884:
	__asm        mov    eax, i;
	__asm        shl    eax, 3;
	__asm        mov    edi, 0x62A530;
	__asm        lea    esi, S_teargas[0].flags[eax+eax*8];
	__asm        mov    ecx, 0x12;
	__asm        rep movsd;
// LINE 2885:
	__asm        mov    eax, lsmsl.dymissile;
	__asm        add    eax, 0x18;
	__asm        mov    ecx, 0x62A530;
	__asm        add    ecx, 0x1C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2890:
	ret = WriteMIFFChunk(0x48, 0x62a530, tgMIFFID, miffWriter);
// LINE 2891:
	__asm        cmp    ret, 0;
	__asm        jne    _T88;
// LINE 2892:
	return 0x0;
// LINE 2894:
_T88:
	__asm        jmp    _FOR_NEXT_15;
// LINE 2897:
_FOR_99:
	i = 0x0;
	__asm        jmp    _FOR_COND_99;
_FOR_NEXT_99:
	i++;
_FOR_COND_99:
	__asm        cmp    i, 0x1E;
	__asm        jge    _T111;
// LINE 2900:
	__asm        mov    eax, i;
	__asm        shl    eax, 3;
	__asm        mov    edi, 0x62A530;
	__asm        lea    esi, S_debris[0].flags[eax+eax*8];
	__asm        mov    ecx, 0x12;
	__asm        rep movsd;
// LINE 2901:
	__asm        mov    eax, lsmsl.dymissile;
	__asm        add    eax, 0x18;
	__asm        mov    ecx, 0x62A530;
	__asm        add    ecx, 0x1C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2906:
	ret = WriteMIFFChunk(0x48, 0x62a530, dbMIFFID, miffWriter);
// LINE 2907:
	__asm        cmp    ret, 0;
	__asm        jne    _T10c;
// LINE 2908:
	return 0x0;
// LINE 2910:
_T10c:
	__asm        jmp    _FOR_NEXT_99;
// LINE 2912:
_T111:
	return 0x1;
// LINE 2913:
}



// Contribution: 2:00003fd8-00003fef Module: 167, 8 byte alignment, initialized_data, read, 


// Contribution: 3:000202c8-0002037c Module: 167, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b72c8
static short S_num_active_missiles = 0;

// GLOBAL: COPTER_D 0x005b72cc
static short S_num_active_bullets = 0;

// GLOBAL: COPTER_D 0x005b72d0
static short S_num_active_teargas = 0;

// GLOBAL: COPTER_D 0x005b72d4
static short S_num_active_debris = 0;

// GLOBAL: COPTER_D 0x005b72d8
static short S_num_active_traj = 0;

// GLOBAL: COPTER_D 0x005b72dc
static short S_num_active_lasers = 0;

// GLOBAL: COPTER_D 0x005b72e0
static long S_debris_fireseq[8] = {5, 4, 10, 11, 11, 10, 2, 1};

// GLOBAL: COPTER_D 0x005b7300
static int32_t S_debris_firealt[8] = {0, 327680, 327680, 983040, 655360, 327680, 655360, 1966080};

// GLOBAL: COPTER_D 0x005b7320
static long S_tracer = 16;

// GLOBAL: COPTER_D 0x005b7328
int32_t S_debris_types[3] = {329, 330, 331};

// GLOBAL: COPTER_D 0x005b7334
int32_t S_num_debris_types = 3;

// GLOBAL: COPTER_D 0x005b7338
static int32_t S_msl_fire_delay = 0;

// GLOBAL: COPTER_D 0x005b733c
static long tgMIFFID = 1413955923;

// GLOBAL: COPTER_D 0x005b7340
static long dbMIFFID = 1145197139;



// Contribution: 3:00093530-00093577 Module: 167, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0062a530
static /*packed*/ struct _MISSILE_DATA lsmsl;



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.
// GLOBAL: COPTER_D 0x0066e270
/*packed*/ struct _MISSILE_DATA S_debris[30]; // Contrib missing

// GLOBAL: COPTER_D 0x0066dfa0
/*packed*/ struct _MISSILE_DATA S_traj[10]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c920
/*packed*/ struct _MISSILE_DATA S_bullets[80]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c890
/*packed*/ struct _MISSILE_DATA S_lasers[2]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c5c0
/*packed*/ struct _MISSILE_DATA S_teargas[10]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c2f0
/*packed*/ struct _MISSILE_DATA S_missiles[10]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c2f0
/*packed*/ struct _MISSILE_DATA S_missiles[10]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c5c0
/*packed*/ struct _MISSILE_DATA S_teargas[10]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c920
/*packed*/ struct _MISSILE_DATA S_bullets[80]; // Contrib missing

// GLOBAL: COPTER_D 0x0066e270
/*packed*/ struct _MISSILE_DATA S_debris[30]; // Contrib missing

// GLOBAL: COPTER_D 0x0066dfa0
/*packed*/ struct _MISSILE_DATA S_traj[10]; // Contrib missing

// GLOBAL: COPTER_D 0x0066c890
/*packed*/ struct _MISSILE_DATA S_lasers[2]; // Contrib missing

