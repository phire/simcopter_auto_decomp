// Module: S3crminl.obj
// Source: C:\Copter\source\game\S3crminl.cpp
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: short;

// Type: long;

// Type: class CriminalEvaderCarClass (forward reference);
class CriminalEvaderCarClass : public AutomobileClass
{
public:
	static class CriminalEvaderCarClass* criminalCars[0];
		enum MissionState {
			CRUISING = 0,
			SEARCHING = 1,
			ON_THE_RUN = 2,
			OUT_OF_CAR = 3,
			MISSION_OVER = 4,
		};
		enum CriminalType {
			BURGLAR = 0,
			DRUG_PUSHER = 1,
			SNIPER = 2,
			ARSONIST = 3,
			TERRORIST = 4,
		};
protected:
	enum CriminalEvaderCarClass::MissionState missionState;
	enum CriminalEvaderCarClass::CriminalType criminalType;
	int32_t timeToLeaveCar;
	int32_t timeToBeOnTheRun;
	static int32_t baseTimeBetweenCriminalActivities;
	static int32_t maxTimeBetweenCriminalActivities;
	static int32_t constantTimeToBeOnTheRun;
	static int32_t evasionSpeedMultiplier;
	static short maxSearchForBuildingRadius;
	static int32_t curCriminalCars;
public:
	void CriminalEvaderCarClass(const class CriminalEvaderCarClass&);
	void CriminalEvaderCarClass();
	virtual void ~CriminalEvaderCarClass();
	// calltype: NearC
	static class CriminalEvaderCarClass* CreateInstance(int32_t);
	// calltype: NearC
	static int32_t StartCriminalMission(short, short, long, long);
protected:
	virtual void AdjustSpeed();
	virtual void BeamToWithinCameraRange();
	virtual void ItterateFSM();
	virtual void PullOver(short);
	virtual void SetSaveData(struct _AUTO_LOAD_SAVE*);
	virtual void LoadSaveData(struct _AUTO_LOAD_SAVE*);
	int32_t AtScene();
	int32_t NearToBuilding();
public:
	class CriminalEvaderCarClass operator=(const class CriminalEvaderCarClass&);
private:
	void ShowWhereWeAre();
};

// Type: void;

// Type: struct _MISSION_PARMS;
class _MISSION_PARMS{
public:
	long op;
	long id;
	struct Point2d maploc;
	long i2num;
	long flags;
};

// Type: struct _GridCoordinates;
class _GridCoordinates{
public:
	unsigned char x;
	unsigned char y;
};

// Type: struct Point3d;
class Point3d{
public:
	int32_t x;
	int32_t y;
	int32_t z;
};

// Type: class SpiralScan;
class SpiralScan{
public:
	void SpiralScan(int32_t);
	void ~SpiralScan();
	int32_t Next(struct _GridCoordinates&);
	int32_t InCityGridLimits(struct _GridCoordinates);
private:
	int32_t currDist;
	int32_t currDir;
	int32_t currDia;
	int32_t maxDia;
};

// Type: unsigned short;

// Type: struct _AUTO_LOAD_SAVE (forward reference);

// Type: uint32_t;

// Type: class AutomobileClass;
class AutomobileClass{
		enum __unnamed {
			CAR_TYPES = 7,
			PERCENTAGE_OF_AUTO1 = 10,
			PERCENTAGE_OF_AUTO2 = 20,
			PERCENTAGE_OF_AUTO3 = 20,
			PERCENTAGE_OF_AUTO4 = 10,
			PERCENTAGE_OF_AUTO5 = 10,
			PERCENTAGE_OF_AUTO6 = 20,
			PERCENTAGE_OF_AUTO7 = 20,
			TOTAL_PERCENTAGE = 110,
		};
		enum __unnamed {
			NO_X_POSITION = -1,
			STARTING_X = 3,
			ENDING_X = 125,
			NO_Y_POSITION = -1,
			STARTING_Y = 3,
			ENDING_Y = 125,
		};
		enum IntersectionTypes {
			DEAD_END = 0,
			STRAIGHT_AHEAD = 1,
			LEFT_ONLY = 2,
			RIGHT_ONLY = 4,
			LEFT_OR_STRAIGHT = 3,
			LEFT_OR_RIGHT = 6,
			RIGHT_OR_STRAIGHT = 5,
			LEFT_STRAIGHT_OR_RIGHT = 7,
			DEAD_END_HIWAY = 16,
		};
		enum StoppedReasons {
			NO_REASON = 0,
			TRAFFIC = 1,
			STOPPED_TRAFFIC = 2,
			PERSON_IN_WAY = 3,
			AUTO_IN_WAY = 4,
			DEBRIS_IN_WAY = 5,
			UNIDENTIFIED_IN_WAY = 6,
			HELI_IN_WAY = 7,
			END_OF_ROAD = 8,
			END_OF_HIWAY = 9,
			INTERSECTION_FULL = 10,
			BEEN_PULLED_OVER = 11,
		};
		enum RoadTileOffsets {
			RD_CENTOFF = 851968,
			RD_EDGEOFF = 131072,
		};
		enum HiwayOffsets {
			HW_CENTOFF_LANE1 = 851968,
			HW_EDGEOFF_LANE1 = 131072,
			HW_CENTOFF_LANE2 = 851968,
			HW_EDGEOFF_LANE2 = 131072,
			HW_HEIGHT = 2031616,
		};
		enum PersonState {
			PS_IN_VEHICLE = 0,
			PS_OUT_OF_VEHICLE = 1,
			PS_BACK_IN_VEHICLE = 2,
			PS_GOT_AWAY = 3,
			PS_MISSION_OVER = 4,
		};
		enum __unnamed {
			CAR_RADIUS = 327680,
			COLLISION_SPACE = 655360,
			ROAD_SPEED = 2621440,
			ROAD_SLOWDOWN_FACTOR = 131072,
			HIWAY_SPEED = 6225920,
			HIWAY_SLOWDOWN_FACTOR = 327680,
			SPEED_VARIANCE = 262144,
			HIWAY_VARIANCE = 655360,
			MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
			MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
			MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
		};
		enum Flags {
			AUTO_INITIALIZED = 1,
			AUTO_PLACED = 2,
			AUTO_TURNING = 4,
			AUTO_MAKING_UTURN = 8,
			AUTO_PULL_OVER = 16,
			AUTO_PULLING_OVER = 32,
			AUTO_PULLED_OVER = 64,
			AUTO_AT_DEAD_END = 128,
			AUTO_IN_INTERSECTION = 256,
			AUTO_ON_FIRE = 512,
			AUTO_JAMMED = 1024,
			AUTO_PULLING_OUT = 2048,
			AUTO_RIGHT_OF_WAY = 4096,
			AUTO_ON_HIWAY = 8192,
		};
public:
	int32_t flags;
	struct _DYOBJ_INST autoDynomitor;
	struct Goal goal;
private:
	static struct Point2d lastScannedLocation;
	int32_t DeltaFromCenter;
	int32_t stalledTimer;
	struct Point3d directionVector;
	int32_t remainingTime;
	int32_t desiredSpeed;
	int32_t desiredHiwaySpeed;
	int32_t beamDelay;
	int32_t beamTimer;
	int32_t m_cellBaseY;
	int32_t timePulledOver;
	enum DirectionTypes hiwaydir;
	struct _GridCoordinates currentLocation;
	struct _GridCoordinates nextLocation;
	struct _GridCoordinates northCell;
	struct _GridCoordinates southCell;
	struct _GridCoordinates eastCell;
	struct _GridCoordinates westCell;
protected:
	long carModel;
	int32_t speed;
	enum DirIndex2 prevDir;
	enum TurnIndex turnIndex;
	int32_t currDist;
	int32_t legOfTurn;
	struct Point3d* pDirVector;
	int32_t timeToLive;
	int32_t fireTime;
	long fireSeq;
	long missionId;
	struct _CELL_INFO* cptr;
	enum AutomobileClass::PersonState personState;
	int32_t spotlightHitCounter;
	int32_t IsCarPersistant();
	int32_t CanCarBeamToHiwayTile(unsigned short);
public:
	void AutomobileClass(const class AutomobileClass&);
	void AutomobileClass();
	// vtable: 0
	intro void ~AutomobileClass();
	// calltype: NearC
	static class AutomobileClass* CreateInstance(int32_t);
	// calltype: NearC
	static class AutomobileClass* GetAutoPointer(long);
	// calltype: NearC
	static void DestroyInstance(class AutomobileClass*);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t MissionStartFire(long, struct Point2d*);
	// calltype: NearC
	static int32_t MissionStartJam(long, struct Point2d*);
	// calltype: NearC
	static void MissionCancel(long);
	// calltype: NearC
	static void SetAllHeadlights(int32_t);
	void HitDispatch(long, struct _DYOBJ_INST*, long, long);
	int32_t AmIABadGuy();
	int32_t Initialize(int32_t);
	void WaterDouse(struct _DYOBJ_INST*);
	void IveBeenMegaphoned(long);
	void StartFire(long);
	void StartJam(long);
	void PullOver();
	void PullOut();
	int32_t CanIPullOut();
protected:
	void Itterate();
	// vtable: 4
	intro void AdjustSpeed();
	void Reset();
	// vtable: 8
	intro enum TurnIndex PickTurnDir(struct Goal*);
	void UnPlaceCar();
	void PullOverCiviliansInWay();
	// vtable: 12
	intro void ItterateFSM();
	int32_t InitializeInstance(int32_t);
	void LinkToCell(const struct _GridCoordinates&);
	int32_t AreCarsHeadOn(struct Point3d*);
	enum AutomobileClass::StoppedReasons CollisionCheck(int32_t, struct _DYOBJ_INST**);
	int32_t IsCarOutOfCameraRange();
	void TurnOffHeadlight();
	void TurnOnHeadlight();
	void SetHiwayDirection(unsigned short);
	int32_t DoHiwayTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void AdjustCurrentHiwayPosition();
	void AdjustNextHiwayPosition();
	enum AutomobileClass::IntersectionTypes PickHiwayDir(struct _GridCoordinates&);
	void MakeAHiwayTurn(enum AutomobileClass::IntersectionTypes);
	void GoStraight();
	void TurnLeft();
	void TurnRight();
	void MoveForwardOnHiway();
	void DoDiagonalRoadFixup();
	// vtable: 16
	intro void BeamToWithinCameraRange();
	// vtable: 20
	intro int32_t BeamToLocation(const struct _GridCoordinates&);
	void MoveAuto(int32_t);
private:
	void UnlinkFromCell(const struct _GridCoordinates&);
	void TransitionBetweenGoals();
	void RunFireState();
	void RunJamState();
	void IveBeenSpotlighted(struct _DYOBJ_INST*);
	int32_t IsThisAnEmergencyVehicle();
public:
	class AutomobileClass operator=(const class AutomobileClass&);
};



// Contribution: 1:001339c0-0013483c Module: 161, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x005349c0
int32_t CreateCriminalCarInstance(int32_t instanceID) {
// LINE 81:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
// LINE 82:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        call   0x00534A73;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x005349E4;
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x005349E6;
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x005349EB;
// LINE 83:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x005349f0
int32_t S3CriminalMissionStart(short mID, short mType, long x, long y) {
// LINE 87:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
// LINE 88:
	__asm        mov    eax, y;
	__asm        push   eax;
	__asm        mov    eax, x;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(mType);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(mID);
	__asm        push   eax;
	__asm        call   0x00534B21;
	__asm        add    esp, 0x10;
	__asm        jmp    near ptr 0x00534A13;
// LINE 89:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00534a18
void CriminalEvaderCarClass::CriminalEvaderCarClass() {
// LINE 97:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
	__asm        mov    ecx, this;
	__asm        call   0x00501B6C;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x593258;
// LINE 98:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+4], 0x11E;
// LINE 99:
	__asm        jmp    near ptr 0x00534A44;
	__asm        mov    eax, this;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00534a4c
void CriminalEvaderCarClass::~CriminalEvaderCarClass() {
// LINE 103:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x593258;
	__asm        jmp    near ptr 0x00534A66;
	__asm        mov    ecx, this;
	__asm        call   0x00501D09;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00534a73
class CriminalEvaderCarClass* CriminalEvaderCarClass::CreateInstance(int32_t instanceID) {
	class CriminalEvaderCarClass* youveWonABrandNewCar;

// LINE 123:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x10;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
// LINE 127:
	__asm        push   0x12A;
	__asm        call   0x0056A600;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     near ptr 0x00534AA6;
	__asm        mov    ecx, [ebp-8];
	__asm        call   0x00534A18;
	__asm        mov    youveWonABrandNewCar, eax;
	__asm        jmp    near ptr 0x00534AAD;
	__asm        mov    youveWonABrandNewCar, 0;
// LINE 130:
	__asm        cmp    youveWonABrandNewCar, 0;
	__asm        je     near ptr 0x00534B15;
// LINE 133:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    ecx, youveWonABrandNewCar;
	__asm        call   0x00504554;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x00534AEE;
// LINE 135:
	__asm        mov    eax, youveWonABrandNewCar;
	__asm        mov    ecx, ds:[0x5B7CBC];
	__asm        mov    [ecx*4+0x62B9A0], eax;
	__asm        inc    dword ptr ds:[0x5B7CBC];
// LINE 138:
	__asm        mov    eax, youveWonABrandNewCar;
	__asm        jmp    near ptr 0x00534B1C;
// LINE 140:
	__asm        jmp    near ptr 0x00534B15;
// LINE 143:
	__asm        mov    eax, youveWonABrandNewCar;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     near ptr 0x00534B15;
	__asm        push   1;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   dword ptr [eax];
	__asm        jmp    near ptr 0x00534B15;
// LINE 149:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x00534B1C;
// LINE 150:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00534b21
int32_t CriminalEvaderCarClass::StartCriminalMission(short mID, short mType, long x, long y) {
	struct _MISSION_PARMS mp;
	int32_t i;
	struct _GridCoordinates startLoc;

// LINE 156:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x20;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
// LINE 159:
	__asm        mov    al, reinterpret_cast<uint8_t>(x);
	__asm        mov    startLoc.x, al;
// LINE 160:
	__asm        mov    al, reinterpret_cast<uint8_t>(y);
	__asm        mov    startLoc.y, al;
// LINE 165:
	__asm        mov    i, 0;
	__asm        jmp    near ptr 0x00534B45;
	__asm        inc    i;
	__asm        cmp    i, 5;
	__asm        jge    near ptr 0x00534C39;
// LINE 167:
	__asm        mov    eax, i;
	__asm        mov    eax, [eax*4+0x62B9A0];
	__asm        test   byte ptr [eax+8], 2;
	__asm        jne    near ptr 0x00534C34;
// LINE 170:
	__asm        lea    eax, startLoc.x;
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        mov    ecx, [eax*4+0x62B9A0];
	__asm        call   0x005030AA;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x00534C2D;
// LINE 175:
	__asm        mov    mp.op, 0xA;
// LINE 176:
	__asm        movsx  eax, mID;
	__asm        mov    mp.id, eax;
// LINE 180:
	__asm        mov    eax, i;
	__asm        mov    eax, [eax*4+0x62B9A0];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    mp.maploc.x, ecx;
// LINE 181:
	__asm        mov    eax, i;
	__asm        mov    eax, [eax*4+0x62B9A0];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    mp.maploc.y, ecx;
// LINE 182:
	__asm        lea    eax, mp.op;
	__asm        push   eax;
	__asm        call   0x004FBD4A;
	__asm        add    esp, 4;
// LINE 185:
	__asm        movsx  eax, mID;
	__asm        mov    ecx, i;
	__asm        mov    ecx, [ecx*4+0x62B9A0];
	__asm        mov    [ecx+0x10E], eax;
// LINE 186:
	__asm        mov    eax, i;
	__asm        mov    eax, [eax*4+0x62B9A0];
	__asm        mov    dword ptr [eax+0x11A], 0;
// LINE 187:
	__asm        movsx  eax, mType;
	__asm        mov    ecx, i;
	__asm        mov    ecx, [ecx*4+0x62B9A0];
	__asm        mov    [ecx+0x11E], eax;
// LINE 189:
	__asm        call   0x0056EC50;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   dword ptr ds:[0x5B7CAC];
	__asm        mov    eax, ds:[0x5B7CA8];
	__asm        add    eax, edx;
	__asm        mov    ecx, i;
	__asm        mov    ecx, [ecx*4+0x62B9A0];
	__asm        mov    [ecx+0x122], eax;
// LINE 190:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x00534C40;
// LINE 192:
	__asm        jmp    near ptr 0x00534C34;
// LINE 193:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x00534C40;
// LINE 195:
	__asm        jmp    near ptr 0x00534B42;
// LINE 198:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x00534C40;
// LINE 199:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00534c45
void CriminalEvaderCarClass::ItterateFSM() {
	struct _MISSION_PARMS mp;

// LINE 206:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x68;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 209:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11A];
	__asm        mov    [ebp-0x68], eax;
	__asm        jmp    near ptr 0x005350FC;
// LINE 212:
	__asm        mov    ecx, this;
	__asm        call   0x00535709;
// LINE 214:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     near ptr 0x00534D86;
// LINE 216:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 2;
// LINE 218:
	__asm        push   0x30;
	__asm        call   0x00446F02;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    near ptr 0x00534D81;
// LINE 222:
// Block start:
	struct Point3d loc;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF2];
	__asm        mov    ecx, [ecx];
	__asm        shl    ecx, 4;
	__asm        sub    eax, ecx;
	__asm        mov    loc.x, eax;
// LINE 223:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF2];
	__asm        mov    ecx, [ecx+4];
	__asm        shl    ecx, 4;
	__asm        sub    eax, ecx;
	__asm        mov    loc.y, eax;
// LINE 224:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF2];
	__asm        mov    ecx, [ecx+8];
	__asm        shl    ecx, 4;
	__asm        sub    eax, ecx;
	__asm        mov    loc.z, eax;
// LINE 226:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x30;
	__asm        call   0x00446CC2;
	__asm        add    esp, 0xC;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0x5C], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x60], ecx;
// LINE 227:
	__asm        mov    eax, [ebp-0x60];
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, [ebp-0x5C];
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, [eax+ecx*4+0x67ED30];
	__asm        mov    [ebp-0x58], eax;
	__asm        cmp    dword ptr [ebp-0x58], 0;
	__asm        jne    near ptr 0x00534D53;
	__asm        push   0xA0;
	__asm        push   0x5B57C4;
	__asm        push   0x5B57B8;
	__asm        call   0x0056DA30;
	__asm        add    esp, 0xC;
	__asm        jmp    near ptr 0x00534D58;
	__asm        jmp    near ptr 0x00534D58;
	__asm        jmp    near ptr 0x00534D5D;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 228:
	__asm        push   6;
	__asm        lea    eax, loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x112];
	__asm        push   eax;
	__asm        call   0x005240DC;
	__asm        add    esp, 0xC;
// LINE 230:
// Block end:
	__asm        jmp    near ptr 0x00535124;
// LINE 233:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x122], 0;
	__asm        jge    near ptr 0x00534DC7;
// LINE 235:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 1;
// LINE 236:
	__asm        call   0x0056EC50;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   dword ptr ds:[0x5B7CAC];
	__asm        mov    eax, ds:[0x5B7CA8];
	__asm        add    eax, edx;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x122], eax;
// LINE 238:
	__asm        jmp    near ptr 0x00534DDA;
// LINE 240:
	__asm        xor    eax, eax;
	__asm        sub    eax, ds:[0x5B4760];
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x122], eax;
// LINE 243:
	__asm        mov    ecx, this;
	__asm        call   0x005022B0;
// LINE 244:
	__asm        jmp    near ptr 0x00535124;
// LINE 247:
	__asm        mov    ecx, this;
	__asm        call   0x00535709;
// LINE 249:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     near ptr 0x00534E11;
// LINE 251:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 2;
// LINE 253:
	__asm        jmp    near ptr 0x00534EEA;
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x30;
	__asm        jne    near ptr 0x00534E50;
	__asm        mov    ecx, this;
	__asm        call   0x00535202;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x00534E50;
	__asm        mov    ecx, this;
	__asm        call   0x005045B6;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x00534E50;
// LINE 255:
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 257:
	__asm        jmp    near ptr 0x00534EEA;
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     near ptr 0x00534EEA;
// LINE 259:
	__asm        push   0xA;
	__asm        push   0xF;
	__asm        mov    ecx, this;
	__asm        call   0x0050217C;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x00534E9D;
// LINE 261:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 3;
// LINE 262:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xF6], 0;
// LINE 263:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xFE], 0x780000;
// LINE 265:
	__asm        jmp    near ptr 0x00534EE5;
// LINE 269:
// Block start:
	struct _MISSION_PARMS mp;
	__asm        push   0x10D;
	__asm        push   0x5B7CC0;
	__asm        push   0x5B7CE4;
	__asm        call   0x0056DA30;
	__asm        add    esp, 0xC;
	__asm        jmp    near ptr 0x00534EBE;
	__asm        jmp    near ptr 0x00534EBE;
// LINE 270:
	__asm        mov    mp.op, 0x1D;
// LINE 271:
	__asm        mov    mp.i2num, 8;
// LINE 272:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        mov    mp.id, eax;
// LINE 274:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 4;
// LINE 277:
// Block end:
	__asm        jmp    near ptr 0x00535129;
// LINE 280:
	__asm        mov    ecx, this;
	__asm        call   0x005022B0;
// LINE 281:
	__asm        jmp    near ptr 0x00535124;
// LINE 289:
	__asm        xor    eax, eax;
	__asm        sub    eax, ds:[0x5B4760];
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0xFE], eax;
// LINE 291:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xF6], 0;
	__asm        jne    near ptr 0x00534F2A;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xFE], 0;
	__asm        jg     near ptr 0x00534FAD;
// LINE 293:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xFA], 0;
	__asm        jne    near ptr 0x00534F66;
// LINE 295:
	__asm        mov    mp.op, 0x1D;
// LINE 296:
	__asm        mov    mp.i2num, 8;
// LINE 297:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        mov    mp.id, eax;
// LINE 299:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 4;
// LINE 300:
	__asm        jmp    near ptr 0x00535129;
// LINE 304:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     near ptr 0x00534F8B;
	__asm        mov    ecx, this;
	__asm        call   0x005049FE;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x00534F8B;
// LINE 306:
	__asm        mov    ecx, this;
	__asm        call   0x00504B0A;
// LINE 310:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x60;
	__asm        jne    near ptr 0x00534FA5;
// LINE 313:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 0;
// LINE 316:
	__asm        mov    ecx, this;
	__asm        call   0x005022B0;
// LINE 319:
	__asm        jmp    near ptr 0x00535124;
// LINE 322:
	__asm        mov    ecx, this;
	__asm        call   0x00535709;
// LINE 323:
	__asm        mov    ecx, this;
	__asm        call   0x0050417D;
// LINE 326:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     near ptr 0x0053506C;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     near ptr 0x0053506C;
// LINE 328:
	__asm        push   0xA;
	__asm        push   0xF;
	__asm        mov    ecx, this;
	__asm        call   0x0050217C;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x0053501F;
// LINE 330:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 3;
// LINE 331:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xF6], 0;
// LINE 332:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xFE], 0x780000;
// LINE 334:
	__asm        jmp    near ptr 0x00535067;
// LINE 338:
// Block start:
	struct _MISSION_PARMS mp;
	__asm        push   0x152;
	__asm        push   0x5B7CEC;
	__asm        push   0x5B7D10;
	__asm        call   0x0056DA30;
	__asm        add    esp, 0xC;
	__asm        jmp    near ptr 0x00535040;
	__asm        jmp    near ptr 0x00535040;
// LINE 339:
	__asm        mov    mp.op, 0x1D;
// LINE 340:
	__asm        mov    mp.i2num, 8;
// LINE 341:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        mov    mp.id, eax;
// LINE 343:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 4;
// LINE 346:
// Block end:
	__asm        jmp    near ptr 0x00535124;
// LINE 351:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     near ptr 0x0053508F;
// LINE 352:
	__asm        mov    eax, ds:[0x5B7CB0];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x126], eax;
// LINE 354:
	__asm        jmp    near ptr 0x005350D2;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x126], 0;
	__asm        jge    near ptr 0x005350BF;
// LINE 356:
	__asm        mov    eax, ds:[0x5B7CB0];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x126], eax;
// LINE 357:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 0;
// LINE 359:
	__asm        jmp    near ptr 0x005350D2;
// LINE 360:
	__asm        xor    eax, eax;
	__asm        sub    eax, ds:[0x5B4760];
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x126], eax;
// LINE 362:
	__asm        mov    ecx, this;
	__asm        call   0x005022B0;
// LINE 363:
	__asm        jmp    near ptr 0x00535124;
// LINE 367:
	__asm        mov    ecx, this;
	__asm        call   0x00506333;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x005350F7;
// LINE 369:
	__asm        mov    ecx, this;
	__asm        call   0x00503E6E;
// LINE 371:
	__asm        jmp    near ptr 0x00535124;
	__asm        cmp    dword ptr [ebp-0x68], 4;
	__asm        ja     near ptr 0x00535124;
	__asm        mov    eax, [ebp-0x68];
	__asm        jmp    dword ptr [eax*4+0x535110];
	__asm        bound  ecx, qword ptr [ebx+edx*2];
	__asm        out    0x4D, eax;
	__asm        push   ebx;
	__asm        add    [edx-0x8FFACB1], dh;
	__asm        dec    esi;
	__asm        push   ebx;
	__asm        add    bh, bl;
	__asm        push   eax;
	__asm        push   ebx;
	__asm        (bad);
// LINE 387:
	__asm        jmp    near ptr 0x00535129;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0053512e
void CriminalEvaderCarClass::PullOver(short carModel) {
// LINE 391:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 393:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 3;
	__asm        je     near ptr 0x0053515A;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 4;
	__asm        jne    near ptr 0x0053515F;
// LINE 394:
	__asm        jmp    near ptr 0x005351AC;
// LINE 397:
	__asm        movsx  eax, carModel;
	__asm        cmp    eax, 0x11D;
	__asm        jne    near ptr 0x0053517E;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        jne    near ptr 0x0053519B;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 1;
	__asm        jne    near ptr 0x005351A7;
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x30;
	__asm        jne    near ptr 0x005351A7;
// LINE 398:
	__asm        mov    eax, reinterpret_cast<uint32_t>(carModel);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x005048CD;
// LINE 399:
	__asm        jmp    near ptr 0x005351AC;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}

// FUNCTION: COPTER_D 0x005351b3
void CriminalEvaderCarClass::AdjustSpeed() {
// LINE 417:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 418:
	__asm        mov    ecx, this;
	__asm        call   0x0050409A;
// LINE 420:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 2;
	__asm        jne    near ptr 0x005351F8;
// LINE 422:
	__asm        mov    eax, ds:[0x5B7CB4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDE], eax;
// LINE 424:
	__asm        jmp    near ptr 0x005351FD;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00535202
int32_t CriminalEvaderCarClass::NearToBuilding() {
	 // Switch table at 0x00535675
	 // Switch table at 0x0053557c
	 // Switch table at 0x005354c9
	 // Switch table at 0x005353dc
	 // Switch table at 0x005352c5
	struct _GridCoordinates scanLoc;
	class SpiralScan scan;

// LINE 441:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x4C;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 442:
	__asm        movsx  eax, word ptr ds:[0x5B7CB8];
	__asm        push   eax;
	__asm        lea    ecx, scan.currDist;
	__asm        call   0x00542DC0;
// LINE 443:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x7C];
	__asm        mov    reinterpret_cast<uint16_t>(scanLoc.x), ax;
// LINE 447:
// Block start:
	unsigned short tt;
	__asm        xor    eax, eax;
	__asm        mov    al, scanLoc.x;
	__asm        mov    eax, [eax*4+0x639850];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, scanLoc.y;
	__asm        movzx  ax, byte ptr [eax+ecx];
	__asm        mov    tt, ax;
// LINE 448:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11E];
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    near ptr 0x005356B4;
// LINE 451:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    near ptr 0x00535282;
// LINE 480:
	__asm        mov    dword ptr [ebp-0x1C], 1;
	__asm        jmp    near ptr 0x00535270;
	__asm        mov    eax, [ebp-0x1C];
	__asm        jmp    near ptr 0x00535704;
// LINE 481:
	__asm        jmp    near ptr 0x00535355;
// LINE 482:
	__asm        jmp    near ptr 0x00535355;
	__asm        sub    dword ptr [ebp-0x3C], 0x70;
	__asm        cmp    dword ptr [ebp-0x3C], 0x8F;
	__asm        ja     near ptr 0x00535355;
	__asm        mov    eax, [ebp-0x3C];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x5352C5];
	__asm        jmp    dword ptr [ecx*4+0x5352A5];
	__asm        push   edx;
	__asm        push   ebx;
	__asm        add    [edx+edx*2+0x53], ah;
	__asm        add    [edx+edx*2+0x53], ah;
	__asm        add    [edx+edx*2+0x53], ah;
	__asm        add    [edx+edx*2+0x53], ah;
	__asm        add    [edx+edx*2+0x53], ah;
	__asm        add    [edx+edx*2+0x53], ah;
	__asm        add    [ebp+0x53], dl;
	__asm        push   ebx;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        pop    es;
	__asm        add    [ecx], eax;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        add    al, [edx];
	__asm        add    al, [edx];
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        add    eax, [edi];
	__asm        pop    es;
	__asm        pop    es;
	__asm        add    al, 7;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        add    eax, 0x7070707;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
// LINE 484:
	__asm        jmp    near ptr 0x005356DC;
// LINE 487:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x40], eax;
	__asm        jmp    near ptr 0x00535388;
// LINE 510:
	__asm        mov    dword ptr [ebp-0x20], 1;
	__asm        jmp    near ptr 0x00535376;
	__asm        mov    eax, [ebp-0x20];
	__asm        jmp    near ptr 0x00535704;
// LINE 511:
	__asm        jmp    near ptr 0x00535457;
// LINE 512:
	__asm        jmp    near ptr 0x00535457;
	__asm        sub    dword ptr [ebp-0x40], 0x7D;
	__asm        cmp    dword ptr [ebp-0x40], 0x7A;
	__asm        ja     near ptr 0x00535457;
	__asm        mov    eax, [ebp-0x40];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x5353DC];
	__asm        jmp    dword ptr [ecx*4+0x5353A8];
	__asm        push   0x53;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edx+0x53], ch;
	__asm        push   ebx;
	__asm        add    [edi+0x54], dl;
	__asm        push   ebx;
	__asm        add    [eax], al;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        add    [ecx], eax;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        add    al, [edx];
	__asm        or     al, 3;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        add    al, 0xC;
	__asm        or     al, 5;
	__asm        add    eax, 0xC060C0C;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        pop    es;
	__asm        pop    es;
	__asm        pop    es;
	__asm        or     al, 8;
	__asm        or     [ecx+ecx], cl;
	__asm        or     [ecx], ecx;
	__asm        or     [esp+ecx], ecx;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xA;
	__asm        or     al, 0xB;
// LINE 513:
	__asm        jmp    near ptr 0x005356DC;
// LINE 516:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x44], eax;
	__asm        jmp    near ptr 0x0053548A;
// LINE 531:
	__asm        mov    dword ptr [ebp-0x24], 1;
	__asm        jmp    near ptr 0x00535478;
	__asm        mov    eax, [ebp-0x24];
	__asm        jmp    near ptr 0x00535704;
// LINE 532:
	__asm        jmp    near ptr 0x005354F2;
// LINE 533:
	__asm        jmp    near ptr 0x005354F2;
	__asm        sub    dword ptr [ebp-0x44], 0x90;
	__asm        cmp    dword ptr [ebp-0x44], 0x28;
	__asm        ja     near ptr 0x005354F2;
	__asm        mov    eax, [ebp-0x44];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x5354C9];
	__asm        jmp    dword ptr [ecx*4+0x5354AD];
	__asm        insb;
	__asm        push   esp;
	__asm        push   ebx;
	__asm        add    [esp+edx*2+0x53], ch;
	__asm        add    [esp+edx*2+0x53], ch;
	__asm        add    [esp+edx*2+0x53], ch;
	__asm        add    [esp+edx*2+0x53], ch;
	__asm        add    [esp+edx*2+0x53], ch;
	__asm        add    dl, dh;
	__asm        push   esp;
	__asm        push   ebx;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [esi], al;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        add    [ecx], eax;
	__asm        add    [esi], eax;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        push   es;
	__asm        add    al, [edx];
	__asm        push   es;
	__asm        add    eax, [esi];
	__asm        add    al, 6;
	__asm        push   es;
	__asm        push   es;
	__asm        (bad);
// LINE 534:
	__asm        jmp    near ptr 0x005356DC;
// LINE 537:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x48], eax;
	__asm        jmp    near ptr 0x00535525;
// LINE 572:
	__asm        mov    dword ptr [ebp-0x28], 1;
	__asm        jmp    near ptr 0x00535513;
	__asm        mov    eax, [ebp-0x28];
	__asm        jmp    near ptr 0x00535704;
// LINE 573:
	__asm        jmp    near ptr 0x005355EF;
// LINE 574:
	__asm        jmp    near ptr 0x005355EF;
	__asm        sub    dword ptr [ebp-0x48], 0x80;
	__asm        cmp    dword ptr [ebp-0x48], 0x72;
	__asm        ja     near ptr 0x005355EF;
	__asm        mov    eax, [ebp-0x48];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x53557C];
	__asm        jmp    dword ptr [ecx*4+0x535548];
	__asm        pop    es;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [edi], al;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    bh, ch;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        add    [eax], al;
	__asm        add    [esp+ecx], cl;
	__asm        add    [ecx], eax;
	__asm        add    [ecx], eax;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        add    cl, [ebx+eax];
	__asm        add    eax, [ebx];
	__asm        or     al, 0xC;
	__asm        or     al, 4;
	__asm        add    al, 4;
	__asm        add    al, 4;
	__asm        add    al, 4;
	__asm        add    al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 5;
	__asm        add    eax, 0x5050505;
	__asm        add    eax, 0xC0C0C05;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 6;
	__asm        or     al, 0xC;
	__asm        pop    es;
	__asm        or     al, 0xC;
	__asm        or     al, 0xC;
	__asm        or     al, 8;
	__asm        or     al, 0xC;
	__asm        or     [ecx], ecx;
	__asm        or     al, 0xC;
	__asm        or     cl, [ebx+ecx];
// LINE 575:
	__asm        jmp    near ptr 0x005356DC;
// LINE 578:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
	__asm        and    eax, 0xFFFF;
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    near ptr 0x00535622;
// LINE 613:
	__asm        mov    dword ptr [ebp-0x2C], 1;
	__asm        jmp    near ptr 0x00535610;
	__asm        mov    eax, [ebp-0x2C];
	__asm        jmp    near ptr 0x00535704;
// LINE 614:
	__asm        jmp    near ptr 0x005356AA;
// LINE 615:
	__asm        jmp    near ptr 0x005356AA;
	__asm        sub    dword ptr [ebp-0x4C], 0xC6;
	__asm        cmp    dword ptr [ebp-0x4C], 0x34;
	__asm        ja     near ptr 0x005356AA;
	__asm        mov    eax, [ebp-0x4C];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x535675];
	__asm        jmp    dword ptr [ecx*4+0x535645];
	__asm        add    al, 0x56;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [esi+edx*2], al;
	__asm        push   ebx;
	__asm        add    [edx+0x5356], ch;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        add    [eax], al;
	__asm        or     ecx, [ebx];
	__asm        or     ecx, [ebx];
	__asm        or     ecx, [ebx];
	__asm        add    [ebx], ecx;
	__asm        or     ecx, [ebx];
	__asm        or     eax, [edx];
	__asm        add    al, [edx];
	__asm        or     ecx, [ebx];
	__asm        add    eax, [ebx];
	__asm        or     eax, [esp+eax];
	__asm        add    al, 4;
	__asm        add    al, 0xB;
	__asm        add    eax, 0x60B0B05;
	__asm        push   es;
	__asm        or     eax, [edi];
	__asm        or     ecx, [eax];
	__asm        or     [ebx], cl;
	__asm        or     [ebx], ecx;
	__asm        or     cl, [edx];
	__asm        (bad);
// LINE 616:
	__asm        jmp    near ptr 0x005356DC;
// LINE 617:
	__asm        jmp    near ptr 0x005356DC;
	__asm        cmp    dword ptr [ebp-0x38], 4;
	__asm        ja     near ptr 0x005356DC;
	__asm        mov    eax, [ebp-0x38];
	__asm        jmp    dword ptr [eax*4+0x5356C8];
	__asm        push   esp;
	__asm        push   edx;
	__asm        push   ebx;
	__asm        add    [edx+0x53], bl;
	__asm        push   ebx;
	__asm        add    [esp+edx*2+0x53], bl;
	__asm        add    bh, dh;
	__asm        push   esp;
	__asm        push   ebx;
	__asm        add    ah, dh;
	__asm        push   ebp;
	__asm        push   ebx;
	__asm        (bad);
// LINE 619:
// Block end:
	__asm        lea    eax, scanLoc.x;
	__asm        push   eax;
	__asm        lea    ecx, scan.currDist;
	__asm        call   0x00542E03;
	__asm        test   eax, eax;
	__asm        jne    near ptr 0x00535229;
// LINE 621:
	__asm        mov    dword ptr [ebp-0x30], 0;
	__asm        jmp    near ptr 0x005356FC;
	__asm        mov    eax, [ebp-0x30];
	__asm        jmp    near ptr 0x00535704;
// LINE 622:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00535709
void CriminalEvaderCarClass::ShowWhereWeAre() {
	struct _MISSION_PARMS mp;

// LINE 644:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x1C;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 649:
	__asm        mov    mp.op, 0xA;
// LINE 650:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10E];
	__asm        mov    mp.id, eax;
// LINE 654:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    mp.maploc.x, ecx;
// LINE 655:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    mp.maploc.y, ecx;
// LINE 656:
	__asm        lea    eax, mp.op;
	__asm        push   eax;
	__asm        call   0x004FBD4A;
	__asm        add    esp, 4;
// LINE 657:
	__asm        jmp    near ptr 0x0053574F;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x00535754
void CriminalEvaderCarClass::SetSaveData(struct _AUTO_LOAD_SAVE* sd) {
// LINE 667:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 669:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11A];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x10E], eax;
// LINE 670:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11E];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x112], eax;
// LINE 671:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x122];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x116], eax;
// LINE 672:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x126];
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x11A], eax;
// LINE 675:
	__asm        mov    eax, sd;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x0050917E;
// LINE 676:
	__asm        jmp    near ptr 0x005357B9;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}

// FUNCTION: COPTER_D 0x005357c0
void CriminalEvaderCarClass::LoadSaveData(struct _AUTO_LOAD_SAVE* sd) {
// LINE 687:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 689:
	__asm        mov    eax, sd;
	__asm        test   byte ptr [eax], 2;
	__asm        jne    near ptr 0x005357DD;
// LINE 691:
	__asm        jmp    near ptr 0x00535836;
// LINE 695:
	__asm        mov    eax, sd;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x00509489;
// LINE 698:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x10E];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11A], eax;
// LINE 699:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x112];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x11E], eax;
// LINE 700:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x116];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x122], eax;
// LINE 701:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x11A];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x126], eax;
// LINE 702:
	__asm        jmp    near ptr 0x00535836;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}



// Contribution: 1:00134840-00134855 Module: 161, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:00134860-00134898 Module: 161, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00535860
// CriminalEvaderCarClass::`scalar deleting destructor'



// Contribution: 2:00004258-0000427b Module: 161, 8 byte alignment, initialized_data, (comdat), read, 
// GLOBAL: COPTER_D 0x00593258
// ??_7CriminalEvaderCarClass@@6B@


// Contribution: 3:00020ca8-00020d15 Module: 161, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b7ca8
// CriminalEvaderCarClass::baseTimeBetweenCriminalActivities
// GLOBAL: COPTER_D 0x005b7cac
// CriminalEvaderCarClass::maxTimeBetweenCriminalActivities
// GLOBAL: COPTER_D 0x005b7cb0
// CriminalEvaderCarClass::constantTimeToBeOnTheRun
// GLOBAL: COPTER_D 0x005b7cb4
// CriminalEvaderCarClass::evasionSpeedMultiplier
// GLOBAL: COPTER_D 0x005b7cb8
// CriminalEvaderCarClass::maxSearchForBuildingRadius
// GLOBAL: COPTER_D 0x005b7cbc
// CriminalEvaderCarClass::curCriminalCars


// Contribution: 3:000949a0-000949b3 Module: 161, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0062b9a0
// CriminalEvaderCarClass::criminalCars
