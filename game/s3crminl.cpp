// Module: S3crminl.obj
// Source: C:\Copter\source\game\S3crminl.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class CriminalEvaderCarClass (forward reference);
// VTABLE: COPTER_D 0x00593258
class CriminalEvaderCarClass : public AutomobileClass
{ // packed(0x12a bytes) TI: 0x4598
public:
	static /*packed*/ class CriminalEvaderCarClass *criminalCars[0];
	enum MissionState {
		CRUISING = 0,
		SEARCHING = 1,
		ON_THE_RUN = 2,
		OUT_OF_CAR = 3,
		MISSION_OVER = 4,
	};
	enum CriminalType {
		BURGLAR = 0,
		DRUG_PUSHER = 1,
		SNIPER = 2,
		ARSONIST = 3,
		TERRORIST = 4,
	};
protected:
	/*+0x11a*/ enum CriminalEvaderCarClass::MissionState missionState;
	/*+0x11e*/ enum CriminalEvaderCarClass::CriminalType criminalType;
	/*+0x122*/ int32_t timeToLeaveCar;
	/*+0x126*/ int32_t timeToBeOnTheRun;
	static int32_t baseTimeBetweenCriminalActivities;
	static int32_t maxTimeBetweenCriminalActivities;
	static int32_t constantTimeToBeOnTheRun;
	static int32_t evasionSpeedMultiplier;
	static short maxSearchForBuildingRadius;
	static int32_t curCriminalCars;
public:
	void CriminalEvaderCarClass(const /*packed*/ class CriminalEvaderCarClass&);
	void CriminalEvaderCarClass();
	virtual void ~CriminalEvaderCarClass() /* override */;
	// calltype: NearC
	static /*packed*/ class CriminalEvaderCarClass* CreateInstance(int32_t);
	// calltype: NearC
	static int32_t StartCriminalMission(short, short, long, long);
protected:
	virtual void AdjustSpeed() /* override */;
	virtual void BeamToWithinCameraRange() /* override */;
	virtual void ItterateFSM() /* override */;
	virtual void PullOver(short) /* override */;
	virtual void SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*) /* override */;
	virtual void LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*) /* override */;
	int32_t AtScene();
	int32_t NearToBuilding();
public:
	/*packed*/ class CriminalEvaderCarClass operator=(const /*packed*/ class CriminalEvaderCarClass&);
private:
	void ShowWhereWeAre();
};

// Type: int32_t;

// Type: short;

// Type: long;

// Type: void;

// Type: /*packed*/ struct _MISSION_PARMS;
struct _MISSION_PARMS{ // packed(0x18 bytes) TI: 0x307d
	/*+0x0*/   long op;
	/*+0x4*/   long id;
	/*+0x8*/   /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x10*/  long i2num;
	/*+0x14*/  long flags;
};

// Type: /*packed*/ struct _GridCoordinates;
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ class SpiralScan;
class SpiralScan{ // packed(0x10 bytes) TI: 0x2fb5
public:
	void SpiralScan(int32_t);
	void ~SpiralScan();
	int32_t Next(/*packed*/ struct _GridCoordinates&);
	int32_t InCityGridLimits(/*packed*/ struct _GridCoordinates);
private:
	/*+0x0*/   int32_t currDist;
	/*+0x4*/   int32_t currDir;
	/*+0x8*/   int32_t currDia;
	/*+0xc*/   int32_t maxDia;
};

// Type: unsigned short;

// Type: /*packed*/ struct _AUTO_LOAD_SAVE (forward reference);
struct _AUTO_LOAD_SAVE{ // packed(0x344 bytes) TI: 0x42d7
	/*+0x0*/   int32_t flags;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x68*/  /*packed*/ struct Goal goal; // 0x2a bytes
	/*+0x92*/  /*packed*/ struct _GridCoordinates goalpRGVFixup; // 0x2 bytes
	/*+0x94*/  int32_t DeltaFromCenter;
	/*+0x98*/  int32_t stalledTimer;
	/*+0x9c*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xa8*/  int32_t remainingTime;
	/*+0xac*/  int32_t desiredSpeed;
	/*+0xb0*/  int32_t desiredHiwaySpeed;
	/*+0xb4*/  int32_t beamDelay;
	/*+0xb8*/  int32_t beamTimer;
	/*+0xbc*/  int32_t m_cellBaseY;
	/*+0xc0*/  int32_t timePulledOver;
	/*+0xc4*/  enum DirectionTypes hiwaydir;
	/*+0xc8*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xca*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xcc*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xce*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xd0*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xd2*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
	/*+0xd4*/  int32_t speed;
	/*+0xd8*/  long prevDir;
	/*+0xdc*/  long turnIndex;
	/*+0xe0*/  int32_t currDist;
	/*+0xe4*/  int32_t legOfTurn;
	/*+0xe8*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xec*/  int32_t personDone;
	/*+0xf0*/  int32_t personState;
	/*+0xf4*/  int32_t personTimer;
	/*+0xf8*/  int32_t timeToLive;
	/*+0xfc*/  int32_t fireTime;
	/*+0x100*/ long fireSeq;
	/*+0x104*/ long missionId;
	/*+0x108*/ /*packed*/ struct _GridCoordinates cptrfixup; // 0x2 bytes
	/*+0x10a*/ int32_t spotlightHitCounter;
	struct _AUTO_LOAD_SAVE::_CRIMINAL{ // packed(0x10 bytes) TI: 0x42df
		/*+0x0*/   long missionState;
		/*+0x4*/   long criminalType;
		/*+0x8*/   int32_t timeToLeaveCar;
		/*+0xc*/   int32_t timeToBeOnTheRun;
	};
public:
	/*+0x10e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_CRIMINAL c; // 0x10 bytes
	struct _AUTO_LOAD_SAVE::_EMERGENCY{ // packed(0x186 bytes) TI: 0x42dd
		/*+0x0*/   /*packed*/ struct _GridCoordinates baseLocation; // 0x2 bytes
		/*+0x2*/   /*packed*/ struct _GridCoordinates emergencyLocation; // 0x2 bytes
		/*+0x4*/   long emergencyType;
		/*+0x8*/   long timeOfArrival;
		/*+0xc*/   /*packed*/ struct _DYOBJ_INST dispatchIcon; // 0x64 bytes
		/*+0x70*/  int32_t timeToEmergency;
		/*+0x74*/  long targetfixup;
		/*+0x78*/  unsigned char dispatchPath[256]; // 0x100 bytes
		/*+0x178*/ unsigned char dispatchPathIndex; // 0x1 bytes
		/*+0x179*/ unsigned char dispatchPathLength; // 0x1 bytes
		/*+0x17a*/ long emergencyState;
		/*+0x17e*/ int32_t stationID;
		/*+0x182*/ int32_t numberOfSeats;
	};
public:
	/*+0x11e*/ /*packed*/ struct _AUTO_LOAD_SAVE::_EMERGENCY e; // 0x186 bytes
	struct _AUTO_LOAD_SAVE::_FIRE{ // packed(0x18 bytes) TI: 0x42db
		/*+0x0*/   int32_t dousingFire;
		/*+0x4*/   int32_t distToFire;
		/*+0x8*/   /*packed*/ struct Point3d firevec; // 0xc bytes
		/*+0x14*/  int32_t pathID;
	};
public:
	/*+0x2a4*/ /*packed*/ struct _AUTO_LOAD_SAVE::_FIRE f; // 0x18 bytes
	struct _AUTO_LOAD_SAVE::_POLICE{ // packed(0x88 bytes) TI: 0x42d9
		/*+0x0*/   /*packed*/ struct Goal currDestGoal; // 0x2a bytes
		/*+0x2a*/  /*packed*/ struct _GridCoordinates currpRGVFixup; // 0x2 bytes
		/*+0x2c*/  /*packed*/ struct Goal destGoal1; // 0x2a bytes
		/*+0x56*/  /*packed*/ struct _GridCoordinates dest1pRGVFixup; // 0x2 bytes
		/*+0x58*/  /*packed*/ struct Goal destGoal2; // 0x2a bytes
		/*+0x82*/  /*packed*/ struct _GridCoordinates dest2pRGVFixup; // 0x2 bytes
		/*+0x84*/  int32_t foundRoad;
	};
public:
	/*+0x2bc*/ /*packed*/ struct _AUTO_LOAD_SAVE::_POLICE p; // 0x88 bytes
};

// Type: uint32_t;

// Type: /*packed*/ class AutomobileClass;
// VTABLE: COPTER_D 0x00592d98
class AutomobileClass{ // packed(0x11a bytes) TI: 0x4880
	enum CarType {
		kCarAmbulance = 0,
		kCarCop = 1,
		kCarFiretruck = 2,
		kCarCriminal = 3,
	};
	enum AutoMessageID {
		AM_NO_MESSAGE = 0,
		AM_CANCEL_AUTO_MISSION = 1,
	};
	enum /* __unnamed */ {
		CAR_TYPES = 7,
		PERCENTAGE_OF_AUTO1 = 10,
		PERCENTAGE_OF_AUTO2 = 20,
		PERCENTAGE_OF_AUTO3 = 20,
		PERCENTAGE_OF_AUTO4 = 10,
		PERCENTAGE_OF_AUTO5 = 10,
		PERCENTAGE_OF_AUTO6 = 20,
		PERCENTAGE_OF_AUTO7 = 20,
		TOTAL_PERCENTAGE = 110,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
		DEAD_END_HIWAY = 16,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		AUTO_IN_WAY = 4,
		DEBRIS_IN_WAY = 5,
		UNIDENTIFIED_IN_WAY = 6,
		HELI_IN_WAY = 7,
		END_OF_ROAD = 8,
		END_OF_HIWAY = 9,
		INTERSECTION_FULL = 10,
		BEEN_PULLED_OVER = 11,
	};
	enum RoadTileOffsets {
		RD_CENTOFF = 851968,
		RD_EDGEOFF = 131072,
	};
	enum HiwayOffsets {
		HW_CENTOFF_LANE1 = 851968,
		HW_EDGEOFF_LANE1 = 131072,
		HW_CENTOFF_LANE2 = 851968,
		HW_EDGEOFF_LANE2 = 131072,
		HW_HEIGHT = 2031616,
	};
public:
	static int32_t fireSirenDist;
	static int32_t policeSirenDist;
	static int32_t ambSirenDist;
	static int32_t fireHoseDist;
	enum /* __unnamed */ {
		CAR_RADIUS = 327680,
		COLLISION_SPACE = 655360,
		ROAD_SPEED = 2621440,
		ROAD_SLOWDOWN_FACTOR = 131072,
		HIWAY_SPEED = 6225920,
		HIWAY_SLOWDOWN_FACTOR = 327680,
		SPEED_VARIANCE = 262144,
		HIWAY_VARIANCE = 655360,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
	};
	enum Flags {
		AUTO_INITIALIZED = 1,
		AUTO_PLACED = 2,
		AUTO_NEEDS_TO_PULL_OVER = 4,
		AUTO_PULL_OVER = 8,
		AUTO_PULLING_OVER = 16,
		AUTO_PULLED_OVER = 32,
		AUTO_PULLING_OUT = 64,
		AUTO_IN_INTERSECTION = 128,
		AUTO_ON_FIRE = 256,
		AUTO_JAMMED = 512,
		AUTO_RIGHT_OF_WAY = 1024,
		AUTO_ON_HIWAY = 2048,
		AUTO_SPEEDER = 4096,
		AUTO_SPEEDER_DONE = 8192,
		AUTO_UTURN = 16384,
	};
public:
	/*+0x4*/   long carModel;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x70*/  /*packed*/ struct Goal goal; // 0x2a bytes
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	/*+0x9a*/  int32_t DeltaFromCenter;
	/*+0x9e*/  int32_t stalledTimer;
	/*+0xa2*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xae*/  int32_t remainingTime;
	/*+0xb2*/  int32_t desiredSpeed;
	/*+0xb6*/  int32_t desiredHiwaySpeed;
	/*+0xba*/  int32_t beamDelay;
	/*+0xbe*/  int32_t beamTimer;
	/*+0xc2*/  int32_t m_cellBaseY;
	/*+0xc6*/  int32_t timePulledOver;
	/*+0xca*/  int32_t hornSoundId;
	/*+0xce*/  enum DirectionTypes hiwaydir;
	/*+0xd2*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xd4*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xd6*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xd8*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xda*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xdc*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
protected:
	/*+0xde*/  int32_t speed;
	/*+0xe2*/  enum DirIndex2 prevDir;
	/*+0xe6*/  enum TurnIndex turnIndex;
	/*+0xea*/  int32_t currDist;
	/*+0xee*/  int32_t legOfTurn;
	/*+0xf2*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xf6*/  int32_t personDone;
	/*+0xfa*/  int32_t personState;
	/*+0xfe*/  int32_t personTimer;
	/*+0x102*/ int32_t timeToLive;
	/*+0x106*/ int32_t fireTime;
	/*+0x10a*/ long fireSeq;
	/*+0x10e*/ long missionId;
	/*+0x112*/ /*packed*/ struct _CELL_INFO *cptr;
	/*+0x116*/ int32_t spotlightHitCounter;
	int32_t IsCarPersistant();
	int32_t CanCarBeamToHiwayTile(unsigned short);
public:
	void AutomobileClass(const /*packed*/ class AutomobileClass&);
	void AutomobileClass();
	virtual void ~AutomobileClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class AutomobileClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class AutomobileClass* GetAutoPointer(long);
	// calltype: NearC
	static void DestroyInstance(/*packed*/ class AutomobileClass*);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t MissionStartFire(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static int32_t MissionStartJam(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static void MissionCancel(long);
	// calltype: NearC
	static void SetAllHeadlights(int32_t);
	// calltype: NearC
	static int32_t S3AutoMessage(short, short);
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
	void HitDispatch(long, /*packed*/ struct _DYOBJ_INST*, long, long);
	int32_t AmIABadGuy();
	int32_t Initialize(int32_t);
	void WaterDouse(/*packed*/ struct _DYOBJ_INST*);
	void IveBeenMegaphoned(long);
	void StartFire(long);
	void StartJam(long);
	virtual void PullOver(short); // vtable+0x4
	void PullOut();
	int32_t CanIPullOut();
	int32_t CanIPullOver();
	void DoAUTurn();
	long GetCarModel();
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* GetClosestCar(int32_t, int32_t, int32_t);
protected:
	void Itterate();
	virtual void AdjustSpeed(); // vtable+0x8
	void Reset();
	virtual enum TurnIndex PickTurnDir(/*packed*/ struct Goal*); // vtable+0xc
	void UnPlaceCar();
	void PullOverCiviliansInWay();
	virtual void ItterateFSM(); // vtable+0x10
	int32_t InitializeInstance(int32_t);
	void LinkToCell(const /*packed*/ struct _GridCoordinates&);
	int32_t AreCarsHeadOn(/*packed*/ struct Point3d*);
	enum AutomobileClass::StoppedReasons CollisionCheck(int32_t, /*packed*/ struct _DYOBJ_INST**);
	int32_t IsCarOutOfCameraRange();
	void TurnOffHeadlight();
	void TurnOnHeadlight();
	int32_t AutoMessage(short);
	int32_t PlacePerson(int32_t, int32_t);
	virtual void SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x14
	virtual void LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x18
	void HonkHorn();
	void SetHiwayDirection(unsigned short);
	int32_t DoHiwayTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void AdjustCurrentHiwayPosition();
	void AdjustNextHiwayPosition();
	enum AutomobileClass::IntersectionTypes PickHiwayDir(/*packed*/ struct _GridCoordinates&);
	void MakeAHiwayTurn(enum AutomobileClass::IntersectionTypes);
	void GoStraight();
	void TurnLeft();
	void TurnRight();
	void MoveForwardOnHiway();
	void DoDiagonalRoadFixup();
	virtual void BeamToWithinCameraRange(); // vtable+0x1c
	virtual int32_t BeamToLocation(const /*packed*/ struct _GridCoordinates&); // vtable+0x20
	void MoveAuto(int32_t);
	void ChangeAutoColor();
private:
	void UnlinkFromCell(const /*packed*/ struct _GridCoordinates&);
	void TransitionBetweenGoals();
	void RunFireState();
	void RunJamState();
	void IveBeenSpotlighted(/*packed*/ struct _DYOBJ_INST*);
	int32_t IsThisAnEmergencyVehicle();
	void DoPullOverStuff(int32_t);
	int32_t CanIDoAUTurn();
public:
	/*packed*/ class AutomobileClass operator=(const /*packed*/ class AutomobileClass&);
};



// Contribution: 1:001339c0-0013483c Module: 161, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x005349c0
int32_t CreateCriminalCarInstance(int32_t instanceID) {
// LINE 82:
_T24:
_T26:
	return (CriminalEvaderCarClass::CreateInstance(instanceID) == 0x0);
// LINE 83:
}

// FUNCTION: COPTER_D 0x005349f0
int32_t S3CriminalMissionStart(short mID, short mType, long x, long y) {
// LINE 88:
	return CriminalEvaderCarClass::StartCriminalMission(mID, mType, x, y);
// LINE 89:
}

// FUNCTION: COPTER_D 0x00534a18
void CriminalEvaderCarClass::CriminalEvaderCarClass() {

	this->AutomobileClass::AutomobileClass();
	this-><CriminalEvaderCarClass+0x00> = 0x593258;
// LINE 98:
	this->carModel = 0x11e;
// LINE 99:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00534a4c
void CriminalEvaderCarClass::~CriminalEvaderCarClass() {

	this-><CriminalEvaderCarClass+0x00> = 0x593258;
	__asm        jmp    __RETURN;
__RETURN:
	this->AutomobileClass::~AutomobileClass();
}

// FUNCTION: COPTER_D 0x00534a73
/*packed*/ class CriminalEvaderCarClass* CriminalEvaderCarClass::CreateInstance(int32_t instanceID) {
	/*bp-0x4*/   /*packed*/ class CriminalEvaderCarClass *youveWonABrandNewCar;

// LINE 127:
	__asm        push   0x12A;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T33;

	__asm        mov    ecx, [ebp-8];
	__asm        call   CriminalEvaderCarClass::CriminalEvaderCarClass;
	__asm        mov    youveWonABrandNewCar, eax;
	__asm        jmp    _T3a;
_T33:
	youveWonABrandNewCar = 0x0;
// LINE 130:
_T3a:
	__asm        cmp    youveWonABrandNewCar, 0;
	__asm        je     _Ta2;
// LINE 133:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    ecx, youveWonABrandNewCar;
	__asm        call   AutomobileClass::Initialize;
	__asm        test   eax, eax;
	__asm        je     _T7b;
// LINE 135:
	__asm        mov    eax, youveWonABrandNewCar;
	__asm        mov    ecx, CriminalEvaderCarClass::curCriminalCars;
	__asm        mov    CriminalEvaderCarClass::criminalCars[0][ecx*4], eax;
	__asm        inc    CriminalEvaderCarClass::curCriminalCars;
// LINE 138:
	return youveWonABrandNewCar;
// LINE 140:
	__asm        jmp    _Ta2;
// LINE 143:
_T7b:
	__asm        mov    eax, youveWonABrandNewCar;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Ta2;

	__asm        push   1;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   dword ptr [eax];
	__asm        jmp    _Ta2;
// LINE 149:
_Ta2:
	return 0x0;
// LINE 150:
}

// FUNCTION: COPTER_D 0x00534b21
int32_t CriminalEvaderCarClass::StartCriminalMission(short mID, short mType, long x, long y) {
	/*bp-0x4*/   /*packed*/ struct _GridCoordinates startLoc;
	/*bp-0x8*/   int32_t i;
	/*bp-0x20*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 159:
	startLoc.x = reinterpret_cast<uint8_t>(x);
// LINE 160:
	startLoc.y = reinterpret_cast<uint8_t>(y);
// LINE 165:
_FOR_21:
	for (i = 0x0; (i < 0x5); i++) {
// LINE 167:
		__asm        mov    eax, i;
		__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
		__asm        test   byte ptr [eax+8], 2;
		__asm        jne    _T113;
// LINE 170:
		__asm        lea    eax, startLoc.x;
		__asm        push   eax;
		__asm        mov    eax, i;
		__asm        mov    ecx, CriminalEvaderCarClass::criminalCars[0][eax*4];
		__asm        call   AutomobileClass::BeamToLocation;
		__asm        test   eax, eax;
		__asm        je     _T10c;
// LINE 175:
		mp.op = 0xa;
// LINE 176:
		mp.id = reinterpret_cast<int16_t>(mID);
// LINE 180:
		__asm        mov    eax, i;
		__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, [eax+0x7C];
		__asm        mov    mp.maploc.x, ecx;
// LINE 181:
		__asm        mov    eax, i;
		__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, [eax+0x7D];
		__asm        mov    mp.maploc.y, ecx;
// LINE 182:
		S3MissionUpdate(mp.op);
// LINE 185:
		__asm        movsx  eax, mID;
		__asm        mov    ecx, i;
		__asm        mov    ecx, CriminalEvaderCarClass::criminalCars[0][ecx*4];
		__asm        mov    [ecx+0x10E], eax;
// LINE 186:
		__asm        mov    eax, i;
		__asm        mov    eax, CriminalEvaderCarClass::criminalCars[0][eax*4];
		__asm        mov    dword ptr [eax+0x11A], 0;
// LINE 187:
		__asm        movsx  eax, mType;
		__asm        mov    ecx, i;
		__asm        mov    ecx, CriminalEvaderCarClass::criminalCars[0][ecx*4];
		__asm        mov    [ecx+0x11E], eax;
// LINE 189:
		__asm        call   rand;
		__asm        movsx  eax, ax;
		__asm        cdq;
		__asm        idiv   CriminalEvaderCarClass::maxTimeBetweenCriminalActivities;
		__asm        mov    eax, CriminalEvaderCarClass::baseTimeBetweenCriminalActivities;
		__asm        add    eax, edx;
		__asm        mov    ecx, i;
		__asm        mov    ecx, CriminalEvaderCarClass::criminalCars[0][ecx*4];
		__asm        mov    [ecx+0x122], eax;
// LINE 190:
		return 0x1;
// LINE 192:
		__asm        jmp    _T113;
// LINE 193:
_T10c:
		return 0x0;
// LINE 195:
_T113:
	}
// LINE 198:
_T118:
	return 0x0;
// LINE 199:
}

// FUNCTION: COPTER_D 0x00534c45
void CriminalEvaderCarClass::ItterateFSM() {
	/*bp-0x18*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 209:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x11A];
	__asm        mov    [ebp-0x68], eax;
	__asm        jmp    _T4b7;
// LINE 212:
_T1d:
	this->CriminalEvaderCarClass::ShowWhereWeAre();
// LINE 214:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     _T141;
// LINE 216:
	this->missionState = 0x2;
// LINE 218:
	__asm        push   0x30;
	__asm        call   S3SoundIsPlaying;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T13c;
// LINE 222:
// Block start:
	/*bp-0x24*/  /*packed*/ struct Point3d loc; // 0xc bytes
	loc.x = (this->autoDynomitor.loc.x - (this->pDirVector->x << 0x4));
// LINE 223:
	loc.y = (this->autoDynomitor.loc.y - (this->pDirVector->y << 0x4));
// LINE 224:
	loc.z = (this->autoDynomitor.loc.z - (this->pDirVector->z << 0x4));
// LINE 226:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        push   0x30;
	__asm        call   S3DSPlay;
	__asm        add    esp, 0xC;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    [ebp-0x5C], ecx;
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    [ebp-0x60], ecx;
// LINE 227:
	__asm        mov    eax, [ebp-0x60];
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 0xA;
	__asm        mov    ecx, [ebp-0x5C];
	__asm        and    ecx, 0xFF;
	__asm        mov    eax, G_omap[0][0][eax+ecx*4];
	__asm        mov    [ebp-0x58], eax;
	__asm        cmp    dword ptr [ebp-0x58], 0;
	__asm        jne    _T10e;

	_assert(0x5b57b8, 0x5b57c4, 0xa0);
	__asm        jmp    _T113;
_T10e:
	__asm        jmp    _T113;
_T113:
	__asm        jmp    _T118;
_T118:
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x112], eax;
// LINE 228:
	S3ExplosionSmokeStart(this->cptr, loc.x, 0x6);
// LINE 230:
// Block end:
_T13c:
	__asm        jmp    _T4df;
// LINE 233:
_T141:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x122], 0;
	__asm        jge    _T182;
// LINE 235:
	this->missionState = 0x1;
// LINE 236:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   CriminalEvaderCarClass::maxTimeBetweenCriminalActivities;
	__asm        mov    eax, CriminalEvaderCarClass::baseTimeBetweenCriminalActivities;
	__asm        add    eax, edx;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x122], eax;
// LINE 238:
	__asm        jmp    _T195;
// LINE 240:
_T182:
	this->timeToLeaveCar -= LoopTime;
// LINE 243:
_T195:
	this->AutomobileClass::ItterateFSM();
// LINE 244:
	__asm        jmp    _T4df;
// LINE 247:
_T1a2:
	this->CriminalEvaderCarClass::ShowWhereWeAre();
// LINE 249:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     _T1cc;
// LINE 251:
	this->missionState = 0x2;
// LINE 253:
	__asm        jmp    _T2a5;
_T1cc:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x30;
	__asm        jne    _T20b;

	__asm        mov    ecx, this;
	__asm        call   CriminalEvaderCarClass::NearToBuilding;
	__asm        test   eax, eax;
	__asm        je     _T20b;

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIPullOver;
	__asm        test   eax, eax;
	__asm        je     _T20b;
// LINE 255:
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 257:
	__asm        jmp    _T2a5;
_T20b:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     _T2a5;
// LINE 259:
	__asm        push   0xA;
	__asm        push   0xF;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::PlacePerson;
	__asm        test   eax, eax;
	__asm        je     _T258;
// LINE 261:
	this->missionState = 0x3;
// LINE 262:
	this->personDone = 0x0;
// LINE 263:
	this->personTimer = 0x780000;
// LINE 265:
	__asm        jmp    _T2a0;
// LINE 269:
// Block start:
	/*bp-0x3c*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
_T258:
	_assert(0x5b7ce4, 0x5b7cc0, 0x10d);
	__asm        jmp    _T279;

	__asm        jmp    _T279;
// LINE 270:
_T279:
	mp.op = 0x1d;
// LINE 271:
	mp.i2num = 0x8;
// LINE 272:
	mp.id = this->missionId;
// LINE 274:
	this->missionState = 0x4;
// LINE 277:
// Block end:
_T2a0:
	return;
// LINE 280:
_T2a5:
	this->AutomobileClass::ItterateFSM();
// LINE 281:
	__asm        jmp    _T4df;
// LINE 289:
_T2b2:
	this->personTimer -= LoopTime;
// LINE 291:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xF6], 0;
	__asm        jne    _T2e5;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xFE], 0;
	__asm        jg     _T368;
// LINE 293:
_T2e5:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xFA], 0;
	__asm        jne    _T321;
// LINE 295:
	mp.op = 0x1d;
// LINE 296:
	mp.i2num = 0x8;
// LINE 297:
	mp.id = this->missionId;
// LINE 299:
	this->missionState = 0x4;
// LINE 300:
	return;
// LINE 304:
_T321:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     _T346;

	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::CanIPullOut;
	__asm        test   eax, eax;
	__asm        je     _T346;
// LINE 306:
	this->AutomobileClass::PullOut();
// LINE 310:
_T346:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x60;
	__asm        jne    _T360;
// LINE 313:
	this->missionState = 0x0;
// LINE 316:
_T360:
	this->AutomobileClass::ItterateFSM();
// LINE 319:
_T368:
	__asm        jmp    _T4df;
// LINE 322:
_T36d:
	this->CriminalEvaderCarClass::ShowWhereWeAre();
// LINE 323:
	this->AutomobileClass::PullOverCiviliansInWay();
// LINE 326:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x20;
	__asm        je     _T427;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     _T427;
// LINE 328:
	__asm        push   0xA;
	__asm        push   0xF;
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::PlacePerson;
	__asm        test   eax, eax;
	__asm        je     _T3da;
// LINE 330:
	this->missionState = 0x3;
// LINE 331:
	this->personDone = 0x0;
// LINE 332:
	this->personTimer = 0x780000;
// LINE 334:
	__asm        jmp    _T422;
// LINE 338:
// Block start:
	/*bp-0x54*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
_T3da:
	_assert(0x5b7d10, 0x5b7cec, 0x152);
	__asm        jmp    _T3fb;

	__asm        jmp    _T3fb;
// LINE 339:
_T3fb:
	mp.op = 0x1d;
// LINE 340:
	mp.i2num = 0x8;
// LINE 341:
	mp.id = this->missionId;
// LINE 343:
	this->missionState = 0x4;
// LINE 346:
// Block end:
_T422:
	__asm        jmp    _T4df;
// LINE 351:
_T427:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        je     _T44a;
// LINE 352:
	this->timeToBeOnTheRun = CriminalEvaderCarClass::constantTimeToBeOnTheRun;
// LINE 354:
	__asm        jmp    _T48d;
_T44a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x126], 0;
	__asm        jge    _T47a;
// LINE 356:
	this->timeToBeOnTheRun = CriminalEvaderCarClass::constantTimeToBeOnTheRun;
// LINE 357:
	this->missionState = 0x0;
// LINE 359:
	__asm        jmp    _T48d;
// LINE 360:
_T47a:
	this->timeToBeOnTheRun -= LoopTime;
// LINE 362:
_T48d:
	this->AutomobileClass::ItterateFSM();
// LINE 363:
	__asm        jmp    _T4df;
// LINE 367:
_T49a:
	__asm        mov    ecx, this;
	__asm        call   AutomobileClass::IsCarOutOfCameraRange;
	__asm        test   eax, eax;
	__asm        je     _T4b2;
// LINE 369:
	this->AutomobileClass::UnPlaceCar();
// LINE 371:
_T4b2:
	__asm        jmp    _T4df;
_T4b7:
	__asm        cmp    dword ptr [ebp-0x68], 4;
	__asm        ja     _T4df;

	__asm        mov    eax, [ebp-0x68];
	__asm        jmp    _Switch_4cb[0][eax*4];
	// Switch pointers:
	//   _T1d
	//   _T1a2
	//   _T36d
	//   _T2b2
	//   _T49a
// LINE 387:
_T4df:
	return;
}

// FUNCTION: COPTER_D 0x0053512e
void CriminalEvaderCarClass::PullOver(short carModel) {
// LINE 393:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 3;
	__asm        je     _T2c;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 4;
	__asm        jne    _T31;
// LINE 394:
_T2c:
	return;
// LINE 397:
_T31:
	__asm        movsx  eax, carModel;
	__asm        cmp    eax, 0x11D;
	__asm        jne    _T50;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x116], 0;
	__asm        jne    _T6d;
_T50:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 1;
	__asm        jne    _T79;

	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+8], 0x30;
	__asm        jne    _T79;
// LINE 398:
_T6d:
	this->AutomobileClass::PullOver(carModel);
// LINE 399:
_T79:
	return;
}

// FUNCTION: COPTER_D 0x005351b3
void CriminalEvaderCarClass::AdjustSpeed() {
// LINE 418:
	this->AutomobileClass::AdjustSpeed();
// LINE 420:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x11A], 2;
	__asm        jne    _T45;
// LINE 422:
	__asm        mov    eax, CriminalEvaderCarClass::evasionSpeedMultiplier;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xDE];
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xDE], eax;
// LINE 424:
_T45:
	return;
}

// FUNCTION: COPTER_D 0x00535202
int32_t CriminalEvaderCarClass::NearToBuilding() {
	/*bp-0x10*/  /*packed*/ class SpiralScan scan; // 0x10 bytes
	/*bp-0x14*/  /*packed*/ struct _GridCoordinates scanLoc;

// LINE 442:
	scan.currDist->SpiralScan::SpiralScan(reinterpret_cast<int16_t>(CriminalEvaderCarClass::maxSearchForBuildingRadius));
// LINE 443:
	__asm        mov    eax, this;
	__asm        mov    ax, [eax+0x7C];
	__asm        mov    reinterpret_cast<uint16_t>(scanLoc.x), ax;
// LINE 447:
	// Block start:
		/*bp-0x18*/  unsigned short tt;
__DO_27:
	do {
// LINE 447:
	// Block start:
		/*bp-0x18*/  unsigned short tt;
__DO_27:
		__asm        xor    eax, eax;
		__asm        mov    al, scanLoc.x;
		__asm        mov    eax, BuildMap[eax*4];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, scanLoc.y;
		__asm        movzx  ax, byte ptr [eax+ecx];
		__asm        mov    tt, ax;
// LINE 448:
		__asm        mov    eax, this;
		__asm        mov    eax, [eax+0x11E];
		__asm        mov    [ebp-0x38], eax;
		__asm        jmp    _T4b2;
// LINE 451:
_T52:
		__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
		__asm        and    eax, 0xFFFF;
		__asm        mov    [ebp-0x3C], eax;
		__asm        jmp    _T80;
// LINE 480:
_T62:
		__asm        mov    dword ptr [ebp-0x1C], 1;
		__asm        jmp    _T6e;
_T6e:
		__asm        mov    eax, [ebp-0x1C];
		__asm        jmp    __RETURN;
// LINE 481:
		__asm        jmp    _T153;
// LINE 482:
		__asm        jmp    _T153;
_T80:
		__asm        sub    dword ptr [ebp-0x3C], 0x70;
		__asm        cmp    dword ptr [ebp-0x3C], 0x8F;
		__asm        ja     _T153;

		__asm        mov    eax, [ebp-0x3C];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, _SwitchTable_c3[0][eax];
		__asm        jmp    _Switch_a3[0][ecx*4];
		// Switch pointers:
		//   _T62
		//   _T62
		//   _T62
		//   _T62
		//   _T62
		//   _T62
		//   _T62
		//   _T153
		// Switch table
		//  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6]
// LINE 484:
_T153:
		__asm        jmp    __DO_WHILE_27;
// LINE 487:
_T158:
		__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
		__asm        and    eax, 0xFFFF;
		__asm        mov    [ebp-0x40], eax;
		__asm        jmp    _T186;
// LINE 510:
_T168:
		__asm        mov    dword ptr [ebp-0x20], 1;
		__asm        jmp    _T174;
_T174:
		__asm        mov    eax, [ebp-0x20];
		__asm        jmp    __RETURN;
// LINE 511:
		__asm        jmp    _T255;
// LINE 512:
		__asm        jmp    _T255;
_T186:
		__asm        sub    dword ptr [ebp-0x40], 0x7D;
		__asm        cmp    dword ptr [ebp-0x40], 0x7A;
		__asm        ja     _T255;

		__asm        mov    eax, [ebp-0x40];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, _SwitchTable_1da[0][eax];
		__asm        jmp    _Switch_1a6[0][ecx*4];
		// Switch pointers:
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T168
		//   _T255
		// Switch table
		//  [0, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 2, 2, 12, 3, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 12, 12, 5, 5, 12, 12, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 7, 7, 7, 12, 8, 8, 12, 9, 9, 9, 9, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 10, 12, 11]
// LINE 513:
_T255:
		__asm        jmp    __DO_WHILE_27;
// LINE 516:
_T25a:
		__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
		__asm        and    eax, 0xFFFF;
		__asm        mov    [ebp-0x44], eax;
		__asm        jmp    _T288;
// LINE 531:
_T26a:
		__asm        mov    dword ptr [ebp-0x24], 1;
		__asm        jmp    _T276;
_T276:
		__asm        mov    eax, [ebp-0x24];
		__asm        jmp    __RETURN;
// LINE 532:
		__asm        jmp    _T2f0;
// LINE 533:
		__asm        jmp    _T2f0;
_T288:
		__asm        sub    dword ptr [ebp-0x44], 0x90;
		__asm        cmp    dword ptr [ebp-0x44], 0x28;
		__asm        ja     _T2f0;

		__asm        mov    eax, [ebp-0x44];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, _SwitchTable_2c7[0][eax];
		__asm        jmp    _Switch_2ab[0][ecx*4];
		// Switch pointers:
		//   _T26a
		//   _T26a
		//   _T26a
		//   _T26a
		//   _T26a
		//   _T26a
		//   _T2f0
		// Switch table
		//  [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 3, 6, 4, 6, 6, 6, 5, 5]
// LINE 534:
_T2f0:
		__asm        jmp    __DO_WHILE_27;
// LINE 537:
_T2f5:
		__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
		__asm        and    eax, 0xFFFF;
		__asm        mov    [ebp-0x48], eax;
		__asm        jmp    _T323;
// LINE 572:
_T305:
		__asm        mov    dword ptr [ebp-0x28], 1;
		__asm        jmp    _T311;
_T311:
		__asm        mov    eax, [ebp-0x28];
		__asm        jmp    __RETURN;
// LINE 573:
		__asm        jmp    _T3ed;
// LINE 574:
		__asm        jmp    _T3ed;
_T323:
		__asm        sub    dword ptr [ebp-0x48], 0x80;
		__asm        cmp    dword ptr [ebp-0x48], 0x72;
		__asm        ja     _T3ed;

		__asm        mov    eax, [ebp-0x48];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, _SwitchTable_37a[0][eax];
		__asm        jmp    _Switch_346[0][ecx*4];
		// Switch pointers:
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T305
		//   _T3ed
		// Switch table
		//  [0, 0, 12, 12, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 2, 12, 3, 3, 3, 12, 12, 12, 4, 4, 4, 4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 5, 5, 5, 5, 5, 5, 5, 5, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 6, 12, 12, 7, 12, 12, 12, 12, 12, 8, 12, 12, 9, 9, 12, 12, 10, 12, 11]
// LINE 575:
_T3ed:
		__asm        jmp    __DO_WHILE_27;
// LINE 578:
_T3f2:
		__asm        mov    eax, reinterpret_cast<uint32_t>(tt);
		__asm        and    eax, 0xFFFF;
		__asm        mov    [ebp-0x4C], eax;
		__asm        jmp    _T420;
// LINE 613:
_T402:
		__asm        mov    dword ptr [ebp-0x2C], 1;
		__asm        jmp    _T40e;
_T40e:
		__asm        mov    eax, [ebp-0x2C];
		__asm        jmp    __RETURN;
// LINE 614:
		__asm        jmp    _T4a8;
// LINE 615:
		__asm        jmp    _T4a8;
_T420:
		__asm        sub    dword ptr [ebp-0x4C], 0xC6;
		__asm        cmp    dword ptr [ebp-0x4C], 0x34;
		__asm        ja     _T4a8;

		__asm        mov    eax, [ebp-0x4C];
		__asm        xor    ecx, ecx;
		__asm        mov    cl, _SwitchTable_473[0][eax];
		__asm        jmp    _Switch_443[0][ecx*4];
		// Switch pointers:
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T402
		//   _T4a8
		// Switch table
		//  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 11, 11, 11, 11, 1, 11, 11, 11, 11, 2, 2, 2, 11, 11, 3, 3, 11, 4, 4, 4, 4, 4, 11, 5, 5, 11, 11, 6, 6, 11, 7, 11, 8, 8, 11, 9, 11, 10, 10, 10]
// LINE 616:
_T4a8:
		__asm        jmp    __DO_WHILE_27;
// LINE 617:
		__asm        jmp    __DO_WHILE_27;
_T4b2:
		__asm        cmp    dword ptr [ebp-0x38], 4;
		__asm        ja     __DO_WHILE_27;

		__asm        mov    eax, [ebp-0x38];
		__asm        jmp    _Switch_4c6[0][eax*4];
		// Switch pointers:
		//   _T52
		//   _T158
		//   _T25a
		//   _T2f5
		//   _T3f2
	} while ((scan.currDist->SpiralScan::Next(scanLoc.x) != 0x0));
// LINE 621:
	__asm        mov    dword ptr [ebp-0x30], 0;
	__asm        jmp    _T4fa;
_T4fa:
	__asm        mov    eax, [ebp-0x30];
	__asm        jmp    __RETURN;
// LINE 622:
__RETURN:
}

// FUNCTION: COPTER_D 0x00535709
void CriminalEvaderCarClass::ShowWhereWeAre() {
	/*bp-0x18*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes

// LINE 649:
	mp.op = 0xa;
// LINE 650:
	mp.id = this->missionId;
// LINE 654:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7C];
	__asm        mov    mp.maploc.x, ecx;
// LINE 655:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x7D];
	__asm        mov    mp.maploc.y, ecx;
// LINE 656:
	S3MissionUpdate(mp.op);
// LINE 657:
	return;
}

// FUNCTION: COPTER_D 0x00535754
void CriminalEvaderCarClass::SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE *sd) {
// LINE 669:
	sd->c.missionState = this->missionState;
// LINE 670:
	sd->c.criminalType = this->criminalType;
// LINE 671:
	sd->c.timeToLeaveCar = this->timeToLeaveCar;
// LINE 672:
	sd->c.timeToBeOnTheRun = this->timeToBeOnTheRun;
// LINE 675:
	this->AutomobileClass::SetSaveData(sd);
// LINE 676:
	return;
}

// FUNCTION: COPTER_D 0x005357c0
void CriminalEvaderCarClass::LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE *sd) {
// LINE 689:
	__asm        mov    eax, sd;
	__asm        test   byte ptr [eax], 2;
	__asm        jne    _T1d;
// LINE 691:
	return;
// LINE 695:
_T1d:
	this->AutomobileClass::LoadSaveData(sd);
// LINE 698:
	this->missionState = sd->c.missionState;
// LINE 699:
	this->criminalType = sd->c.criminalType;
// LINE 700:
	this->timeToLeaveCar = sd->c.timeToLeaveCar;
// LINE 701:
	this->timeToBeOnTheRun = sd->c.timeToBeOnTheRun;
// LINE 702:
	return;
}



// Contribution: 1:00134840-00134855 Module: 161, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:00134860-00134898 Module: 161, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00535860
// CriminalEvaderCarClass::`scalar deleting destructor'



// Contribution: 2:00004258-0000427b Module: 161, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for CriminalEvaderCarClass @ 0x00593258
//   00: CriminalEvaderCarClass::`scalar deleting destructor' @ 0x00535860
//   01: CriminalEvaderCarClass::PullOver @ 0x0053512e
//   02: CriminalEvaderCarClass::AdjustSpeed @ 0x005351b3
//   03: AutomobileClass::PickTurnDir @ 0x00502c92
//   04: CriminalEvaderCarClass::ItterateFSM @ 0x00534c45
//   05: CriminalEvaderCarClass::SetSaveData @ 0x00535754
//   06: CriminalEvaderCarClass::LoadSaveData @ 0x005357c0
//   07: CriminalEvaderCarClass::BeamToWithinCameraRange @ 0x00535840
//   08: AutomobileClass::BeamToLocation @ 0x005030aa
//   9 entries



// Contribution: 3:00020ca8-00020d15 Module: 161, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b7ca8
int32_t CriminalEvaderCarClass::baseTimeBetweenCriminalActivities = 6553600;

// GLOBAL: COPTER_D 0x005b7cac
int32_t CriminalEvaderCarClass::maxTimeBetweenCriminalActivities = 39321600;

// GLOBAL: COPTER_D 0x005b7cb0
int32_t CriminalEvaderCarClass::constantTimeToBeOnTheRun = 1310720;

// GLOBAL: COPTER_D 0x005b7cb4
int32_t CriminalEvaderCarClass::evasionSpeedMultiplier = 131072;

// GLOBAL: COPTER_D 0x005b7cb8
short CriminalEvaderCarClass::maxSearchForBuildingRadius = 3;

// GLOBAL: COPTER_D 0x005b7cbc
int32_t CriminalEvaderCarClass::curCriminalCars = 0;



// Contribution: 3:000949a0-000949b3 Module: 161, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0062b9a0
/*packed*/ class CriminalEvaderCarClass *CriminalEvaderCarClass::criminalCars[5];

