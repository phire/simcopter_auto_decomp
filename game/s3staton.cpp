// Module: S3staton.obj
// Source: C:\Copter\Source\Game\S3staton.cpp
// autogenerated by simcopter_tool from PDB file

// Type: unsigned char;

// Type: void;

// Type: /*packed*/ class Station (forward reference);
class Station{ // packed(0x1c bytes) TI: 0x47e8
public:
	void Station(unsigned char);
	void ~Station();
	int32_t DispatchNearestAvailableVehicle(long, long, enum EmergencyType, enum EmergencyLevel, /*packed*/ class EmergencyVehicleClass**, int32_t);
	short GetNearestStation(/*packed*/ struct _GridCoordinates, /*packed*/ struct _GridCoordinates*);
	short GetNextNearest(/*packed*/ struct _GridCoordinates*);
	void DecrementQuantityOfVehicleDispatched(int32_t);
private:
	/*+0x0*/   /*packed*/ struct _StructStation *stationList;
	/*+0x4*/   int32_t quantityOfStations;
	/*+0x8*/   /*packed*/ struct _StationHeapStruct *stationHeap;
	/*+0xc*/   int32_t stationHeapSize;
	/*+0x10*/  /*packed*/ struct _VehicleHeapStruct *vehicleHeap;
	/*+0x14*/  int32_t vehicleHeapSize;
	/*+0x18*/  int32_t maxVehicles;
	int32_t FindNearestRoadToStation(/*packed*/ struct _GridCoordinates&);
	int32_t FindNearestRoadToEmergency(/*packed*/ struct _GridCoordinates&);
	int32_t FindNearestStation(/*packed*/ struct _GridCoordinates);
	/*packed*/ class EmergencyVehicleClass* FindAvailableVehicle(enum EmergencyLevel, /*packed*/ class EmergencyVehicleClass**, int32_t);
	void SortStationsByDistanceFromDestination(/*packed*/ struct _GridCoordinates);
	void SortVehiclesByDistanceFromDestination(/*packed*/ struct _GridCoordinates, /*packed*/ class EmergencyVehicleClass**, int32_t);
	void StationHeapInsert(const /*packed*/ struct _StationHeapStruct*);
	void StationHeapRemove(/*packed*/ struct _StationHeapStruct*);
	void VehicleHeapInsert(const /*packed*/ struct _VehicleHeapStruct*);
	void VehicleHeapRemove(/*packed*/ struct _VehicleHeapStruct*);
};

// Type: /*packed*/ struct _GridCoordinates;
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: /*packed*/ struct _GridCoordinates (forward reference);
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: short;

// Type: int32_t;

// Type: /*packed*/ class SpiralScan;
class SpiralScan{ // packed(0x10 bytes) TI: 0x2fb5
public:
	void SpiralScan(int32_t);
	void ~SpiralScan();
	int32_t Next(/*packed*/ struct _GridCoordinates&);
	int32_t InCityGridLimits(/*packed*/ struct _GridCoordinates);
private:
	/*+0x0*/   int32_t currDist;
	/*+0x4*/   int32_t currDir;
	/*+0x8*/   int32_t currDia;
	/*+0xc*/   int32_t maxDia;
};

// Type: /*packed*/ struct _StationHeapStruct;
struct _StationHeapStruct{ // packed(0x8 bytes) TI: 0x2fc4
	/*+0x0*/   long cost;
	/*+0x4*/   int32_t stationID;
};

// Type: /*packed*/ class EmergencyVehicleClass (forward reference);
// VTABLE: COPTER_D 0x005934c0
class EmergencyVehicleClass : public AutomobileClass
{ // packed(0x2a0 bytes) TI: 0x47d8
	enum /* __unnamed */ {
		MAXIMUM_DISTANCE_FROM_BASE = 7,
		MAXIMUM_TIME_TO_EMERGENCY = 3932160,
		AMBULANCE_CAPACITY = 2,
	};
protected:
	/*+0x11a*/ /*packed*/ struct _GridCoordinates baseLocation; // 0x2 bytes
	/*+0x11c*/ /*packed*/ struct _GridCoordinates emergencyLocation; // 0x2 bytes
	/*+0x11e*/ enum EmergencyType emergencyType;
	/*+0x122*/ long timeOfArrival;
	/*+0x126*/ /*packed*/ struct _DYOBJ_INST dispatchIcon; // 0x64 bytes
	/*+0x18a*/ int32_t timeToEmergency;
	/*+0x18e*/ /*packed*/ class AutomobileClass *dispatchTarget;
	/*+0x192*/ unsigned char dispatchPath[256]; // 0x100 bytes
	/*+0x292*/ unsigned char dispatchPathIndex; // 0x1 bytes
	/*+0x293*/ unsigned char dispatchPathLength; // 0x1 bytes
	/*+0x294*/ enum EmergencyLevel emergencyState;
	/*+0x298*/ int32_t stationID;
	/*+0x29c*/ int32_t numberOfSeats;
public:
	void EmergencyVehicleClass(const /*packed*/ class EmergencyVehicleClass&);
	void EmergencyVehicleClass();
	virtual void ~EmergencyVehicleClass() /* override */;
	enum EmergencyLevel GetEmergencyState();
	void InitializePlacedVehicleForDispatch(/*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct _GridCoordinates, /*packed*/ struct Goal, enum EmergencyType, enum EmergencyLevel);
	void InitializeStationVehicleForDispatch(int32_t, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct _GridCoordinates, /*packed*/ struct Goal, /*packed*/ struct Goal, /*packed*/ struct _GridCoordinates, int32_t, /*packed*/ struct Goal, enum EmergencyType, enum EmergencyLevel);
	// calltype: NearC
	static int32_t AreThereMoreSeats(/*packed*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static void FillSeat(/*packed*/ struct _DYOBJ_INST*);
	// calltype: NearC
	static int32_t S3UpdateCar(int32_t, int32_t);
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* S3GetCar(int32_t);
	void CancelEmergencyDispatch();
protected:
	virtual void Reset(); // vtable+0x24
	virtual void AdjustSpeed() /* override */;
	virtual enum TurnIndex PickTurnDir(/*packed*/ struct Goal*) /* override */;
	virtual void SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*) /* override */;
	virtual void LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*) /* override */;
	void ArriveOnScene();
	void UnLinkIconFromCell(const /*packed*/ struct _GridCoordinates);
	void LinkIconToCell(const /*packed*/ struct _GridCoordinates);
	void PositionIcon();
	void GoBackToStation();
	void BuildPath(/*packed*/ struct _RGIndex, /*packed*/ struct _RGIndex);
	void TurnOnStrobe();
	void TurnOffStrobe();
	int32_t UpdateCar(int32_t);
	virtual void BeamToWithinCameraRange() /* override */;
public:
	/*packed*/ class EmergencyVehicleClass operator=(const /*packed*/ class EmergencyVehicleClass&);
};

// Type: /*packed*/ struct _VehicleHeapStruct;
struct _VehicleHeapStruct{ // packed(0xa bytes) TI: 0x2fca
	/*+0x0*/   long cost;
	/*+0x4*/   /*packed*/ class EmergencyVehicleClass *pVehicle;
	/*+0x8*/   /*packed*/ struct _GridCoordinates loc; // 0x2 bytes
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: enum EmergencyLevel;
enum EmergencyLevel {
	ES_UNDEFINED = 0,
	ES_STAKEOUT = 1,
	ES_RETURN = 2,
	ES_PURSUIT = 3,
	ES_DISPATCHED = 4,
	ES_AT_SCENE = 5,
	ES_COP_CHASE = 6,
};

// Type: /*packed*/ struct _StationHeapStruct (forward reference);
struct _StationHeapStruct{ // packed(0x8 bytes) TI: 0x2fc4
	/*+0x0*/   long cost;
	/*+0x4*/   int32_t stationID;
};

// Type: /*packed*/ struct _VehicleHeapStruct (forward reference);
struct _VehicleHeapStruct{ // packed(0xa bytes) TI: 0x2fca
	/*+0x0*/   long cost;
	/*+0x4*/   /*packed*/ class EmergencyVehicleClass *pVehicle;
	/*+0x8*/   /*packed*/ struct _GridCoordinates loc; // 0x2 bytes
};

// Type: long;

// Type: enum EmergencyType;
enum EmergencyType {
	NO_EMERGENCY = 0,
	FIRE_TRUCK = 1,
	AMBULANCE_CAR = 2,
	POLICE_CHASING_CAR = 3,
	POLICE_ON_PATROL = 4,
};

// Type: /*packed*/ struct Goal;
struct Goal{ // packed(0x2a bytes) TI: 0x12ce
	/*+0x0*/   /*packed*/ struct RGVertex *pRGV;
	/*+0x4*/   int32_t elementIndex;
	/*+0x8*/   int32_t gridIndex;
	/*+0xc*/   /*packed*/ struct _GridCoordinates gridLoc; // 0x2 bytes
	/*+0xe*/   enum DirIndex2 edgeIndex;
	/*+0x12*/  enum DirIndex2 direction;
	/*+0x16*/  int32_t distance;
	/*+0x1a*/  int32_t turnFlags;
	/*+0x1e*/  int32_t deadEndFlags;
	/*+0x22*/  int32_t fElevated;
	/*+0x26*/  enum SlopeIndex slope;
};

// Type: /*packed*/ struct _RGIndex;
struct _RGIndex{ // packed(0x2 bytes) TI: 0x2ab2
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char yindex; // 0x1 bytes
};

// Type: /*packed*/ class basic_string<char>;
class basic_string<char>{ // packed(0x8 bytes) TI: 0x1380
	using reference_class = /*unpacked*/ class basic_string_ref<char>;
	using reference_pointer = /*unpacked*/ class basic_string_ref<char>*;
private:
	/*+0x0*/   char * c_str_ptr;
	/*+0x4*/   /*unpacked*/ class basic_string_ref<char> *reference;
	char * point();
	uint32_t& len();
	uint32_t ref_count();
	// calltype: NearC
	static char eos();
	void assign_str(char *, uint32_t);
	void append_str(char *, uint32_t);
	void insert_str(uint32_t, char *, uint32_t);
	void replace_str(uint32_t, uint32_t, char *, uint32_t);
	int32_t compare_str(uint32_t, char *, uint32_t, uint32_t);
	uint32_t find_str(char *, uint32_t, uint32_t);
	uint32_t rfind_str(char *, uint32_t, uint32_t);
	uint32_t find_first_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_of_str(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of_str(char *, uint32_t, uint32_t);
public:
	void basic_string<char>(const /*packed*/ class vector<char>&);
	void basic_string<char>(char, uint32_t);
	void basic_string<char>(char *);
	void basic_string<char>(char *, uint32_t);
	void basic_string<char>(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	void basic_string<char>(uint32_t, enum capacity);
	void basic_string<char>();
protected:
	void basic_string<char>(char *, uint32_t, uint32_t);
	void delete_ref();
	using char_type = char;
	using baggage_type = /*packed*/ struct string_char_baggage<char>;
public:
	void ~basic_string<char>();
	/*packed*/ class basic_string<char>& operator=(char);
	/*packed*/ class basic_string<char>& operator=(char *);
	/*packed*/ class basic_string<char>& operator=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class basic_string<char>& operator+=(char);
	/*packed*/ class basic_string<char>& operator+=(char *);
	/*packed*/ class basic_string<char>& operator+=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class vector<char> operator class vector<char>();
	/*packed*/ class basic_string<char>& append(char, uint32_t);
	/*packed*/ class basic_string<char>& append(char *);
	/*packed*/ class basic_string<char>& append(char *, uint32_t);
	/*packed*/ class basic_string<char>& append(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& assign(char, uint32_t);
	/*packed*/ class basic_string<char>& assign(char *);
	/*packed*/ class basic_string<char>& assign(char *, uint32_t);
	/*packed*/ class basic_string<char>& assign(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& remove(uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	char get_at(uint32_t);
	void put_at(uint32_t, char);
	char& operator[](uint32_t);
	char operator[](uint32_t);
	char * c_str();
	char * data();
	uint32_t length();
	void resize(uint32_t);
	void resize(uint32_t, char);
	void reserve(uint32_t);
	uint32_t reserve();
	uint32_t copy(char *, uint32_t, uint32_t);
	uint32_t find(char, uint32_t);
	uint32_t find(char *, uint32_t);
	uint32_t find(char *, uint32_t, uint32_t);
	uint32_t find(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t rfind(char, uint32_t);
	uint32_t rfind(char *, uint32_t);
	uint32_t rfind(char *, uint32_t, uint32_t);
	uint32_t rfind(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_of(char, uint32_t);
	uint32_t find_first_of(char *, uint32_t);
	uint32_t find_first_of(char *, uint32_t, uint32_t);
	uint32_t find_first_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_of(char, uint32_t);
	uint32_t find_last_of(char *, uint32_t);
	uint32_t find_last_of(char *, uint32_t, uint32_t);
	uint32_t find_last_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_not_of(char, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_not_of(char, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	/*packed*/ class basic_string<char> substr(uint32_t, uint32_t);
	int32_t compare(char, uint32_t, uint32_t);
	int32_t compare(char *, uint32_t);
	int32_t compare(char *, uint32_t, uint32_t);
	int32_t compare(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
};

// Type: /*packed*/ class DigitalSound;
// VTABLE: COPTER_D 0x0058f488
class DigitalSound : public Sound
{ // packed(0x7a bytes) TI: 0x45d4
protected:
	/*+0x34*/  int32_t nStreamingType;
	/*+0x38*/  int32_t nCompletionEstimationTimerSet;
	static /*packed*/ struct IDirectSound *lpDirectSound;
	/*+0x3c*/  uint32_t cbSize;
	/*+0x40*/  /*packed*/ struct tWAVEFORMATEX waveFormatEx; // 0x12 bytes
	/*+0x52*/  /*packed*/ struct IDirectSoundBuffer *lpSound[8]; // 0x20 bytes
	/*+0x72*/  /*packed*/ struct _STREAMBUFINFO *lpStreamBufferInfo;
	/*+0x76*/  unsigned long dwDesiredBufferDescFlags;
public:
	void DigitalSound(long);
	void DigitalSound(const /*packed*/ class basic_string<char>&, int32_t);
	void DigitalSound();
	virtual void ~DigitalSound() /* override */;
	/*packed*/ class DigitalSound& operator=(/*packed*/ class DigitalSound&);
	virtual void SetSoundFile(const /*packed*/ class basic_string<char>&, int32_t); // vtable+0x2c
	virtual int32_t Load(); // vtable+0x30
	virtual int32_t LoadFromResource(); // vtable+0x34
	virtual int32_t LoadFromFile(); // vtable+0x38
	virtual void Unload(); // vtable+0x3c
	virtual long Play(long, int32_t) /* override */;
	virtual long Stop() /* override */;
	virtual long ShouldWeStream(); // vtable+0x40
	virtual long PlayStream(); // vtable+0x44
	virtual long StopStream(); // vtable+0x48
protected:
	virtual long IsPlaying(/*packed*/ struct IDirectSoundBuffer**); // vtable+0x4c
public:
	virtual long IsPlaying() /* override */;
	virtual int32_t GetVolume(long *) /* override */;
	virtual int32_t SetVolume(long) /* override */;
	virtual int32_t GetPan(long *); // vtable+0x50
	virtual int32_t SetPan(long); // vtable+0x54
	virtual int32_t SetPosition(long, long, long); // vtable+0x58
	virtual long GetOriginalFrequency(); // vtable+0x5c
	virtual int32_t GetFrequency(long *); // vtable+0x60
	virtual int32_t SetFrequency(long); // vtable+0x64
	virtual int32_t GetSoundType() /* override */;
	virtual int32_t SetCompletionNotification(void (*)(long), long) /* override */;
	virtual void StopCompletionNotification() /* override */;
	virtual long EstimateRemainingPlayTime() /* override */;
protected:
	virtual int32_t GetSoundAliasToPlay(/*packed*/ struct IDirectSoundBuffer**); // vtable+0x68
	virtual int32_t CreateSoundBuffer(/*packed*/ struct _DSBUFFERDESC*); // vtable+0x6c
	virtual int32_t CreatePrimarySoundBuffer(); // vtable+0x70
	virtual int32_t ReleaseSoundBuffer(); // vtable+0x74
	virtual long InitializeStreamBuffer(long); // vtable+0x78
	virtual void ProcessStreamingBufferTimerCallback(); // vtable+0x7c
	virtual void ProcessCompletionEstimationTimerCallback(); // vtable+0x80
	virtual void StopCompletionNotificationEstimationTimer(); // vtable+0x84
	virtual int32_t StartCompletionNotificationEstimationTimer(); // vtable+0x88
};

// Type: /*packed*/ struct _StructStation (forward reference);
struct _StructStation{ // packed(0x60 bytes) TI: 0x2feb
	/*+0x0*/   /*packed*/ struct Goal goal1; // 0x2a bytes
	/*+0x2a*/  /*packed*/ struct Goal goal2; // 0x2a bytes
	/*+0x54*/  int32_t direction;
	/*+0x58*/  /*packed*/ struct _GridCoordinates location; // 0x2 bytes
	/*+0x5a*/  /*packed*/ struct _GridCoordinates nearestRoadTile; // 0x2 bytes
	/*+0x5c*/  int32_t quanVehiclesDispatched;
};

// Type: /*packed*/ struct RGVertex (forward reference);
struct RGVertex{ // packed(0x33 bytes) TI: 0x1776
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
	/*+0x2*/   LfBitfield @ 0x11f58:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1771
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 turnFlags;
	/*+0x2*/   LfBitfield @ 0x11f60:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1772
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x4
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 deadEndFlags;
	/*+0x3*/   unsigned char fElevated; // 0x1 bytes
	/*+0x4*/   /*packed*/ struct Edge edge[4]; // 0x28 bytes
	/*+0x2c*/  unsigned char yindexPrev; // 0x1 bytes
	/*+0x2d*/  unsigned char xPrev; // 0x1 bytes
	/*+0x2e*/  unsigned char edgeIndexPrev; // 0x1 bytes
	/*+0x2f*/  int32_t STVisited;
};

// Type: unsigned char *;

// Type: /*packed*/ class AutomobileClass;
// VTABLE: COPTER_D 0x00592d98
class AutomobileClass{ // packed(0x11a bytes) TI: 0x4880
	enum CarType {
		kCarAmbulance = 0,
		kCarCop = 1,
		kCarFiretruck = 2,
		kCarCriminal = 3,
	};
	enum AutoMessageID {
		AM_NO_MESSAGE = 0,
		AM_CANCEL_AUTO_MISSION = 1,
	};
	enum /* __unnamed */ {
		CAR_TYPES = 7,
		PERCENTAGE_OF_AUTO1 = 10,
		PERCENTAGE_OF_AUTO2 = 20,
		PERCENTAGE_OF_AUTO3 = 20,
		PERCENTAGE_OF_AUTO4 = 10,
		PERCENTAGE_OF_AUTO5 = 10,
		PERCENTAGE_OF_AUTO6 = 20,
		PERCENTAGE_OF_AUTO7 = 20,
		TOTAL_PERCENTAGE = 110,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
		DEAD_END_HIWAY = 16,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		AUTO_IN_WAY = 4,
		DEBRIS_IN_WAY = 5,
		UNIDENTIFIED_IN_WAY = 6,
		HELI_IN_WAY = 7,
		END_OF_ROAD = 8,
		END_OF_HIWAY = 9,
		INTERSECTION_FULL = 10,
		BEEN_PULLED_OVER = 11,
	};
	enum RoadTileOffsets {
		RD_CENTOFF = 851968,
		RD_EDGEOFF = 131072,
	};
	enum HiwayOffsets {
		HW_CENTOFF_LANE1 = 851968,
		HW_EDGEOFF_LANE1 = 131072,
		HW_CENTOFF_LANE2 = 851968,
		HW_EDGEOFF_LANE2 = 131072,
		HW_HEIGHT = 2031616,
	};
public:
	static int32_t fireSirenDist;
	static int32_t policeSirenDist;
	static int32_t ambSirenDist;
	static int32_t fireHoseDist;
	enum /* __unnamed */ {
		CAR_RADIUS = 327680,
		COLLISION_SPACE = 655360,
		ROAD_SPEED = 2621440,
		ROAD_SLOWDOWN_FACTOR = 131072,
		HIWAY_SPEED = 6225920,
		HIWAY_SLOWDOWN_FACTOR = 327680,
		SPEED_VARIANCE = 262144,
		HIWAY_VARIANCE = 655360,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 235,
	};
	enum Flags {
		AUTO_INITIALIZED = 1,
		AUTO_PLACED = 2,
		AUTO_NEEDS_TO_PULL_OVER = 4,
		AUTO_PULL_OVER = 8,
		AUTO_PULLING_OVER = 16,
		AUTO_PULLED_OVER = 32,
		AUTO_PULLING_OUT = 64,
		AUTO_IN_INTERSECTION = 128,
		AUTO_ON_FIRE = 256,
		AUTO_JAMMED = 512,
		AUTO_RIGHT_OF_WAY = 1024,
		AUTO_ON_HIWAY = 2048,
		AUTO_SPEEDER = 4096,
		AUTO_SPEEDER_DONE = 8192,
		AUTO_UTURN = 16384,
	};
public:
	/*+0x4*/   long carModel;
	/*+0x8*/   int32_t flags;
	/*+0xc*/   /*packed*/ struct _DYOBJ_INST autoDynomitor; // 0x64 bytes
	/*+0x70*/  /*packed*/ struct Goal goal; // 0x2a bytes
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	/*+0x9a*/  int32_t DeltaFromCenter;
	/*+0x9e*/  int32_t stalledTimer;
	/*+0xa2*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0xae*/  int32_t remainingTime;
	/*+0xb2*/  int32_t desiredSpeed;
	/*+0xb6*/  int32_t desiredHiwaySpeed;
	/*+0xba*/  int32_t beamDelay;
	/*+0xbe*/  int32_t beamTimer;
	/*+0xc2*/  int32_t m_cellBaseY;
	/*+0xc6*/  int32_t timePulledOver;
	/*+0xca*/  int32_t hornSoundId;
	/*+0xce*/  enum DirectionTypes hiwaydir;
	/*+0xd2*/  /*packed*/ struct _GridCoordinates currentLocation; // 0x2 bytes
	/*+0xd4*/  /*packed*/ struct _GridCoordinates nextLocation; // 0x2 bytes
	/*+0xd6*/  /*packed*/ struct _GridCoordinates northCell; // 0x2 bytes
	/*+0xd8*/  /*packed*/ struct _GridCoordinates southCell; // 0x2 bytes
	/*+0xda*/  /*packed*/ struct _GridCoordinates eastCell; // 0x2 bytes
	/*+0xdc*/  /*packed*/ struct _GridCoordinates westCell; // 0x2 bytes
protected:
	/*+0xde*/  int32_t speed;
	/*+0xe2*/  enum DirIndex2 prevDir;
	/*+0xe6*/  enum TurnIndex turnIndex;
	/*+0xea*/  int32_t currDist;
	/*+0xee*/  int32_t legOfTurn;
	/*+0xf2*/  /*packed*/ struct Point3d *pDirVector;
	/*+0xf6*/  int32_t personDone;
	/*+0xfa*/  int32_t personState;
	/*+0xfe*/  int32_t personTimer;
	/*+0x102*/ int32_t timeToLive;
	/*+0x106*/ int32_t fireTime;
	/*+0x10a*/ long fireSeq;
	/*+0x10e*/ long missionId;
	/*+0x112*/ /*packed*/ struct _CELL_INFO *cptr;
	/*+0x116*/ int32_t spotlightHitCounter;
	int32_t IsCarPersistant();
	int32_t CanCarBeamToHiwayTile(unsigned short);
public:
	void AutomobileClass(const /*packed*/ class AutomobileClass&);
	void AutomobileClass();
	virtual void ~AutomobileClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class AutomobileClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class AutomobileClass* GetAutoPointer(long);
	// calltype: NearC
	static void DestroyInstance(/*packed*/ class AutomobileClass*);
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static int32_t MissionStartFire(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static int32_t MissionStartJam(long, /*packed*/ struct Point2d*);
	// calltype: NearC
	static void MissionCancel(long);
	// calltype: NearC
	static void SetAllHeadlights(int32_t);
	// calltype: NearC
	static int32_t S3AutoMessage(short, short);
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
	void HitDispatch(long, /*packed*/ struct _DYOBJ_INST*, long, long);
	int32_t AmIABadGuy();
	int32_t Initialize(int32_t);
	void WaterDouse(/*packed*/ struct _DYOBJ_INST*);
	void IveBeenMegaphoned(long);
	void StartFire(long);
	void StartJam(long);
	virtual void PullOver(short); // vtable+0x4
	void PullOut();
	int32_t CanIPullOut();
	int32_t CanIPullOver();
	void DoAUTurn();
	long GetCarModel();
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* GetClosestCar(int32_t, int32_t, int32_t);
protected:
	void Itterate();
	virtual void AdjustSpeed(); // vtable+0x8
	void Reset();
	virtual enum TurnIndex PickTurnDir(/*packed*/ struct Goal*); // vtable+0xc
	void UnPlaceCar();
	void PullOverCiviliansInWay();
	virtual void ItterateFSM(); // vtable+0x10
	int32_t InitializeInstance(int32_t);
	void LinkToCell(const /*packed*/ struct _GridCoordinates&);
	int32_t AreCarsHeadOn(/*packed*/ struct Point3d*);
	enum AutomobileClass::StoppedReasons CollisionCheck(int32_t, /*packed*/ struct _DYOBJ_INST**);
	int32_t IsCarOutOfCameraRange();
	void TurnOffHeadlight();
	void TurnOnHeadlight();
	int32_t AutoMessage(short);
	int32_t PlacePerson(int32_t, int32_t);
	virtual void SetSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x14
	virtual void LoadSaveData(/*packed*/ struct _AUTO_LOAD_SAVE*); // vtable+0x18
	void HonkHorn();
	void SetHiwayDirection(unsigned short);
	int32_t DoHiwayTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void AdjustCurrentHiwayPosition();
	void AdjustNextHiwayPosition();
	enum AutomobileClass::IntersectionTypes PickHiwayDir(/*packed*/ struct _GridCoordinates&);
	void MakeAHiwayTurn(enum AutomobileClass::IntersectionTypes);
	void GoStraight();
	void TurnLeft();
	void TurnRight();
	void MoveForwardOnHiway();
	void DoDiagonalRoadFixup();
	virtual void BeamToWithinCameraRange(); // vtable+0x1c
	virtual int32_t BeamToLocation(const /*packed*/ struct _GridCoordinates&); // vtable+0x20
	void MoveAuto(int32_t);
	void ChangeAutoColor();
private:
	void UnlinkFromCell(const /*packed*/ struct _GridCoordinates&);
	void TransitionBetweenGoals();
	void RunFireState();
	void RunJamState();
	void IveBeenSpotlighted(/*packed*/ struct _DYOBJ_INST*);
	int32_t IsThisAnEmergencyVehicle();
	void DoPullOverStuff(int32_t);
	int32_t CanIDoAUTurn();
public:
	/*packed*/ class AutomobileClass operator=(const /*packed*/ class AutomobileClass&);
};

// Type: /*packed*/ class Sound;
// VTABLE: COPTER_D 0x0058f458
class Sound{ // packed(0x34 bytes) TI: 0x4335
	enum SoundSourceType {
		nSoundSourceTypeResource = 0,
		nSoundSourceTypeFile = 1,
	};
public:
	/*+0x4*/   enum Sound::SoundSourceType nSoundSourceType;
	enum SoundDuplicateType {
		nSoundDuplicateDefault = 0,
		nSoundDuplicateInterrupt = 1,
		nSoundDuplicateContinue = 2,
		nSoundDuplicateOverlap = 3,
	};
public:
	/*+0x8*/   enum Sound::SoundDuplicateType nSoundDuplicateType;
	/*+0xc*/   long lID;
	/*+0x10*/  long lResID;
	/*+0x14*/  /*packed*/ class basic_string<char> sSoundFile; // 0x8 bytes
	/*+0x1c*/  long bLooping;
	/*+0x20*/  long bStreaming;
	/*+0x24*/  long lVolume;
	/*+0x28*/  void (*soundCompletionFunction)(long);
	/*+0x2c*/  long lSoundCompletionData;
	/*+0x30*/  int32_t bUnloadBeforeNextPlay;
	void Sound();
	virtual void ~Sound(); // vtable+0x0
	/*packed*/ class Sound& operator=(const /*packed*/ class Sound&);
	virtual void SetSoundFile(const /*packed*/ class basic_string<char>&); // vtable+0x4
	virtual long Play(long, int32_t); // vtable+0x8
	virtual long Stop(); // vtable+0xc
	virtual long IsPlaying(); // vtable+0x10
	virtual int32_t SetCompletionNotification(void (*)(long), long); // vtable+0x14
	virtual void StopCompletionNotification(); // vtable+0x18
	virtual long EstimateRemainingPlayTime(); // vtable+0x1c
	virtual int32_t GetVolume(long *); // vtable+0x20
	virtual int32_t SetVolume(long); // vtable+0x24
	virtual int32_t GetSoundType(); // vtable+0x28
	// calltype: NearC
	static unsigned long GetTotalMemoryUsage();
	static unsigned long lTotalMemoryUsage;
};



// Contribution: 1:00138c00-0013ad38 Module: 156, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00539c00
void S3StationInit() {
// LINE 28:
	__asm        push   0x1C;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T37;

	__asm        push   0xD1;
	__asm        mov    ecx, [ebp-4];
	__asm        call   Station::Station;
	__asm        mov    gHospitals, eax;
	__asm        jmp    _T41;
_T37:
	gHospitals = 0x0;
// LINE 29:
_T41:
	__asm        push   0x1C;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T6f;

	__asm        push   0xD2;
	__asm        mov    ecx, [ebp-8];
	__asm        call   Station::Station;
	__asm        mov    gPoliceStations, eax;
	__asm        jmp    _T79;
_T6f:
	gPoliceStations = 0x0;
// LINE 30:
_T79:
	__asm        push   0x1C;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Ta7;

	__asm        push   0xD3;
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   Station::Station;
	__asm        mov    gFireStations, eax;
	__asm        jmp    _Tb1;
_Ta7:
	gFireStations = 0x0;
// LINE 31:
_Tb1:
	return;
}

// FUNCTION: COPTER_D 0x00539cbb
void S3StationReset() {
// LINE 40:
	__asm        mov    eax, gHospitals;
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T3c;

	__asm        jmp    _T26;
_T26:
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T37;
_T37:
	__asm        jmp    _T3c;
// LINE 41:
_T3c:
	__asm        mov    eax, gPoliceStations;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T6f;

	__asm        jmp    _T59;
_T59:
	__asm        mov    eax, [ebp-0xC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T6a;
_T6a:
	__asm        jmp    _T6f;
// LINE 42:
_T6f:
	__asm        mov    eax, gFireStations;
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _Ta2;

	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, [ebp-0x14];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T9d;
_T9d:
	__asm        jmp    _Ta2;
// LINE 43:
_Ta2:
	return;
}

// FUNCTION: COPTER_D 0x00539d67
short S3GetNearestStation(/*packed*/ class Station *station, /*packed*/ struct _GridCoordinates gc, /*packed*/ struct _GridCoordinates *result) {
// LINE 49:
	__asm        mov    eax, result;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(gc.x);
	__asm        push   eax;
	__asm        mov    ecx, station;
	__asm        call   Station::GetNearestStation;
	__asm        jmp    __RETURN;
// LINE 50:
__RETURN:
}

// FUNCTION: COPTER_D 0x00539d87
short S3GetNextNearest(/*packed*/ class Station *station, /*packed*/ struct _GridCoordinates *result) {
// LINE 57:
	__asm        mov    eax, result;
	__asm        push   eax;
	__asm        mov    ecx, station;
	__asm        call   Station::GetNextNearest;
	__asm        jmp    __RETURN;
// LINE 58:
__RETURN:
}

// FUNCTION: COPTER_D 0x00539da3
int32_t Station::FindNearestRoadToStation(/*packed*/ struct _GridCoordinates& loc) {
	/*bp-0x4*/   int32_t direction;
	/*bp-0x8*/   /*packed*/ struct _GridCoordinates center;
	/*bp-0xc*/   int32_t i;

// LINE 80:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, loc;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+1];
	__asm        add    ecx, edx;
	__asm        and    ecx, 3;
	__asm        mov    direction, ecx;
// LINE 82:
	reinterpret_cast<uint16_t>(center.x) = reinterpret_cast<uint16_t>(loc.x);
// LINE 85:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   ecx, ecx;
	__asm        jl     _T6d;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        cmp    ecx, 0x7F;
	__asm        jg     _T6d;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        test   ecx, ecx;
	__asm        jl     _T6d;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        cmp    ecx, 0x7F;
	__asm        jle    _T79;
_T6d:
	__asm        mov    dword ptr [ebp-0x14], 0;
	__asm        jmp    _Td7;
_T79:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, BuildMap[ecx*4];
	__asm        mov    ecx, loc;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+1];
	__asm        movzx  ax, byte ptr [eax+edx];
	__asm        mov    [ebp-0x10], ax;
	__asm        mov    eax, [ebp-0x10];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1D;
	__asm        jl     _Tcb;

	__asm        mov    eax, [ebp-0x10];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2C;
	__asm        jge    _Tcb;

	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        jmp    _Td7;

	__asm        jmp    _Td7;
_Tcb:
	__asm        mov    dword ptr [ebp-0x14], 0;
	__asm        jmp    _Td7;
_Td7:
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _Te9;

	return direction;
// LINE 87:
_Te9:
	__asm        mov    i, 0;
	__asm        jmp    _Tf8;
_Tf5:
	i++;
_Tf8:
	__asm        cmp    i, 4;
	__asm        jge    _T26a;
// LINE 89:
	__asm        mov    eax, direction;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T17e;
// LINE 91:
_T10d:
	__asm        xor    eax, eax;
	__asm        mov    al, center.y;
	__asm        sub    eax, 2;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx+1], al;
	__asm        mov    al, center.x;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx], al;
	__asm        jmp    _T1a2;
// LINE 92:
_T128:
	__asm        xor    eax, eax;
	__asm        mov    al, center.x;
	__asm        add    eax, 2;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx], al;
	__asm        mov    al, center.y;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx+1], al;
	__asm        jmp    _T1a2;
// LINE 93:
_T143:
	__asm        xor    eax, eax;
	__asm        mov    al, center.y;
	__asm        add    eax, 2;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx+1], al;
	__asm        mov    al, center.x;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx], al;
	__asm        jmp    _T1a2;
// LINE 94:
_T15e:
	__asm        xor    eax, eax;
	__asm        mov    al, center.x;
	__asm        sub    eax, 2;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx], al;
	__asm        mov    al, center.y;
	__asm        mov    ecx, loc;
	__asm        mov    [ecx+1], al;
	__asm        jmp    _T1a2;
// LINE 95:
	__asm        jmp    _T1a2;
_T17e:
	__asm        cmp    dword ptr [ebp-0x24], 3;
	__asm        ja     _T1a2;

	__asm        mov    eax, [ebp-0x24];
	__asm        jmp    _Switch_192[0][eax*4];
// Switch pointers:
//   _T10d
//   _T128
//   _T143
//   _T15e
// LINE 97:
_T1a2:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   ecx, ecx;
	__asm        jl     _T1e2;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        cmp    ecx, 0x7F;
	__asm        jg     _T1e2;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        test   ecx, ecx;
	__asm        jl     _T1e2;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        cmp    ecx, 0x7F;
	__asm        jle    _T1ee;
_T1e2:
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        jmp    _T24c;
_T1ee:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, BuildMap[ecx*4];
	__asm        mov    ecx, loc;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+1];
	__asm        movzx  ax, byte ptr [eax+edx];
	__asm        mov    [ebp-0x18], ax;
	__asm        mov    eax, [ebp-0x18];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1D;
	__asm        jl     _T240;

	__asm        mov    eax, [ebp-0x18];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2C;
	__asm        jge    _T240;

	__asm        mov    dword ptr [ebp-0x1C], 1;
	__asm        jmp    _T24c;

	__asm        jmp    _T24c;
_T240:
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        jmp    _T24c;
_T24c:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T25e;

	return direction;
// LINE 99:
_T25e:
	__asm        inc    direction;
	__asm        and    direction, 3;
// LINE 100:
	__asm        jmp    _Tf5;
// LINE 103:
_T26a:
	return 0xff;
// LINE 104:
}

// FUNCTION: COPTER_D 0x0053a01e
int32_t Station::FindNearestRoadToEmergency(/*packed*/ struct _GridCoordinates& loc) {
	/*bp-0x10*/  /*packed*/ class SpiralScan spiral; // 0x10 bytes

// LINE 110:
	__asm        push   0x80;
	__asm        lea    ecx, spiral.currDist;
	__asm        call   SpiralScan::SpiralScan;
// LINE 113:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   ecx, ecx;
	__asm        jl     _T59;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        cmp    ecx, 0x7F;
	__asm        jg     _T59;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        test   ecx, ecx;
	__asm        jl     _T59;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        cmp    ecx, 0x7F;
	__asm        jle    _T65;
_T59:
	__asm        mov    dword ptr [ebp-0x24], 0;
	__asm        jmp    _Tc3;
_T65:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, BuildMap[ecx*4];
	__asm        mov    ecx, loc;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+1];
	__asm        movzx  ax, byte ptr [eax+edx];
	__asm        mov    [ebp-0x20], ax;
	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1D;
	__asm        jl     _Tb7;

	__asm        mov    eax, [ebp-0x20];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2C;
	__asm        jge    _Tb7;

	__asm        mov    dword ptr [ebp-0x24], 1;
	__asm        jmp    _Tc3;

	__asm        jmp    _Tc3;
_Tb7:
	__asm        mov    dword ptr [ebp-0x24], 0;
	__asm        jmp    _Tc3;
_Tc3:
	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        je     _Te1;
// LINE 114:
	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        jmp    _Td9;
_Td9:
	__asm        mov    eax, [ebp-0x14];
	__asm        jmp    __RETURN;
// LINE 116:
_Te1:
	__asm        mov    eax, loc;
	__asm        push   eax;
	__asm        lea    ecx, spiral.currDist;
	__asm        call   SpiralScan::Next;
	__asm        test   eax, eax;
	__asm        je     _T1c2;
// LINE 118:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        test   ecx, ecx;
	__asm        jl     _T135;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        cmp    ecx, 0x7F;
	__asm        jg     _T135;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        test   ecx, ecx;
	__asm        jl     _T135;

	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        cmp    ecx, 0x7F;
	__asm        jle    _T141;
_T135:
	__asm        mov    dword ptr [ebp-0x2C], 0;
	__asm        jmp    _T19f;
_T141:
	__asm        mov    eax, loc;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        mov    eax, BuildMap[ecx*4];
	__asm        mov    ecx, loc;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx+1];
	__asm        movzx  ax, byte ptr [eax+edx];
	__asm        mov    [ebp-0x28], ax;
	__asm        mov    eax, [ebp-0x28];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x1D;
	__asm        jl     _T193;

	__asm        mov    eax, [ebp-0x28];
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x2C;
	__asm        jge    _T193;

	__asm        mov    dword ptr [ebp-0x2C], 1;
	__asm        jmp    _T19f;

	__asm        jmp    _T19f;
_T193:
	__asm        mov    dword ptr [ebp-0x2C], 0;
	__asm        jmp    _T19f;
_T19f:
	__asm        cmp    dword ptr [ebp-0x2C], 0;
	__asm        je     _T1bd;
// LINE 119:
	__asm        mov    dword ptr [ebp-0x18], 1;
	__asm        jmp    _T1b5;
_T1b5:
	__asm        mov    eax, [ebp-0x18];
	__asm        jmp    __RETURN;
// LINE 120:
_T1bd:
	__asm        jmp    _Te1;
// LINE 122:
_T1c2:
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        jmp    _T1ce;
_T1ce:
	__asm        mov    eax, [ebp-0x1C];
	__asm        jmp    __RETURN;
// LINE 123:
__RETURN:
}

// FUNCTION: COPTER_D 0x0053a1fb
void Station::SortStationsByDistanceFromDestination(/*packed*/ struct _GridCoordinates loc) {
	/*bp-0x4*/   int32_t i;
	/*bp-0x8*/   int32_t deltax;
	/*bp-0xc*/   int32_t deltay;
	/*bp-0x14*/  /*packed*/ struct _StationHeapStruct station; // 0x8 bytes

// LINE 132:
	this->stationHeapSize = 0x0;
// LINE 134:
	__asm        mov    i, 0;
	__asm        jmp    _T25;
_T22:
	i++;
_T25:
	__asm        mov    eax, this;
	__asm        mov    ecx, i;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _T151;
// LINE 138:
	__asm        mov    eax, i;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx+0x58];
	__asm        xor    eax, eax;
	__asm        mov    al, loc.x;
	__asm        cmp    edx, eax;
	__asm        jle    _T78;
// LINE 139:
	__asm        mov    eax, i;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx+0x58];
	__asm        xor    eax, eax;
	__asm        mov    al, loc.x;
	__asm        sub    edx, eax;
	__asm        mov    deltax, edx;
// LINE 140:
	__asm        jmp    _T96;
// LINE 141:
_T78:
	__asm        xor    eax, eax;
	__asm        mov    al, loc.x;
	__asm        mov    ecx, i;
	__asm        shl    ecx, 5;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx+0x58];
	__asm        sub    eax, ebx;
	__asm        mov    deltax, eax;
// LINE 145:
_T96:
	__asm        mov    eax, i;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx+0x59];
	__asm        xor    eax, eax;
	__asm        mov    al, loc.y;
	__asm        cmp    edx, eax;
	__asm        jle    _Tda;
// LINE 146:
	__asm        mov    eax, i;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx+0x59];
	__asm        xor    eax, eax;
	__asm        mov    al, loc.y;
	__asm        sub    edx, eax;
	__asm        mov    deltay, edx;
// LINE 147:
	__asm        jmp    _Tf8;
// LINE 148:
_Tda:
	__asm        xor    eax, eax;
	__asm        mov    al, loc.y;
	__asm        mov    ecx, i;
	__asm        shl    ecx, 5;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        xor    ebx, ebx;
	__asm        mov    bl, [ecx+edx+0x59];
	__asm        sub    eax, ebx;
	__asm        mov    deltay, eax;
// LINE 151:
_Tf8:
	__asm        mov    eax, i;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        cmp    dword ptr [eax+ecx+0x5C], 1;
	__asm        jge    _T14c;
// LINE 153:
	__asm        mov    eax, deltax;
	__asm        cmp    deltay, eax;
	__asm        jge    _T12e;
// LINE 155:
	__asm        mov    eax, deltay;
	__asm        sar    eax, 1;
	__asm        add    eax, deltax;
	__asm        mov    station.cost, eax;
// LINE 157:
	__asm        jmp    _T13a;
// LINE 159:
_T12e:
	__asm        mov    eax, deltax;
	__asm        sar    eax, 1;
	__asm        add    eax, deltay;
	__asm        mov    station.cost, eax;
// LINE 162:
_T13a:
	station.stationID = i;
// LINE 163:
	__asm        lea    eax, station.cost;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::StationHeapInsert;
// LINE 165:
_T14c:
	__asm        jmp    _T22;
// LINE 166:
_T151:
	return;
}

// FUNCTION: COPTER_D 0x0053a358
void Station::SortVehiclesByDistanceFromDestination(/*packed*/ struct _GridCoordinates destLoc, /*packed*/ class EmergencyVehicleClass **vehicleList, int32_t vehicleListLength) {
	/*bp-0xc*/   /*packed*/ struct _VehicleHeapStruct vehicle; // 0xa bytes
	/*bp-0x10*/  int32_t i;
	/*bp-0x14*/  int32_t deltax;
	/*bp-0x18*/  int32_t deltay;

// LINE 178:
	this->vehicleHeapSize = 0x0;
// LINE 181:
	__asm        mov    i, 0;
	__asm        jmp    _T25;
_T22:
	i++;
_T25:
	__asm        mov    eax, vehicleListLength;
	__asm        cmp    i, eax;
	__asm        jge    _T13c;
// LINE 184:
// Block start:
	/*bp-0x24*/  /*packed*/ struct Point3d DyObjLoc; // 0xc bytes
	__asm        jmp    _T36;
_T36:
	__asm        mov    eax, i;
	__asm        mov    ecx, vehicleList;
	__asm        mov    eax, [ecx+eax*4];
	__asm        cmp    dword ptr [eax+0x294], 3;
	__asm        jle    _T51;
// LINE 185:
	__asm        jmp    _T22;
// LINE 187:
_T51:
	__asm        mov    eax, i;
	__asm        mov    ecx, vehicleList;
	__asm        mov    eax, [ecx+eax*4];
	__asm        add    eax, 0x24;
	__asm        lea    ecx, DyObjLoc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 188:
	__asm        mov    eax, DyObjLoc.x;
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    vehicle.loc.x, al;
// LINE 189:
	__asm        mov    eax, 0x20000000;
	__asm        sub    eax, DyObjLoc.z;
	__asm        sar    eax, 0x16;
	__asm        mov    vehicle.loc.y, al;
// LINE 193:
	__asm        xor    eax, eax;
	__asm        mov    al, vehicle.loc.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destLoc.x;
	__asm        cmp    eax, ecx;
	__asm        jle    _Tb2;
// LINE 194:
	__asm        xor    eax, eax;
	__asm        mov    al, vehicle.loc.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destLoc.x;
	__asm        sub    eax, ecx;
	__asm        mov    deltax, eax;
// LINE 195:
	__asm        jmp    _Tc1;
// LINE 196:
_Tb2:
	__asm        xor    eax, eax;
	__asm        mov    al, destLoc.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, vehicle.loc.x;
	__asm        sub    eax, ecx;
	__asm        mov    deltax, eax;
// LINE 200:
_Tc1:
	__asm        xor    eax, eax;
	__asm        mov    al, vehicle.loc.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destLoc.y;
	__asm        cmp    eax, ecx;
	__asm        jle    _Te7;
// LINE 201:
	__asm        xor    eax, eax;
	__asm        mov    al, vehicle.loc.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destLoc.y;
	__asm        sub    eax, ecx;
	__asm        mov    deltay, eax;
// LINE 202:
	__asm        jmp    _Tf6;
// LINE 203:
_Te7:
	__asm        xor    eax, eax;
	__asm        mov    al, destLoc.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, vehicle.loc.y;
	__asm        sub    eax, ecx;
	__asm        mov    deltay, eax;
// LINE 206:
_Tf6:
	__asm        mov    eax, deltax;
	__asm        cmp    deltay, eax;
	__asm        jge    _T113;
// LINE 208:
	__asm        mov    eax, deltay;
	__asm        sar    eax, 1;
	__asm        add    eax, deltax;
	__asm        mov    vehicle.cost, eax;
// LINE 210:
	__asm        jmp    _T11f;
// LINE 212:
_T113:
	__asm        mov    eax, deltax;
	__asm        sar    eax, 1;
	__asm        add    eax, deltay;
	__asm        mov    vehicle.cost, eax;
// LINE 215:
_T11f:
	vehicle.pVehicle = vehicleList->;
// LINE 216:
	__asm        lea    eax, vehicle.cost;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::VehicleHeapInsert;
// LINE 217:
// Block end:
	__asm        jmp    _T22;
// LINE 218:
_T13c:
	return;
}

// FUNCTION: COPTER_D 0x0053a4a0
/*packed*/ class EmergencyVehicleClass* Station::FindAvailableVehicle(enum EmergencyLevel responseLevel, /*packed*/ class EmergencyVehicleClass **vehicleList, int32_t vehicleListLength) {
	/*bp-0x4*/   int32_t i;
	/*bp-0x8*/   int32_t code;

// LINE 227:
	__asm        mov    i, 0;
	__asm        jmp    _T1b;
_T18:
	i++;
_T1b:
	__asm        mov    eax, vehicleListLength;
	__asm        cmp    i, eax;
	__asm        jge    _T4d;
// LINE 229:
	__asm        mov    eax, i;
	__asm        mov    ecx, vehicleList;
	__asm        mov    eax, [ecx+eax*4];
	__asm        test   byte ptr [eax+8], 2;
	__asm        jne    _T48;
// LINE 230:
	return vehicleList->;
// LINE 231:
_T48:
	__asm        jmp    _T18;
// LINE 235:
_T4d:
	__asm        mov    code, 2;
	__asm        jmp    _T5c;
_T59:
	code++;
_T5c:
	__asm        mov    eax, code;
	__asm        cmp    responseLevel, eax;
	__asm        jle    _Tb8;
// LINE 237:
	__asm        mov    i, 0;
	__asm        jmp    _T77;
_T74:
	i++;
_T77:
	__asm        mov    eax, vehicleListLength;
	__asm        cmp    i, eax;
	__asm        jge    _Tb3;
// LINE 239:
	__asm        jmp    _T88;
_T88:
	__asm        mov    eax, i;
	__asm        mov    ecx, vehicleList;
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    ecx, code;
	__asm        cmp    [eax+0x294], ecx;
	__asm        jge    _Tae;
// LINE 240:
	return vehicleList->;
// LINE 241:
_Tae:
	__asm        jmp    _T74;
// LINE 242:
_Tb3:
	__asm        jmp    _T59;
// LINE 244:
_Tb8:
	return 0x0;
// LINE 245:
}

// FUNCTION: COPTER_D 0x0053a566
void Station::StationHeapInsert(const /*packed*/ struct _StationHeapStruct *pInsertStruct) {
	/*bp-0x8*/   /*packed*/ struct _StationHeapStruct tempStruct; // 0x8 bytes
	/*bp-0xc*/   int32_t index;

// LINE 252:
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+0xC];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    index, eax;
// LINE 255:
	__asm        mov    eax, pInsertStruct;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, index;
	__asm        lea    edx, [edx+ebx*8];
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 261:
_T34:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, index;
	__asm        mov    edx, [edx+ebx*8];
	__asm        cmp    [ecx+eax*8], edx;
	__asm        jle    _Tc5;
// LINE 263:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, index;
	__asm        lea    eax, [eax+ecx*8];
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    tempStruct.cost, ecx;
	__asm        mov    tempStruct.stationID, eax;
// LINE 264:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        shl    eax, 3;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+8];
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, index;
	__asm        lea    edx, [edx+ebx*8];
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 265:
	__asm        mov    ecx, tempStruct.cost;
	__asm        mov    ebx, tempStruct.stationID;
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        shl    eax, 3;
	__asm        mov    edx, this;
	__asm        add    eax, [edx+8];
	__asm        mov    [eax], ecx;
	__asm        mov    [eax+4], ebx;
// LINE 266:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    index, eax;
// LINE 267:
	__asm        jmp    _T34;
// LINE 268:
_Tc5:
	return;
}

// FUNCTION: COPTER_D 0x0053a637
void Station::StationHeapRemove(/*packed*/ struct _StationHeapStruct *pRemovedStruct) {
	/*bp-0x8*/   /*packed*/ struct _StationHeapStruct tempStruct; // 0x8 bytes
	/*bp-0xc*/   int32_t parent;
	/*bp-0x10*/  int32_t child;
	/*bp-0x14*/  int32_t index;

// LINE 278:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    index, eax;
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+0xC];
// LINE 279:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        add    eax, 8;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, pRemovedStruct;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 280:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, index;
	__asm        lea    eax, [eax+ecx*8];
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        add    edx, 8;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    tempStruct.cost, ecx;
	__asm        mov    tempStruct.stationID, eax;
// LINE 284:
	parent = 0x1;
// LINE 287:
_T71:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        cmp    eax, parent;
	__asm        jl     _T13e;
// LINE 290:
	__asm        mov    eax, parent;
	__asm        add    eax, parent;
	__asm        mov    child, eax;
// LINE 293:
	__asm        mov    eax, this;
	__asm        mov    ecx, child;
	__asm        cmp    [eax+0xC], ecx;
	__asm        jle    _Tc0;

	__asm        mov    eax, child;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, child;
	__asm        mov    edx, [edx+ebx*8];
	__asm        cmp    [ecx+eax*8+8], edx;
	__asm        jge    _Tc0;
// LINE 294:
	child++;
// LINE 297:
_Tc0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, parent;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, child;
	__asm        mov    edx, [edx+ebx*8];
	__asm        cmp    [eax+ecx*8], edx;
	__asm        jg     _Te3;
// LINE 298:
	__asm        jmp    _T13e;
// LINE 301:
_Te3:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, parent;
	__asm        lea    eax, [eax+ecx*8];
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    tempStruct.cost, ecx;
	__asm        mov    tempStruct.stationID, eax;
// LINE 302:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, child;
	__asm        lea    eax, [eax+ecx*8];
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, parent;
	__asm        lea    edx, [edx+ebx*8];
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 303:
	__asm        mov    eax, tempStruct.cost;
	__asm        mov    ecx, tempStruct.stationID;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, child;
	__asm        lea    edx, [edx+ebx*8];
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 306:
	parent = child;
// LINE 307:
	__asm        jmp    _T71;
// LINE 310:
_T13e:
	__asm        mov    eax, tempStruct.cost;
	__asm        mov    ecx, tempStruct.stationID;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+8];
	__asm        mov    ebx, parent;
	__asm        lea    edx, [edx+ebx*8];
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 311:
	return;
}

// FUNCTION: COPTER_D 0x0053a798
void Station::VehicleHeapInsert(const /*packed*/ struct _VehicleHeapStruct *pInsertStruct) {
	/*bp-0xc*/   /*packed*/ struct _VehicleHeapStruct tempStruct; // 0xa bytes
	/*bp-0x10*/  int32_t index;

// LINE 318:
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+0x14];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    index, eax;
// LINE 321:
	__asm        mov    eax, pInsertStruct;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, index;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 327:
_T3f:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x10];
	__asm        mov    ebx, index;
	__asm        lea    ebx, [ebx+ebx*4];
	__asm        mov    edx, [edx+ebx*2];
	__asm        cmp    [ecx+eax*2], edx;
	__asm        jle    _Tfc;
// LINE 329:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    eax, [eax+ecx*2];
	__asm        lea    ecx, tempStruct.cost;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 330:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, index;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 331:
	__asm        lea    ecx, tempStruct.cost;
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        mov    edx, this;
	__asm        add    eax, [edx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    [eax], edx;
	__asm        mov    edx, [ecx+4];
	__asm        mov    [eax+4], edx;
	__asm        mov    cx, [ecx+8];
	__asm        mov    [eax+8], cx;
// LINE 332:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    index, eax;
// LINE 333:
	__asm        jmp    _T3f;
// LINE 334:
_Tfc:
	return;
}

// FUNCTION: COPTER_D 0x0053a8a0
void Station::VehicleHeapRemove(/*packed*/ struct _VehicleHeapStruct *pRemovedStruct) {
	/*bp-0xc*/   /*packed*/ struct _VehicleHeapStruct tempStruct; // 0xa bytes
	/*bp-0x10*/  int32_t parent;
	/*bp-0x14*/  int32_t child;
	/*bp-0x18*/  int32_t index;

// LINE 344:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    index, eax;
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+0x14];
// LINE 345:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        add    eax, 0xA;
	__asm        mov    ecx, pRemovedStruct;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 346:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    eax, [eax+ecx*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        add    ecx, 0xA;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        add    eax, 0xA;
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        lea    ecx, tempStruct.cost;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 350:
	parent = 0x1;
// LINE 353:
_T8e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        cmp    eax, parent;
	__asm        jl     _T18f;
// LINE 356:
	__asm        mov    eax, parent;
	__asm        add    eax, parent;
	__asm        mov    child, eax;
// LINE 359:
	__asm        mov    eax, this;
	__asm        mov    ecx, child;
	__asm        cmp    [eax+0x14], ecx;
	__asm        jle    _Te3;

	__asm        mov    eax, child;
	__asm        lea    eax, [eax+eax*4+5];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x10];
	__asm        mov    ebx, child;
	__asm        lea    ebx, [ebx+ebx*4];
	__asm        mov    edx, [edx+ebx*2];
	__asm        cmp    [ecx+eax*2], edx;
	__asm        jge    _Te3;
// LINE 360:
	child++;
// LINE 363:
_Te3:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, child;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x10];
	__asm        mov    ebx, parent;
	__asm        lea    ebx, [ebx+ebx*4];
	__asm        mov    edx, [edx+ebx*2];
	__asm        cmp    [eax+ecx*2], edx;
	__asm        jl     _T10c;
// LINE 364:
	__asm        jmp    _T18f;
// LINE 367:
_T10c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, parent;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    eax, [eax+ecx*2];
	__asm        lea    ecx, tempStruct.cost;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 368:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ecx, child;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    eax, [eax+ecx*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 369:
	__asm        lea    eax, tempStruct.cost;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, child;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 372:
	parent = child;
// LINE 373:
	__asm        jmp    _T8e;
// LINE 376:
_T18f:
	__asm        lea    eax, tempStruct.cost;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    ax, [eax+8];
	__asm        mov    [ecx+8], ax;
// LINE 377:
	return;
}

// FUNCTION: COPTER_D 0x0053aa5f
short Station::GetNearestStation(/*packed*/ struct _GridCoordinates gc, /*packed*/ struct _GridCoordinates *result) {
// LINE 385:
	__asm        mov    eax, reinterpret_cast<uint32_t>(gc.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::SortStationsByDistanceFromDestination;
// LINE 386:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        je     _T58;
// LINE 390:
// Block start:
	/*bp-0x8*/   /*packed*/ struct _StationHeapStruct removedStruct; // 0x8 bytes
	__asm        lea    eax, removedStruct.cost;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::StationHeapRemove;
// LINE 391:
	__asm        mov    ecx, removedStruct.stationID;
	__asm        shl    ecx, 5;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    cx, [ecx+edx+0x58];
	__asm        mov    edx, result;
	__asm        mov    [edx], cx;
// LINE 392:
	return reinterpret_cast<uint16_t>(removedStruct.cost);
// LINE 394:
// Block end:
	__asm        jmp    __RETURN;
// LINE 396:
_T58:
	result = 0x0;
// LINE 397:
	return 0x0;
// LINE 399:
__RETURN:
}

// FUNCTION: COPTER_D 0x0053aacd
short Station::GetNextNearest(/*packed*/ struct _GridCoordinates *result) {
// LINE 404:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        je     _T4c;
// LINE 408:
// Block start:
	/*bp-0x8*/   /*packed*/ struct _StationHeapStruct removedStruct; // 0x8 bytes
	__asm        lea    eax, removedStruct.cost;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::StationHeapRemove;
// LINE 409:
	__asm        mov    ecx, removedStruct.stationID;
	__asm        shl    ecx, 5;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    cx, [ecx+edx+0x58];
	__asm        mov    edx, result;
	__asm        mov    [edx], cx;
// LINE 410:
	return reinterpret_cast<uint16_t>(removedStruct.cost);
// LINE 412:
// Block end:
	__asm        jmp    __RETURN;
// LINE 414:
_T4c:
	result = 0x0;
// LINE 415:
	return 0x0;
// LINE 417:
__RETURN:
}

// FUNCTION: COPTER_D 0x0053ab2f
void Station::DecrementQuantityOfVehicleDispatched(int32_t stationID) {
// LINE 423:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, stationID;
	__asm        shl    ecx, 5;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        cmp    dword ptr [eax+ecx+0x5C], 0;
	__asm        jne    _T41;

	__asm        push   0x1A7;
	__asm        push   0x5B8078;
	__asm        push   0x5B809C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T46;
_T41:
	__asm        jmp    _T46;
// LINE 425:
_T46:
	__asm        mov    eax, stationID;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        dec    dword ptr [eax+ecx+0x5C];
// LINE 426:
	return;
}

// FUNCTION: COPTER_D 0x0053ab93
int32_t Station::DispatchNearestAvailableVehicle(long mapx, long mapy, enum EmergencyType responseType, enum EmergencyLevel responseLevel, /*packed*/ class EmergencyVehicleClass **vehicleList, int32_t vehicleListLength) {
	/*bp-0x4*/   /*packed*/ struct _RGIndex startVertex;
	/*bp-0x30*/  /*packed*/ struct Goal result; // 0x2a bytes
	/*bp-0x38*/  /*packed*/ struct _StationHeapStruct stationHeapStruct; // 0x8 bytes
	// StaticLocal: 0x006351d0
	static /*packed*/ class DigitalSound errorMsgSound;
	;
	/*bp-0x3c*/  /*packed*/ class EmergencyVehicleClass *availableVehicle;
	/*bp-0x68*/  /*packed*/ struct Goal destGoal2; // 0x2a bytes
	/*bp-0x6c*/  int32_t pathFound;
	/*bp-0x98*/  /*packed*/ struct Goal destGoal1; // 0x2a bytes
	/*bp-0xa0*/  /*packed*/ class basic_string<char> errorMsgSoundFullPath; // 0x8 bytes
	/*bp-0xa4*/  /*packed*/ struct _GridCoordinates destLoc;
	/*bp-0xb0*/  /*packed*/ struct _VehicleHeapStruct vehicleHeapStruct; // 0xa bytes
	/*bp-0xb4*/  /*packed*/ struct _RGIndex destVert;
	/*bp-0xe0*/  /*packed*/ struct Goal startGoal2; // 0x2a bytes
	/*bp-0x10c*/ /*packed*/ struct Goal startGoal1; // 0x2a bytes

// LINE 433:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x284], eax;
	__asm        cmp    dword ptr [ebp-0x284], 0;
	__asm        je     _T7d;

	__asm        mov    eax, [ebp-0x284];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x284];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x284];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x284];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x284];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T6c;
_T6c:
	__asm        mov    eax, [ebp-0x284];
	__asm        mov    errorMsgSoundFullPath.reference, eax;
	__asm        jmp    _T87;
_T7d:
	errorMsgSoundFullPath.reference = 0x0;
_T87:
	__asm        mov    errorMsgSoundFullPath.c_str_ptr, 0;
	__asm        jmp    _T96;
// LINE 434:
_T96:
	__asm        xor    eax, eax;
	__asm        mov    al, ?$S35@?1??DispatchNearestAvailableVehicle@Station@@QAEHJJW4EmergencyType@@W4EmergencyLevel@@PAPAVEmergencyVehicleClass@@H@Z@4EA;
	__asm        test   al, 1;
	__asm        jne    _Tca;

	__asm        xor    eax, eax;
	__asm        mov    al, ?$S35@?1??DispatchNearestAvailableVehicle@Station@@QAEHJJW4EmergencyType@@W4EmergencyLevel@@PAPAVEmergencyVehicleClass@@H@Z@4EA;
	__asm        or     al, 1;
	__asm        mov    ?$S35@?1??DispatchNearestAvailableVehicle@Station@@QAEHJJW4EmergencyType@@W4EmergencyLevel@@PAPAVEmergencyVehicleClass@@H@Z@4EA, al;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::DigitalSound;
	__asm        push   0x53B99B;
	__asm        call   atexit;
	__asm        add    esp, 4;
// LINE 450:
_Tca:
	destLoc.x = reinterpret_cast<uint8_t>(mapx);
// LINE 451:
	destLoc.y = reinterpret_cast<uint8_t>(mapy);
// LINE 454:
	__asm        mov    eax, vehicleListLength;
	__asm        push   eax;
	__asm        mov    eax, vehicleList;
	__asm        push   eax;
	__asm        mov    eax, responseLevel;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::FindAvailableVehicle;
	__asm        mov    availableVehicle, eax;
// LINE 457:
	__asm        cmp    availableVehicle, 0;
	__asm        jne    _T3b9;
// LINE 459:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x278], eax;
	__asm        cmp    dword ptr [ebp-0x278], 0;
	__asm        je     _T1ef;

	__asm        mov    edi, 0x5B80CC;
	__asm        mov    ecx, 0xFFFFFFFF;
	__asm        sub    eax, eax;
	__asm        repne scasb;
	__asm        not    ecx;
	__asm        lea    eax, [ecx-1];
	__asm        mov    ecx, [ebp-0x278];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T13e;
_T13e:
	__asm        mov    eax, [ebp-0x278];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x278];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x278];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T1c0;

	__asm        mov    eax, [ebp-0x278];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x278];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x278];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x27C], eax;
	__asm        mov    eax, [ebp-0x278];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x280], eax;
	__asm        mov    eax, [ebp-0x27C];
	__asm        mov    esi, 0x5B80CC;
	__asm        mov    edi, [ebp-0x280];
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
	__asm        jmp    _T1bb;
_T1bb:
	__asm        jmp    _T1cc;
_T1c0:
	__asm        mov    eax, [ebp-0x278];
	__asm        mov    dword ptr [eax], 0;
_T1cc:
	__asm        mov    eax, [ebp-0x278];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T1de;
_T1de:
	__asm        mov    eax, [ebp-0x278];
	__asm        mov    [ebp-0x118], eax;
	__asm        jmp    _T1f9;
_T1ef:
	__asm        mov    dword ptr [ebp-0x118], 0;
_T1f9:
	__asm        mov    dword ptr [ebp-0x11C], 0;
	__asm        jmp    _T208;
_T208:
	__asm        lea    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x11C];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   2;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T229;
_T229:
	__asm        mov    eax, [ebp-0x118];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x118];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T290;

	__asm        mov    eax, [ebp-0x118];
	__asm        mov    [ebp-0x264], eax;
	__asm        mov    eax, [ebp-0x264];
	__asm        mov    [ebp-0x260], eax;
	__asm        cmp    dword ptr [ebp-0x260], 0;
	__asm        je     _T290;

	__asm        mov    ecx, [ebp-0x260];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T277;
_T277:
	__asm        mov    eax, [ebp-0x260];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T28b;
_T28b:
	__asm        jmp    _T290;
_T290:
	__asm        jmp    _T295;
_T295:
	__asm        cmp    dword ptr [ebp-0x11C], 0;
	__asm        je     _T2c9;

	__asm        mov    eax, [ebp-0x11C];
	__asm        mov    [ebp-0x258], eax;
	__asm        mov    eax, [ebp-0x258];
	__asm        mov    [ebp-0x25C], eax;
	__asm        mov    eax, [ebp-0x25C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T2c9:
	__asm        jmp    _T2ce;
// LINE 460:
_T2ce:
	__asm        push   2;
	__asm        lea    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::SetSoundFile;
// LINE 461:
	__asm        mov    eax, glMasterVolume;
	__asm        push   eax;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::SetVolume;
// LINE 462:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::Play;
// LINE 464:
	__asm        mov    dword ptr [ebp-0x120], 0x101;
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T370;

	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        mov    [ebp-0x274], eax;
	__asm        mov    eax, [ebp-0x274];
	__asm        mov    [ebp-0x270], eax;
	__asm        cmp    dword ptr [ebp-0x270], 0;
	__asm        je     _T370;

	__asm        mov    ecx, [ebp-0x270];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T357;
_T357:
	__asm        mov    eax, [ebp-0x270];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T36b;
_T36b:
	__asm        jmp    _T370;
_T370:
	__asm        jmp    _T375;
_T375:
	__asm        cmp    errorMsgSoundFullPath.c_str_ptr, 0;
	__asm        je     _T3a9;

	__asm        mov    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        mov    [ebp-0x268], eax;
	__asm        mov    eax, [ebp-0x268];
	__asm        mov    [ebp-0x26C], eax;
	__asm        mov    eax, [ebp-0x26C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T3a9:
	__asm        jmp    _T3ae;
_T3ae:
	__asm        mov    eax, [ebp-0x120];
	__asm        jmp    __RETURN;
// LINE 467:
_T3b9:
	__asm        lea    eax, destLoc.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::FindNearestRoadToEmergency;
	__asm        test   eax, eax;
	__asm        jne    _T68c;
// LINE 469:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x24C], eax;
	__asm        cmp    dword ptr [ebp-0x24C], 0;
	__asm        je     _T4c2;

	__asm        mov    edi, 0x5B80D8;
	__asm        mov    ecx, 0xFFFFFFFF;
	__asm        sub    eax, eax;
	__asm        repne scasb;
	__asm        not    ecx;
	__asm        lea    eax, [ecx-1];
	__asm        mov    ecx, [ebp-0x24C];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T411;
_T411:
	__asm        mov    eax, [ebp-0x24C];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x24C];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x24C];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T493;

	__asm        mov    eax, [ebp-0x24C];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x24C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x24C];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x250], eax;
	__asm        mov    eax, [ebp-0x24C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x254], eax;
	__asm        mov    eax, [ebp-0x250];
	__asm        mov    esi, 0x5B80D8;
	__asm        mov    edi, [ebp-0x254];
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
	__asm        jmp    _T48e;
_T48e:
	__asm        jmp    _T49f;
_T493:
	__asm        mov    eax, [ebp-0x24C];
	__asm        mov    dword ptr [eax], 0;
_T49f:
	__asm        mov    eax, [ebp-0x24C];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T4b1;
_T4b1:
	__asm        mov    eax, [ebp-0x24C];
	__asm        mov    [ebp-0x124], eax;
	__asm        jmp    _T4cc;
_T4c2:
	__asm        mov    dword ptr [ebp-0x124], 0;
_T4cc:
	__asm        mov    dword ptr [ebp-0x128], 0;
	__asm        jmp    _T4db;
_T4db:
	__asm        lea    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x128];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   2;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T4fc;
_T4fc:
	__asm        mov    eax, [ebp-0x124];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x124];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T563;

	__asm        mov    eax, [ebp-0x124];
	__asm        mov    [ebp-0x238], eax;
	__asm        mov    eax, [ebp-0x238];
	__asm        mov    [ebp-0x234], eax;
	__asm        cmp    dword ptr [ebp-0x234], 0;
	__asm        je     _T563;

	__asm        mov    ecx, [ebp-0x234];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T54a;
_T54a:
	__asm        mov    eax, [ebp-0x234];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T55e;
_T55e:
	__asm        jmp    _T563;
_T563:
	__asm        jmp    _T568;
_T568:
	__asm        cmp    dword ptr [ebp-0x128], 0;
	__asm        je     _T59c;

	__asm        mov    eax, [ebp-0x128];
	__asm        mov    [ebp-0x22C], eax;
	__asm        mov    eax, [ebp-0x22C];
	__asm        mov    [ebp-0x230], eax;
	__asm        mov    eax, [ebp-0x230];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T59c:
	__asm        jmp    _T5a1;
// LINE 470:
_T5a1:
	__asm        push   2;
	__asm        lea    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::SetSoundFile;
// LINE 471:
	__asm        mov    eax, glMasterVolume;
	__asm        push   eax;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::SetVolume;
// LINE 472:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::Play;
// LINE 474:
	__asm        mov    dword ptr [ebp-0x12C], 0x103;
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T643;

	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        mov    [ebp-0x248], eax;
	__asm        mov    eax, [ebp-0x248];
	__asm        mov    [ebp-0x244], eax;
	__asm        cmp    dword ptr [ebp-0x244], 0;
	__asm        je     _T643;

	__asm        mov    ecx, [ebp-0x244];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T62a;
_T62a:
	__asm        mov    eax, [ebp-0x244];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T63e;
_T63e:
	__asm        jmp    _T643;
_T643:
	__asm        jmp    _T648;
_T648:
	__asm        cmp    errorMsgSoundFullPath.c_str_ptr, 0;
	__asm        je     _T67c;

	__asm        mov    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        mov    [ebp-0x23C], eax;
	__asm        mov    eax, [ebp-0x23C];
	__asm        mov    [ebp-0x240], eax;
	__asm        mov    eax, [ebp-0x240];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T67c:
	__asm        jmp    _T681;
_T681:
	__asm        mov    eax, [ebp-0x12C];
	__asm        jmp    __RETURN;
// LINE 479:
_T68c:
	__asm        mov    eax, availableVehicle;
	__asm        test   byte ptr [eax+8], 2;
	__asm        je     _T861;
// LINE 483:
	__asm        mov    eax, vehicleListLength;
	__asm        push   eax;
	__asm        mov    eax, vehicleList;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::SortVehiclesByDistanceFromDestination;
// LINE 487:
_T6b3:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T85c;
// LINE 489:
	__asm        lea    eax, vehicleHeapStruct.cost;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::VehicleHeapRemove;
// LINE 493:
	__asm        lea    eax, startGoal2.pRGV;
	__asm        push   eax;
	__asm        lea    eax, startGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, vehicleHeapStruct.pVehicle;
	__asm        mov    ax, [eax+0x7C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x158];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
	__asm        lea    edi, result.pRGV;
	__asm        mov    esi, eax;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 495:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T7c9;
// LINE 497:
	__asm        lea    eax, destGoal2.pRGV;
	__asm        push   eax;
	__asm        lea    eax, destGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x184];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
// LINE 501:
	startVertex.x = startGoal1.pRGV->x;
// LINE 502:
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, startGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    startVertex.yindex, al;
// LINE 504:
	destVert.x = destGoal1.pRGV->x;
// LINE 505:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destVert.yindex, al;
// LINE 507:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destVert.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(startVertex.x);
	__asm        push   eax;
	__asm        mov    ecx, 0x5C37F8;
	__asm        call   ShortestPath::BreadthFirstSearch;
	__asm        mov    pathFound, eax;
// LINE 509:
	__asm        jmp    _T7d0;
// LINE 511:
_T7c9:
	pathFound = 0x1;
// LINE 516:
_T7d0:
	__asm        cmp    pathFound, 0;
	__asm        je     _T857;
// LINE 519:
	__asm        mov    eax, responseLevel;
	__asm        push   eax;
	__asm        mov    eax, responseType;
	__asm        push   eax;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, result.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal2.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal1.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, startGoal2.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, startGoal1.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    ecx, vehicleHeapStruct.pVehicle;
	__asm        call   EmergencyVehicleClass::InitializePlacedVehicleForDispatch;
// LINE 520:
	__asm        jmp    _T85c;
// LINE 522:
_T857:
	__asm        jmp    _T6b3;
// LINE 524:
_T85c:
	__asm        jmp    _Ta84;
// LINE 528:
_T861:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::SortStationsByDistanceFromDestination;
// LINE 530:
_T873:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        je     _Ta84;
// LINE 532:
// Block start:
	/*bp-0x110*/ /*packed*/ struct _StructStation *sS;
	__asm        lea    eax, stationHeapStruct.cost;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::StationHeapRemove;
// LINE 537:
	__asm        lea    eax, destGoal1.pRGV;
	__asm        push   eax;
	__asm        lea    eax, destGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, stationHeapStruct.stationID;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    ax, [eax+ecx+0x5A];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1B0];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
	__asm        lea    edi, result.pRGV;
	__asm        mov    esi, eax;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
// LINE 539:
	__asm        cmp    result.pRGV, 0;
	__asm        jne    _T9ac;
// LINE 541:
// Block start:
	/*bp-0x114*/ /*packed*/ struct RGVertex *pRGV;
	__asm        lea    eax, destGoal2.pRGV;
	__asm        push   eax;
	__asm        lea    eax, destGoal1.pRGV;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1DC];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
// LINE 545:
	__asm        mov    eax, stationHeapStruct.stationID;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    eax, [eax+ecx];
	__asm        mov    pRGV, eax;
// LINE 546:
	startVertex.x = pRGV->x;
// LINE 547:
	__asm        mov    eax, pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    startVertex.yindex, al;
// LINE 549:
	destVert.x = destGoal1.pRGV->x;
// LINE 550:
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        push   ecx;
	__asm        mov    eax, destGoal1.pRGV;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        push   ecx;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindYIndexToVertex;
	__asm        mov    destVert.yindex, al;
// LINE 552:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destVert.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(startVertex.x);
	__asm        push   eax;
	__asm        mov    ecx, 0x5C37F8;
	__asm        call   ShortestPath::BreadthFirstSearch;
	__asm        mov    pathFound, eax;
// LINE 554:
// Block end:
	__asm        jmp    _T9b3;
// LINE 556:
_T9ac:
	pathFound = 0x1;
// LINE 561:
_T9b3:
	__asm        mov    eax, stationHeapStruct.stationID;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        mov    sS, eax;
// LINE 562:
	__asm        cmp    pathFound, 0;
	__asm        je     _Ta7f;
// LINE 564:
	sS->quanVehiclesDispatched++;
// LINE 567:
	__asm        mov    eax, responseLevel;
	__asm        push   eax;
	__asm        mov    eax, responseType;
	__asm        push   eax;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, result.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    eax, stationHeapStruct.stationID;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    eax, [eax+ecx+0x54];
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal2.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        lea    esi, destGoal1.pRGV;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    eax, sS;
	__asm        mov    ax, [eax+0x5A];
	__asm        push   eax;
	__asm        sub    esp, 0x2C;
	__asm        mov    esi, sS;
	__asm        add    esi, 0x2A;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        sub    esp, 0x2C;
	__asm        mov    esi, sS;
	__asm        mov    edi, esp;
	__asm        mov    ecx, 0xA;
	__asm        rep movsd;
	__asm        movsw;
	__asm        mov    eax, stationHeapStruct.stationID;
	__asm        push   eax;
	__asm        mov    ecx, availableVehicle;
	__asm        call   EmergencyVehicleClass::InitializeStationVehicleForDispatch;
// LINE 568:
	__asm        jmp    _Ta84;
// LINE 570:
// Block end:
_Ta7f:
	__asm        jmp    _T873;
// LINE 573:
_Ta84:
	__asm        cmp    pathFound, 0;
	__asm        jne    _Td47;
// LINE 576:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x220], eax;
	__asm        cmp    dword ptr [ebp-0x220], 0;
	__asm        je     _Tb7d;

	__asm        mov    edi, 0x5B80E4;
	__asm        mov    ecx, 0xFFFFFFFF;
	__asm        sub    eax, eax;
	__asm        repne scasb;
	__asm        not    ecx;
	__asm        lea    eax, [ecx-1];
	__asm        mov    ecx, [ebp-0x220];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _Tacc;
_Tacc:
	__asm        mov    eax, [ebp-0x220];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x220];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x220];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _Tb4e;

	__asm        mov    eax, [ebp-0x220];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x220];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x220];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x224], eax;
	__asm        mov    eax, [ebp-0x220];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x228], eax;
	__asm        mov    eax, [ebp-0x224];
	__asm        mov    esi, 0x5B80E4;
	__asm        mov    edi, [ebp-0x228];
	__asm        mov    ecx, eax;
	__asm        shr    ecx, 2;
	__asm        rep movsd;
	__asm        mov    ecx, eax;
	__asm        and    ecx, 3;
	__asm        rep movsb;
	__asm        jmp    _Tb49;
_Tb49:
	__asm        jmp    _Tb5a;
_Tb4e:
	__asm        mov    eax, [ebp-0x220];
	__asm        mov    dword ptr [eax], 0;
_Tb5a:
	__asm        mov    eax, [ebp-0x220];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _Tb6c;
_Tb6c:
	__asm        mov    eax, [ebp-0x220];
	__asm        mov    [ebp-0x1E0], eax;
	__asm        jmp    _Tb87;
_Tb7d:
	__asm        mov    dword ptr [ebp-0x1E0], 0;
_Tb87:
	__asm        mov    dword ptr [ebp-0x1E4], 0;
	__asm        jmp    _Tb96;
_Tb96:
	__asm        lea    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1E4];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   2;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _Tbb7;
_Tbb7:
	__asm        mov    eax, [ebp-0x1E0];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x1E0];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _Tc1e;

	__asm        mov    eax, [ebp-0x1E0];
	__asm        mov    [ebp-0x1FC], eax;
	__asm        mov    eax, [ebp-0x1FC];
	__asm        mov    [ebp-0x1F8], eax;
	__asm        cmp    dword ptr [ebp-0x1F8], 0;
	__asm        je     _Tc1e;

	__asm        mov    ecx, [ebp-0x1F8];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _Tc05;
_Tc05:
	__asm        mov    eax, [ebp-0x1F8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _Tc19;
_Tc19:
	__asm        jmp    _Tc1e;
_Tc1e:
	__asm        jmp    _Tc23;
_Tc23:
	__asm        cmp    dword ptr [ebp-0x1E4], 0;
	__asm        je     _Tc57;

	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    [ebp-0x1F0], eax;
	__asm        mov    eax, [ebp-0x1F0];
	__asm        mov    [ebp-0x1F4], eax;
	__asm        mov    eax, [ebp-0x1F4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_Tc57:
	__asm        jmp    _Tc5c;
// LINE 577:
_Tc5c:
	__asm        push   2;
	__asm        lea    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::SetSoundFile;
// LINE 578:
	__asm        mov    eax, glMasterVolume;
	__asm        push   eax;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::SetVolume;
// LINE 579:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::Play;
// LINE 581:
	__asm        mov    dword ptr [ebp-0x1E8], 0x105;
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _Tcfe;

	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        mov    [ebp-0x20C], eax;
	__asm        mov    eax, [ebp-0x20C];
	__asm        mov    [ebp-0x208], eax;
	__asm        cmp    dword ptr [ebp-0x208], 0;
	__asm        je     _Tcfe;

	__asm        mov    ecx, [ebp-0x208];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _Tce5;
_Tce5:
	__asm        mov    eax, [ebp-0x208];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _Tcf9;
_Tcf9:
	__asm        jmp    _Tcfe;
_Tcfe:
	__asm        jmp    _Td03;
_Td03:
	__asm        cmp    errorMsgSoundFullPath.c_str_ptr, 0;
	__asm        je     _Td37;

	__asm        mov    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        mov    [ebp-0x200], eax;
	__asm        mov    eax, [ebp-0x200];
	__asm        mov    [ebp-0x204], eax;
	__asm        mov    eax, [ebp-0x204];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_Td37:
	__asm        jmp    _Td3c;
_Td3c:
	__asm        mov    eax, [ebp-0x1E8];
	__asm        jmp    __RETURN;
// LINE 584:
_Td47:
	__asm        mov    dword ptr [ebp-0x1EC], 1;
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _Tdb8;

	__asm        mov    eax, errorMsgSoundFullPath.reference;
	__asm        mov    [ebp-0x21C], eax;
	__asm        mov    eax, [ebp-0x21C];
	__asm        mov    [ebp-0x218], eax;
	__asm        cmp    dword ptr [ebp-0x218], 0;
	__asm        je     _Tdb8;

	__asm        mov    ecx, [ebp-0x218];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _Td9f;
_Td9f:
	__asm        mov    eax, [ebp-0x218];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _Tdb3;
_Tdb3:
	__asm        jmp    _Tdb8;
_Tdb8:
	__asm        jmp    _Tdbd;
_Tdbd:
	__asm        cmp    errorMsgSoundFullPath.c_str_ptr, 0;
	__asm        je     _Tdf1;

	__asm        mov    eax, errorMsgSoundFullPath.c_str_ptr;
	__asm        mov    [ebp-0x210], eax;
	__asm        mov    eax, [ebp-0x210];
	__asm        mov    [ebp-0x214], eax;
	__asm        mov    eax, [ebp-0x214];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_Tdf1:
	__asm        jmp    _Tdf6;
_Tdf6:
	__asm        mov    eax, [ebp-0x1EC];
	__asm        jmp    __RETURN;
// LINE 585:
__RETURN:
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x0053b99b
static void $E36() {

	__asm        mov    ecx, 0x6351D0;
	__asm        call   DigitalSound::~DigitalSound;
	__asm        jmp    __RETURN;
__RETURN:
}

// FUNCTION: COPTER_D 0x0053b9b5
void Station::Station(unsigned char stationScurkID) {
	/*bp-0x4*/   /*packed*/ struct _GridCoordinates workingLoc;
	/*bp-0x8*/   unsigned char * tempBuildMap;
	/*bp-0xc*/   int32_t x;
	/*bp-0x10*/  int32_t y;
	/*bp-0x14*/  int32_t stationIndex;

// LINE 594:
	tempBuildMap = 0x5c3ab0;
// LINE 596:
	this->quantityOfStations = 0x0;
// LINE 599:
	__asm        mov    y, 0;
	__asm        jmp    _T2c;
_T29:
	y++;
_T2c:
	__asm        cmp    y, 0x80;
	__asm        jge    _T7e;
// LINE 601:
	__asm        mov    x, 0;
	__asm        jmp    _T48;
_T45:
	x++;
_T48:
	__asm        cmp    x, 0x80;
	__asm        jge    _T79;
// LINE 603:
	__asm        mov    eax, x;
	__asm        mov    eax, BuildMap[eax*4];
	__asm        mov    ecx, y;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, y;
	__asm        shl    ecx, 7;
	__asm        add    ecx, x;
	__asm        mov    edx, tempBuildMap;
	__asm        mov    [ecx+edx], al;
// LINE 604:
	__asm        jmp    _T45;
// LINE 605:
_T79:
	__asm        jmp    _T29;
// LINE 610:
_T7e:
	__asm        mov    x, 0;
	__asm        jmp    _T8d;
_T8a:
	x++;
_T8d:
	__asm        cmp    x, 0x80;
	__asm        jge    _T1a8;
// LINE 612:
	__asm        mov    y, 0;
	__asm        jmp    _Ta9;
_Ta6:
	y++;
_Ta9:
	__asm        cmp    y, 0x80;
	__asm        jge    _T1a3;
// LINE 614:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        xor    eax, eax;
	__asm        mov    al, stationScurkID;
	__asm        cmp    edx, eax;
	__asm        jne    _T19e;
// LINE 618:
// Block start:
	/*bp-0x18*/  int32_t result;
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+1], 0;
// LINE 619:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+2], 0;
// LINE 621:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+0x80], 0;
// LINE 622:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+0x81], 0;
// LINE 623:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+0x82], 0;
// LINE 625:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+0x100], 0;
// LINE 626:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+0x101], 0;
// LINE 627:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        mov    byte ptr [eax+ecx+0x102], 0;
// LINE 631:
	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        mov    workingLoc.x, al;
// LINE 632:
	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        mov    workingLoc.y, al;
// LINE 633:
	__asm        lea    eax, workingLoc.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::FindNearestRoadToStation;
	__asm        mov    result, eax;
// LINE 634:
	__asm        cmp    result, 0xFF;
	__asm        je     _T19e;
// LINE 635:
	this->quantityOfStations++;
// LINE 637:
// Block end:
_T19e:
	__asm        jmp    _Ta6;
// LINE 638:
_T1a3:
	__asm        jmp    _T8a;
// LINE 641:
_T1a8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        push   eax;
	__asm        mov    eax, G_citymempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx], eax;
// LINE 644:
	stationIndex = 0x0;
// LINE 645:
	__asm        mov    y, 0;
	__asm        jmp    _T1de;
_T1db:
	y++;
_T1de:
	__asm        cmp    y, 0x80;
	__asm        jge    _T2cc;
// LINE 647:
	__asm        mov    x, 0;
	__asm        jmp    _T1fa;
_T1f7:
	x++;
_T1fa:
	__asm        cmp    x, 0x80;
	__asm        jge    _T2c7;
// LINE 649:
	__asm        mov    eax, y;
	__asm        shl    eax, 7;
	__asm        add    eax, x;
	__asm        mov    ecx, tempBuildMap;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        xor    eax, eax;
	__asm        mov    al, stationScurkID;
	__asm        cmp    edx, eax;
	__asm        jne    _T2c2;
// LINE 654:
// Block start:
	/*bp-0x1c*/  int32_t direction;
	/*bp-0x20*/  /*packed*/ struct _StructStation *pStation;
	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        mov    workingLoc.x, al;
// LINE 655:
	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        mov    workingLoc.y, al;
// LINE 658:
	__asm        lea    eax, workingLoc.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   Station::FindNearestRoadToStation;
	__asm        mov    direction, eax;
// LINE 661:
	__asm        cmp    direction, 0xFF;
	__asm        jne    _T254;
// LINE 662:
	__asm        jmp    _T1f7;
// LINE 665:
_T254:
	__asm        mov    eax, stationIndex;
	__asm        shl    eax, 5;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        mov    pStation, eax;
	__asm        inc    stationIndex;
// LINE 668:
	__asm        mov    eax, pStation;
	__asm        add    eax, 0x2A;
	__asm        push   eax;
	__asm        mov    eax, pStation;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(workingLoc.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(workingLoc.x);
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        mov    ecx, 0x5C3828;
	__asm        call   RoadGraph::FindIntersections;
// LINE 673:
	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        mov    ecx, pStation;
	__asm        mov    [ecx+0x58], al;
// LINE 674:
	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        mov    ecx, pStation;
	__asm        mov    [ecx+0x59], al;
// LINE 675:
	pStation->nearestRoadTile.x = workingLoc.x;
// LINE 676:
	pStation->nearestRoadTile.y = workingLoc.y;
// LINE 677:
	pStation->quanVehiclesDispatched = 0x0;
// LINE 678:
	pStation->direction = direction;
// LINE 680:
// Block end:
_T2c2:
	__asm        jmp    _T1f7;
// LINE 681:
_T2c7:
	__asm        jmp    _T1db;
// LINE 683:
_T2cc:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        shl    eax, 3;
	__asm        push   eax;
	__asm        mov    eax, G_citymempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
// LINE 686:
	__asm        xor    eax, eax;
	__asm        mov    al, stationScurkID;
	__asm        mov    [ebp-0x54], eax;
	__asm        jmp    _T329;
// LINE 688:
_T2f7:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x18], 5;
	__asm        jmp    _T355;
// LINE 689:
_T306:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x18], 5;
	__asm        jmp    _T355;
// LINE 690:
_T315:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x18], 5;
	__asm        jmp    _T355;
// LINE 691:
	__asm        jmp    _T355;
_T329:
	__asm        cmp    dword ptr [ebp-0x54], 0xD1;
	__asm        je     _T2f7;

	__asm        cmp    dword ptr [ebp-0x54], 0xD2;
	__asm        je     _T306;

	__asm        cmp    dword ptr [ebp-0x54], 0xD3;
	__asm        je     _T315;

	__asm        jmp    _T355;
// LINE 693:
_T355:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, G_citymempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x10], eax;
// LINE 694:
	return;

	__asm        mov    eax, this;
}



// Contribution: 3:00021078-000210ec Module: 156, 4 byte alignment, initialized_data, read, write, 


// Contribution: 3:0009e1d0-0009e24c Module: 156, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0063524c
static unsigned char ?$S35@?1??DispatchNearestAvailableVehicle@Station@@QAEHJJW4EmergencyType@@W4EmergencyLevel@@PAPAVEmergencyVehicleClass@@H@Z@4EA;

