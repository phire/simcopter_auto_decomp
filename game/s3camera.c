// Module: S3camera.obj
// Source: C:\Copter\source\game\S3camera.c
// autogenerated by simcopter_tool from PDB file

// Type: long;

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: unsigned short;

// Type: int32_t;

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: void;

// Type: int32_t *;

// Type: /*packed*/ struct _CHASE_INFO (forward reference);
struct _CHASE_INFO{ // packed(0xc bytes) TI: 0x31b0
	/*+0x0*/   int32_t dist;
	/*+0x4*/   int32_t height;
	/*+0x8*/   int32_t focus;
};

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct _STOBJ_INST (forward reference);
struct _STOBJ_INST{ // packed(0x10 bytes) TI: 0x193f
	/*+0x0*/   /*packed*/ struct _STOBJ_INST *next;
	/*+0x4*/   void * __ptr32 mesh;
	/*+0x8*/   long user1;
	/*+0xc*/   long user2;
};



// Contribution: 1:000f7af0-000f8bb0 Module: 175, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004f8af0
void S3CameraMove(/*packed*/ struct Point3d *P) {
	/*bp-0x40*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x4c*/  /*packed*/ struct Point3d viewerPos; // 0xc bytes
	/*bp-0x58*/  /*packed*/ struct Point3d CameraVector; // 0xc bytes
	/*bp-0x5c*/  int32_t Velocity;
	/*bp-0x60*/  int32_t altdiff;
	/*bp-0x64*/  int32_t alt;
	/*bp-0x68*/  /*packed*/ struct _DYOBJ_INST *u_dyobj;
	/*bp-0x74*/  /*packed*/ struct Point3d CameraDelta; // 0xc bytes

// LINE 101:
	Velocity = 0x0;
// LINE 124:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _T23d;
// LINE 126:
	__asm        cmp    G_camera_mode, 3;
	__asm        jne    _Tfe;
// LINE 129:
	__asm        call   GetAvatarDYOBJ;
	__asm        mov    u_dyobj, eax;
// LINE 130:
	__asm        mov    eax, u_dyobj;
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, viewerPos.x;
	__asm        push   eax;
	__asm        push   0x5B4DE0;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 131:
	__asm        mov    eax, u_dyobj;
	__asm        mov    eax, [eax+0x18];
	__asm        add    eax, viewerPos.x;
	__asm        mov    Viewer.pos.x, eax;
// LINE 132:
	__asm        mov    eax, u_dyobj;
	__asm        mov    eax, [eax+0x1C];
	__asm        add    eax, viewerPos.y;
	__asm        mov    Viewer.pos.y, eax;
// LINE 133:
	__asm        mov    eax, u_dyobj;
	__asm        mov    eax, [eax+0x20];
	__asm        add    eax, viewerPos.z;
	__asm        mov    Viewer.pos.z, eax;
// LINE 136:
	__asm        mov    eax, 0x6C12A0;
	__asm        add    eax, 0x78;
	__asm        push   eax;
	__asm        call   S3CameraGetBldAlt;
	__asm        add    esp, 4;
	__asm        mov    alt, eax;
// LINE 137:
	__asm        cmp    alt, 0x500000;
	__asm        jle    _T9c;
// LINE 138:
	alt = 0x500000;
// LINE 140:
_T9c:
	__asm        push   0;
	__asm        mov    eax, Viewer.pos.z;
	__asm        push   eax;
	__asm        mov    eax, Viewer.pos.x;
	__asm        push   eax;
	__asm        call   S3TerrPrecisionAlt;
	__asm        add    esp, 0xC;
	__asm        add    eax, 0xA0000;
	__asm        add    alt, eax;
// LINE 141:
	__asm        mov    eax, alt;
	__asm        sub    eax, Viewer.pos.y;
	__asm        mov    altdiff, eax;
// LINE 142:
	__asm        cmp    altdiff, 0;
	__asm        jge    _Td7;

	altdiff = 0x0;
// LINE 144:
_Td7:
	__asm        mov    eax, S_altdiff;
	__asm        mov    ecx, eax;
	__asm        shl    eax, 3;
	__asm        sub    eax, ecx;
	__asm        add    eax, altdiff;
	__asm        sar    eax, 3;
	__asm        mov    S_altdiff, eax;
// LINE 145:
	Viewer.pos.y += S_altdiff;
// LINE 148:
	__asm        jmp    _T238;
_Tfe:
	__asm        cmp    G_camera_mode, 1;
	__asm        jne    _T172;
// LINE 151:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, viewerPos.x;
	__asm        push   eax;
	__asm        push   0x5B4DD0;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 152:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        add    eax, viewerPos.x;
	__asm        mov    Viewer.pos.x, eax;
// LINE 153:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        add    eax, viewerPos.y;
	__asm        mov    Viewer.pos.y, eax;
// LINE 154:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        add    eax, viewerPos.z;
	__asm        mov    Viewer.pos.z, eax;
// LINE 156:
	__asm        jmp    _T238;
_T172:
	__asm        cmp    G_camera_mode, 2;
	__asm        jne    _T1f2;
// LINE 158:
	__asm        mov    eax, G_uheli;
	__asm        add    eax, 0x100;
	__asm        push   eax;
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   MTCreateDOF4x4;
	__asm        add    esp, 8;
// LINE 161:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, viewerPos.x;
	__asm        push   eax;
	__asm        push   0x5B4DC0;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 162:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        add    eax, viewerPos.x;
	__asm        mov    Viewer.pos.x, eax;
// LINE 163:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        add    eax, viewerPos.y;
	__asm        mov    Viewer.pos.y, eax;
// LINE 164:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        add    eax, viewerPos.z;
	__asm        mov    Viewer.pos.z, eax;
// LINE 166:
	__asm        jmp    _T238;
// LINE 169:
_T1f2:
	Viewer.pos.x = G_uheli->dyheli->loc.x;
// LINE 170:
	Viewer.pos.z = G_uheli->dyheli->loc.z;
// LINE 172:
	__asm        push   0;
	__asm        mov    eax, Viewer.pos.z;
	__asm        push   eax;
	__asm        mov    eax, Viewer.pos.x;
	__asm        push   eax;
	__asm        call   S3TerrPrecisionAlt;
	__asm        add    esp, 0xC;
	__asm        add    eax, 0x3200000;
	__asm        mov    Viewer.pos.y, eax;
// LINE 174:
_T238:
	return;
// LINE 177:
_T23d:
	__asm        mov    eax, ViewState.world_pos.x;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        sub    eax, [ecx+0x18];
	__asm        mov    viewerPos.x, eax;
// LINE 178:
	__asm        mov    eax, ViewState.world_pos.y;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        sub    eax, [ecx+0x1C];
	__asm        mov    viewerPos.y, eax;
// LINE 179:
	__asm        mov    eax, ViewState.world_pos.z;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        sub    eax, [ecx+0x20];
	__asm        mov    viewerPos.z, eax;
// LINE 181:
	__asm        cmp    viewerPos.x, 0x20000000;
	__asm        jle    _T296;
// LINE 182:
	viewerPos.x -= 0x40000000;
// LINE 183:
_T296:
	__asm        cmp    viewerPos.x, 0xE0000000;
	__asm        jge    _T2aa;
// LINE 184:
	viewerPos.x += 0x40000000;
// LINE 186:
_T2aa:
	__asm        cmp    viewerPos.z, 0x20000000;
	__asm        jle    _T2be;
// LINE 187:
	viewerPos.z -= 0x40000000;
// LINE 188:
_T2be:
	__asm        cmp    viewerPos.z, 0xE0000000;
	__asm        jge    _T2d2;
// LINE 189:
	viewerPos.z += 0x40000000;
// LINE 191:
_T2d2:
	viewerPos.x += G_uheli->dyheli->loc.x;
// LINE 192:
	viewerPos.y += G_uheli->dyheli->loc.y;
// LINE 193:
	viewerPos.z += G_uheli->dyheli->loc.z;
// LINE 195:
	__asm        mov    eax, P;
	__asm        mov    eax, [eax];
	__asm        sub    eax, viewerPos.x;
	__asm        mov    CameraVector.x, eax;
// LINE 196:
	__asm        mov    eax, P;
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, viewerPos.y;
	__asm        mov    CameraVector.y, eax;
// LINE 197:
	__asm        mov    eax, P;
	__asm        mov    eax, [eax+8];
	__asm        sub    eax, viewerPos.z;
	__asm        mov    CameraVector.z, eax;
// LINE 218:
	__asm        mov    eax, P;
	__asm        mov    ecx, 0x6C12A0;
	__asm        add    ecx, 0x78;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 219:
	__asm        lea    eax, CameraVector.x;
	__asm        lea    ecx, CameraDelta.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 237:
	__asm        mov    eax, CameraVector.y;
	__asm        add    eax, viewerPos.y;
	__asm        mov    Viewer.pos.y, eax;
// LINE 240:
	CameraVector.y = 0x0;
// LINE 243:
	__asm        lea    eax, CameraVector.x;
	__asm        push   eax;
	__asm        call   MTNormalize;
	__asm        add    esp, 4;
	__asm        mov    Velocity, eax;
// LINE 244:
	__asm        lea    eax, CameraVector.x;
	__asm        push   eax;
	__asm        call   NormalizeXZVector;
	__asm        add    esp, 4;
// LINE 246:
	__asm        cmp    Velocity, 0x50000;
	__asm        jle    _T3b4;
// LINE 248:
	__asm        xor    eax, eax;
	__asm        mov    ax, InClose;
	__asm        test   eax, eax;
	__asm        je     _T3a8;
// LINE 250:
	__asm        jmp    _T3b4;
// LINE 251:
_T3a8:
	__asm        mov    eax, Velocity;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    Velocity, eax;
// LINE 254:
_T3b4:
	__asm        mov    eax, Velocity;
	__asm        and    eax, 0xFFFFFA00;
	__asm        mov    Velocity, eax;
// LINE 255:
	Viewer.p.Vmag = Velocity;
// LINE 257:
	__asm        mov    eax, Velocity;
	__asm        push   eax;
	__asm        mov    eax, CameraVector.x;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    CameraDelta.x, eax;
// LINE 258:
	__asm        mov    eax, Velocity;
	__asm        push   eax;
	__asm        mov    eax, CameraVector.z;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    CameraDelta.z, eax;
// LINE 260:
	__asm        mov    eax, viewerPos.x;
	__asm        add    eax, CameraDelta.x;
	__asm        mov    Viewer.pos.x, eax;
// LINE 261:
	__asm        mov    eax, CameraDelta.z;
	__asm        add    eax, viewerPos.z;
	__asm        mov    Viewer.pos.z, eax;
// LINE 264:
	__asm        mov    eax, 0x6C12A0;
	__asm        add    eax, 0x78;
	__asm        push   eax;
	__asm        call   S3CameraGetBldAlt;
	__asm        add    esp, 4;
	__asm        mov    alt, eax;
// LINE 270:
	__asm        push   0;
	__asm        mov    eax, Viewer.pos.z;
	__asm        push   eax;
	__asm        mov    eax, Viewer.pos.x;
	__asm        push   eax;
	__asm        call   S3TerrPrecisionAlt;
	__asm        add    esp, 0xC;
	__asm        add    eax, 0xA0000;
	__asm        add    alt, eax;
// LINE 271:
	__asm        mov    eax, alt;
	__asm        sub    eax, Viewer.pos.y;
	__asm        mov    altdiff, eax;
// LINE 272:
	__asm        cmp    altdiff, 0;
	__asm        jge    _T452;

	altdiff = 0x0;
// LINE 274:
_T452:
	__asm        mov    eax, S_altdiff;
	__asm        mov    ecx, eax;
	__asm        shl    eax, 3;
	__asm        sub    eax, ecx;
	__asm        add    eax, altdiff;
	__asm        sar    eax, 3;
	__asm        mov    S_altdiff, eax;
// LINE 275:
	Viewer.pos.y += S_altdiff;
// LINE 276:
_T474:
}

// FUNCTION: COPTER_D 0x004f8f69
void NormalizeGridPoint(/*packed*/ struct Point3d *P) {
// LINE 284:
	__asm        mov    eax, P;
	__asm        cmp    dword ptr [eax], 0xD0000000;
	__asm        jg     _T23;
// LINE 285:
	P->x += 0x40000000;
// LINE 286:
	__asm        jmp    _T3b;
_T23:
	__asm        mov    eax, P;
	__asm        cmp    dword ptr [eax], 0x10000000;
	__asm        jl     _T3b;
// LINE 287:
	P->x -= 0x40000000;
// LINE 289:
_T3b:
	__asm        mov    eax, P;
	__asm        cmp    dword ptr [eax+8], 0xF0000000;
	__asm        jg     _T5a;
// LINE 290:
	P->z += 0x40000000;
// LINE 291:
	return;
_T5a:
	__asm        mov    eax, P;
	__asm        cmp    dword ptr [eax+8], 0x30000000;
	__asm        jl     _T74;
// LINE 292:
	P->z -= 0x40000000;
// LINE 293:
_T74:
}

// FUNCTION: COPTER_D 0x004f8fe2
void SetIdealCameraPos() {
	/*bp-0x4*/   int32_t cameraDistance;
	/*bp-0x8*/   int32_t Acceleration;
	/*bp-0xc*/   long temp;
	/*bp-0x10*/  int32_t AccelAdjust;

// LINE 308:
	AccelAdjust = 0x0;
// LINE 309:
	temp = 0x0;
// LINE 311:
	InClose = 0x0;
// LINE 318:
	__asm        cmp    G_camera_mode, 3;
	__asm        jne    _T43;
// LINE 320:
	__asm        call   GetAvatarDYOBJ;
	__asm        add    eax, 0x18;
	__asm        push   eax;
	__asm        call   NormalizeGridPoint;
	__asm        add    esp, 4;
// LINE 321:
	return;
// LINE 325:
_T43:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x18;
	__asm        push   eax;
	__asm        call   NormalizeGridPoint;
	__asm        add    esp, 4;
// LINE 328:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _T6c;
// LINE 329:
	return;
// LINE 332:
_T6c:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    eax, S_chase[0].dist[eax*4];
	__asm        neg    eax;
	__asm        mov    cameraDistance, eax;
// LINE 334:
	Acceleration = 0x0;
// LINE 336:
	__asm        cmp    Acceleration, 0;
	__asm        je     _Tbe;
// LINE 338:
	__asm        mov    eax, Acceleration;
	__asm        cdq;
	__asm        and    edx, 0x1FF;
	__asm        add    eax, edx;
	__asm        sar    eax, 9;
	__asm        mov    AccelAdjust, eax;
// LINE 339:
	__asm        cmp    Acceleration, 0;
	__asm        jge    _Tbe;
// LINE 341:
	__asm        mov    eax, AccelAdjust;
	__asm        neg    eax;
	__asm        mov    AccelAdjust, eax;
// LINE 342:
	InClose = 0x1;
// LINE 347:
_Tbe:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _Td7;
// LINE 348:
	AccelAdjust = 0x0;
// LINE 350:
_Td7:
	__asm        xor    eax, eax;
	__asm        sub    eax, AccelAdjust;
	__asm        neg    eax;
	__asm        sub    cameraDistance, eax;
// LINE 351:
	__asm        xor    ecx, ecx;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xDC];
	__asm        cdq;
	__asm        and    edx, 0x1F;
	__asm        add    eax, edx;
	__asm        sar    eax, 5;
	__asm        sub    ecx, eax;
	__asm        neg    ecx;
	__asm        sub    cameraDistance, ecx;
// LINE 354:
	__asm        mov    eax, S_ctwk_min_dist;
	__asm        neg    eax;
	__asm        cmp    eax, cameraDistance;
	__asm        jge    _T118;
// LINE 355:
	__asm        mov    eax, S_ctwk_min_dist;
	__asm        neg    eax;
	__asm        mov    cameraDistance, eax;
// LINE 358:
_T118:
	__asm        mov    eax, cameraDistance;
	__asm        push   eax;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x100];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    ecx, [ecx+0x18];
	__asm        add    ecx, eax;
	__asm        mov    CameraIdeal.x, ecx;
// LINE 359:
	__asm        mov    eax, cameraDistance;
	__asm        push   eax;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, eax;
	__asm        mov    CameraIdeal.z, ecx;
// LINE 369:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+0x1B0], 0;
	__asm        jne    _T19f;
// LINE 370:
	__asm        mov    eax, 0x11;
	__asm        mov    ecx, G_uheli;
	__asm        sub    eax, [ecx+0x1AC];
	__asm        shl    eax, 2;
	__asm        mov    temp, eax;
// LINE 372:
_T19f:
	__asm        cmp    temp, 0;
	__asm        jge    _T1b0;

	temp = 0x0;
// LINE 373:
_T1b0:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x1C];
	__asm        mov    ecx, temp;
	__asm        shl    ecx, 0x10;
	__asm        add    eax, ecx;
	__asm        mov    CameraIdeal.y, eax;
// LINE 375:
	__asm        mov    eax, G_uheli;
	__asm        cmp    dword ptr [eax+0x1B0], 1;
	__asm        jne    _T1fe;
// LINE 376:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xDC];
	__asm        cdq;
	__asm        and    edx, 3;
	__asm        add    eax, edx;
	__asm        sar    eax, 2;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    AccelAdjust, eax;
// LINE 377:
	__asm        jmp    _T21a;
// LINE 378:
_T1fe:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xDC];
	__asm        cdq;
	__asm        and    edx, 7;
	__asm        add    eax, edx;
	__asm        sar    eax, 3;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    AccelAdjust, eax;
// LINE 380:
_T21a:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, AccelAdjust;
	__asm        cmp    S_chase[0].height[eax*4], ecx;
	__asm        jle    _T24a;
// LINE 381:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    eax, S_chase[0].height[eax*4];
	__asm        sub    eax, AccelAdjust;
	__asm        add    CameraIdeal.y, eax;
// LINE 395:
_T24a:
	__asm        mov    eax, CameraIdeal.y;
	__asm        and    eax, 0xFFFFFF00;
	__asm        mov    CameraIdeal.y, eax;
// LINE 398:
_T259:
}

// FUNCTION: COPTER_D 0x004f9240
void GetIdealCameraPos(/*packed*/ struct Point3d *P) {
// LINE 404:
	__asm        mov    eax, 0x6BF1A0;
	__asm        mov    ecx, P;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 405:
}

// FUNCTION: COPTER_D 0x004f9263
void CalcCameraAngles(/*packed*/ struct Point3d *Vector) {
	/*bp-0x4*/   int32_t LengthXZ;
	/*bp-0x8*/   int32_t cosineYaw;
	/*bp-0x14*/  /*packed*/ struct Point3d WorkVector; // 0xc bytes
	/*bp-0x18*/  int32_t LengthXYZ;
	/*bp-0x1c*/  int32_t cosineRoll;
	/*bp-0x20*/  int32_t sineRoll;
	/*bp-0x24*/  int32_t sineYaw;
	/*bp-0x28*/  int32_t cosinePitch;
	/*bp-0x2c*/  int32_t sinePitch;

// LINE 434:
	WorkVector.x = Vector->x;
// LINE 435:
	WorkVector.y = 0x0;
// LINE 436:
	WorkVector.z = Vector->z;
// LINE 438:
	__asm        lea    eax, WorkVector.x;
	__asm        push   eax;
	__asm        call   MTMagnitude;
	__asm        add    esp, 4;
	__asm        mov    LengthXZ, eax;
// LINE 439:
	__asm        cmp    LengthXZ, 0;
	__asm        jne    _T66;
// LINE 441:
	__asm        mov    eax, Vector;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jl     _T53;
// LINE 442:
	sineYaw = 0x10000;
// LINE 443:
	__asm        jmp    _T5a;
// LINE 444:
_T53:
	sineYaw = 0xffff0000;
// LINE 445:
_T5a:
	cosineYaw = 0x0;
// LINE 447:
	__asm        jmp    _T8c;
// LINE 449:
_T66:
	__asm        mov    eax, LengthXZ;
	__asm        push   eax;
	__asm        mov    eax, WorkVector.z;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    cosineYaw, eax;
// LINE 450:
	__asm        mov    eax, LengthXZ;
	__asm        push   eax;
	__asm        mov    eax, WorkVector.x;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    sineYaw, eax;
// LINE 461:
_T8c:
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D20B1;
	__asm        add    esp, 8;
	__asm        mov    cameraHeading, eax;
// LINE 465:
	WorkVector.y = Vector->y;
// LINE 466:
	__asm        lea    eax, WorkVector.x;
	__asm        push   eax;
	__asm        call   MTMagnitude;
	__asm        add    esp, 4;
	__asm        mov    LengthXYZ, eax;
// LINE 468:
	__asm        cmp    LengthXYZ, 0;
	__asm        jne    _Tee;
// LINE 470:
	__asm        mov    eax, Vector;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jle    _Tdb;
// LINE 471:
	sinePitch = 0xffff0000;
// LINE 472:
	__asm        jmp    _Te2;
// LINE 473:
_Tdb:
	sinePitch = 0x10000;
// LINE 474:
_Te2:
	cosinePitch = 0x0;
// LINE 476:
	__asm        jmp    _T116;
// LINE 478:
_Tee:
	__asm        mov    eax, LengthXYZ;
	__asm        push   eax;
	__asm        mov    eax, WorkVector.y;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        mov    sinePitch, eax;
// LINE 479:
	__asm        mov    eax, LengthXYZ;
	__asm        push   eax;
	__asm        mov    eax, LengthXZ;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    cosinePitch, eax;
// LINE 481:
_T116:
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D20B1;
	__asm        add    esp, 8;
	__asm        mov    cameraPitch, eax;
// LINE 485:
	cosineRoll = 0x10000;
// LINE 486:
	sineRoll = 0x0;
// LINE 490:
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    Viewer.matrix[0][0], ebx;
// LINE 491:
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    Viewer.matrix[0][1], eax;
// LINE 493:
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        add    ebx, eax;
	__asm        mov    Viewer.matrix[0][2], ebx;
// LINE 494:
	Viewer.matrix[0][3] = 0x0;
// LINE 497:
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        add    ebx, eax;
	__asm        mov    Viewer.matrix[1][0], ebx;
// LINE 498:
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    Viewer.matrix[1][1], eax;
// LINE 500:
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    Viewer.matrix[1][2], ebx;
// LINE 501:
	Viewer.matrix[1][3] = 0x0;
// LINE 503:
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    Viewer.matrix[2][0], eax;
// LINE 504:
	__asm        mov    eax, sinePitch;
	__asm        neg    eax;
	__asm        mov    Viewer.matrix[2][1], eax;
// LINE 505:
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    Viewer.matrix[2][2], eax;
// LINE 506:
	Viewer.matrix[2][3] = 0x0;
// LINE 510:
	__asm        mov    Viewer.matrix[3][2], 0;
	__asm        mov    eax, Viewer.matrix[3][2];
	__asm        mov    Viewer.matrix[3][1], eax;
	__asm        mov    eax, Viewer.matrix[3][1];
	__asm        mov    Viewer.matrix[3][0], eax;
// LINE 511:
	Viewer.matrix[3][3] = 0x10000;
// LINE 515:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _T2d7;

	__asm        cmp    G_camera_mode, 1;
	__asm        jne    _T2f7;
// LINE 517:
_T2d7:
	__asm        mov    eax, 0x6C12A0;
	__asm        add    eax, 0x38;
	__asm        push   eax;
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0x114];
	__asm        sar    eax, 1;
	__asm        push   eax;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 520:
_T2f7:
}

// FUNCTION: COPTER_D 0x004f955f
void S3AngleRotMat(int32_t *matrix[4], int32_t Yaw, int32_t Pitch, int32_t Roll) {
	/*bp-0x4*/   int32_t cosineYaw;
	/*bp-0x8*/   int32_t cosineRoll;
	/*bp-0xc*/   int32_t sineRoll;
	/*bp-0x10*/  int32_t sineYaw;
	/*bp-0x14*/  int32_t cosinePitch;
	/*bp-0x18*/  int32_t sinePitch;

// LINE 533:
	__asm        lea    eax, cosineYaw;
	__asm        push   eax;
	__asm        lea    eax, sineYaw;
	__asm        push   eax;
	__asm        mov    eax, Yaw;
	__asm        push   eax;
	__asm        call   0x004D19FC;
	__asm        add    esp, 0xC;
// LINE 534:
	__asm        lea    eax, cosinePitch;
	__asm        push   eax;
	__asm        lea    eax, sinePitch;
	__asm        push   eax;
	__asm        mov    eax, Pitch;
	__asm        push   eax;
	__asm        call   0x004D19FC;
	__asm        add    esp, 0xC;
// LINE 535:
	__asm        lea    eax, cosineRoll;
	__asm        push   eax;
	__asm        lea    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, Roll;
	__asm        push   eax;
	__asm        call   0x004D19FC;
	__asm        add    esp, 0xC;
// LINE 538:
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    eax, matrix;
	__asm        mov    [eax], ebx;
// LINE 539:
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, matrix;
	__asm        mov    [ecx+4], eax;
// LINE 541:
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        add    ebx, eax;
	__asm        mov    eax, matrix;
	__asm        mov    [eax+8], ebx;
// LINE 542:
	matrix[3] = 0x0;
// LINE 545:
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        add    ebx, eax;
	__asm        mov    eax, matrix;
	__asm        mov    [eax+0x10], ebx;
// LINE 546:
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, matrix;
	__asm        mov    [ecx+0x14], eax;
// LINE 548:
	__asm        mov    eax, cosineRoll;
	__asm        push   eax;
	__asm        mov    eax, sinePitch;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, sineRoll;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    eax, matrix;
	__asm        mov    [eax+0x18], ebx;
// LINE 549:
	matrix[7] = 0x0;
// LINE 551:
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        mov    eax, sineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, matrix;
	__asm        mov    [ecx+0x20], eax;
// LINE 552:
	__asm        mov    eax, sinePitch;
	__asm        neg    eax;
	__asm        mov    ecx, matrix;
	__asm        mov    [ecx+0x24], eax;
// LINE 553:
	__asm        mov    eax, cosinePitch;
	__asm        push   eax;
	__asm        mov    eax, cosineYaw;
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, matrix;
	__asm        mov    [ecx+0x28], eax;
// LINE 554:
	matrix[11] = 0x0;
// LINE 558:
	__asm        mov    eax, matrix;
	__asm        mov    dword ptr [eax+0x38], 0;
	__asm        mov    eax, matrix;
	__asm        mov    eax, [eax+0x38];
	__asm        mov    ecx, matrix;
	__asm        mov    [ecx+0x34], eax;
	__asm        mov    eax, matrix;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    ecx, matrix;
	__asm        mov    [ecx+0x30], eax;
// LINE 559:
	matrix[15] = 0x10000;
// LINE 561:
}

// FUNCTION: COPTER_D 0x004f9735
void S3CameraRotate() {
	/*bp-0xc*/   /*packed*/ struct Point3d cameraDelta; // 0xc bytes
	/*bp-0x10*/  int32_t temp;
	/*bp-0x14*/  int32_t alt;

// LINE 606:
	__asm        cmp    G_camera_mode, 3;
	__asm        jne    _T5c;
// LINE 608:
// Block start:
	/*bp-0x18*/  /*packed*/ struct _DYOBJ_INST *dyobj;
	__asm        call   GetAvatarDYOBJ;
	__asm        mov    dyobj, eax;
// LINE 613:
	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x18];
	__asm        sub    eax, Viewer.pos.x;
	__asm        mov    cameraDelta.x, eax;
// LINE 614:
	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x20];
	__asm        sub    eax, Viewer.pos.z;
	__asm        mov    cameraDelta.z, eax;
// LINE 615:
	__asm        mov    eax, dyobj;
	__asm        mov    eax, [eax+0x1C];
	__asm        sub    eax, Viewer.pos.y;
	__asm        mov    cameraDelta.y, eax;
// LINE 634:
	__asm        lea    eax, cameraDelta.x;
	__asm        push   eax;
	__asm        call   CalcCameraAngles;
	__asm        add    esp, 4;
// LINE 636:
// Block end:
	return;
_T5c:
	__asm        cmp    G_camera_mode, 2;
	__asm        jne    _Td6;
// LINE 639:
	__asm        cmp    G_camera_targ2firey, 0;
	__asm        je     _T83;

	__asm        mov    eax, G_camera_targ2objy;
	__asm        mov    alt, eax;
	__asm        jmp    _T8b;
_T83:
	alt = G_camera_targ2objy;
// LINE 640:
_T8b:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        sub    eax, Viewer.pos.x;
	__asm        mov    cameraDelta.x, eax;
// LINE 641:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        sub    eax, Viewer.pos.z;
	__asm        mov    cameraDelta.z, eax;
// LINE 642:
	__asm        mov    eax, alt;
	__asm        sub    eax, Viewer.pos.y;
	__asm        mov    cameraDelta.y, eax;
// LINE 654:
	__asm        lea    eax, cameraDelta.x;
	__asm        push   eax;
	__asm        call   CalcCameraAngles;
	__asm        add    esp, 4;
// LINE 656:
	return;
_Td6:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _T114;
// LINE 658:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        lea    eax, cameraDelta.x;
	__asm        push   eax;
	__asm        push   0x59B518;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 671:
	__asm        lea    eax, cameraDelta.x;
	__asm        push   eax;
	__asm        call   CalcCameraAngles;
	__asm        add    esp, 4;
// LINE 673:
	return;
// LINE 676:
_T114:
	__asm        mov    eax, 0x11;
	__asm        mov    ecx, G_uheli;
	__asm        sub    eax, [ecx+0x1AC];
	__asm        mov    temp, eax;
// LINE 677:
	__asm        cmp    temp, 0;
	__asm        jge    _T139;

	temp = 0x0;
// LINE 678:
_T139:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x18];
	__asm        sub    eax, Viewer.pos.x;
	__asm        mov    cameraDelta.x, eax;
// LINE 679:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    eax, S_chase[0].focus[eax*4];
	__asm        mov    ecx, G_uheli;
	__asm        mov    ecx, [ecx+0xA4];
	__asm        add    eax, [ecx+0x1C];
	__asm        mov    ecx, temp;
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        sub    eax, Viewer.pos.y;
	__asm        mov    cameraDelta.y, eax;
// LINE 680:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax+0xA4];
	__asm        mov    eax, [eax+0x20];
	__asm        sub    eax, Viewer.pos.z;
	__asm        mov    cameraDelta.z, eax;
// LINE 693:
	__asm        lea    eax, cameraDelta.x;
	__asm        push   eax;
	__asm        call   CalcCameraAngles;
	__asm        add    esp, 4;
// LINE 699:
_T1a2:
}

// FUNCTION: COPTER_D 0x004f98dc
void S3CameraTweakInit() {
	/*bp-0x28*/  int32_t * pvals[10]; // 0x28 bytes

// LINE 726:
	pvals[0] = 0x5b4df4;
// LINE 727:
	pvals[1] = 0x5b4df0;
// LINE 728:
	pvals[2] = 0x5b4df8;
// LINE 730:
	__asm        push   0x5B4E04;
	__asm        push   3;
	__asm        lea    eax, pvals[0];
	__asm        push   eax;
	__asm        call   TWKEnQueue;
	__asm        add    esp, 0xC;
// LINE 732:
}

// FUNCTION: COPTER_D 0x004f9912
void S3CameraChaseAdjust(int32_t camevent) {
// LINE 743:
	__asm        mov    eax, camevent;
	__asm        mov    [ebp-4], eax;
	__asm        jmp    _T107;
// LINE 746:
_T14:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        sub    S_chase[0].dist[eax*4], 0x40000;
// LINE 747:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, S_ctwk_min_dist;
	__asm        cmp    S_chase[0].dist[eax*4], ecx;
	__asm        jge    _T57;
// LINE 748:
	__asm        mov    eax, S_ctwk_min_dist;
	__asm        mov    ecx, S_curr_chase;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    S_chase[0].dist[ecx*4], eax;
// LINE 749:
_T57:
	return;
// LINE 751:
_T5c:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        add    S_chase[0].dist[eax*4], 0x40000;
// LINE 752:
	return;
// LINE 754:
_T74:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        add    S_chase[0].height[eax*4], 0x40000;
// LINE 755:
	return;
// LINE 757:
_T8c:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        sub    S_chase[0].height[eax*4], 0x40000;
// LINE 759:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        cmp    S_chase[0].height[eax*4], 0;
	__asm        jge    _Tc8;
// LINE 760:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    S_chase[0].height[eax*4], 0;
// LINE 761:
_Tc8:
	return;
// LINE 763:
_Tcd:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        sub    S_chase[0].focus[eax*4], 0x40000;
// LINE 764:
	return;
// LINE 766:
_Te5:
	__asm        mov    eax, S_curr_chase;
	__asm        lea    eax, [eax+eax*2];
	__asm        add    S_chase[0].focus[eax*4], 0x40000;
// LINE 767:
	return;
// LINE 770:
	return;
// LINE 771:
	return;
_T107:
	__asm        sub    dword ptr [ebp-4], 0x1B;
	__asm        cmp    dword ptr [ebp-4], 5;
	__asm        ja     _T137;

	__asm        mov    eax, [ebp-4];
	__asm        jmp    _Switch_11f[0][eax*4];
// Switch pointers:
//   _T14
//   _T5c
//   _T74
//   _T8c
//   _Te5
//   _Tcd
// LINE 772:
_T137:
}

// FUNCTION: COPTER_D 0x004f9a4e
void S3CameraCycleChase() {
// LINE 782:
	S_curr_chase++;
// LINE 783:
	__asm        cmp    S_curr_chase, 3;
	__asm        jl     _T23;
// LINE 784:
	S_curr_chase = 0x0;
// LINE 785:
_T23:
}

// FUNCTION: COPTER_D 0x004f9a76
/*packed*/ struct _CHASE_INFO* S3CameraGetChaseInfo() {
// LINE 795:
	__asm        mov    eax, 0x6BF160;
	__asm        jmp    _T10;
// LINE 796:
_T10:
}

// FUNCTION: COPTER_D 0x004f9a8b
void S3CameraSetChaseInfo(/*packed*/ struct _CHASE_INFO *cinfo) {
// LINE 806:
	__asm        mov    edi, 0x6BF160;
	__asm        mov    esi, cinfo;
	__asm        mov    ecx, 9;
	__asm        rep movsd;
// LINE 807:
}

// FUNCTION: COPTER_D 0x004f9aa5
int32_t S3CameraGetBldAlt(/*packed*/ struct Point3d *loc) {
	/*bp-0x4*/   int32_t flags;
	/*bp-0x8*/   int32_t normz;
	/*bp-0xc*/   int32_t maxobjy;
	/*bp-0x10*/  /*packed*/ struct _STOBJ_INST *stobj;
	/*bp-0x14*/  int32_t x;
	/*bp-0x18*/  int32_t y;
	/*bp-0x1c*/  int32_t objy;
	/*bp-0x20*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x24*/  int32_t normx;
	/*bp-0x28*/  int32_t normy;

// LINE 825:
	__asm        mov    eax, loc;
	__asm        mov    eax, [eax];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    x, eax;
// LINE 826:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, loc;
	__asm        sub    eax, [ecx+8];
	__asm        sar    eax, 0x16;
	__asm        mov    y, eax;
// LINE 828:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    cptr, eax;
// LINE 830:
	__asm        mov    eax, loc;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+2];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normx, eax;
// LINE 831:
	__asm        mov    eax, loc;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+6];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normz, eax;
// LINE 832:
	__asm        mov    eax, loc;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, cptr;
	__asm        movsx  ecx, word ptr [ecx+4];
	__asm        shl    ecx, 0x10;
	__asm        sub    eax, ecx;
	__asm        mov    normy, eax;
// LINE 834:
	objy = 0x0;
// LINE 835:
	maxobjy = 0x0;
// LINE 836:
	stobj = cptr->stptr;
// LINE 837:
_T9d:
	__asm        cmp    stobj, 0;
	__asm        je     _Tff;
// LINE 839:
	flags = stobj->user1;
// LINE 845:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x10000;
	__asm        push   0x10000;
	__asm        lea    eax, flags;
	__asm        push   eax;
	__asm        mov    eax, normz;
	__asm        push   eax;
	__asm        mov    eax, normy;
	__asm        push   eax;
	__asm        mov    eax, normx;
	__asm        push   eax;
	__asm        mov    eax, stobj;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   VRGetObjAlt2;
	__asm        add    esp, 0x24;
	__asm        mov    objy, eax;
// LINE 846:
	__asm        mov    eax, objy;
	__asm        cmp    maxobjy, eax;
	__asm        jge    _Tf2;
// LINE 848:
	maxobjy = objy;
// LINE 850:
_Tf2:
	stobj = stobj->next;
// LINE 851:
	__asm        jmp    _T9d;
// LINE 853:
_Tff:
	__asm        mov    eax, maxobjy;
	__asm        jmp    _T107;
// LINE 854:
_T107:
}



// Contribution: 3:0001ddb8-0001de10 Module: 175, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b4db8
long G_camera_mode = 3;

// GLOBAL: COPTER_D 0x005b4dc0
/*packed*/ struct Point3d S_camera_targpos2 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b4dd0
/*packed*/ struct Point3d S_camera_targpos1 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b4de0
/*packed*/ struct Point3d S_camera_targpos3 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005b4dec
unsigned short InClose = 0;

// GLOBAL: COPTER_D 0x005b4df0
int32_t S_ctwk_min_dist = 2097152;

// GLOBAL: COPTER_D 0x005b4df4
int32_t S_ctwk_max_dist = 4718592;

// GLOBAL: COPTER_D 0x005b4df8
int32_t S_ctwk_height = 3145728;

// GLOBAL: COPTER_D 0x005b4dfc
long S_curr_chase = 0;

// GLOBAL: COPTER_D 0x005b4e00
int32_t S_altdiff = 0;



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.
// GLOBAL: COPTER_D 0x006bf1a0
/*packed*/ struct Point3d CameraIdeal; // Contrib missing

// GLOBAL: COPTER_D 0x006bf194
int32_t G_camera_targ2objy; // Contrib missing

// GLOBAL: COPTER_D 0x006bf190
int32_t G_camera_targ2firey; // Contrib missing

// GLOBAL: COPTER_D 0x006bf160
/*packed*/ struct _CHASE_INFO S_chase[3]; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\game\S3heli.c
// GLOBAL: COPTER_D 0x006bf194
int32_t G_camera_targ2objy; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\game\S3heli.c
// GLOBAL: COPTER_D 0x006bf190
int32_t G_camera_targ2firey; // Contrib missing

// GLOBAL: COPTER_D 0x006bf1a0
/*packed*/ struct Point3d CameraIdeal; // Contrib missing

// GLOBAL: COPTER_D 0x006bf160
/*packed*/ struct _CHASE_INFO S_chase[3]; // Contrib missing

