// Module: S3boat.obj
// Source: C:\Copter\Source\Game\S3boat.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class BoatClass (forward reference);
// VTABLE: COPTER_D 0x00593200
class BoatClass{ // packed(0xe3 bytes) TI: 0x42b3
	enum /* __unnamed */ {
		BOAT_TYPES = 1,
		PERCENTAGE_OF_BOAT1 = 100,
		TOTAL_PERCENTAGE = 100,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		END_OF_WATER = 4,
		INTERSECTION_FULL = 5,
	};
	enum WaterTileOffsets {
		WT_CENTOFF = 0,
		WT_EDGEOFF = 0,
	};
	enum /* __unnamed */ {
		COLLISION_SPACE = 655360,
		SPRAY_TIME = 58982,
		WATER_SPEED = 917504,
		WATER_SLOWDOWN_FACTOR = 131072,
		SPEED_VARIANCE = 262144,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 655360,
	};
	enum flagEnums {
		INITIALIZED = 0,
		PLACED = 1,
		TURNING = 2,
		IN_INTERSECTION = 3,
		MAKING_UTURN = 4,
		AT_DEAD_END = 5,
		PERSON_ON_BOARD = 6,
		NUMBER_OF_FLAGS = 7,
	};
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	/*+0x4*/   char flags[7]; // 0x7 bytes
	/*+0xb*/   int32_t sprayTimer;
	/*+0xf*/   enum DirectionTypes direction;
	/*+0x13*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0x1f*/  int32_t remainingDist;
	/*+0x23*/  int32_t remainingTime;
	/*+0x27*/  enum DirectionTypes utdirection;
	/*+0x2b*/  int32_t speed;
	/*+0x2f*/  int32_t desiredSpeed;
	/*+0x33*/  /*packed*/ struct Point2d currentLocation; // 0x8 bytes
	/*+0x3b*/  /*packed*/ struct Point2d currentCell; // 0x8 bytes
	/*+0x43*/  /*packed*/ struct Point2d nextLocation; // 0x8 bytes
	/*+0x4b*/  int32_t beamDelay;
	/*+0x4f*/  int32_t beamTimer;
	/*+0x53*/  long missionId;
	/*+0x57*/  int32_t timeToLive;
	/*+0x5b*/  /*packed*/ struct Point2d northCell; // 0x8 bytes
	/*+0x63*/  /*packed*/ struct Point2d southCell; // 0x8 bytes
	/*+0x6b*/  /*packed*/ struct Point2d eastCell; // 0x8 bytes
	/*+0x73*/  /*packed*/ struct Point2d westCell; // 0x8 bytes
protected:
	/*+0x7b*/  long boatModel;
	/*+0x7f*/  /*packed*/ struct _DYOBJ_INST dyObj; // 0x64 bytes
public:
	void BoatClass(const /*packed*/ class BoatClass&);
	void BoatClass(long, long, int32_t);
	void BoatClass();
	virtual void ~BoatClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class BoatClass* CreateInstance(long, long, int32_t);
	// calltype: NearC
	static /*packed*/ class BoatClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class BoatClass* GetBoatPointer(long);
	static /*packed*/ class BoatClass lsBoat;
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* StartCapsizedBoat(long, int32_t);
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* GetCapsizedBoat();
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
protected:
	int32_t IsBoatInitialized();
	int32_t IsBoatPlaced();
	int32_t IsBoatAtDeadEnd();
	int32_t IsPersonOnBoard();
	int32_t IsBoatTurning();
	int32_t IsBoatInIntersection();
	int32_t IsBoatMakingUturn();
	int32_t IsBoatMoving();
	long GetBoatModel();
	const const /*packed*/ struct _DYOBJ_INST* GetBoatDyObj();
	enum DirectionTypes GetDirection();
	int32_t AmIMovingNorth();
	int32_t AmIMovingSouth();
	int32_t AmIMovingEast();
	int32_t AmIMovingWest();
	const /*packed*/ struct Point3d& GetDirectionVector();
	int32_t GetSpeed();
	int32_t GetDesiredSpeed();
	const /*packed*/ struct Point2d& GetCurrentLocation();
	const /*packed*/ struct Point2d& GetNextLocation();
	void SetCurrentLocation(/*packed*/ struct Point2d&);
	int32_t CanBoatBePlacedOnTile(unsigned short);
	void SetSpeed(int32_t);
	int32_t Initialize(int32_t);
	void Reset();
	void Itterate();
	virtual void ItterateFSM(); // vtable+0x4
	virtual void AdjustSpeed(); // vtable+0x8
	virtual enum BoatClass::StoppedReasons IsWaterPathClear(); // vtable+0xc
	enum BoatClass::StoppedReasons CheckWaterDynamicObjectsAt(const /*packed*/ struct Point2d&, const /*packed*/ struct Point3d&);
	int32_t IsBoatOutOfCameraRange();
	void SetBoatDirection(unsigned short);
	int32_t CheckForStop(short, short);
	int32_t FinishedUturn();
	void SlowDown();
	void Stop();
	void MoveForward();
	int32_t HaveIReachedNextLoc();
	int32_t AmIInANewCell();
	int32_t IsAnythingThere(const /*packed*/ struct Point2d&, /*packed*/ struct mv);
	void UnlinkFromCell(const /*packed*/ struct Point2d&);
	void LinkToCell(const /*packed*/ struct Point2d&);
	int32_t IsLocationAnIntersection(/*packed*/ struct Point2d&);
	virtual enum BoatClass::IntersectionTypes PickTurnDirection(const /*packed*/ struct Point2d&); // vtable+0x10
	int32_t DoWaterTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void MakeATurn(enum BoatClass::IntersectionTypes);
	void GetNewPredictedLocation();
	void AdjustCurrentPosition();
	void AdjustNextPosition();
	enum BoatClass::StoppedReasons WhyAmIStopped();
	void GoStraight();
	void MakeUturn();
	void TurnLeft();
	void TurnRight();
	void UnPlaceBoat();
	// calltype: NearC
	static void InitArrays();
	// calltype: NearC
	static void SetBoatTypesAndLocations();
	// calltype: NearC
	static void PlaceInitialBoats();
	virtual void BeamBoatToWithinCameraRange(); // vtable+0x14
	virtual int32_t BeamBoatToLocation(long, long); // vtable+0x18
private:
	int32_t InitializeInstance(long, long, int32_t);
public:
	/*packed*/ class BoatClass operator=(const /*packed*/ class BoatClass&);
};

// Type: void ();

// Type: /*packed*/ struct Point2d;
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ class BoatClass;
// VTABLE: COPTER_D 0x00593200
class BoatClass{ // packed(0xe3 bytes) TI: 0x42b3
	enum /* __unnamed */ {
		BOAT_TYPES = 1,
		PERCENTAGE_OF_BOAT1 = 100,
		TOTAL_PERCENTAGE = 100,
	};
	enum /* __unnamed */ {
		NO_X_POSITION = -1,
		STARTING_X = 3,
		ENDING_X = 125,
		NO_Y_POSITION = -1,
		STARTING_Y = 3,
		ENDING_Y = 125,
	};
	enum IntersectionTypes {
		DEAD_END = 0,
		STRAIGHT_AHEAD = 1,
		LEFT_ONLY = 2,
		RIGHT_ONLY = 4,
		LEFT_OR_STRAIGHT = 3,
		LEFT_OR_RIGHT = 6,
		RIGHT_OR_STRAIGHT = 5,
		LEFT_STRAIGHT_OR_RIGHT = 7,
	};
	enum StoppedReasons {
		NO_REASON = 0,
		TRAFFIC = 1,
		STOPPED_TRAFFIC = 2,
		PERSON_IN_WAY = 3,
		END_OF_WATER = 4,
		INTERSECTION_FULL = 5,
	};
	enum WaterTileOffsets {
		WT_CENTOFF = 0,
		WT_EDGEOFF = 0,
	};
	enum /* __unnamed */ {
		COLLISION_SPACE = 655360,
		SPRAY_TIME = 58982,
		WATER_SPEED = 917504,
		WATER_SLOWDOWN_FACTOR = 131072,
		SPEED_VARIANCE = 262144,
		MAX_TIME_TO_WAIT_FOR_TRAFFIC = 1310720,
		MAX_TIME_TO_WAIT_PULLED_OVER = 196608,
		MAX_TIME_TO_WAIT_BEFORE_BEAMING = 655360,
	};
	enum flagEnums {
		INITIALIZED = 0,
		PLACED = 1,
		TURNING = 2,
		IN_INTERSECTION = 3,
		MAKING_UTURN = 4,
		AT_DEAD_END = 5,
		PERSON_ON_BOARD = 6,
		NUMBER_OF_FLAGS = 7,
	};
private:
	static /*packed*/ struct Point2d lastScannedLocation;
	/*+0x4*/   char flags[7]; // 0x7 bytes
	/*+0xb*/   int32_t sprayTimer;
	/*+0xf*/   enum DirectionTypes direction;
	/*+0x13*/  /*packed*/ struct Point3d directionVector; // 0xc bytes
	/*+0x1f*/  int32_t remainingDist;
	/*+0x23*/  int32_t remainingTime;
	/*+0x27*/  enum DirectionTypes utdirection;
	/*+0x2b*/  int32_t speed;
	/*+0x2f*/  int32_t desiredSpeed;
	/*+0x33*/  /*packed*/ struct Point2d currentLocation; // 0x8 bytes
	/*+0x3b*/  /*packed*/ struct Point2d currentCell; // 0x8 bytes
	/*+0x43*/  /*packed*/ struct Point2d nextLocation; // 0x8 bytes
	/*+0x4b*/  int32_t beamDelay;
	/*+0x4f*/  int32_t beamTimer;
	/*+0x53*/  long missionId;
	/*+0x57*/  int32_t timeToLive;
	/*+0x5b*/  /*packed*/ struct Point2d northCell; // 0x8 bytes
	/*+0x63*/  /*packed*/ struct Point2d southCell; // 0x8 bytes
	/*+0x6b*/  /*packed*/ struct Point2d eastCell; // 0x8 bytes
	/*+0x73*/  /*packed*/ struct Point2d westCell; // 0x8 bytes
protected:
	/*+0x7b*/  long boatModel;
	/*+0x7f*/  /*packed*/ struct _DYOBJ_INST dyObj; // 0x64 bytes
public:
	void BoatClass(const /*packed*/ class BoatClass&);
	void BoatClass(long, long, int32_t);
	void BoatClass();
	virtual void ~BoatClass(); // vtable+0x0
	// calltype: NearC
	static /*packed*/ class BoatClass* CreateInstance(long, long, int32_t);
	// calltype: NearC
	static /*packed*/ class BoatClass* CreateInstance(int32_t);
	// calltype: NearC
	static /*packed*/ class BoatClass* GetBoatPointer(long);
	static /*packed*/ class BoatClass lsBoat;
	// calltype: NearC
	static void ItterateAll();
	// calltype: NearC
	static void ResetAll();
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* StartCapsizedBoat(long, int32_t);
	// calltype: NearC
	static /*packed*/ struct _DYOBJ_INST* GetCapsizedBoat();
	// calltype: NearC
	static int32_t MIFFLoad(void * __ptr32);
	// calltype: NearC
	static int32_t MIFFSave(void * __ptr32);
protected:
	int32_t IsBoatInitialized();
	int32_t IsBoatPlaced();
	int32_t IsBoatAtDeadEnd();
	int32_t IsPersonOnBoard();
	int32_t IsBoatTurning();
	int32_t IsBoatInIntersection();
	int32_t IsBoatMakingUturn();
	int32_t IsBoatMoving();
	long GetBoatModel();
	const const /*packed*/ struct _DYOBJ_INST* GetBoatDyObj();
	enum DirectionTypes GetDirection();
	int32_t AmIMovingNorth();
	int32_t AmIMovingSouth();
	int32_t AmIMovingEast();
	int32_t AmIMovingWest();
	const /*packed*/ struct Point3d& GetDirectionVector();
	int32_t GetSpeed();
	int32_t GetDesiredSpeed();
	const /*packed*/ struct Point2d& GetCurrentLocation();
	const /*packed*/ struct Point2d& GetNextLocation();
	void SetCurrentLocation(/*packed*/ struct Point2d&);
	int32_t CanBoatBePlacedOnTile(unsigned short);
	void SetSpeed(int32_t);
	int32_t Initialize(int32_t);
	void Reset();
	void Itterate();
	virtual void ItterateFSM(); // vtable+0x4
	virtual void AdjustSpeed(); // vtable+0x8
	virtual enum BoatClass::StoppedReasons IsWaterPathClear(); // vtable+0xc
	enum BoatClass::StoppedReasons CheckWaterDynamicObjectsAt(const /*packed*/ struct Point2d&, const /*packed*/ struct Point3d&);
	int32_t IsBoatOutOfCameraRange();
	void SetBoatDirection(unsigned short);
	int32_t CheckForStop(short, short);
	int32_t FinishedUturn();
	void SlowDown();
	void Stop();
	void MoveForward();
	int32_t HaveIReachedNextLoc();
	int32_t AmIInANewCell();
	int32_t IsAnythingThere(const /*packed*/ struct Point2d&, /*packed*/ struct mv);
	void UnlinkFromCell(const /*packed*/ struct Point2d&);
	void LinkToCell(const /*packed*/ struct Point2d&);
	int32_t IsLocationAnIntersection(/*packed*/ struct Point2d&);
	virtual enum BoatClass::IntersectionTypes PickTurnDirection(const /*packed*/ struct Point2d&); // vtable+0x10
	int32_t DoWaterTilesConnect(unsigned short, unsigned short, enum DirectionTypes);
	void MakeATurn(enum BoatClass::IntersectionTypes);
	void GetNewPredictedLocation();
	void AdjustCurrentPosition();
	void AdjustNextPosition();
	enum BoatClass::StoppedReasons WhyAmIStopped();
	void GoStraight();
	void MakeUturn();
	void TurnLeft();
	void TurnRight();
	void UnPlaceBoat();
	// calltype: NearC
	static void InitArrays();
	// calltype: NearC
	static void SetBoatTypesAndLocations();
	// calltype: NearC
	static void PlaceInitialBoats();
	virtual void BeamBoatToWithinCameraRange(); // vtable+0x14
	virtual int32_t BeamBoatToLocation(long, long); // vtable+0x18
private:
	int32_t InitializeInstance(long, long, int32_t);
public:
	/*packed*/ class BoatClass operator=(const /*packed*/ class BoatClass&);
};

// Type: void;

// Type: long;

// Type: int32_t;

// Type: /*packed*/ struct VRview;
struct VRview{ // packed(0x58 bytes) TI: 0x2ecc
	/*+0x0*/   /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0xc*/   /*packed*/ struct Point3d scale; // 0xc bytes
	/*+0x18*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	/*+0x0*/   short flags; // 0x2 bytes
	/*+0x2*/   short x; // 0x2 bytes
	/*+0x4*/   short y; // 0x2 bytes
	/*+0x6*/   short z; // 0x2 bytes
	/*+0x8*/   short size; // 0x2 bytes
	/*+0xa*/   short ctr; // 0x2 bytes
	/*+0xc*/   /*packed*/ struct _STOBJ_INST *stptr;
	/*+0x10*/  /*packed*/ struct _DYOBJ_INST *dyptr;
	/*+0x14*/  /*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: enum BoatClass::StoppedReasons;
enum StoppedReasons {
	NO_REASON = 0,
	TRAFFIC = 1,
	STOPPED_TRAFFIC = 2,
	PERSON_IN_WAY = 3,
	END_OF_WATER = 4,
	INTERSECTION_FULL = 5,
};

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: unsigned short;

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*+0x0*/   /*packed*/ struct _DYOBJ_INST *next;
	/*+0x4*/   /*packed*/ struct _DYOBJ_INST *vnext;
	/*+0x8*/   void * __ptr32 mesh;
	/*+0xc*/   short flags; // 0x2 bytes
	/*+0xe*/   short user1; // 0x2 bytes
	/*+0x10*/  long radius;
	/*+0x14*/  long height;
	/*+0x18*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*+0x24*/  int32_t matrix[4][4]; // 0x40 bytes
};

// Type: enum DirectionTypes;
enum DirectionTypes {
	NO_DIRECTION = 0,
	NORTH = 1,
	SOUTH = 2,
	EAST = 4,
	WEST = 8,
	RISING_NORTH = 16,
	RISING_SOUTH = 32,
	RISING_EAST = 64,
	RISING_WEST = 128,
	NORTH_EAST = 5,
	SOUTH_EAST = 6,
	SOUTH_WEST = 10,
	NORTH_WEST = 9,
};

// Type: enum BoatClass::IntersectionTypes;
enum IntersectionTypes {
	DEAD_END = 0,
	STRAIGHT_AHEAD = 1,
	LEFT_ONLY = 2,
	RIGHT_ONLY = 4,
	LEFT_OR_STRAIGHT = 3,
	LEFT_OR_RIGHT = 6,
	RIGHT_OR_STRAIGHT = 5,
	LEFT_STRAIGHT_OR_RIGHT = 7,
};

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: char *;

// Type: /*packed*/ struct _MISSION_PARMS;
struct _MISSION_PARMS{ // packed(0x18 bytes) TI: 0x307d
	/*+0x0*/   long op;
	/*+0x4*/   long id;
	/*+0x8*/   /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x10*/  long i2num;
	/*+0x14*/  long flags;
};

// Type: void * __ptr32;

// Type: uint32_t;



// Contribution: 1:00126470-0012a074 Module: 164, 16 byte alignment, code, execute, read, 
// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x00527470
static void $E7() {

	__asm        call   $E3;
	__asm        call   $E6;
	__asm        jmp    __RETURN;
__RETURN:
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x0052748a
static void $E3() {

	__asm        mov    BoatClass::lsBoat<vftable>, 0x593200;
	__asm        jmp    _T15;
_T15:
	return;
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x005274a9
static void $E6() {

	__asm        push   0x5274C6;
	__asm        call   atexit;
	__asm        add    esp, 4;
	__asm        jmp    __RETURN;
__RETURN:
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x005274c6
static void $E4() {

	__asm        xor    eax, eax;
	__asm        mov    al, ds:[0x62B6E4];
	__asm        test   al, 1;
	__asm        jne    _T2d;

	__asm        xor    eax, eax;
	__asm        mov    al, ds:[0x62B6E4];
	__asm        or     al, 1;
	__asm        mov    ds:[0x62B6E4], al;
	__asm        mov    ecx, 0x62B5F0;
	__asm        call   BoatClass::~BoatClass;
_T2d:
	return;
}

// FUNCTION: COPTER_D 0x005274fd
void BoatClass::BoatClass(long mapx, long mapy, int32_t instanceID) {
	/*bp-0x4*/   int32_t currentFlag;
	/*bp-0x8*/   long odds;


	this-><vftable> = 0x593200;
// LINE 156:
	__asm        mov    currentFlag, 0;
	__asm        jmp    _T24;
_T21:
	currentFlag++;
_T24:
	__asm        cmp    currentFlag, 7;
	__asm        jge    _T3e;
// LINE 158:
	__asm        mov    eax, currentFlag;
	__asm        mov    ecx, this;
	__asm        mov    byte ptr [eax+ecx+4], 0;
// LINE 159:
	__asm        jmp    _T21;
// LINE 161:
_T3e:
	this->dyObj.mesh = 0x0;
// LINE 162:
	this->beamTimer = 0x0;
// LINE 163:
	this->direction = 0x0;
// LINE 164:
	this->speed = 0x0;
// LINE 165:
	this->desiredSpeed = 0x0;
// LINE 166:
	this->currentLocation.x = mapx;
// LINE 167:
	this->currentLocation.y = mapy;
// LINE 168:
	this->currentCell.x = mapx;
// LINE 169:
	this->currentCell.y = mapy;
// LINE 170:
	this->nextLocation.x = mapx;
// LINE 171:
	this->nextLocation.y = mapy;
// LINE 177:
	__asm        call   rand;
	__asm        mov    ecx, 0x64;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    odds, edx;
// LINE 179:
	__asm        cmp    odds, 0x64;
	__asm        jge    _Tee;
// LINE 182:
	__asm        cmp    instanceID, 0;
	__asm        jne    _Tdf;
// LINE 183:
	this->boatModel = 0x163;
// LINE 184:
	__asm        jmp    _Te9;
// LINE 185:
_Tdf:
	this->boatModel = 0x12f;
// LINE 187:
_Te9:
	__asm        jmp    _T10f;
// LINE 189:
_Tee:
	__asm        push   0xBD;
	__asm        push   0x5B73F4;
	__asm        push   0x5B7418;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T10f;

	__asm        jmp    _T10f;
// LINE 192:
_T10f:
	this->currentLocation.x = mapx;
// LINE 193:
	this->currentLocation.y = mapy;
// LINE 194:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0052762d
void BoatClass::~BoatClass() {

	this-><vftable> = 0x593200;
// LINE 218:
	__asm        jmp    _T1a;
_T1a:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        je     _T4c;
// LINE 220:
	__asm        jmp    _T2e;
_T2e:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T4c;
// LINE 222:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnlinkFromCell;
// LINE 234:
_T4c:
	this->flags[0] = 0x0;
// LINE 235:
	return;
}

// FUNCTION: COPTER_D 0x0052768a
/*packed*/ class BoatClass* BoatClass::GetBoatPointer(long index) {
// LINE 255:
	__asm        cmp    index, 3;
	__asm        jl     _T17;
// LINE 256:
	return 0x0;
// LINE 258:
_T17:
	__asm        mov    eax, index;
	__asm        mov    eax, boats[0][eax*4];
	__asm        jmp    __RETURN;
// LINE 259:
__RETURN:
}

// FUNCTION: COPTER_D 0x005276b5
/*packed*/ class BoatClass* BoatClass::CreateInstance(int32_t instanceID) {
// LINE 282:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        push   0xFFFFFFFF;
	__asm        push   0xFFFFFFFF;
	__asm        call   BoatClass::CreateInstance;
	__asm        add    esp, 0xC;
	__asm        jmp    __RETURN;
// LINE 319:
__RETURN:
}

// FUNCTION: COPTER_D 0x005276d5
/*packed*/ class BoatClass* BoatClass::CreateInstance(long mapx, long mapy, int32_t instanceID) {
	/*bp-0x4*/   /*packed*/ class BoatClass *newboat;

// LINE 344:
	__asm        push   0xE3;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T3f;

	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    eax, mapy;
	__asm        push   eax;
	__asm        mov    eax, mapx;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-8];
	__asm        call   BoatClass::BoatClass;
	__asm        mov    newboat, eax;
	__asm        jmp    _T46;
_T3f:
	newboat = 0x0;
// LINE 348:
_T46:
	__asm        cmp    newboat, 0;
	__asm        je     _T98;
// LINE 352:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    ecx, newboat;
	__asm        call   BoatClass::Initialize;
	__asm        test   eax, eax;
	__asm        je     _T71;
// LINE 354:
	return newboat;
// LINE 356:
	__asm        jmp    _T98;
// LINE 360:
_T71:
	__asm        mov    eax, newboat;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T98;

	__asm        push   1;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T98;
// LINE 367:
_T98:
	return 0x0;
// LINE 368:
}

// FUNCTION: COPTER_D 0x00527779
int32_t BoatClass::Initialize(int32_t instanceID) {
// LINE 444:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x33];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::InitializeInstance;
	__asm        jmp    __RETURN;
// LINE 445:
__RETURN:
}

// FUNCTION: COPTER_D 0x005277ab
void BoatClass::ResetAll() {
	/*bp-0x4*/   int32_t currentBoatIndex;

// LINE 489:
	__asm        mov    currentBoatIndex, 0;
	__asm        jmp    _T18;
_T15:
	currentBoatIndex++;
_T18:
	__asm        cmp    currentBoatIndex, 3;
	__asm        jge    _T36;
// LINE 491:
	__asm        mov    eax, currentBoatIndex;
	__asm        mov    ecx, boats[0][eax*4];
	__asm        call   BoatClass::Reset;
// LINE 492:
	__asm        jmp    _T15;
// LINE 494:
_T36:
	return;
}

// FUNCTION: COPTER_D 0x005277eb
void BoatClass::ItterateAll() {
	/*bp-0x4*/   int32_t currentBoatIndex;

// LINE 537:
	__asm        mov    currentBoatIndex, 0;
	__asm        jmp    _T18;
_T15:
	currentBoatIndex++;
_T18:
	__asm        cmp    currentBoatIndex, 3;
	__asm        jge    _T36;
// LINE 539:
	__asm        mov    eax, currentBoatIndex;
	__asm        mov    ecx, boats[0][eax*4];
	__asm        call   BoatClass::Itterate;
// LINE 540:
	__asm        jmp    _T15;
// LINE 542:
_T36:
	return;
}

// FUNCTION: COPTER_D 0x0052782b
void BoatClass::Itterate() {
// LINE 565:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        je     _Tea;
// LINE 568:
	this->beamTimer += LoopTime;
// LINE 569:
	__asm        jmp    _T30;
_T30:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        jne    _T6c;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x4F];
	__asm        cmp    [eax+0x4B], ecx;
	__asm        jge    _T6c;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7B], 0x163;
	__asm        je     _T6c;
// LINE 572:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
// LINE 575:
_T6c:
	__asm        jmp    _T71;
_T71:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _Te5;
// LINE 581:
// Block start:
	/*bp-0x58*/  /*packed*/ struct VRview position; // 0x58 bytes
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 585:
	__asm        jmp    _T90;
_T90:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _Te5;
// LINE 588:
	__asm        mov    eax, this;
	__asm        add    eax, 0x97;
	__asm        lea    ecx, position.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 592:
	__asm        mov    esi, this;
	__asm        lea    edi, position.matrix[0][0];
	__asm        add    esi, 0xA3;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 596:
	__asm        push   3;
	__asm        lea    eax, position.loc.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x87];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 601:
// Block end:
_Te5:
	__asm        jmp    _T11f;
// LINE 605:
_Tea:
	__asm        jmp    _Tef;
_Tef:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        jne    _T11a;

	__asm        push   0x25D;
	__asm        push   0x5B7420;
	__asm        push   0x5B7444;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T11f;
_T11a:
	__asm        jmp    _T11f;
// LINE 607:
_T11f:
	return;
}

// FUNCTION: COPTER_D 0x00527954
void BoatClass::Reset() {
// LINE 629:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnPlaceBoat;
// LINE 631:
	this->flags[2] = 0x0;
// LINE 632:
	this->flags[3] = 0x0;
// LINE 633:
	this->flags[4] = 0x0;
// LINE 634:
	this->flags[5] = 0x0;
// LINE 635:
	this->flags[6] = 0x0;
// LINE 636:
	this->beamTimer = 0x0;
// LINE 637:
	this->direction = 0x0;
// LINE 638:
	this->speed = 0x0;
// LINE 639:
	this->currentLocation.x = 0xffffffff;
// LINE 640:
	this->currentLocation.y = 0xffffffff;
// LINE 641:
	this->currentCell.x = 0xffffffff;
// LINE 642:
	this->currentCell.y = 0xffffffff;
// LINE 643:
	this->nextLocation.x = 0xffffffff;
// LINE 644:
	this->nextLocation.y = 0xffffffff;
// LINE 645:
	return;
}

// FUNCTION: COPTER_D 0x005279ef
void BoatClass::ItterateFSM() {
// LINE 688:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::IsBoatOutOfCameraRange;
	__asm        test   eax, eax;
	__asm        je     _T39;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7B], 0x163;
	__asm        je     _T39;
// LINE 690:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnPlaceBoat;
// LINE 691:
	return;
// LINE 698:
_T39:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7B], 0x163;
	__asm        jne    _T146;
// LINE 700:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x9F];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x97];
	__asm        push   eax;
	__asm        call   S3TerrPrecisionAlt;
	__asm        add    esp, 0xC;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x9B], eax;
// LINE 703:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x57], eax;
// LINE 704:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x57], 0;
	__asm        jge    _T141;
// LINE 707:
// Block start:
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cptr;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        jne    _Td7;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tdc;
_Td7:
	__asm        jmp    _Tdc;
_Tdc:
	__asm        jmp    _Te1;
_Te1:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    cptr, eax;
// LINE 709:
	__asm        push   9;
	__asm        mov    eax, this;
	__asm        add    eax, 0x97;
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        call   S3ExplosionSmokeStart;
	__asm        add    esp, 0xC;
// LINE 710:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x97;
	__asm        push   eax;
	__asm        mov    eax, cptr;
	__asm        push   eax;
	__asm        call   S3ExplosionSmokeStart;
	__asm        add    esp, 0xC;
// LINE 711:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x97;
	__asm        push   eax;
	__asm        push   0xF;
	__asm        call   S3DSPlay;
	__asm        add    esp, 0xC;
// LINE 714:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x53];
	__asm        push   eax;
	__asm        call   KillMissionPeople;
	__asm        add    esp, 4;
// LINE 715:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnPlaceBoat;
// LINE 717:
// Block end:
_T141:
	return;
// LINE 720:
_T146:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC];
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T268;
// LINE 726:
_T159:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::MoveForward;
// LINE 729:
	__asm        xor    eax, eax;
	__asm        sub    eax, LoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0xB], eax;
// LINE 730:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xB], 0;
	__asm        jge    _T1d7;
// LINE 735:
// Block start:
	/*bp-0x10*/  /*packed*/ struct Point3d sprayvect; // 0xc bytes
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x13];
	__asm        neg    eax;
	__asm        mov    sprayvect.x, eax;
// LINE 736:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x17];
	__asm        neg    eax;
	__asm        mov    sprayvect.y, eax;
// LINE 737:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1B];
	__asm        neg    eax;
	__asm        mov    sprayvect.z, eax;
// LINE 748:
	__asm        push   0xFFFFFFFF;
	__asm        push   0x140000;
	__asm        mov    eax, this;
	__asm        add    eax, 0x7F;
	__asm        push   eax;
	__asm        push   1;
	__asm        lea    eax, sprayvect.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x97;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        push   7;
	__asm        call   S3MissileStart;
	__asm        add    esp, 0x20;
// LINE 750:
	this->sprayTimer = 0xe666;
// LINE 795:
// Block end:
_T1d7:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::HaveIReachedNextLoc;
	__asm        test   eax, eax;
	__asm        je     _T23e;
// LINE 798:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnlinkFromCell;
// LINE 799:
	__asm        mov    eax, this;
	__asm        add    eax, 0x43;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::LinkToCell;
// LINE 800:
	__asm        mov    eax, this;
	__asm        add    eax, 0x43;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x33;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 802:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::MakeATurn;
// LINE 808:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustNextPosition;
// LINE 815:
_T23e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 817:
	__asm        jmp    _T281;
// LINE 827:
_T24e:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::Stop;
// LINE 829:
	__asm        jmp    _T281;
// LINE 835:
_T25b:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::Stop;
// LINE 837:
	__asm        jmp    _T281;
_T268:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T159;

	__asm        cmp    dword ptr [ebp-0x1C], 1;
	__asm        je     _T24e;

	__asm        jmp    _T25b;
// LINE 839:
_T281:
	return;
}

// FUNCTION: COPTER_D 0x00527c7a
void BoatClass::AdjustSpeed() {
	// StaticLocal: 0x005b73f0
	static int32_t speedAdjustor = 1;
	;

// LINE 861:
	this->speed = this->desiredSpeed;
// LINE 863:
	__asm        cmp    speedAdjustor, 0;
	__asm        jne    _T2f;
// LINE 865:
	this->speed = 0x1;
// LINE 867:
_T2f:
	return;
}

// FUNCTION: COPTER_D 0x00527cb3
enum BoatClass::StoppedReasons BoatClass::IsWaterPathClear() {
	/*bp-0xc*/   /*packed*/ struct Point3d boatHeading; // 0xc bytes
	/*bp-0x14*/  /*packed*/ struct Point2d boatLocation; // 0x8 bytes

// LINE 893:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8F];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x13];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x97];
	__asm        add    ecx, eax;
	__asm        mov    boatHeading.x, ecx;
// LINE 894:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8F];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x17];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x9B];
	__asm        add    ecx, eax;
	__asm        mov    boatHeading.y, ecx;
// LINE 895:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8F];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1B];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x9F];
	__asm        add    ecx, eax;
	__asm        mov    boatHeading.z, ecx;
// LINE 897:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x97];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    boatLocation.x, eax;
// LINE 898:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x9F];
	__asm        sar    eax, 0x16;
	__asm        mov    boatLocation.y, eax;
// LINE 900:
	__asm        lea    eax, boatHeading.x;
	__asm        push   eax;
	__asm        lea    eax, boatLocation.x;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::CheckWaterDynamicObjectsAt;
	__asm        jmp    __RETURN;
// LINE 901:
__RETURN:
}

// FUNCTION: COPTER_D 0x00527d76
enum BoatClass::StoppedReasons BoatClass::CheckWaterDynamicObjectsAt(const /*packed*/ struct Point2d& __formal, const /*packed*/ struct Point3d& collisionPoint) {
	/*bp-0x4*/   int32_t ydiff;
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST *currentObject;
	/*bp-0xc*/   /*packed*/ struct _CELL_INFO *currentCell;
	/*bp-0x10*/  unsigned short cellType;
	/*bp-0x14*/  int32_t zdiff;
	/*bp-0x18*/  int32_t xdiff;
	/*bp-0x1c*/  int32_t combinedradius;

// LINE 923:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, collisionPoint;
	__asm        sub    eax, [ecx+8];
	__asm        shr    eax, 0x16;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, collisionPoint;
	__asm        mov    ecx, [ecx];
	__asm        add    ecx, 0x20000000;
	__asm        shr    ecx, 0x16;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    cellType, ax;
	__asm        jmp    _T48;
// LINE 924:
_T48:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x20], eax;
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        jne    _T92;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T97;
_T92:
	__asm        jmp    _T97;
_T97:
	__asm        jmp    _T9c;
_T9c:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    currentCell, eax;
// LINE 927:
	__asm        cmp    currentCell, 0;
	__asm        jne    _Tb6;
// LINE 929:
	return 0x4;
// LINE 934:
_Tb6:
	currentObject = currentCell->dyptr;
// LINE 937:
_Tbf:
	__asm        cmp    currentObject, 0;
	__asm        je     _T1aa;
// LINE 940:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7F;
	__asm        cmp    eax, currentObject;
	__asm        jne    _Te5;
// LINE 942:
	currentObject = currentObject->next;
// LINE 943:
	__asm        jmp    _Tbf;
// LINE 947:
_Te5:
	__asm        mov    eax, currentObject;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x20;
	__asm        je     _T101;
// LINE 949:
	currentObject = currentObject->next;
// LINE 950:
	__asm        jmp    _Tbf;
// LINE 955:
_T101:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, currentObject;
	__asm        sub    eax, [ecx+0x18];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    xdiff, eax;
// LINE 956:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, currentObject;
	__asm        sub    eax, [ecx+0x1C];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ydiff, eax;
// LINE 957:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, currentObject;
	__asm        sub    eax, [ecx+0x20];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    zdiff, eax;
// LINE 959:
	combinedradius = currentObject->radius;
// LINE 960:
	combinedradius += 0x50000;
// LINE 963:
	__asm        mov    eax, combinedradius;
	__asm        cmp    xdiff, eax;
	__asm        jg     _T19d;

	__asm        mov    eax, ydiff;
	__asm        cmp    combinedradius, eax;
	__asm        jl     _T19d;

	__asm        mov    eax, zdiff;
	__asm        cmp    combinedradius, eax;
	__asm        jl     _T19d;
// LINE 967:
	__asm        jmp    _T175;
_T175:
	__asm        mov    eax, currentObject;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _T193;
// LINE 972:
	return 0x3;
// LINE 974:
	__asm        jmp    _T19d;
// LINE 978:
_T193:
	return 0x1;
// LINE 983:
_T19d:
	currentObject = currentObject->next;
// LINE 984:
	__asm        jmp    _Tbf;
// LINE 987:
_T1aa:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        cmp    [eax+0x43], ecx;
	__asm        jne    _T1d5;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x37];
	__asm        cmp    [eax+0x47], ecx;
	__asm        jne    _T1d5;
// LINE 988:
	return 0x0;
// LINE 993:
_T1d5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x47];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x43];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x24], eax;
	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        jne    _T21f;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T224;
_T21f:
	__asm        jmp    _T224;
_T224:
	__asm        jmp    _T229;
_T229:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    currentCell, eax;
// LINE 995:
	__asm        cmp    currentCell, 0;
	__asm        jne    _T243;
// LINE 997:
	return 0x4;
// LINE 1001:
_T243:
	currentObject = currentCell->dyptr;
// LINE 1004:
_T24c:
	__asm        cmp    currentObject, 0;
	__asm        je     _T337;
// LINE 1007:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7F;
	__asm        cmp    eax, currentObject;
	__asm        jne    _T272;
// LINE 1009:
	currentObject = currentObject->next;
// LINE 1010:
	__asm        jmp    _T24c;
// LINE 1014:
_T272:
	__asm        mov    eax, currentObject;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 0x20;
	__asm        je     _T28e;
// LINE 1016:
	currentObject = currentObject->next;
// LINE 1017:
	__asm        jmp    _T24c;
// LINE 1021:
_T28e:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, currentObject;
	__asm        sub    eax, [ecx+0x18];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    xdiff, eax;
// LINE 1022:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, currentObject;
	__asm        sub    eax, [ecx+0x1C];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    ydiff, eax;
// LINE 1023:
	__asm        mov    eax, collisionPoint;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, currentObject;
	__asm        sub    eax, [ecx+0x20];
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    zdiff, eax;
// LINE 1026:
	combinedradius = currentObject->radius;
// LINE 1027:
	combinedradius += 0x50000;
// LINE 1030:
	__asm        mov    eax, combinedradius;
	__asm        cmp    xdiff, eax;
	__asm        jg     _T32a;

	__asm        mov    eax, ydiff;
	__asm        cmp    combinedradius, eax;
	__asm        jl     _T32a;

	__asm        mov    eax, zdiff;
	__asm        cmp    combinedradius, eax;
	__asm        jl     _T32a;
// LINE 1033:
	__asm        jmp    _T302;
_T302:
	__asm        mov    eax, currentObject;
	__asm        movsx  eax, word ptr [eax+0xC];
	__asm        test   al, 8;
	__asm        je     _T320;
// LINE 1038:
	return 0x3;
// LINE 1040:
	__asm        jmp    _T32a;
// LINE 1044:
_T320:
	return 0x1;
// LINE 1049:
_T32a:
	currentObject = currentObject->next;
// LINE 1050:
	__asm        jmp    _T24c;
// LINE 1054:
_T337:
	return 0x0;
// LINE 1055:
}

// FUNCTION: COPTER_D 0x005280bb
int32_t BoatClass::IsBoatOutOfCameraRange() {
	/*bp-0x4*/   int32_t deltaX;
	/*bp-0x8*/   int32_t deltaY;

// LINE 1078:
	deltaX = (CameraCell.x - this->currentLocation.x);
// LINE 1079:
	deltaY = (CameraCell.y - this->currentLocation.y);
// LINE 1084:
_T28:
	__asm        cmp    deltaX, 0x80;
	__asm        jle    _T41;
// LINE 1086:
	deltaX -= 0x100;
// LINE 1087:
	__asm        jmp    _T28;
// LINE 1088:
_T41:
	__asm        cmp    deltaX, 0xFFFFFF80;
	__asm        jge    _T57;
// LINE 1090:
	deltaX += 0x100;
// LINE 1091:
	__asm        jmp    _T41;
// LINE 1093:
_T57:
	__asm        cmp    deltaY, 0x80;
	__asm        jle    _T70;
// LINE 1095:
	deltaY -= 0x100;
// LINE 1096:
	__asm        jmp    _T57;
// LINE 1097:
_T70:
	__asm        cmp    deltaY, 0xFFFFFF80;
	__asm        jge    _T86;
// LINE 1099:
	deltaY += 0x100;
// LINE 1100:
	__asm        jmp    _T70;
// LINE 1102:
_T86:
	__asm        cmp    deltaX, 0;
	__asm        jge    _T98;
// LINE 1104:
	__asm        mov    eax, deltaX;
	__asm        neg    eax;
	__asm        mov    deltaX, eax;
// LINE 1106:
_T98:
	__asm        cmp    deltaY, 0;
	__asm        jge    _Taa;
// LINE 1108:
	__asm        mov    eax, deltaY;
	__asm        neg    eax;
	__asm        mov    deltaY, eax;
// LINE 1112:
_Taa:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        add    eax, 4;
	__asm        cmp    eax, deltaX;
	__asm        jl     _Td2;

	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        add    eax, 4;
	__asm        cmp    eax, deltaY;
	__asm        jge    _Te1;
// LINE 1114:
_Td2:
	return 0x1;
// LINE 1116:
	__asm        jmp    __RETURN;
// LINE 1118:
_Te1:
	return 0x0;
// LINE 1120:
__RETURN:
}

// FUNCTION: COPTER_D 0x005281a8
void BoatClass::SetBoatDirection(unsigned short tileType) {
	/*bp-0x4*/   int32_t i;
	/*bp-0x14*/  enum DirectionTypes validdirs[4]; // 0x10 bytes
	/*bp-0x18*/  unsigned short tile;

// LINE 1141:
	validdirs[0] = 0x0;
// LINE 1142:
	validdirs[1] = 0x0;
// LINE 1143:
	validdirs[2] = 0x0;
// LINE 1144:
	validdirs[3] = 0x0;
// LINE 1145:
	i = 0x0;
// LINE 1147:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1148:
	this->direction = 0x0;
// LINE 1150:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        dec    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    tile, ax;
	__asm        jmp    _T7c;
// LINE 1151:
_T7c:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _Ta3;

	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _Ta3;

	__asm        jmp    _Tb7;
_Ta3:
	__asm        jmp    _Tc5;

	__asm        jmp    _Tb7;

	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _Tc5;
// LINE 1153:
_Tb7:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x14], 1;
	__asm        inc    i;
// LINE 1156:
_Tc5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    tile, ax;
	__asm        jmp    _Tf2;
// LINE 1157:
_Tf2:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _T119;

	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _T119;

	__asm        jmp    _T12d;
_T119:
	__asm        jmp    _T13b;

	__asm        jmp    _T12d;

	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        je     _T13b;
// LINE 1159:
_T12d:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x14], 2;
	__asm        inc    i;
// LINE 1162:
_T13b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x33];
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x37];
	__asm        and    ecx, 0xFF;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    tile, ax;
	__asm        jmp    _T168;
// LINE 1163:
_T168:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _T18f;

	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _T18f;

	__asm        jmp    _T1a3;
_T18f:
	__asm        jmp    _T1b1;

	__asm        jmp    _T1a3;

	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        je     _T1b1;
// LINE 1165:
_T1a3:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x14], 4;
	__asm        inc    i;
// LINE 1168:
_T1b1:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x33];
	__asm        dec    eax;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x37];
	__asm        and    ecx, 0xFF;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    tile, ax;
	__asm        jmp    _T1de;
// LINE 1169:
_T1de:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _T205;

	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _T205;

	__asm        jmp    _T219;
_T205:
	__asm        jmp    _T227;

	__asm        jmp    _T219;

	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T227;
// LINE 1171:
_T219:
	__asm        mov    eax, i;
	__asm        mov    dword ptr [ebp+eax*4-0x14], 8;
	__asm        inc    i;
// LINE 1175:
_T227:
	__asm        cmp    i, 0;
	__asm        jne    _T236;
// LINE 1176:
	return;
// LINE 1178:
_T236:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   i;
	__asm        mov    eax, [ebp+edx*4-0x14];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xF], eax;
// LINE 1180:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _T28b;
// LINE 1183:
_T25a:
	this->nextLocation.y--;
// LINE 1184:
	__asm        jmp    _T2c6;
// LINE 1186:
_T265:
	this->nextLocation.y++;
// LINE 1187:
	__asm        jmp    _T2c6;
// LINE 1189:
_T270:
	this->nextLocation.x++;
// LINE 1190:
	__asm        jmp    _T2c6;
// LINE 1192:
_T27b:
	this->nextLocation.x--;
// LINE 1193:
	__asm        jmp    _T2c6;
// LINE 1194:
	__asm        jmp    _T2c6;
_T28b:
	__asm        dec    dword ptr [ebp-0x30];
	__asm        cmp    dword ptr [ebp-0x30], 7;
	__asm        ja     _T2c6;

	__asm        mov    eax, [ebp-0x30];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, _SwitchTable_2be[0][eax];
	__asm        jmp    _Switch_2aa[0][ecx*4];
// Switch pointers:
//   _T25a
//   _T265
//   _T270
//   _T27b
//   _T2c6
// Switch table
//  [0, 1, 4, 2, 4, 4, 4, 3]
// LINE 1196:
_T2c6:
	return;
}

// FUNCTION: COPTER_D 0x0052847a
void BoatClass::SlowDown() {
// LINE 1215:
	this->speed -= 0x20000;
// LINE 1216:
	return;
}

// FUNCTION: COPTER_D 0x0052849a
void BoatClass::Stop() {
// LINE 1236:
	this->speed = 0x0;
// LINE 1237:
	return;
}

// FUNCTION: COPTER_D 0x005284ba
void BoatClass::MoveForward() {
	/*bp-0x4*/   int32_t distance;

// LINE 1259:
	__asm        mov    eax, LoopTime;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x2B];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    distance, eax;
// LINE 1261:
	__asm        mov    eax, this;
	__asm        mov    ecx, distance;
	__asm        cmp    [eax+0x1F], ecx;
	__asm        jge    _T3c;
// LINE 1262:
	distance = this->remainingDist;
// LINE 1263:
_T3c:
	__asm        xor    eax, eax;
	__asm        sub    eax, distance;
	__asm        neg    eax;
	__asm        mov    ecx, this;
	__asm        sub    [ecx+0x1F], eax;
// LINE 1270:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x13];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x97], eax;
// LINE 1271:
	__asm        mov    eax, distance;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1B];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        add    [ecx+0x9F], eax;
// LINE 1272:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x9F];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x97];
	__asm        push   eax;
	__asm        call   S3TerrPrecisionAlt;
	__asm        add    esp, 0xC;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x9B], eax;
// LINE 1275:
	__asm        jmp    _Tad;
_Tad:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x9F];
	__asm        shr    eax, 0x16;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x97];
	__asm        add    ecx, 0x20000000;
	__asm        shr    ecx, 0x16;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T13d;

	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x9F];
	__asm        shr    eax, 0x16;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x97];
	__asm        add    ecx, 0x20000000;
	__asm        shr    ecx, 0x16;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T13d;

	__asm        jmp    _T151;

	__asm        jmp    _T147;
_T13d:
	__asm        jmp    _T15d;

	__asm        jmp    _T151;
_T147:
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T15d;
// LINE 1277:
_T151:
	this->flags[3] = 0x1;
// LINE 1279:
	__asm        jmp    _T164;
// LINE 1281:
_T15d:
	this->flags[3] = 0x0;
// LINE 1285:
_T164:
	return;
}

// FUNCTION: COPTER_D 0x00528628
int32_t BoatClass::HaveIReachedNextLoc() {
// LINE 1306:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1F], 0;
	__asm        jg     _T28;
// LINE 1308:
	return 0x1;
// LINE 1310:
	__asm        jmp    __RETURN;
// LINE 1312:
_T28:
	return 0x0;
// LINE 1314:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052865c
int32_t BoatClass::AmIInANewCell() {
// LINE 1338:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x97];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x3B], eax;
// LINE 1339:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x9F];
	__asm        sar    eax, 0x16;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x3F], eax;
// LINE 1343:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        cmp    [eax+0x3B], ecx;
	__asm        jne    _T5e;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x37];
	__asm        cmp    [eax+0x3F], ecx;
	__asm        je     _Tde;
// LINE 1346:
_T5e:
	__asm        jmp    _T63;
_T63:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3F];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x3B];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _Tc0;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x3F];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x3B];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _Tc0;

	__asm        jmp    _Td4;
_Tc0:
	__asm        jmp    _Tde;

	__asm        jmp    _Td4;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _Tde;
// LINE 1347:
_Td4:
	return 0x1;
// LINE 1350:
_Tde:
	return 0x0;
// LINE 1351:
}

// FUNCTION: COPTER_D 0x00528746
void BoatClass::UnlinkFromCell(const /*packed*/ struct Point2d& point) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 1373:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, point;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T55;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T5a;
_T55:
	__asm        jmp    _T5a;
_T5a:
	__asm        jmp    _T5f;
_T5f:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    cellPointer, eax;
// LINE 1375:
	__asm        cmp    cellPointer, 0;
	__asm        jne    _T8b;

	__asm        push   0x55F;
	__asm        push   0x5B7458;
	__asm        push   0x5B747C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T90;
_T8b:
	__asm        jmp    _T90;
// LINE 1377:
_T90:
	__asm        cmp    cellPointer, 0;
	__asm        je     _T10a;
// LINE 1379:
// Block start:
	/*bp-0x8*/   /*packed*/ struct _DYOBJ_INST **dyptrptr;
	dyptrptr = (cellPointer + 0x10);
// LINE 1381:
_Ta3:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Tdd;
// LINE 1385:
	__asm        mov    eax, this;
	__asm        add    eax, 0x7F;
	__asm        mov    ecx, dyptrptr;
	__asm        cmp    eax, [ecx];
	__asm        jne    _Td0;
// LINE 1389:
	dyptrptr-> = this->dyObj.next;
// LINE 1391:
	return;
// LINE 1394:
_Td0:
	dyptrptr = dyptrptr->;
// LINE 1395:
	__asm        jmp    _Ta3;
// LINE 1397:
_Tdd:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _T105;

	__asm        push   0x575;
	__asm        push   0x5B7488;
	__asm        push   0x5B74AC;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T10a;
_T105:
	__asm        jmp    _T10a;
// LINE 1399:
// Block end:
_T10a:
	return;
}

// FUNCTION: COPTER_D 0x0052885c
void BoatClass::LinkToCell(const /*packed*/ struct Point2d& point) {
	/*bp-0x4*/   /*packed*/ struct _CELL_INFO *cellPointer;

// LINE 1421:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, point;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T55;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T5a;
_T55:
	__asm        jmp    _T5a;
_T5a:
	__asm        jmp    _T5f;
_T5f:
	__asm        mov    eax, [ebp-8];
	__asm        mov    cellPointer, eax;
// LINE 1423:
	__asm        mov    eax, cellPointer;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x7F;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T93;

	__asm        push   0x58F;
	__asm        push   0x5B74B8;
	__asm        push   0x5B74DC;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T98;
_T93:
	__asm        jmp    _T98;
// LINE 1425:
_T98:
	this->dyObj.next = cellPointer->dyptr;
// LINE 1426:
	cellPointer->dyptr = (this + 0x7f);
// LINE 1427:
	return;
}

// FUNCTION: COPTER_D 0x00528918
enum BoatClass::IntersectionTypes BoatClass::PickTurnDirection(const /*packed*/ struct Point2d& point) {
	/*bp-0x4*/   unsigned short northTile;
	/*bp-0x8*/   /*packed*/ struct _CELL_INFO *ecptr;
	/*bp-0xc*/   long intersection;
	/*bp-0x10*/  /*packed*/ struct _CELL_INFO *scptr;
	/*bp-0x14*/  /*packed*/ struct _CELL_INFO *wcptr;
	/*bp-0x18*/  unsigned short eastTile;
	/*bp-0x1c*/  unsigned short currentTile;
	/*bp-0x20*/  unsigned short westTile;
	/*bp-0x24*/  unsigned short southTile;
	/*bp-0x28*/  /*packed*/ struct _CELL_INFO *ncptr;

// LINE 1465:
	this->northCell.x = point.x;
// LINE 1466:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x5F], eax;
// LINE 1467:
	this->southCell.x = point.x;
// LINE 1468:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        inc    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x67], eax;
// LINE 1469:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax];
	__asm        inc    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x6B], eax;
// LINE 1470:
	this->eastCell.y = point.y;
// LINE 1471:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax];
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x73], eax;
// LINE 1472:
	this->westCell.y = point.y;
// LINE 1474:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x5F];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x5B];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x2C], eax;
	__asm        cmp    dword ptr [ebp-0x2C], 0;
	__asm        jne    _Tb6;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tbb;
_Tb6:
	__asm        jmp    _Tbb;
_Tbb:
	__asm        jmp    _Tc0;
_Tc0:
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    ncptr, eax;
// LINE 1475:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x6F];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x6B];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x30], eax;
	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        jne    _T110;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T115;
_T110:
	__asm        jmp    _T115;
_T115:
	__asm        jmp    _T11a;
_T11a:
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    ecptr, eax;
// LINE 1476:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x77];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x73];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x34], eax;
	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        jne    _T16a;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T16f;
_T16a:
	__asm        jmp    _T16f;
_T16f:
	__asm        jmp    _T174;
_T174:
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    wcptr, eax;
// LINE 1477:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x67];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x63];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x38], eax;
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        jne    _T1c4;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T1c9;
_T1c4:
	__asm        jmp    _T1c9;
_T1c9:
	__asm        jmp    _T1ce;
_T1ce:
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    scptr, eax;
// LINE 1480:
	__asm        mov    eax, point;
	__asm        mov    eax, [eax+4];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, point;
	__asm        mov    ecx, [ecx];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    currentTile, ax;
	__asm        jmp    _T1ff;
// LINE 1482:
_T1ff:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x5F];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x5B];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    northTile, ax;
	__asm        jmp    _T22b;
// LINE 1483:
_T22b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x67];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x63];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    southTile, ax;
	__asm        jmp    _T257;
// LINE 1484:
_T257:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x6F];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x6B];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    eastTile, ax;
	__asm        jmp    _T283;
// LINE 1485:
_T283:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x77];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x73];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    westTile, ax;
	__asm        jmp    _T2af;
// LINE 1491:
_T2af:
	intersection = 0x0;
// LINE 1495:
	__asm        jmp    _T2bb;
_T2bb:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T34f;

	__asm        jmp    _T2da;
_T2da:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x40;
	__asm        or     eax, ecx;
	__asm        je     _T34f;
// LINE 1498:
	__asm        mov    eax, ncptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T31f;

	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T31f;
// LINE 1500:
	__asm        or     intersection, 1;
// LINE 1502:
_T31f:
	__asm        mov    eax, ecptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T34a;

	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T34a;
// LINE 1504:
	__asm        or     intersection, 4;
// LINE 1507:
_T34a:
	__asm        jmp    _T7be;
_T34f:
	__asm        jmp    _T354;
_T354:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T3eb;

	__asm        jmp    _T373;
_T373:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x80;
	__asm        or     eax, ecx;
	__asm        je     _T3eb;
// LINE 1510:
	__asm        mov    eax, ncptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T3bb;

	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T3bb;
// LINE 1512:
	__asm        or     intersection, 1;
// LINE 1514:
_T3bb:
	__asm        mov    eax, wcptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T3e6;

	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T3e6;
// LINE 1516:
	__asm        or     intersection, 2;
// LINE 1519:
_T3e6:
	__asm        jmp    _T7be;
_T3eb:
	__asm        jmp    _T3f0;
_T3f0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x20;
	__asm        or     eax, ecx;
	__asm        je     _T484;

	__asm        jmp    _T40f;
_T40f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x40;
	__asm        or     eax, ecx;
	__asm        je     _T484;
// LINE 1522:
	__asm        mov    eax, scptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T454;

	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T454;
// LINE 1524:
	__asm        or     intersection, 1;
// LINE 1526:
_T454:
	__asm        mov    eax, ecptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T47f;

	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T47f;
// LINE 1528:
	__asm        or     intersection, 2;
// LINE 1531:
_T47f:
	__asm        jmp    _T7be;
_T484:
	__asm        jmp    _T489;
_T489:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x20;
	__asm        or     eax, ecx;
	__asm        je     _T520;

	__asm        jmp    _T4a8;
_T4a8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x80;
	__asm        or     eax, ecx;
	__asm        je     _T520;
// LINE 1534:
	__asm        mov    eax, scptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T4f0;

	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T4f0;
// LINE 1536:
	__asm        or     intersection, 1;
// LINE 1538:
_T4f0:
	__asm        mov    eax, wcptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T51b;

	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T51b;
// LINE 1540:
	__asm        or     intersection, 4;
// LINE 1543:
_T51b:
	__asm        jmp    _T7be;
_T520:
	__asm        jmp    _T525;
_T525:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T5c5;
// LINE 1546:
	__asm        mov    eax, ncptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T56a;

	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T56a;
// LINE 1548:
	__asm        or     intersection, 1;
// LINE 1550:
_T56a:
	__asm        mov    eax, wcptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T595;

	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T595;
// LINE 1552:
	__asm        or     intersection, 2;
// LINE 1554:
_T595:
	__asm        mov    eax, ecptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T5c0;

	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T5c0;
// LINE 1556:
	__asm        or     intersection, 4;
// LINE 1559:
_T5c0:
	__asm        jmp    _T7be;
_T5c5:
	__asm        jmp    _T5ca;
_T5ca:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x20;
	__asm        or     eax, ecx;
	__asm        je     _T66a;
// LINE 1562:
	__asm        mov    eax, scptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T60f;

	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T60f;
// LINE 1564:
	__asm        or     intersection, 1;
// LINE 1566:
_T60f:
	__asm        mov    eax, ecptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T63a;

	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T63a;
// LINE 1568:
	__asm        or     intersection, 2;
// LINE 1570:
_T63a:
	__asm        mov    eax, wcptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T665;

	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T665;
// LINE 1572:
	__asm        or     intersection, 4;
// LINE 1575:
_T665:
	__asm        jmp    _T7be;
_T66a:
	__asm        jmp    _T66f;
_T66f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x40;
	__asm        or     eax, ecx;
	__asm        je     _T70f;
// LINE 1578:
	__asm        mov    eax, ecptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T6b4;

	__asm        push   4;
	__asm        mov    eax, reinterpret_cast<uint32_t>(eastTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T6b4;
// LINE 1580:
	__asm        or     intersection, 1;
// LINE 1582:
_T6b4:
	__asm        mov    eax, ncptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T6df;

	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T6df;
// LINE 1584:
	__asm        or     intersection, 2;
// LINE 1586:
_T6df:
	__asm        mov    eax, scptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T70a;

	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T70a;
// LINE 1588:
	__asm        or     intersection, 4;
// LINE 1591:
_T70a:
	__asm        jmp    _T7be;
_T70f:
	__asm        jmp    _T714;
_T714:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x80;
	__asm        or     eax, ecx;
	__asm        je     _T7b7;
// LINE 1594:
	__asm        mov    eax, wcptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T75c;

	__asm        push   8;
	__asm        mov    eax, reinterpret_cast<uint32_t>(westTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T75c;
// LINE 1596:
	__asm        or     intersection, 1;
// LINE 1598:
_T75c:
	__asm        mov    eax, scptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T787;

	__asm        push   2;
	__asm        mov    eax, reinterpret_cast<uint32_t>(southTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T787;
// LINE 1600:
	__asm        or     intersection, 2;
// LINE 1602:
_T787:
	__asm        mov    eax, ncptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T7b2;

	__asm        push   1;
	__asm        mov    eax, reinterpret_cast<uint32_t>(northTile);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currentTile);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::DoWaterTilesConnect;
	__asm        test   eax, eax;
	__asm        je     _T7b2;
// LINE 1604:
	__asm        or     intersection, 4;
// LINE 1607:
_T7b2:
	__asm        jmp    _T7be;
// LINE 1611:
_T7b7:
	return 0x0;
// LINE 1622:
_T7be:
	return intersection;
// LINE 1623:
}

// FUNCTION: COPTER_D 0x005290e5
int32_t BoatClass::DoWaterTilesConnect(unsigned short fromTile, unsigned short toTile, enum DirectionTypes direction) {
// LINE 1654:
	__asm        mov    eax, reinterpret_cast<uint32_t>(fromTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _T3f;

	__asm        mov    eax, reinterpret_cast<uint32_t>(fromTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _T3f;

	__asm        mov    dword ptr [ebp-8], 0xF;
	__asm        jmp    _T4b;

	__asm        jmp    _T4b;
_T3f:
	__asm        mov    dword ptr [ebp-8], 0;
	__asm        jmp    _T4b;
_T4b:
	__asm        mov    eax, reinterpret_cast<uint32_t>(toTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _T7e;

	__asm        mov    eax, reinterpret_cast<uint32_t>(toTile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _T7e;

	__asm        mov    dword ptr [ebp-4], 0xF;
	__asm        jmp    _T8a;

	__asm        jmp    _T8a;
_T7e:
	__asm        mov    dword ptr [ebp-4], 0;
	__asm        jmp    _T8a;
_T8a:
	__asm        test   reinterpret_cast<uint8_t>(direction), 1;
	__asm        je     _Tb4;

	__asm        test   byte ptr [ebp-8], 1;
	__asm        je     _Tb4;

	__asm        test   byte ptr [ebp-4], 2;
	__asm        je     _Tb4;

	__asm        mov    dword ptr [ebp-0xC], 1;
	__asm        jmp    _T13e;
_Tb4:
	__asm        test   reinterpret_cast<uint8_t>(direction), 2;
	__asm        je     _Tde;

	__asm        test   byte ptr [ebp-8], 2;
	__asm        je     _Tde;

	__asm        test   byte ptr [ebp-4], 1;
	__asm        je     _Tde;

	__asm        mov    dword ptr [ebp-0xC], 1;
	__asm        jmp    _T13e;
_Tde:
	__asm        test   reinterpret_cast<uint8_t>(direction), 8;
	__asm        je     _T108;

	__asm        test   byte ptr [ebp-8], 8;
	__asm        je     _T108;

	__asm        test   byte ptr [ebp-4], 4;
	__asm        je     _T108;

	__asm        mov    dword ptr [ebp-0xC], 1;
	__asm        jmp    _T13e;
_T108:
	__asm        test   reinterpret_cast<uint8_t>(direction), 4;
	__asm        je     _T132;

	__asm        test   byte ptr [ebp-8], 4;
	__asm        je     _T132;

	__asm        test   byte ptr [ebp-4], 8;
	__asm        je     _T132;

	__asm        mov    dword ptr [ebp-0xC], 1;
	__asm        jmp    _T13e;
_T132:
	__asm        mov    dword ptr [ebp-0xC], 0;
	__asm        jmp    _T13e;
_T13e:
	__asm        mov    eax, [ebp-0xC];
	__asm        jmp    __RETURN;
// LINE 1655:
__RETURN:
}

// FUNCTION: COPTER_D 0x00529232
void BoatClass::MakeATurn(enum BoatClass::IntersectionTypes intersectionType) {
// LINE 1675:
	__asm        mov    eax, intersectionType;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T181;
// LINE 1679:
_T17:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnPlaceBoat;
// LINE 1681:
	__asm        jmp    _T1b5;
// LINE 1691:
_T24:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::GoStraight;
// LINE 1693:
	__asm        jmp    _T1b5;
// LINE 1697:
_T31:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnLeft;
// LINE 1699:
	__asm        jmp    _T1b5;
// LINE 1703:
_T3e:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnRight;
// LINE 1705:
	__asm        jmp    _T1b5;
// LINE 1709:
_T4b:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T68;
// LINE 1711:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnLeft;
// LINE 1713:
	__asm        jmp    _T70;
// LINE 1715:
_T68:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::GoStraight;
// LINE 1718:
_T70:
	__asm        jmp    _T1b5;
// LINE 1722:
_T75:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _T92;
// LINE 1724:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnLeft;
// LINE 1726:
	__asm        jmp    _T9a;
// LINE 1728:
_T92:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnRight;
// LINE 1731:
_T9a:
	__asm        jmp    _T1b5;
// LINE 1735:
_T9f:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        test   al, 1;
	__asm        je     _Tbc;
// LINE 1737:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnRight;
// LINE 1739:
	__asm        jmp    _Tc4;
// LINE 1741:
_Tbc:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::GoStraight;
// LINE 1744:
_Tc4:
	__asm        jmp    _T1b5;
// LINE 1748:
_Tc9:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    [ebp-0xC], edx;
	__asm        jmp    _T133;
// LINE 1750:
_Te1:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::GoStraight;
	__asm        jmp    _T156;
// LINE 1751:
_Tee:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnLeft;
	__asm        jmp    _T156;
// LINE 1752:
_Tfb:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::TurnRight;
	__asm        jmp    _T156;
// LINE 1753:
_T108:
	__asm        push   0x6D9;
	__asm        push   0x5B74FC;
	__asm        push   0x5B7520;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T129;

	__asm        jmp    _T129;
_T129:
	__asm        jmp    _T156;
// LINE 1754:
	__asm        jmp    _T156;
_T133:
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Te1;

	__asm        cmp    dword ptr [ebp-0xC], 1;
	__asm        je     _Tee;

	__asm        cmp    dword ptr [ebp-0xC], 2;
	__asm        je     _Tfb;

	__asm        jmp    _T108;
// LINE 1756:
_T156:
	__asm        jmp    _T1b5;
// LINE 1762:
_T15b:
	__asm        push   0x6E2;
	__asm        push   0x5B7528;
	__asm        push   0x5B754C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T17c;

	__asm        jmp    _T17c;
// LINE 1764:
_T17c:
	__asm        jmp    _T1b5;
_T181:
	__asm        cmp    dword ptr [ebp-8], 7;
	__asm        ja     _T15b;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    _Switch_195[0][eax*4];
// Switch pointers:
//   _T17
//   _T24
//   _T31
//   _T4b
//   _T3e
//   _T9f
//   _T75
//   _Tc9
// LINE 1765:
_T1b5:
	return;
}

// FUNCTION: COPTER_D 0x005293f3
enum BoatClass::StoppedReasons BoatClass::WhyAmIStopped() {
// LINE 1788:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T73;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T73;

	__asm        jmp    _T8c;

	__asm        jmp    _T82;
_T73:
	__asm        jmp    _T82;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        jne    _T8c;
// LINE 1792:
_T82:
	return 0x4;
// LINE 1797:
_T8c:
	return 0x3;
// LINE 1798:
}

// FUNCTION: COPTER_D 0x0052948e
void BoatClass::AdjustCurrentPosition() {
// LINE 1831:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x33];
	__asm        push   eax;
	__asm        call   GetAltitude;
	__asm        add    esp, 8;
	__asm        movsx  eax, ax;
	__asm        shl    eax, 5;
	__asm        add    eax, 0x20;
	__asm        shl    eax, 0x10;
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x33];
	__asm        shl    eax, 6;
	__asm        sub    eax, 0x1FE0;
	__asm        shl    eax, 0x10;
	__asm        mov    [ebp-0x24], eax;
	__asm        mov    eax, 0x2000;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x37];
	__asm        shl    ecx, 6;
	__asm        sub    eax, ecx;
	__asm        sub    eax, 0x20;
	__asm        shl    eax, 0x10;
	__asm        mov    [ebp-0x1C], eax;
	__asm        lea    eax, [ebp-0x24];
	__asm        lea    ecx, [ebp-0x18];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        jmp    _T79;
_T79:
	__asm        lea    eax, [ebp-0x18];
	__asm        lea    ecx, [ebp-0xC];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        lea    eax, [ebp-0xC];
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x97;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1833:
	return;
}

// FUNCTION: COPTER_D 0x00529543
void BoatClass::AdjustNextPosition() {
	/*bp-0xc*/   /*packed*/ struct Point3d nextFineLocation; // 0xc bytes

// LINE 1856:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x47];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x43];
	__asm        push   eax;
	__asm        call   GetAltitude;
	__asm        add    esp, 8;
	__asm        movsx  eax, ax;
	__asm        shl    eax, 5;
	__asm        add    eax, 0x20;
	__asm        shl    eax, 0x10;
	__asm        mov    [ebp-0x2C], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x43];
	__asm        shl    eax, 6;
	__asm        sub    eax, 0x1FE0;
	__asm        shl    eax, 0x10;
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    eax, 0x2000;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x47];
	__asm        shl    ecx, 6;
	__asm        sub    eax, ecx;
	__asm        sub    eax, 0x20;
	__asm        shl    eax, 0x10;
	__asm        mov    [ebp-0x28], eax;
	__asm        lea    eax, [ebp-0x30];
	__asm        lea    ecx, [ebp-0x24];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        jmp    _T79;
_T79:
	__asm        lea    eax, [ebp-0x24];
	__asm        lea    ecx, [ebp-0x18];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
	__asm        lea    eax, [ebp-0x18];
	__asm        lea    ecx, nextFineLocation.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1861:
	this->directionVector.x = (nextFineLocation.x - this->dyObj.loc.x);
// LINE 1862:
	this->directionVector.y = 0x0;
// LINE 1863:
	this->directionVector.z = (nextFineLocation.z - this->dyObj.loc.z);
// LINE 1864:
	__asm        mov    eax, this;
	__asm        add    eax, 0x13;
	__asm        push   eax;
	__asm        call   MTNormalize;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1F], eax;
// LINE 1869:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x8B];
	__asm        test   al, 1;
	__asm        je     _T112;
// LINE 1871:
	__asm        mov    eax, this;
	__asm        add    eax, 0x13;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0xA3;
	__asm        push   eax;
	__asm        call   MTCreateDOF4x4;
	__asm        add    esp, 8;
// LINE 1873:
_T112:
	return;
}

// FUNCTION: COPTER_D 0x0052965f
void BoatClass::GoStraight() {
// LINE 1895:
	this->flags[2] = 0x0;
// LINE 1899:
	__asm        jmp    _T18;
_T18:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T4d;
// LINE 1902:
	__asm        mov    eax, this;
	__asm        add    eax, 0x5B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1904:
	__asm        jmp    _T11f;
_T4d:
	__asm        jmp    _T52;
_T52:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x20;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 2;
	__asm        or     eax, ecx;
	__asm        je     _T87;
// LINE 1907:
	__asm        mov    eax, this;
	__asm        add    eax, 0x63;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1909:
	__asm        jmp    _T11f;
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x40;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 4;
	__asm        or     eax, ecx;
	__asm        je     _Tc1;
// LINE 1912:
	__asm        mov    eax, this;
	__asm        add    eax, 0x6B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1914:
	__asm        jmp    _T11f;
_Tc1:
	__asm        jmp    _Tc6;
_Tc6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x80;
	__asm        or     eax, ecx;
	__asm        je     _Tfe;
// LINE 1917:
	__asm        mov    eax, this;
	__asm        add    eax, 0x73;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1919:
	__asm        jmp    _T11f;
// LINE 1921:
_Tfe:
	__asm        push   0x781;
	__asm        push   0x5B7554;
	__asm        push   0x5B7578;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T11f;

	__asm        jmp    _T11f;
// LINE 1923:
_T11f:
	return;
}

// FUNCTION: COPTER_D 0x00529788
void BoatClass::TurnLeft() {
// LINE 1945:
	this->flags[2] = 0x1;
// LINE 1949:
	__asm        jmp    _T18;
_T18:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T4d;
// LINE 1952:
	__asm        mov    eax, this;
	__asm        add    eax, 0x73;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1954:
	__asm        jmp    _T11f;
_T4d:
	__asm        jmp    _T52;
_T52:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x20;
	__asm        or     eax, ecx;
	__asm        je     _T87;
// LINE 1957:
	__asm        mov    eax, this;
	__asm        add    eax, 0x6B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1959:
	__asm        jmp    _T11f;
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x40;
	__asm        or     eax, ecx;
	__asm        je     _Tc1;
// LINE 1962:
	__asm        mov    eax, this;
	__asm        add    eax, 0x5B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1964:
	__asm        jmp    _T11f;
_Tc1:
	__asm        jmp    _Tc6;
_Tc6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x80;
	__asm        or     eax, ecx;
	__asm        je     _Tfe;
// LINE 1967:
	__asm        mov    eax, this;
	__asm        add    eax, 0x63;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 1969:
	__asm        jmp    _T11f;
// LINE 1971:
_Tfe:
	__asm        push   0x7B3;
	__asm        push   0x5B7580;
	__asm        push   0x5B75A4;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T11f;

	__asm        jmp    _T11f;
// LINE 1974:
_T11f:
	return;
}

// FUNCTION: COPTER_D 0x005298b1
void BoatClass::TurnRight() {
// LINE 1996:
	this->flags[2] = 0x1;
// LINE 2000:
	__asm        jmp    _T18;
_T18:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 0x10;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 1;
	__asm        or     eax, ecx;
	__asm        je     _T4d;
// LINE 2003:
	__asm        mov    eax, this;
	__asm        add    eax, 0x6B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 2006:
	__asm        jmp    _T11f;
_T4d:
	__asm        jmp    _T52;
_T52:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 2;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x20;
	__asm        or     eax, ecx;
	__asm        je     _T87;
// LINE 2009:
	__asm        mov    eax, this;
	__asm        add    eax, 0x73;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 2012:
	__asm        jmp    _T11f;
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x40;
	__asm        or     eax, ecx;
	__asm        je     _Tc1;
// LINE 2015:
	__asm        mov    eax, this;
	__asm        add    eax, 0x63;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 2018:
	__asm        jmp    _T11f;
_Tc1:
	__asm        jmp    _Tc6;
_Tc6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xF];
	__asm        and    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xF];
	__asm        and    ecx, 0x80;
	__asm        or     eax, ecx;
	__asm        je     _Tfe;
// LINE 2021:
	__asm        mov    eax, this;
	__asm        add    eax, 0x5B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, this;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 2024:
	__asm        jmp    _T11f;
// LINE 2026:
_Tfe:
	__asm        push   0x7EA;
	__asm        push   0x5B75AC;
	__asm        push   0x5B75D0;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T11f;

	__asm        jmp    _T11f;
// LINE 2029:
_T11f:
	return;
}

// FUNCTION: COPTER_D 0x005299da
void BoatClass::MakeUturn() {
// LINE 2051:
	__asm        jmp    _T11;
_T11:
	__asm        jmp    _T16;
_T16:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::SetBoatDirection;
// LINE 2052:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustCurrentPosition;
// LINE 2053:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustNextPosition;
// LINE 2136:
	return;
}

// FUNCTION: COPTER_D 0x00529a36
int32_t BoatClass::FinishedUturn() {
// LINE 2158:
	return 0x1;
// LINE 2170:
}

// FUNCTION: COPTER_D 0x00529a51
void BoatClass::BeamBoatToWithinCameraRange() {
	/*bp-0x4*/   int32_t xdir;
	/*bp-0x8*/   int32_t ydir;
	/*bp-0xc*/   int32_t curr_dist;
	/*bp-0x10*/  int32_t spiral_dist;
	/*bp-0x1c*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x24*/  /*packed*/ struct Point2d beampoint; // 0x8 bytes
	/*bp-0x28*/  int32_t x;
	/*bp-0x2c*/  int32_t y;
	/*bp-0x30*/  int32_t i;
	/*bp-0x34*/  int32_t currentFlag;
	/*bp-0x38*/  int32_t curr_dir;
	/*bp-0x3c*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x40*/  int32_t stop_now;
	/*bp-0x44*/  int32_t foundcell;

// LINE 2192:
	curr_dist = 0x0;
// LINE 2193:
	curr_dir = 0xffffffff;
// LINE 2195:
	stop_now = 0x0;
// LINE 2196:
	spiral_dist = 0x7;
// LINE 2198:
	foundcell = 0x0;
// LINE 2202:
	__asm        mov    eax, 0x6C1210;
	__asm        add    eax, 0x14;
	__asm        lea    ecx, vec.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 2203:
	this->beamTimer = 0x0;
// LINE 2206:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0xF;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    [ebp-0x5C], eax;
	__asm        jmp    _T14d;
// LINE 2210:
_T70:
	vec.y = vec.z;
// LINE 2211:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 2212:
	vec.x = vec.y;
// LINE 2214:
	__asm        mov    eax, vec.x;
	__asm        mov    ecx, G_ViewSize;
	__asm        sar    ecx, 1;
	__asm        imul   eax, ecx;
	__asm        mov    vec.x, eax;
// LINE 2215:
	__asm        mov    eax, vec.z;
	__asm        mov    ecx, G_ViewSize;
	__asm        sar    ecx, 1;
	__asm        imul   eax, ecx;
	__asm        mov    vec.z, eax;
// LINE 2216:
	__asm        jmp    _T170;
// LINE 2219:
_Tad:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    vec.y, eax;
// LINE 2220:
	vec.z = vec.x;
// LINE 2221:
	vec.x = vec.y;
// LINE 2223:
	__asm        mov    eax, vec.x;
	__asm        mov    ecx, G_ViewSize;
	__asm        sar    ecx, 1;
	__asm        imul   eax, ecx;
	__asm        mov    vec.x, eax;
// LINE 2224:
	__asm        mov    eax, vec.z;
	__asm        mov    ecx, G_ViewSize;
	__asm        sar    ecx, 1;
	__asm        imul   eax, ecx;
	__asm        mov    vec.z, eax;
// LINE 2225:
	__asm        jmp    _T170;
// LINE 2228:
_Tea:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    vec.x, eax;
// LINE 2229:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    vec.z, eax;
// LINE 2231:
	__asm        mov    eax, vec.x;
	__asm        mov    ecx, G_ViewSize;
	__asm        sar    ecx, 1;
	__asm        imul   eax, ecx;
	__asm        mov    vec.x, eax;
// LINE 2232:
	__asm        mov    eax, vec.z;
	__asm        mov    ecx, G_ViewSize;
	__asm        sar    ecx, 1;
	__asm        imul   eax, ecx;
	__asm        mov    vec.z, eax;
// LINE 2233:
	__asm        jmp    _T170;
// LINE 2237:
_T123:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        inc    eax;
	__asm        imul   eax, vec.x;
	__asm        mov    vec.x, eax;
// LINE 2238:
	__asm        mov    eax, G_ViewSize;
	__asm        sar    eax, 1;
	__asm        inc    eax;
	__asm        imul   eax, vec.z;
	__asm        mov    vec.z, eax;
// LINE 2239:
	__asm        jmp    _T170;
// LINE 2240:
	__asm        jmp    _T170;
_T14d:
	__asm        cmp    dword ptr [ebp-0x5C], 0;
	__asm        je     _T70;

	__asm        cmp    dword ptr [ebp-0x5C], 1;
	__asm        je     _Tad;

	__asm        cmp    dword ptr [ebp-0x5C], 2;
	__asm        je     _Tea;

	__asm        jmp    _T123;
// LINE 2242:
_T170:
	__asm        shl    vec.x, 6;
// LINE 2243:
	__asm        shl    vec.z, 6;
// LINE 2245:
	__asm        mov    eax, ViewState.world_pos.x;
	__asm        add    eax, vec.x;
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    x, eax;
// LINE 2246:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, ViewState.world_pos.z;
	__asm        add    ecx, vec.z;
	__asm        sub    eax, ecx;
	__asm        sar    eax, 0x16;
	__asm        mov    y, eax;
// LINE 2249:
	__asm        cmp    x, 0;
	__asm        jl     _T1c9;

	__asm        cmp    y, 0;
	__asm        jl     _T1c9;

	__asm        cmp    x, 0x7F;
	__asm        jg     _T1c9;

	__asm        cmp    y, 0x7F;
	__asm        jle    _T1ce;
// LINE 2250:
_T1c9:
	return;
// LINE 2257:
_T1ce:
	curr_dir++;
// LINE 2258:
	__asm        mov    eax, curr_dir;
	__asm        mov    [ebp-0x60], eax;
	__asm        jmp    _T23a;
// LINE 2262:
_T1dc:
	curr_dir = 0x0;
// LINE 2263:
	curr_dist++;
// LINE 2264:
	xdir = 0x0;
// LINE 2265:
	ydir = 0xffffffff;
// LINE 2266:
	__asm        jmp    _T262;
// LINE 2268:
_T1f9:
	xdir = 0x1;
// LINE 2269:
	ydir = 0x0;
// LINE 2270:
	__asm        jmp    _T262;
// LINE 2272:
_T20c:
	curr_dist++;
// LINE 2273:
	xdir = 0x0;
// LINE 2274:
	ydir = 0x1;
// LINE 2275:
	__asm        jmp    _T262;
// LINE 2277:
_T222:
	xdir = 0xffffffff;
// LINE 2278:
	ydir = 0x0;
// LINE 2279:
	__asm        jmp    _T262;
// LINE 2280:
	__asm        jmp    _T262;
_T23a:
	__asm        cmp    dword ptr [ebp-0x60], 4;
	__asm        ja     _T262;

	__asm        mov    eax, [ebp-0x60];
	__asm        jmp    _Switch_24e[0][eax*4];
// Switch pointers:
//   _T1dc
//   _T1f9
//   _T20c
//   _T222
//   _T1dc
// LINE 2284:
_T262:
	__asm        mov    eax, spiral_dist;
	__asm        cmp    curr_dist, eax;
	__asm        jne    _T278;
// LINE 2286:
	curr_dist--;
// LINE 2287:
	stop_now = 0x1;
// LINE 2291:
_T278:
	__asm        mov    i, 0;
	__asm        jmp    _T287;
_T284:
	i++;
_T287:
	__asm        mov    eax, i;
	__asm        cmp    curr_dist, eax;
	__asm        jle    _T3b8;
// LINE 2293:
// Block start:
	/*bp-0x48*/  unsigned short tile;
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    tile, ax;
	__asm        jmp    _T2b9;
// LINE 2295:
_T2b9:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _T2e0;

	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _T2e0;

	__asm        jmp    _T2f4;
_T2e0:
	__asm        jmp    _T2fe;

	__asm        jmp    _T2f4;

	__asm        cmp    dword ptr [ebp-0x4C], 0;
	__asm        je     _T2fe;
_T2f4:
	__asm        jmp    _T312;

	__asm        jmp    _T308;
_T2fe:
	__asm        jmp    _T393;

	__asm        jmp    _T312;
_T308:
	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        je     _T393;
// LINE 2297:
_T312:
	beampoint.x = x;
// LINE 2298:
	beampoint.y = y;
// LINE 2299:
	__asm        mov    eax, beampoint.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, beampoint.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x54], eax;
	__asm        cmp    dword ptr [ebp-0x54], 0;
	__asm        jne    _T362;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T367;
_T362:
	__asm        jmp    _T367;
_T367:
	__asm        jmp    _T36c;
_T36c:
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    cptr, eax;
// LINE 2300:
	__asm        mov    eax, cptr;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        jne    _T393;

	__asm        mov    eax, cptr;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T393;
// LINE 2302:
	foundcell = 0x1;
// LINE 2305:
_T393:
	__asm        cmp    foundcell, 0;
	__asm        je     _T3a7;

	__asm        jmp    _T48b;

	__asm        jmp    foundCell;
// LINE 2306:
_T3a7:
	x += xdir;
// LINE 2307:
	y += ydir;
// LINE 2308:
// Block end:
	__asm        jmp    _T284;
// LINE 2310:
_T3b8:
	__asm        cmp    stop_now, 1;
	__asm        jne    _T3c7;
// LINE 2312:
	__asm        jmp    _T3cc;
// LINE 2314:
_T3c7:
	__asm        jmp    _T1ce;
// LINE 2317:
_T3cc:
	return;
// LINE 2323:
foundCell:
	__asm        mov    currentFlag, 2;
	__asm        jmp    _T3e0;
_T3dd:
	currentFlag++;
_T3e0:
	__asm        cmp    currentFlag, 7;
	__asm        jge    _T3fa;
// LINE 2325:
	__asm        mov    eax, currentFlag;
	__asm        mov    ecx, this;
	__asm        mov    byte ptr [eax+ecx+4], 0;
// LINE 2326:
	__asm        jmp    _T3dd;
// LINE 2328:
_T3fa:
	this->direction = 0x0;
// LINE 2329:
	this->speed = 0x0;
// LINE 2330:
	this->flags[1] = 0x1;
// LINE 2335:
	__asm        mov    eax, beampoint.x;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x33], eax;
	__asm        mov    eax, beampoint.y;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x37], eax;
	__asm        jmp    _T42c;
// LINE 2339:
_T42c:
	__asm        jmp    _T431;
_T431:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::LinkToCell;
// LINE 2343:
	__asm        jmp    _T445;
_T445:
	__asm        jmp    _T44a;
_T44a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x37];
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x33];
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::SetBoatDirection;
// LINE 2344:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustCurrentPosition;
// LINE 2345:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustNextPosition;
// LINE 2347:
	return;
_T48b:
	__asm        jmp    foundCell;
}

// FUNCTION: COPTER_D 0x00529ee6
void BoatClass::UnPlaceBoat() {
// LINE 2370:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T3b;
// LINE 2372:
	__asm        jmp    _T25;
_T25:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnlinkFromCell;
// LINE 2373:
	this->flags[1] = 0x0;
// LINE 2375:
_T3b:
	return;
}

// FUNCTION: COPTER_D 0x00529f2b
int32_t BoatClass::BeamBoatToLocation(long mapx, long mapy) {
	/*bp-0x4*/   int32_t xdir;
	/*bp-0x8*/   int32_t ydir;
	/*bp-0xc*/   int32_t curr_dist;
	/*bp-0x10*/  int32_t spiral_dist;
	/*bp-0x18*/  /*packed*/ struct Point2d beampoint; // 0x8 bytes
	/*bp-0x1c*/  int32_t x;
	/*bp-0x20*/  int32_t y;
	/*bp-0x24*/  int32_t i;
	/*bp-0x28*/  int32_t currentFlag;
	/*bp-0x2c*/  int32_t curr_dir;
	/*bp-0x30*/  /*packed*/ struct _CELL_INFO *cptr;
	/*bp-0x34*/  int32_t stop_now;
	/*bp-0x38*/  int32_t foundcell;

// LINE 2397:
	curr_dist = 0x0;
// LINE 2398:
	curr_dir = 0xffffffff;
// LINE 2400:
	stop_now = 0x0;
// LINE 2401:
	spiral_dist = 0x1f;
// LINE 2403:
	foundcell = 0x0;
// LINE 2407:
	x = mapx;
// LINE 2408:
	y = mapy;
// LINE 2415:
_T41:
	curr_dir++;
// LINE 2416:
	__asm        mov    eax, curr_dir;
	__asm        mov    [ebp-0x9C], eax;
	__asm        jmp    _Tb0;
// LINE 2420:
_T52:
	curr_dir = 0x0;
// LINE 2421:
	curr_dist++;
// LINE 2422:
	xdir = 0x0;
// LINE 2423:
	ydir = 0xffffffff;
// LINE 2424:
	__asm        jmp    _Tde;
// LINE 2426:
_T6f:
	xdir = 0x1;
// LINE 2427:
	ydir = 0x0;
// LINE 2428:
	__asm        jmp    _Tde;
// LINE 2430:
_T82:
	curr_dist++;
// LINE 2431:
	xdir = 0x0;
// LINE 2432:
	ydir = 0x1;
// LINE 2433:
	__asm        jmp    _Tde;
// LINE 2435:
_T98:
	xdir = 0xffffffff;
// LINE 2436:
	ydir = 0x0;
// LINE 2437:
	__asm        jmp    _Tde;
// LINE 2438:
	__asm        jmp    _Tde;
_Tb0:
	__asm        cmp    dword ptr [ebp-0x9C], 4;
	__asm        ja     _Tde;

	__asm        mov    eax, [ebp-0x9C];
	__asm        jmp    _Switch_ca[0][eax*4];
// Switch pointers:
//   _T52
//   _T6f
//   _T82
//   _T98
//   _T52
// LINE 2442:
_Tde:
	__asm        mov    eax, curr_dist;
	__asm        cmp    spiral_dist, eax;
	__asm        jne    _Tf4;
// LINE 2444:
	curr_dist--;
// LINE 2445:
	stop_now = 0x1;
// LINE 2449:
_Tf4:
	__asm        mov    i, 0;
	__asm        jmp    _T103;
_T100:
	i++;
_T103:
	__asm        mov    eax, i;
	__asm        cmp    curr_dist, eax;
	__asm        jle    _T7ae;
// LINE 2451:
// Block start:
	/*bp-0x3c*/  unsigned short tile;
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        mov    tile, ax;
	__asm        jmp    _T135;
// LINE 2455:
_T135:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x7B], 0x163;
	__asm        jne    _T6ad;
// LINE 2465:
	__asm        jmp    _T14d;
_T14d:
	__asm        mov    eax, y;
	__asm        dec    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T1a2;

	__asm        mov    eax, y;
	__asm        dec    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T1a2;

	__asm        jmp    _T1b6;
_T1a2:
	__asm        jmp    _T1c0;

	__asm        jmp    _T1b6;

	__asm        cmp    dword ptr [ebp-0x40], 0;
	__asm        je     _T1c0;
_T1b6:
	__asm        jmp    _T1d4;

	__asm        jmp    _T1ca;
_T1c0:
	__asm        jmp    _T6a8;

	__asm        jmp    _T1d4;
_T1ca:
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        je     _T6a8;
_T1d4:
	__asm        jmp    _T1d9;
_T1d9:
	__asm        mov    eax, y;
	__asm        dec    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T22c;

	__asm        mov    eax, y;
	__asm        dec    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T22c;

	__asm        jmp    _T240;
_T22c:
	__asm        jmp    _T24a;

	__asm        jmp    _T240;

	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        je     _T24a;
_T240:
	__asm        jmp    _T25e;

	__asm        jmp    _T254;
_T24a:
	__asm        jmp    _T6a8;

	__asm        jmp    _T25e;
_T254:
	__asm        cmp    dword ptr [ebp-0x4C], 0;
	__asm        je     _T6a8;
_T25e:
	__asm        jmp    _T263;
_T263:
	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, y;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T2b8;

	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, y;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T2b8;

	__asm        jmp    _T2cc;
_T2b8:
	__asm        jmp    _T2d6;

	__asm        jmp    _T2cc;

	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        je     _T2d6;
_T2cc:
	__asm        jmp    _T2ea;

	__asm        jmp    _T2e0;
_T2d6:
	__asm        jmp    _T6a8;

	__asm        jmp    _T2ea;
_T2e0:
	__asm        cmp    dword ptr [ebp-0x54], 0;
	__asm        je     _T6a8;
_T2ea:
	__asm        jmp    _T2ef;
_T2ef:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T342;

	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T342;

	__asm        jmp    _T356;
_T342:
	__asm        jmp    _T360;

	__asm        jmp    _T356;

	__asm        cmp    dword ptr [ebp-0x58], 0;
	__asm        je     _T360;
_T356:
	__asm        jmp    _T374;

	__asm        jmp    _T36a;
_T360:
	__asm        jmp    _T6a8;

	__asm        jmp    _T374;
_T36a:
	__asm        cmp    dword ptr [ebp-0x5C], 0;
	__asm        je     _T6a8;
_T374:
	__asm        jmp    _T379;
_T379:
	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T3ca;

	__asm        mov    eax, y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T3ca;

	__asm        jmp    _T3de;
_T3ca:
	__asm        jmp    _T3e8;

	__asm        jmp    _T3de;

	__asm        cmp    dword ptr [ebp-0x60], 0;
	__asm        je     _T3e8;
_T3de:
	__asm        jmp    _T3fc;

	__asm        jmp    _T3f2;
_T3e8:
	__asm        jmp    _T6a8;

	__asm        jmp    _T3fc;
_T3f2:
	__asm        cmp    dword ptr [ebp-0x64], 0;
	__asm        je     _T6a8;
_T3fc:
	__asm        jmp    _T401;
_T401:
	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, y;
	__asm        and    ecx, 0xFF;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T454;

	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, y;
	__asm        and    ecx, 0xFF;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T454;

	__asm        jmp    _T468;
_T454:
	__asm        jmp    _T472;

	__asm        jmp    _T468;

	__asm        cmp    dword ptr [ebp-0x68], 0;
	__asm        je     _T472;
_T468:
	__asm        jmp    _T486;

	__asm        jmp    _T47c;
_T472:
	__asm        jmp    _T6a8;

	__asm        jmp    _T486;
_T47c:
	__asm        cmp    dword ptr [ebp-0x6C], 0;
	__asm        je     _T6a8;
_T486:
	__asm        jmp    _T48b;
_T48b:
	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T4e0;

	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        dec    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T4e0;

	__asm        jmp    _T4f4;
_T4e0:
	__asm        jmp    _T4fe;

	__asm        jmp    _T4f4;

	__asm        cmp    dword ptr [ebp-0x70], 0;
	__asm        je     _T4fe;
_T4f4:
	__asm        jmp    _T512;

	__asm        jmp    _T508;
_T4fe:
	__asm        jmp    _T6a8;

	__asm        jmp    _T512;
_T508:
	__asm        cmp    dword ptr [ebp-0x74], 0;
	__asm        je     _T6a8;
_T512:
	__asm        jmp    _T517;
_T517:
	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T56a;

	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T56a;

	__asm        jmp    _T57e;
_T56a:
	__asm        jmp    _T588;

	__asm        jmp    _T57e;

	__asm        cmp    dword ptr [ebp-0x78], 0;
	__asm        je     _T588;
_T57e:
	__asm        jmp    _T59c;

	__asm        jmp    _T592;
_T588:
	__asm        jmp    _T6a8;

	__asm        jmp    _T59c;
_T592:
	__asm        cmp    dword ptr [ebp-0x7C], 0;
	__asm        je     _T6a8;
_T59c:
	__asm        jmp    _T5a1;
_T5a1:
	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        inc    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 5;
	__asm        jl     _T5f6;

	__asm        mov    eax, y;
	__asm        inc    eax;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, x;
	__asm        inc    ecx;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 8;
	__asm        xor    edx, edx;
	__asm        mov    dl, G_texmap[0][eax+ecx];
	__asm        cmp    edx, 9;
	__asm        jg     _T5f6;

	__asm        jmp    _T60a;
_T5f6:
	__asm        jmp    _T614;

	__asm        jmp    _T60a;

	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        je     _T614;
_T60a:
	__asm        jmp    _T62b;

	__asm        jmp    _T61e;
_T614:
	__asm        jmp    _T6a8;

	__asm        jmp    _T62b;
_T61e:
	__asm        cmp    dword ptr [ebp-0x84], 0;
	__asm        je     _T6a8;
// LINE 2467:
_T62b:
	beampoint.x = x;
// LINE 2468:
	beampoint.y = y;
// LINE 2469:
	__asm        mov    eax, beampoint.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, beampoint.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x90], eax;
	__asm        cmp    dword ptr [ebp-0x90], 0;
	__asm        jne    _T681;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T686;
_T681:
	__asm        jmp    _T686;
_T686:
	__asm        jmp    _T68b;
_T68b:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    cptr, eax;
// LINE 2470:
	__asm        mov    eax, cptr;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        jne    _T6a8;
// LINE 2472:
	foundcell = 0x1;
// LINE 2476:
_T6a8:
	__asm        jmp    _T789;
_T6ad:
	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 5;
	__asm        jl     _T6d4;

	__asm        mov    eax, reinterpret_cast<uint32_t>(tile);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 9;
	__asm        jg     _T6d4;

	__asm        jmp    _T6eb;
_T6d4:
	__asm        jmp    _T6f5;

	__asm        jmp    _T6eb;

	__asm        cmp    dword ptr [ebp-0x88], 0;
	__asm        je     _T6f5;
_T6eb:
	__asm        jmp    _T70c;

	__asm        jmp    _T6ff;
_T6f5:
	__asm        jmp    _T789;

	__asm        jmp    _T70c;
_T6ff:
	__asm        cmp    dword ptr [ebp-0x8C], 0;
	__asm        je     _T789;
// LINE 2478:
_T70c:
	beampoint.x = x;
// LINE 2479:
	beampoint.y = y;
// LINE 2480:
	__asm        mov    eax, beampoint.y;
	__asm        and    eax, 0xFF;
	__asm        mov    ecx, beampoint.x;
	__asm        and    ecx, 0xFF;
	__asm        shl    ecx, 0xA;
	__asm        mov    eax, G_omap[0][0][ecx+eax*4];
	__asm        mov    [ebp-0x94], eax;
	__asm        cmp    dword ptr [ebp-0x94], 0;
	__asm        jne    _T762;

	__asm        push   0xBA;
	__asm        push   0x5B7668;
	__asm        push   0x5B57B8;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T767;
_T762:
	__asm        jmp    _T767;
_T767:
	__asm        jmp    _T76c;
_T76c:
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    cptr, eax;
// LINE 2481:
	__asm        mov    eax, cptr;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        jne    _T789;
// LINE 2483:
	foundcell = 0x1;
// LINE 2486:
_T789:
	__asm        cmp    foundcell, 0;
	__asm        je     _T79d;

	__asm        jmp    _T8e5;

	__asm        jmp    foundCell;
// LINE 2487:
_T79d:
	x += xdir;
// LINE 2488:
	y += ydir;
// LINE 2489:
// Block end:
	__asm        jmp    _T100;
// LINE 2491:
_T7ae:
	__asm        cmp    stop_now, 1;
	__asm        jne    _T7bd;
// LINE 2493:
	__asm        jmp    _T7c2;
// LINE 2495:
_T7bd:
	__asm        jmp    _T41;
// LINE 2498:
_T7c2:
	return 0x0;
// LINE 2504:
foundCell:
	__asm        mov    currentFlag, 2;
	__asm        jmp    _T7d8;
_T7d5:
	currentFlag++;
_T7d8:
	__asm        cmp    currentFlag, 7;
	__asm        jge    _T7f5;
// LINE 2506:
	__asm        mov    eax, currentFlag;
	__asm        mov    ecx, this;
	__asm        mov    byte ptr [eax+ecx+4], 0;
// LINE 2507:
	__asm        jmp    _T7d5;
// LINE 2509:
_T7f5:
	this->direction = 0x0;
// LINE 2510:
	this->speed = 0x0;
// LINE 2513:
	__asm        jmp    _T814;
_T814:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T845;
// LINE 2515:
	__asm        jmp    _T82b;
_T82b:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::UnlinkFromCell;
// LINE 2517:
	__asm        jmp    _T84f;
// LINE 2519:
_T845:
	this->flags[1] = 0x1;
// LINE 2522:
_T84f:
	__asm        mov    eax, beampoint.x;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x33], eax;
	__asm        mov    eax, beampoint.y;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x37], eax;
	__asm        jmp    _T86c;
// LINE 2526:
_T86c:
	__asm        jmp    _T871;
_T871:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::LinkToCell;
// LINE 2530:
	__asm        jmp    _T88b;
_T88b:
	__asm        jmp    _T890;
_T890:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x33];
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x37];
	__asm        and    ecx, 0xFF;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::SetBoatDirection;
// LINE 2531:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustCurrentPosition;
// LINE 2532:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustNextPosition;
// LINE 2534:
	return 0x1;
// LINE 2536:
_T8e5:
	__asm        jmp    foundCell;
}

// FUNCTION: COPTER_D 0x0052a81c
int32_t BoatClass::InitializeInstance(long mapx, long mapy, int32_t instanceID) {
	/*bp-0x24*/  /*packed*/ struct VRObjInfo objectInfo; // 0x24 bytes
	/*bp-0x28*/  int32_t object;

// LINE 2816:
	this->dyObj.mesh = 0x0;
// LINE 2837:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7B];
	__asm        push   eax;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        mov    object, eax;
// LINE 2839:
	__asm        cmp    object, 0;
	__asm        jne    _T5d;
// LINE 2842:
	__asm        push   0xB1A;
	__asm        push   0x5B75D8;
	__asm        push   0x5B75FC;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T56;

	__asm        jmp    _T56;
// LINE 2843:
_T56:
	return 0x0;
// LINE 2847:
_T5d:
	__asm        cmp    instanceID, 0;
	__asm        jne    _T78;
// LINE 2850:
	this->dyObj.mesh = object;
// LINE 2852:
	__asm        jmp    _T155;
// LINE 2857:
// Block start:
	/*bp-0x2c*/  char * objectMemory;
_T78:
	__asm        mov    eax, object;
	__asm        push   eax;
	__asm        call   0x004D8520;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        mov    eax, G_dyobjmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    objectMemory, eax;
// LINE 2859:
	__asm        cmp    objectMemory, 0;
	__asm        je     _T123;
// LINE 2863:
	__asm        mov    eax, objectMemory;
	__asm        push   eax;
	__asm        mov    eax, object;
	__asm        push   eax;
	__asm        call   0x004D8570;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x87], eax;
// LINE 2865:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x87], 0;
	__asm        je     _Te6;
// LINE 2868:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x87];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 2870:
	__asm        jmp    _T11e;
// LINE 2873:
_Te6:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x87], 0;
	__asm        jne    _T112;

	__asm        push   0xB39;
	__asm        push   0x5B7604;
	__asm        push   0x5B7628;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T117;
_T112:
	__asm        jmp    _T117;
// LINE 2874:
_T117:
	return 0x0;
// LINE 2877:
_T11e:
	__asm        jmp    _T155;
// LINE 2880:
_T123:
	__asm        cmp    objectMemory, 0;
	__asm        jne    _T149;

	__asm        push   0xB40;
	__asm        push   0x5B7634;
	__asm        push   0x5B7658;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T14e;
_T149:
	__asm        jmp    _T14e;
// LINE 2881:
_T14e:
	return 0x0;
// LINE 2886:
// Block end:
_T155:
	__asm        mov    eax, instanceID;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x8D], ax;
// LINE 2887:
	this->dyObj.flags = 0x201;
// LINE 2889:
	__asm        mov    eax, this;
	__asm        add    eax, 0xA3;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 2890:
	__asm        lea    eax, objectInfo.Faces;
	__asm        push   eax;
	__asm        mov    eax, object;
	__asm        push   eax;
	__asm        call   0x004D8859;
	__asm        add    esp, 8;
// LINE 2891:
	this->dyObj.radius = objectInfo.Radius;
// LINE 2892:
	__asm        mov    eax, object;
	__asm        push   eax;
	__asm        call   VRObjGetHeight;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x93], eax;
// LINE 2895:
	this->flags[2] = 0x0;
// LINE 2896:
	this->beamTimer = 0x0;
// LINE 2897:
	this->beamDelay = 0x0;
// LINE 2898:
	this->currentLocation.x = mapx;
// LINE 2899:
	this->currentLocation.y = mapy;
// LINE 2900:
	this->currentCell.x = mapx;
// LINE 2901:
	this->currentCell.y = mapy;
// LINE 2902:
	this->nextLocation.x = mapx;
// LINE 2903:
	this->nextLocation.y = mapy;
// LINE 2904:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 3;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        shl    eax, 0x11;
	__asm        add    eax, 0xA0000;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x2F], eax;
// LINE 2905:
	this->sprayTimer = 0xe666;
// LINE 2909:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7B];
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T24f;
// LINE 2912:
_T23b:
	this->beamDelay = 0xa0000;
// LINE 2913:
	__asm        jmp    _T261;
// LINE 2914:
	__asm        jmp    _T261;
_T24f:
	__asm        cmp    dword ptr [ebp-0x34], 0x12F;
	__asm        je     _T23b;

	__asm        jmp    _T261;
// LINE 2918:
_T261:
	__asm        cmp    mapx, 0xFFFFFFFF;
	__asm        je     _T2dc;

	__asm        cmp    mapy, 0xFFFFFFFF;
	__asm        je     _T2dc;
// LINE 2921:
	__asm        mov    eax, this;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::LinkToCell;
// LINE 2924:
	__asm        jmp    _T289;
_T289:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x33];
	__asm        and    eax, 0xFF;
	__asm        shl    eax, 8;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x37];
	__asm        and    ecx, 0xFF;
	__asm        movzx  ax, G_texmap[0][eax+ecx];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   BoatClass::SetBoatDirection;
// LINE 2925:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustCurrentPosition;
// LINE 2926:
	__asm        mov    ecx, this;
	__asm        call   BoatClass::AdjustNextPosition;
// LINE 2930:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 2934:
	this->flags[1] = 0x1;
// LINE 2936:
	__asm        jmp    _T2e3;
// LINE 2939:
_T2dc:
	this->flags[1] = 0x0;
// LINE 2947:
_T2e3:
	__asm        mov    eax, this;
	__asm        mov    ecx, instanceID;
	__asm        mov    boats[0][ecx*4], eax;
// LINE 2950:
	this->flags[0] = 0x1;
// LINE 2952:
	return 0x1;
// LINE 2953:
}

// FUNCTION: COPTER_D 0x0052ab24
int32_t CreateBoatInstance(int32_t instanceID) {
// LINE 3001:
	__asm        mov    eax, instanceID;
	__asm        push   eax;
	__asm        call   BoatClass::CreateInstance;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T24;

	__asm        mov    eax, 1;
	__asm        jmp    _T26;
_T24:
	__asm        xor    eax, eax;
_T26:
	__asm        jmp    __RETURN;
// LINE 3002:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052ab54
void ItterateAllBoats() {
// LINE 3024:
	__asm        call   BoatClass::ItterateAll;
// LINE 3025:
	return;
}

// FUNCTION: COPTER_D 0x0052ab69
void ResetAllBoats() {
// LINE 3047:
	__asm        call   BoatClass::ResetAll;
// LINE 3048:
	return;
}

// FUNCTION: COPTER_D 0x0052ab7e
/*packed*/ struct _DYOBJ_INST* BoatClass::StartCapsizedBoat(long mission_id, int32_t timetolive) {
	/*bp-0x4*/   /*packed*/ class BoatClass *capboat;
	/*bp-0x8*/   long totalpersons;
	/*bp-0xc*/   long count;
	/*bp-0x10*/  long x;
	/*bp-0x14*/  long y;
	/*bp-0x2c*/  /*packed*/ struct _MISSION_PARMS mp; // 0x18 bytes
	/*bp-0x30*/  long numtostart;

// LINE 3066:
	capboat = boats[0];
// LINE 3068:
	__asm        jmp    _T16;
_T16:
	__asm        mov    eax, capboat;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        cmp    eax, 1;
	__asm        jne    _T2d;
// LINE 3069:
	return 0x0;
// LINE 3071:
_T2d:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0x7F;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    x, eax;
// LINE 3072:
	__asm        call   rand;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        and    eax, 0x7F;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    y, eax;
// LINE 3074:
	__asm        mov    eax, y;
	__asm        push   eax;
	__asm        mov    eax, x;
	__asm        push   eax;
	__asm        mov    eax, capboat;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, capboat;
	__asm        call   dword ptr [eax+0x18];
	__asm        test   eax, eax;
	__asm        jne    _T7d;
// LINE 3075:
	return 0x0;
// LINE 3077:
_T7d:
	capboat->missionId = mission_id;
// LINE 3078:
	capboat->timeToLive = timetolive;
// LINE 3081:
	__asm        call   rand;
	__asm        mov    ecx, 3;
	__asm        movsx  eax, ax;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+3];
	__asm        mov    numtostart, eax;
// LINE 3082:
	totalpersons = 0x0;
// LINE 3083:
	__asm        mov    count, 0;
	__asm        jmp    _Tbb;
_Tb8:
	count++;
_Tbb:
	__asm        mov    eax, numtostart;
	__asm        cmp    count, eax;
	__asm        jge    _T106;
// LINE 3090:
	__asm        push   0;
	__asm        mov    eax, capboat;
	__asm        add    eax, 0x7F;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        mov    eax, capboat;
	__asm        movzx  ax, byte ptr [eax+0x37];
	__asm        push   eax;
	__asm        mov    eax, capboat;
	__asm        movzx  ax, byte ptr [eax+0x33];
	__asm        push   eax;
	__asm        push   1;
	__asm        push   0xFFFFFFFF;
	__asm        call   StartPerson;
	__asm        add    esp, 0x1C;
	__asm        movsx  eax, ax;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jle    _T101;
// LINE 3092:
	totalpersons++;
// LINE 3094:
_T101:
	__asm        jmp    _Tb8;
// LINE 3097:
_T106:
	__asm        cmp    totalpersons, 0;
	__asm        jne    _T11f;
// LINE 3099:
	__asm        mov    ecx, capboat;
	__asm        call   BoatClass::UnPlaceBoat;
// LINE 3100:
	return 0x0;
// LINE 3104:
_T11f:
	mp.op = 0x0;
// LINE 3105:
	mp.id = capboat->missionId;
// LINE 3106:
	mp.maploc.x = capboat->currentLocation.x;
// LINE 3107:
	mp.maploc.y = capboat->currentLocation.y;
// LINE 3108:
	__asm        lea    eax, mp.op;
	__asm        push   eax;
	__asm        call   S3MissionUpdate;
	__asm        add    esp, 4;
// LINE 3110:
	mp.op = 0xe;
// LINE 3111:
	mp.i2num = totalpersons;
// LINE 3112:
	mp.flags = 0x1;
// LINE 3113:
	__asm        lea    eax, mp.op;
	__asm        push   eax;
	__asm        call   S3MissionUpdate;
	__asm        add    esp, 4;
// LINE 3115:
	return (capboat + 0x7f);
// LINE 3116:
}

// FUNCTION: COPTER_D 0x0052acfb
/*packed*/ struct _DYOBJ_INST* BoatClass::GetCapsizedBoat() {
	/*bp-0x4*/   /*packed*/ class BoatClass *capboat;

// LINE 3129:
	capboat = boats[0];
// LINE 3131:
	__asm        jmp    _T16;
_T16:
	__asm        mov    eax, capboat;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        jne    _T2c;
// LINE 3132:
	return 0x0;
// LINE 3134:
_T2c:
	return (capboat + 0x7f);
// LINE 3135:
}

// FUNCTION: COPTER_D 0x0052ad37
/*packed*/ struct _DYOBJ_INST* StartCapsizedBoat(long mission_id, int32_t timetolive) {
// LINE 3148:
	__asm        mov    eax, timetolive;
	__asm        push   eax;
	__asm        mov    eax, mission_id;
	__asm        push   eax;
	__asm        call   BoatClass::StartCapsizedBoat;
	__asm        add    esp, 8;
	__asm        jmp    __RETURN;
// LINE 3149:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052ad57
/*packed*/ struct _DYOBJ_INST* GetCapsizedBoat() {
// LINE 3162:
	__asm        call   BoatClass::GetCapsizedBoat;
	__asm        jmp    __RETURN;
// LINE 3163:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052ad6c
int32_t S3BoatMIFFLoad(void * __ptr32 miffReader) {
// LINE 3175:
	__asm        mov    eax, miffReader;
	__asm        push   eax;
	__asm        call   BoatClass::MIFFLoad;
	__asm        add    esp, 4;
	__asm        jmp    __RETURN;
// LINE 3176:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052ad88
int32_t S3BoatMIFFSave(void * __ptr32 miffWriter) {
// LINE 3188:
	__asm        mov    eax, miffWriter;
	__asm        push   eax;
	__asm        call   BoatClass::MIFFSave;
	__asm        add    esp, 4;
	__asm        jmp    __RETURN;
// LINE 3189:
__RETURN:
}

// FUNCTION: COPTER_D 0x0052ada4
int32_t BoatClass::MIFFLoad(void * __ptr32 miffReader) {
	/*bp-0x4*/   /*packed*/ class BoatClass *b;
	/*bp-0x8*/   int32_t ret;
	/*bp-0xc*/   int32_t i;

// LINE 3207:
	__asm        push   0xE3;
	__asm        push   0x62B5F0;
	__asm        push   0x424F4154;
	__asm        mov    eax, miffReader;
	__asm        push   eax;
	__asm        call   ReadFirstMIFFChunk;
	__asm        add    esp, 0x10;
	__asm        mov    ret, eax;
// LINE 3208:
	__asm        cmp    ret, 0;
	__asm        jne    _T38;
// LINE 3209:
	return 0x0;
// LINE 3211:
_T38:
	__asm        mov    i, 0;
	__asm        jmp    _T47;
_T44:
	i++;
_T47:
	__asm        cmp    i, 3;
	__asm        jge    _T257;
// LINE 3214:
	__asm        mov    eax, i;
	__asm        mov    eax, boats[0][eax*4];
	__asm        mov    b, eax;
// LINE 3215:
	b->sprayTimer = BoatClass::lsBoat.sprayTimer;
// LINE 3216:
	b->direction = BoatClass::lsBoat.direction;
// LINE 3217:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x13;
	__asm        mov    ecx, b;
	__asm        add    ecx, 0x13;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 3218:
	b->remainingDist = BoatClass::lsBoat.remainingDist;
// LINE 3219:
	b->remainingTime = BoatClass::lsBoat.remainingTime;
// LINE 3220:
	b->utdirection = BoatClass::lsBoat.utdirection;
// LINE 3221:
	b->speed = BoatClass::lsBoat.speed;
// LINE 3222:
	b->desiredSpeed = BoatClass::lsBoat.desiredSpeed;
// LINE 3223:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x33;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, b;
	__asm        add    edx, 0x33;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3224:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x3B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, b;
	__asm        add    edx, 0x3B;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3225:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x43;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, b;
	__asm        add    edx, 0x43;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3226:
	b->beamDelay = BoatClass::lsBoat.beamDelay;
// LINE 3227:
	b->beamTimer = BoatClass::lsBoat.beamTimer;
// LINE 3228:
	b->missionId = BoatClass::lsBoat.missionId;
// LINE 3229:
	b->timeToLive = BoatClass::lsBoat.timeToLive;
// LINE 3230:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x5B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, b;
	__asm        add    edx, 0x5B;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3231:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x6B;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, b;
	__asm        add    edx, 0x6B;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3232:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x73;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, b;
	__asm        add    edx, 0x73;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3233:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x63;
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        mov    edx, b;
	__asm        add    edx, 0x63;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 3234:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 0x97;
	__asm        mov    ecx, b;
	__asm        add    ecx, 0x97;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 3235:
	__asm        mov    edi, b;
	__asm        add    edi, 0xA3;
	__asm        lea    esi, BoatClass::lsBoat.dyObj.matrix[0][0];
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 3236:
	__asm        mov    eax, 0x62B5F0;
	__asm        add    eax, 4;
	__asm        mov    ecx, b;
	__asm        add    ecx, 4;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    dx, [eax+4];
	__asm        mov    [ecx+4], dx;
	__asm        mov    al, [eax+6];
	__asm        mov    [ecx+6], al;
// LINE 3238:
	__asm        jmp    _T1fb;
_T1fb:
	__asm        mov    eax, b;
	__asm        movsx  eax, byte ptr [eax+5];
	__asm        test   eax, eax;
	__asm        je     _T219;
// LINE 3240:
	__asm        mov    eax, b;
	__asm        add    eax, 0x33;
	__asm        push   eax;
	__asm        mov    ecx, b;
	__asm        call   BoatClass::LinkToCell;
// LINE 3247:
_T219:
	__asm        push   0xE3;
	__asm        push   0x62B5F0;
	__asm        push   0x424F4154;
	__asm        mov    eax, miffReader;
	__asm        push   eax;
	__asm        call   ReadNextMIFFChunk;
	__asm        add    esp, 0x10;
	__asm        mov    ret, eax;
// LINE 3249:
	__asm        cmp    ret, 0;
	__asm        jne    _T252;

	__asm        cmp    i, 2;
	__asm        je     _T252;
// LINE 3250:
	return 0x0;
// LINE 3251:
_T252:
	__asm        jmp    _T44;
// LINE 3252:
_T257:
	return 0x1;
// LINE 3253:
}

// FUNCTION: COPTER_D 0x0052b00a
int32_t BoatClass::MIFFSave(void * __ptr32 miffWriter) {
	/*bp-0x4*/   int32_t ret;
	/*bp-0x8*/   int32_t i;

// LINE 3266:
	__asm        mov    i, 0;
	__asm        jmp    _T18;
_T15:
	i++;
_T18:
	__asm        cmp    i, 3;
	__asm        jge    _T5c;
// LINE 3271:
	__asm        push   0xE3;
	__asm        mov    eax, i;
	__asm        mov    eax, boats[0][eax*4];
	__asm        push   eax;
	__asm        push   0x424F4154;
	__asm        mov    eax, miffWriter;
	__asm        push   eax;
	__asm        call   WriteMIFFChunk;
	__asm        add    esp, 0x10;
	__asm        mov    ret, eax;
// LINE 3272:
	__asm        cmp    ret, 0;
	__asm        jne    _T57;
// LINE 3273:
	return 0x0;
// LINE 3274:
_T57:
	__asm        jmp    _T15;
// LINE 3275:
_T5c:
	return 0x1;
// LINE 3276:
}



// Contribution: 1:0012a080-0012a0b8 Module: 164, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0052b080
// BoatClass::`scalar deleting destructor'



// Contribution: 2:00004200-0000421b Module: 164, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for BoatClass @ 0x00593200
//   00: BoatClass::`scalar deleting destructor' @ 0x0052b080
//   01: BoatClass::ItterateFSM @ 0x005279ef
//   02: BoatClass::AdjustSpeed @ 0x00527c7a
//   03: BoatClass::IsWaterPathClear @ 0x00527cb3
//   04: BoatClass::PickTurnDirection @ 0x00528918
//   05: BoatClass::BeamBoatToWithinCameraRange @ 0x00529a51
//   06: BoatClass::BeamBoatToLocation @ 0x00529f2b
//   7 entries



// Contribution: 3:000000a4-000000a7 Module: 164, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005970a4
static void (*$S8)() = { 0 /* todo */ };



// Contribution: 3:000203e8-00020664 Module: 164, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b73e8
/*packed*/ struct Point2d BoatClass::lastScannedLocation = { 0 /* todo */ };



// Contribution: 3:00020668-00020688 Module: 164, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "C:\Copter\Source\Game\S3WMOBIL.H"


// Contribution: 3:000945f0-000946e4 Module: 164, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0062b5f0
/*packed*/ class BoatClass BoatClass::lsBoat;

// GLOBAL: COPTER_D 0x0062b6d8
/*packed*/ class BoatClass *boats[3];

// GLOBAL: COPTER_D 0x0062b6e4
// $S5


// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.
// GLOBAL: COPTER_D 0x0066eb10
unsigned char G_texmap[256][256]; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\game\S3fire.c
// GLOBAL: COPTER_D 0x0066eb10
unsigned char G_texmap[256][256]; // Contrib missing

