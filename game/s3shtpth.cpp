// Module: S3shtpth.obj
// Source: C:\Copter\Source\Game\S3shtpth.cpp
// autogenerated by simcopter_tool from PDB file

// Type: const enum DirectionTypes[4];

// Type: class ShortestPath (forward reference);
class ShortestPath{
private:
	struct _FringeHeapNode* heap;
	long heapSize;
public:
	void Init();
	int32_t BreadthFirstSearch(struct _RGIndex, struct _RGIndex);
	int32_t DepthFirstSearch(struct _RGIndex, struct _RGIndex);
private:
	void PriorityHeapInsert(const struct _FringeHeapNode*);
	void PriorityHeapRemove(struct _FringeHeapNode*);
	int32_t FindDistanceFromDestination(struct _GridCoordinates, struct _GridCoordinates);
};

// Type: struct _GridCoordinates;
struct _GridCoordinates{
	unsigned char x;
	unsigned char y;
};

// Type: int32_t;

// Type: struct _RGIndex;
struct _RGIndex{
	unsigned char x;
	unsigned char yindex;
};

// Type: struct _FringeHeapNode;
struct _FringeHeapNode{
	unsigned char xCurr;
	unsigned char yindexCurr;
	unsigned char edgeIndexPrev;
	unsigned char xPrev;
	unsigned char yindexPrev;
	long cost;
};

// Type: struct RGVertex (forward reference);

// Type: struct Edge (forward reference);

// Type: struct _FringeHeapNode (forward reference);

// Type: void;



// Contribution: 1:00142690-00142f6c Module: 151, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00543690
int32_t ShortestPath::FindDistanceFromDestination(struct _GridCoordinates here, struct _GridCoordinates destination) {
	int32_t y;
	int32_t x;

// LINE 16:
	__asm        xor    eax, eax;
	__asm        mov    al, destination.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, here.x;
	__asm        sub    eax, ecx;
	__asm        mov    x, eax;
// LINE 17:
	__asm        xor    eax, eax;
	__asm        mov    al, destination.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, here.y;
	__asm        sub    eax, ecx;
	__asm        mov    y, eax;
// LINE 19:
	__asm        mov    eax, x;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    x, eax;
// LINE 20:
	__asm        mov    eax, y;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    y, eax;
// LINE 22:
	__asm        mov    eax, x;
	__asm        cmp    y, eax;
	__asm        jge    _T5f;
// LINE 24:
	__asm        mov    eax, y;
	__asm        sar    eax, 1;
	__asm        add    eax, x;
	__asm        jmp    _T6d;
// LINE 26:
	__asm        jmp    _T6d;
// LINE 28:
_T5f:
	__asm        mov    eax, x;
	__asm        sar    eax, 1;
	__asm        add    eax, y;
	__asm        jmp    _T6d;
// LINE 30:
_T6d:
}

// FUNCTION: COPTER_D 0x00543704
int32_t ShortestPath::BreadthFirstSearch(struct _RGIndex startVertex, struct _RGIndex destVertex) {
	int32_t pathFoundFlag;
	int32_t x;
	struct _FringeHeapNode path;
	struct RGVertex* pRGV;
	struct _FringeHeapNode scratch;

// LINE 37:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 40:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T74;

	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T74;
// LINE 42:
	__asm        mov    eax, pRGV;
	__asm        mov    byte ptr [eax+0x2E], 0xFF;
// LINE 43:
	__asm        mov    al, destVertex.yindex;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2C], al;
// LINE 44:
	__asm        mov    al, destVertex.x;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2D], al;
// LINE 45:
	__asm        mov    eax, 1;
	__asm        jmp    _T2b0;
// LINE 49:
_T74:
	__asm        mov    pathFoundFlag, 0;
// LINE 52:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5C3AB0;
// LINE 53:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    dword ptr [eax+5], 0xFFFFFFFF;
// LINE 54:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+4], 0;
// LINE 57:
	__asm        mov    x, 0;
	__asm        jmp    _Ta9;
_Ta6:
	__asm        inc    x;
_Ta9:
	__asm        cmp    x, 0x80;
	__asm        jge    _T118;
// LINE 59:
// Block start:
	int32_t yindex;
	__asm        mov    yindex, 0;
	__asm        jmp    _Tc5;
_Tc2:
	__asm        inc    yindex;
_Tc5:
	__asm        mov    eax, x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, gRoadGraph.RGLength[eax];
	__asm        cmp    ecx, yindex;
	__asm        jle    _T113;
// LINE 61:
// Block start:
	struct RGVertex* pRGV;
	__asm        mov    eax, x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        mov    ecx, yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 62:
	__asm        mov    eax, pRGV;
	__asm        mov    dword ptr [eax+0x2F], 0;
// LINE 63:
	__asm        mov    eax, pRGV;
	__asm        mov    byte ptr [eax+0x2D], 0xFF;
// LINE 64:
	__asm        mov    eax, pRGV;
	__asm        mov    byte ptr [eax+0x2C], 0xFF;
// LINE 65:
// Block end:
	__asm        jmp    _Tc2;
// LINE 66:
// Block end:
_T113:
	__asm        jmp    _Ta6;
// LINE 70:
_T118:
	__asm        mov    al, startVertex.yindex;
	__asm        mov    scratch.yindexCurr, al;
// LINE 71:
	__asm        mov    al, startVertex.x;
	__asm        mov    scratch.xCurr, al;
// LINE 72:
	__asm        mov    scratch.edgeIndexPrev, 0xFF;
// LINE 73:
	__asm        mov    scratch.yindexPrev, 0xFF;
// LINE 74:
	__asm        mov    scratch.xPrev, 0xFF;
// LINE 75:
	__asm        mov    scratch.cost, 0;
// LINE 76:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 81:
_T143:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T2a8;

	__asm        cmp    pathFoundFlag, 0;
	__asm        jne    _T2a8;
// LINE 85:
	__asm        lea    eax, path.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapRemove;
// LINE 87:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, path.yindexCurr;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 88:
	__asm        mov    eax, pRGV;
	__asm        cmp    dword ptr [eax+0x2F], 0;
	__asm        jne    _T2a3;
// LINE 92:
	__asm        mov    al, path.xPrev;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2D], al;
// LINE 93:
	__asm        mov    al, path.yindexPrev;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2C], al;
// LINE 94:
	__asm        mov    al, path.edgeIndexPrev;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2E], al;
// LINE 95:
	__asm        mov    eax, pRGV;
	__asm        mov    dword ptr [eax+0x2F], 1;
// LINE 99:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T1e9;

	__asm        xor    eax, eax;
	__asm        mov    al, path.yindexCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T1e9;
// LINE 101:
	__asm        mov    pathFoundFlag, 1;
// LINE 104:
	__asm        jmp    _T2a3;
// LINE 108:
// Block start:
	int32_t i;
_T1e9:
	__asm        mov    i, 0;
	__asm        jmp    _T1f8;
_T1f5:
	__asm        inc    i;
_T1f8:
	__asm        cmp    i, 4;
	__asm        jge    _T2a3;
// LINE 111:
// Block start:
	struct Edge* pEdge;
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+2];
	__asm        and    al, 0xF;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    eax, i;
	__asm        test   IndexToType[0][eax*4], ecx;
	__asm        jne    _T223;
// LINE 112:
	__asm        jmp    _T1f5;
// LINE 115:
_T223:
	__asm        mov    eax, i;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        add    eax, pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 116:
	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        mov    eax, gRoadGraph.RGArray[0][ecx*4];
	__asm        mov    ecx, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx];
	__asm        mov    ecx, edx;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        cmp    dword ptr [eax+ecx+0x2F], 0;
	__asm        jne    _T29e;
// LINE 118:
	__asm        mov    eax, pEdge;
	__asm        mov    al, [eax+1];
	__asm        mov    scratch.xCurr, al;
// LINE 119:
	__asm        mov    eax, pEdge;
	__asm        mov    al, [eax];
	__asm        mov    scratch.yindexCurr, al;
// LINE 120:
	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+2];
	__asm        add    ecx, path.cost;
	__asm        mov    scratch.cost, ecx;
// LINE 121:
	__asm        mov    al, reinterpret_cast<uint8_t>(i);
	__asm        mov    scratch.edgeIndexPrev, al;
// LINE 122:
	__asm        mov    al, path.xCurr;
	__asm        mov    scratch.xPrev, al;
// LINE 123:
	__asm        mov    al, path.yindexCurr;
	__asm        mov    scratch.yindexPrev, al;
// LINE 124:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 126:
// Block end:
_T29e:
	__asm        jmp    _T1f5;
// LINE 129:
// Block end:
_T2a3:
	__asm        jmp    _T143;
// LINE 131:
_T2a8:
	__asm        mov    eax, pathFoundFlag;
	__asm        jmp    _T2b0;
// LINE 132:
_T2b0:
}

// FUNCTION: COPTER_D 0x005439bb
int32_t ShortestPath::DepthFirstSearch(struct _RGIndex startVertex, struct _RGIndex destVertex) {
	struct _GridCoordinates destLoc;
	int32_t pathFoundFlag;
	struct _GridCoordinates currLoc;
	int32_t x;
	struct _FringeHeapNode path;
	struct RGVertex* pRGV;
	struct _FringeHeapNode scratch;

// LINE 139:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 142:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax];
	__asm        mov    destLoc.x, al;
// LINE 143:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+1];
	__asm        mov    destLoc.y, al;
// LINE 146:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T85;

	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T85;
// LINE 148:
	__asm        mov    eax, pRGV;
	__asm        mov    byte ptr [eax+0x2E], 0xFF;
// LINE 149:
	__asm        mov    al, destVertex.yindex;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2C], al;
// LINE 150:
	__asm        mov    al, destVertex.x;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2D], al;
// LINE 151:
	__asm        mov    eax, 1;
	__asm        jmp    _T31b;
// LINE 155:
_T85:
	__asm        mov    pathFoundFlag, 0;
// LINE 158:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5C3AB0;
// LINE 159:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    dword ptr [eax+5], 0xFFFFFFFF;
// LINE 160:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+4], 0;
// LINE 163:
	__asm        mov    x, 0;
	__asm        jmp    _Tba;
_Tb7:
	__asm        inc    x;
_Tba:
	__asm        cmp    x, 0x80;
	__asm        jge    _T129;
// LINE 165:
// Block start:
	int32_t yindex;
	__asm        mov    yindex, 0;
	__asm        jmp    _Td6;
_Td3:
	__asm        inc    yindex;
_Td6:
	__asm        mov    eax, x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, gRoadGraph.RGLength[eax];
	__asm        cmp    ecx, yindex;
	__asm        jle    _T124;
// LINE 167:
// Block start:
	struct RGVertex* pRGV;
	__asm        mov    eax, x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        mov    ecx, yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 168:
	__asm        mov    eax, pRGV;
	__asm        mov    dword ptr [eax+0x2F], 0;
// LINE 169:
	__asm        mov    eax, pRGV;
	__asm        mov    byte ptr [eax+0x2D], 0xFF;
// LINE 170:
	__asm        mov    eax, pRGV;
	__asm        mov    byte ptr [eax+0x2C], 0xFF;
// LINE 171:
// Block end:
	__asm        jmp    _Td3;
// LINE 172:
// Block end:
_T124:
	__asm        jmp    _Tb7;
// LINE 176:
_T129:
	__asm        xor    eax, eax;
	__asm        mov    al, startVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 177:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax];
	__asm        mov    currLoc.x, al;
// LINE 178:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+1];
	__asm        mov    currLoc.y, al;
// LINE 180:
	__asm        mov    al, startVertex.x;
	__asm        mov    scratch.xCurr, al;
// LINE 181:
	__asm        mov    al, startVertex.yindex;
	__asm        mov    scratch.yindexCurr, al;
// LINE 182:
	__asm        mov    scratch.edgeIndexPrev, 0xFF;
// LINE 183:
	__asm        mov    scratch.yindexPrev, 0xFF;
// LINE 184:
	__asm        mov    scratch.xPrev, 0xFF;
// LINE 185:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currLoc.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::FindDistanceFromDestination;
	__asm        mov    scratch.cost, eax;
// LINE 186:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 191:
_T192:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T313;

	__asm        cmp    pathFoundFlag, 0;
	__asm        jne    _T313;
// LINE 195:
	__asm        lea    eax, path.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapRemove;
// LINE 197:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, path.yindexCurr;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 199:
	__asm        mov    eax, pRGV;
	__asm        cmp    dword ptr [eax+0x2F], 0;
	__asm        jne    _T30e;
// LINE 203:
	__asm        mov    al, path.xPrev;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2D], al;
// LINE 204:
	__asm        mov    al, path.yindexPrev;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2C], al;
// LINE 205:
	__asm        mov    al, path.edgeIndexPrev;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2E], al;
// LINE 206:
	__asm        mov    eax, pRGV;
	__asm        mov    dword ptr [eax+0x2F], 1;
// LINE 210:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T238;

	__asm        xor    eax, eax;
	__asm        mov    al, path.yindexCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T238;
// LINE 212:
	__asm        mov    pathFoundFlag, 1;
// LINE 215:
	__asm        jmp    _T30e;
// LINE 219:
// Block start:
	int32_t i;
_T238:
	__asm        mov    i, 0;
	__asm        jmp    _T247;
_T244:
	__asm        inc    i;
_T247:
	__asm        cmp    i, 4;
	__asm        jge    _T30e;
// LINE 222:
// Block start:
	struct RGVertex* pCurrRGV;
	struct Edge* pEdge;
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+2];
	__asm        and    al, 0xF;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    eax, i;
	__asm        test   IndexToType[0][eax*4], ecx;
	__asm        jne    _T272;
// LINE 223:
	__asm        jmp    _T244;
// LINE 226:
_T272:
	__asm        mov    eax, i;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        add    eax, pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 227:
	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        mov    eax, gRoadGraph.RGArray[0][ecx*4];
	__asm        mov    ecx, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx];
	__asm        mov    ecx, edx;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        add    eax, ecx;
	__asm        mov    pCurrRGV, eax;
// LINE 228:
	__asm        mov    eax, pCurrRGV;
	__asm        cmp    dword ptr [eax+0x2F], 0;
	__asm        jne    _T309;
// LINE 230:
	__asm        mov    eax, pCurrRGV;
	__asm        mov    al, [eax];
	__asm        mov    currLoc.x, al;
// LINE 231:
	__asm        mov    eax, pCurrRGV;
	__asm        mov    al, [eax+1];
	__asm        mov    currLoc.y, al;
// LINE 233:
	__asm        mov    eax, pEdge;
	__asm        mov    al, [eax+1];
	__asm        mov    scratch.xCurr, al;
// LINE 234:
	__asm        mov    eax, pEdge;
	__asm        mov    al, [eax];
	__asm        mov    scratch.yindexCurr, al;
// LINE 235:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currLoc.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::FindDistanceFromDestination;
	__asm        mov    scratch.cost, eax;
// LINE 236:
	__asm        mov    al, reinterpret_cast<uint8_t>(i);
	__asm        mov    scratch.edgeIndexPrev, al;
// LINE 237:
	__asm        mov    al, path.xCurr;
	__asm        mov    scratch.xPrev, al;
// LINE 238:
	__asm        mov    al, path.yindexCurr;
	__asm        mov    scratch.yindexPrev, al;
// LINE 239:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 241:
// Block end:
_T309:
	__asm        jmp    _T244;
// LINE 244:
// Block end:
_T30e:
	__asm        jmp    _T192;
// LINE 246:
_T313:
	__asm        mov    eax, pathFoundFlag;
	__asm        jmp    _T31b;
// LINE 247:
_T31b:
}

// FUNCTION: COPTER_D 0x00543cdd
void ShortestPath::PriorityHeapInsert(const struct _FringeHeapNode* pInsertNode) {
	int32_t index;
	struct _FringeHeapNode tempNode;

// LINE 255:
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+4];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    index, eax;
// LINE 258:
	__asm        mov    eax, pInsertNode;
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        add    ecx, [edx];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 264:
_T39:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, index;
	__asm        lea    edx, [edx+edx*8];
	__asm        mov    ebx, this;
	__asm        mov    ebx, [ebx];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jle    _Te2;
// LINE 266:
	__asm        mov    eax, index;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 267:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        add    ecx, [edx];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 268:
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    edx, this;
	__asm        add    eax, [edx];
	__asm        mov    edx, [ecx];
	__asm        mov    [eax], edx;
	__asm        mov    edx, [ecx+4];
	__asm        mov    [eax+4], edx;
	__asm        mov    cl, [ecx+8];
	__asm        mov    [eax+8], cl;
// LINE 269:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    index, eax;
// LINE 270:
	__asm        jmp    _T39;
// LINE 271:
_Te2:
	__asm        jmp    near ptr 0x00543DC4;
}

// FUNCTION: COPTER_D 0x00543dcb
void ShortestPath::PriorityHeapRemove(struct _FringeHeapNode* pRemovedNode) {
	int32_t index;
	int32_t child;
	int32_t parent;
	struct _FringeHeapNode tempNode;

// LINE 281:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    index, eax;
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+4];
// LINE 282:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        add    eax, 9;
	__asm        mov    ecx, pRemovedNode;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 283:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        add    ecx, 9;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        add    eax, 9;
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 287:
	__asm        mov    parent, 1;
// LINE 290:
_T83:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        cmp    eax, parent;
	__asm        jl     _T176;
// LINE 293:
	__asm        mov    eax, parent;
	__asm        add    eax, parent;
	__asm        mov    child, eax;
// LINE 296:
	__asm        mov    eax, this;
	__asm        mov    ecx, child;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _Td8;

	__asm        mov    eax, child;
	__asm        lea    eax, [eax+eax*8+9];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    ebx, child;
	__asm        lea    ebx, [ebx+ebx*8];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jge    _Td8;
// LINE 297:
	__asm        inc    child;
// LINE 300:
_Td8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, parent;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    ebx, child;
	__asm        lea    ebx, [ebx+ebx*8];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jg     _T101;
// LINE 301:
	__asm        jmp    _T176;
// LINE 304:
_T101:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, parent;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 305:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, child;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 306:
	__asm        lea    eax, tempNode.xCurr;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, child;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 309:
	__asm        mov    eax, child;
	__asm        mov    parent, eax;
// LINE 310:
	__asm        jmp    _T83;
// LINE 313:
_T176:
	__asm        lea    eax, tempNode.xCurr;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 314:
	__asm        jmp    near ptr 0x00543F66;
}



// Contribution: 2:000044f8-00004507 Module: 151, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x005934f8
const enum DirectionTypes IndexToType[4] = { /* <data@0x005934f8> */ };

