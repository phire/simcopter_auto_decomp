// Module: S3shtpth.obj
// Source: C:\Copter\Source\Game\S3shtpth.cpp
// autogenerated by simcopter_tool from PDB file

// Type: enum DirectionTypes;
enum DirectionTypes {
	NO_DIRECTION = 0,
	NORTH = 1,
	EAST = 2,
	SOUTH = 4,
	WEST = 8,
	RISING = 16,
	RISING_NORTH = 17,
	RISING_SOUTH = 20,
	RISING_EAST = 18,
	RISING_WEST = 24,
	NORTH_EAST = 3,
	SOUTH_EAST = 6,
	SOUTH_WEST = 12,
	NORTH_WEST = 9,
};

// Type: /*packed*/ class ShortestPath (forward reference);
class ShortestPath{ // packed(0x8 bytes) TI: 0x2aae
private:
	/*packed*/ struct _FringeHeapNode *heap;
	long heapSize;
public:
	void Init();
	int32_t BreadthFirstSearch(/*packed*/ struct _RGIndex, /*packed*/ struct _RGIndex);
	int32_t DepthFirstSearch(/*packed*/ struct _RGIndex, /*packed*/ struct _RGIndex);
private:
	void PriorityHeapInsert(const /*packed*/ struct _FringeHeapNode*);
	void PriorityHeapRemove(/*packed*/ struct _FringeHeapNode*);
	int32_t FindDistanceFromDestination(/*packed*/ struct _GridCoordinates, /*packed*/ struct _GridCoordinates);
};

// Type: /*packed*/ struct _GridCoordinates;
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	unsigned char x;
	unsigned char y;
};

// Type: int32_t;

// Type: /*packed*/ struct _RGIndex;
struct _RGIndex{ // packed(0x2 bytes) TI: 0x2ab2
	unsigned char x;
	unsigned char yindex;
};

// Type: /*packed*/ struct _FringeHeapNode;
struct _FringeHeapNode{ // packed(0x9 bytes) TI: 0x2ab0
	unsigned char xCurr;
	unsigned char yindexCurr;
	unsigned char edgeIndexPrev;
	unsigned char xPrev;
	unsigned char yindexPrev;
	long cost;
};

// Type: /*packed*/ struct RGVertex (forward reference);
struct RGVertex{ // packed(0x33 bytes) TI: 0x1776
	unsigned char x;
	unsigned char y;
	LfBitfield @ 0x11f58:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1771
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 turnFlags;
	LfBitfield @ 0x11f60:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1772
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x4
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 deadEndFlags;
	unsigned char fElevated;
	/*packed*/ struct Edge edge[4];
	unsigned char yindexPrev;
	unsigned char xPrev;
	unsigned char edgeIndexPrev;
	int32_t STVisited;
};

// Type: /*packed*/ struct Edge (forward reference);
struct Edge{ // packed(0xa bytes) TI: 0x176b
	unsigned char yindex;
	unsigned char x;
	unsigned short Time;
	unsigned short numElementsToPath;
	/*packed*/ struct Road *roadArray;
};

// Type: /*packed*/ struct _FringeHeapNode (forward reference);
struct _FringeHeapNode{ // packed(0x9 bytes) TI: 0x2ab0
	unsigned char xCurr;
	unsigned char yindexCurr;
	unsigned char edgeIndexPrev;
	unsigned char xPrev;
	unsigned char yindexPrev;
	long cost;
};

// Type: void;



// Contribution: 1:00142690-00142f6c Module: 151, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00543690
int32_t ShortestPath::FindDistanceFromDestination(/*packed*/ struct _GridCoordinates here, /*packed*/ struct _GridCoordinates destination) {
	/*bp-0x4*/   int32_t x;
	/*bp-0x8*/   int32_t y;

// LINE 16:
	__asm        xor    eax, eax;
	__asm        mov    al, destination.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, here.x;
	__asm        sub    eax, ecx;
	__asm        mov    x, eax;
// LINE 17:
	__asm        xor    eax, eax;
	__asm        mov    al, destination.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, here.y;
	__asm        sub    eax, ecx;
	__asm        mov    y, eax;
// LINE 19:
	__asm        mov    eax, x;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    x, eax;
// LINE 20:
	__asm        mov    eax, y;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    y, eax;
// LINE 22:
	__asm        mov    eax, x;
	__asm        cmp    y, eax;
	__asm        jge    _T5f;
// LINE 24:
	__asm        mov    eax, y;
	__asm        sar    eax, 1;
	__asm        add    eax, x;
	__asm        jmp    _T6d;
// LINE 26:
	__asm        jmp    _T6d;
// LINE 28:
_T5f:
	__asm        mov    eax, x;
	__asm        sar    eax, 1;
	__asm        add    eax, y;
	__asm        jmp    _T6d;
// LINE 30:
_T6d:
}

// FUNCTION: COPTER_D 0x00543704
int32_t ShortestPath::BreadthFirstSearch(/*packed*/ struct _RGIndex startVertex, /*packed*/ struct _RGIndex destVertex) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode scratch; // 0x9 bytes
	/*bp-0x10*/  /*packed*/ struct RGVertex *pRGV;
	/*bp-0x1c*/  /*packed*/ struct _FringeHeapNode path; // 0x9 bytes
	/*bp-0x20*/  int32_t x;
	/*bp-0x24*/  int32_t pathFoundFlag;

// LINE 37:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 40:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T74;

	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T74;
// LINE 42:
	pRGV->edgeIndexPrev = 0xff;
// LINE 43:
	pRGV->yindexPrev = destVertex.yindex;
// LINE 44:
	pRGV->xPrev = destVertex.x;
// LINE 45:
	__asm        mov    eax, 1;
	__asm        jmp    _T2b0;
// LINE 49:
_T74:
	pathFoundFlag = 0x0;
// LINE 52:
	this->heap = 0x5c3ab0;
// LINE 53:
	this->heap->cost = 0xffffffff;
// LINE 54:
	this->heapSize = 0x0;
// LINE 57:
	__asm        mov    x, 0;
	__asm        jmp    _Ta9;
_Ta6:
	__asm        inc    x;
_Ta9:
	__asm        cmp    x, 0x80;
	__asm        jge    _T118;
// LINE 59:
// Block start:
	/*bp-0x28*/  int32_t yindex;
	__asm        mov    yindex, 0;
	__asm        jmp    _Tc5;
_Tc2:
	__asm        inc    yindex;
_Tc5:
	__asm        mov    eax, x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, gRoadGraph.RGLength[eax];
	__asm        cmp    ecx, yindex;
	__asm        jle    _T113;
// LINE 61:
// Block start:
	/*bp-0x2c*/  /*packed*/ struct RGVertex *pRGV;
	__asm        mov    eax, x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        mov    ecx, yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 62:
	pRGV->STVisited = 0x0;
// LINE 63:
	pRGV->xPrev = 0xff;
// LINE 64:
	pRGV->yindexPrev = 0xff;
// LINE 65:
// Block end:
	__asm        jmp    _Tc2;
// LINE 66:
// Block end:
_T113:
	__asm        jmp    _Ta6;
// LINE 70:
_T118:
	scratch.yindexCurr = startVertex.yindex;
// LINE 71:
	scratch.xCurr = startVertex.x;
// LINE 72:
	scratch.edgeIndexPrev = 0xff;
// LINE 73:
	scratch.yindexPrev = 0xff;
// LINE 74:
	scratch.xPrev = 0xff;
// LINE 75:
	scratch.cost = 0x0;
// LINE 76:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 81:
_T143:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T2a8;

	__asm        cmp    pathFoundFlag, 0;
	__asm        jne    _T2a8;
// LINE 85:
	__asm        lea    eax, path.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapRemove;
// LINE 87:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, path.yindexCurr;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 88:
	__asm        mov    eax, pRGV;
	__asm        cmp    dword ptr [eax+0x2F], 0;
	__asm        jne    _T2a3;
// LINE 92:
	pRGV->xPrev = path.xPrev;
// LINE 93:
	pRGV->yindexPrev = path.yindexPrev;
// LINE 94:
	pRGV->edgeIndexPrev = path.edgeIndexPrev;
// LINE 95:
	pRGV->STVisited = 0x1;
// LINE 99:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T1e9;

	__asm        xor    eax, eax;
	__asm        mov    al, path.yindexCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T1e9;
// LINE 101:
	pathFoundFlag = 0x1;
// LINE 104:
	__asm        jmp    _T2a3;
// LINE 108:
// Block start:
	/*bp-0x30*/  int32_t i;
_T1e9:
	__asm        mov    i, 0;
	__asm        jmp    _T1f8;
_T1f5:
	__asm        inc    i;
_T1f8:
	__asm        cmp    i, 4;
	__asm        jge    _T2a3;
// LINE 111:
// Block start:
	/*bp-0x34*/  /*packed*/ struct Edge *pEdge;
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+2];
	__asm        and    al, 0xF;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    eax, i;
	__asm        test   IndexToType[0][eax*4], ecx;
	__asm        jne    _T223;
// LINE 112:
	__asm        jmp    _T1f5;
// LINE 115:
_T223:
	__asm        mov    eax, i;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        add    eax, pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 116:
	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        mov    eax, gRoadGraph.RGArray[0][ecx*4];
	__asm        mov    ecx, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx];
	__asm        mov    ecx, edx;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        cmp    dword ptr [eax+ecx+0x2F], 0;
	__asm        jne    _T29e;
// LINE 118:
	scratch.xCurr = pEdge->x;
// LINE 119:
	scratch.yindexCurr = pEdge->yindex;
// LINE 120:
	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax+2];
	__asm        add    ecx, path.cost;
	__asm        mov    scratch.cost, ecx;
// LINE 121:
	scratch.edgeIndexPrev = reinterpret_cast<uint8_t>(i);
// LINE 122:
	scratch.xPrev = path.xCurr;
// LINE 123:
	scratch.yindexPrev = path.yindexCurr;
// LINE 124:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 126:
// Block end:
_T29e:
	__asm        jmp    _T1f5;
// LINE 129:
// Block end:
_T2a3:
	__asm        jmp    _T143;
// LINE 131:
_T2a8:
	__asm        mov    eax, pathFoundFlag;
	__asm        jmp    _T2b0;
// LINE 132:
_T2b0:
}

// FUNCTION: COPTER_D 0x005439bb
int32_t ShortestPath::DepthFirstSearch(/*packed*/ struct _RGIndex startVertex, /*packed*/ struct _RGIndex destVertex) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode scratch; // 0x9 bytes
	/*bp-0x10*/  /*packed*/ struct RGVertex *pRGV;
	/*bp-0x1c*/  /*packed*/ struct _FringeHeapNode path; // 0x9 bytes
	/*bp-0x20*/  int32_t x;
	/*bp-0x24*/  /*packed*/ struct _GridCoordinates currLoc;
	/*bp-0x28*/  int32_t pathFoundFlag;
	/*bp-0x2c*/  /*packed*/ struct _GridCoordinates destLoc;

// LINE 139:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 142:
	destLoc.x = pRGV->x;
// LINE 143:
	destLoc.y = pRGV->y;
// LINE 146:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T85;

	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T85;
// LINE 148:
	pRGV->edgeIndexPrev = 0xff;
// LINE 149:
	pRGV->yindexPrev = destVertex.yindex;
// LINE 150:
	pRGV->xPrev = destVertex.x;
// LINE 151:
	__asm        mov    eax, 1;
	__asm        jmp    _T31b;
// LINE 155:
_T85:
	pathFoundFlag = 0x0;
// LINE 158:
	this->heap = 0x5c3ab0;
// LINE 159:
	this->heap->cost = 0xffffffff;
// LINE 160:
	this->heapSize = 0x0;
// LINE 163:
	__asm        mov    x, 0;
	__asm        jmp    _Tba;
_Tb7:
	__asm        inc    x;
_Tba:
	__asm        cmp    x, 0x80;
	__asm        jge    _T129;
// LINE 165:
// Block start:
	/*bp-0x30*/  int32_t yindex;
	__asm        mov    yindex, 0;
	__asm        jmp    _Td6;
_Td3:
	__asm        inc    yindex;
_Td6:
	__asm        mov    eax, x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, gRoadGraph.RGLength[eax];
	__asm        cmp    ecx, yindex;
	__asm        jle    _T124;
// LINE 167:
// Block start:
	/*bp-0x34*/  /*packed*/ struct RGVertex *pRGV;
	__asm        mov    eax, x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        mov    ecx, yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 168:
	pRGV->STVisited = 0x0;
// LINE 169:
	pRGV->xPrev = 0xff;
// LINE 170:
	pRGV->yindexPrev = 0xff;
// LINE 171:
// Block end:
	__asm        jmp    _Td3;
// LINE 172:
// Block end:
_T124:
	__asm        jmp    _Tb7;
// LINE 176:
_T129:
	__asm        xor    eax, eax;
	__asm        mov    al, startVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 177:
	currLoc.x = pRGV->x;
// LINE 178:
	currLoc.y = pRGV->y;
// LINE 180:
	scratch.xCurr = startVertex.x;
// LINE 181:
	scratch.yindexCurr = startVertex.yindex;
// LINE 182:
	scratch.edgeIndexPrev = 0xff;
// LINE 183:
	scratch.yindexPrev = 0xff;
// LINE 184:
	scratch.xPrev = 0xff;
// LINE 185:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currLoc.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::FindDistanceFromDestination;
	__asm        mov    scratch.cost, eax;
// LINE 186:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 191:
_T192:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T313;

	__asm        cmp    pathFoundFlag, 0;
	__asm        jne    _T313;
// LINE 195:
	__asm        lea    eax, path.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapRemove;
// LINE 197:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, path.yindexCurr;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 199:
	__asm        mov    eax, pRGV;
	__asm        cmp    dword ptr [eax+0x2F], 0;
	__asm        jne    _T30e;
// LINE 203:
	pRGV->xPrev = path.xPrev;
// LINE 204:
	pRGV->yindexPrev = path.yindexPrev;
// LINE 205:
	pRGV->edgeIndexPrev = path.edgeIndexPrev;
// LINE 206:
	pRGV->STVisited = 0x1;
// LINE 210:
	__asm        xor    eax, eax;
	__asm        mov    al, path.xCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T238;

	__asm        xor    eax, eax;
	__asm        mov    al, path.yindexCurr;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T238;
// LINE 212:
	pathFoundFlag = 0x1;
// LINE 215:
	__asm        jmp    _T30e;
// LINE 219:
// Block start:
	/*bp-0x38*/  int32_t i;
_T238:
	__asm        mov    i, 0;
	__asm        jmp    _T247;
_T244:
	__asm        inc    i;
_T247:
	__asm        cmp    i, 4;
	__asm        jge    _T30e;
// LINE 222:
// Block start:
	/*bp-0x3c*/  /*packed*/ struct Edge *pEdge;
	/*bp-0x40*/  /*packed*/ struct RGVertex *pCurrRGV;
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+2];
	__asm        and    al, 0xF;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, al;
	__asm        mov    eax, i;
	__asm        test   IndexToType[0][eax*4], ecx;
	__asm        jne    _T272;
// LINE 223:
	__asm        jmp    _T244;
// LINE 226:
_T272:
	__asm        mov    eax, i;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, eax;
	__asm        add    eax, pRGV;
	__asm        add    eax, 4;
	__asm        mov    pEdge, eax;
// LINE 227:
	__asm        mov    eax, pEdge;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+1];
	__asm        mov    eax, gRoadGraph.RGArray[0][ecx*4];
	__asm        mov    ecx, pEdge;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ecx];
	__asm        mov    ecx, edx;
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    edx, [edx+edx*4];
	__asm        lea    ecx, [ecx+edx*2];
	__asm        add    eax, ecx;
	__asm        mov    pCurrRGV, eax;
// LINE 228:
	__asm        mov    eax, pCurrRGV;
	__asm        cmp    dword ptr [eax+0x2F], 0;
	__asm        jne    _T309;
// LINE 230:
	currLoc.x = pCurrRGV->x;
// LINE 231:
	currLoc.y = pCurrRGV->y;
// LINE 233:
	scratch.xCurr = pEdge->x;
// LINE 234:
	scratch.yindexCurr = pEdge->yindex;
// LINE 235:
	__asm        mov    eax, reinterpret_cast<uint32_t>(destLoc.x);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(currLoc.x);
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::FindDistanceFromDestination;
	__asm        mov    scratch.cost, eax;
// LINE 236:
	scratch.edgeIndexPrev = reinterpret_cast<uint8_t>(i);
// LINE 237:
	scratch.xPrev = path.xCurr;
// LINE 238:
	scratch.yindexPrev = path.yindexCurr;
// LINE 239:
	__asm        lea    eax, scratch.xCurr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ShortestPath::PriorityHeapInsert;
// LINE 241:
// Block end:
_T309:
	__asm        jmp    _T244;
// LINE 244:
// Block end:
_T30e:
	__asm        jmp    _T192;
// LINE 246:
_T313:
	__asm        mov    eax, pathFoundFlag;
	__asm        jmp    _T31b;
// LINE 247:
_T31b:
}

// FUNCTION: COPTER_D 0x00543cdd
void ShortestPath::PriorityHeapInsert(const /*packed*/ struct _FringeHeapNode *pInsertNode) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode tempNode; // 0x9 bytes
	/*bp-0x10*/  int32_t index;

// LINE 255:
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+4];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    index, eax;
// LINE 258:
	__asm        mov    eax, pInsertNode;
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        add    ecx, [edx];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 264:
_T39:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, index;
	__asm        lea    edx, [edx+edx*8];
	__asm        mov    ebx, this;
	__asm        mov    ebx, [ebx];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jle    _Te2;
// LINE 266:
	__asm        mov    eax, index;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 267:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        add    ecx, [edx];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 268:
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    edx, this;
	__asm        add    eax, [edx];
	__asm        mov    edx, [ecx];
	__asm        mov    [eax], edx;
	__asm        mov    edx, [ecx+4];
	__asm        mov    [eax+4], edx;
	__asm        mov    cl, [ecx+8];
	__asm        mov    [eax+8], cl;
// LINE 269:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    index, eax;
// LINE 270:
	__asm        jmp    _T39;
// LINE 271:
_Te2:
	__asm        jmp    near ptr 0x00543DC4;
}

// FUNCTION: COPTER_D 0x00543dcb
void ShortestPath::PriorityHeapRemove(/*packed*/ struct _FringeHeapNode *pRemovedNode) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode tempNode; // 0x9 bytes
	/*bp-0x10*/  int32_t parent;
	/*bp-0x14*/  int32_t child;
	/*bp-0x18*/  int32_t index;

// LINE 281:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    index, eax;
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+4];
// LINE 282:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        add    eax, 9;
	__asm        mov    ecx, pRemovedNode;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 283:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        add    ecx, 9;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        add    eax, 9;
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 287:
	parent = 0x1;
// LINE 290:
_T83:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        cmp    eax, parent;
	__asm        jl     _T176;
// LINE 293:
	__asm        mov    eax, parent;
	__asm        add    eax, parent;
	__asm        mov    child, eax;
// LINE 296:
	__asm        mov    eax, this;
	__asm        mov    ecx, child;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _Td8;

	__asm        mov    eax, child;
	__asm        lea    eax, [eax+eax*8+9];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    ebx, child;
	__asm        lea    ebx, [ebx+ebx*8];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jge    _Td8;
// LINE 297:
	__asm        inc    child;
// LINE 300:
_Td8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, parent;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    ebx, child;
	__asm        lea    ebx, [ebx+ebx*8];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jg     _T101;
// LINE 301:
	__asm        jmp    _T176;
// LINE 304:
_T101:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, parent;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 305:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, child;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 306:
	__asm        lea    eax, tempNode.xCurr;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, child;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 309:
	parent = child;
// LINE 310:
	__asm        jmp    _T83;
// LINE 313:
_T176:
	__asm        lea    eax, tempNode.xCurr;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 314:
	__asm        jmp    near ptr 0x00543F66;
}



// Contribution: 2:000044f8-00004507 Module: 151, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x005934f8
static const enum DirectionTypes IndexToType[4] = { 0 /* todo */ };

