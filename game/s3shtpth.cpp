// Module: S3shtpth.obj
// Source: C:\Copter\Source\Game\S3shtpth.cpp
// autogenerated by simcopter_tool from PDB file

// Type: enum DirectionTypes;
enum DirectionTypes {
	NO_DIRECTION = 0,
	NORTH = 1,
	EAST = 2,
	SOUTH = 4,
	WEST = 8,
	RISING = 16,
	RISING_NORTH = 17,
	RISING_SOUTH = 20,
	RISING_EAST = 18,
	RISING_WEST = 24,
	NORTH_EAST = 3,
	SOUTH_EAST = 6,
	SOUTH_WEST = 12,
	NORTH_WEST = 9,
};

// Type: /*packed*/ class ShortestPath (forward reference);
class ShortestPath{ // packed(0x8 bytes) TI: 0x2aae
private:
	/*+0x0*/   /*packed*/ struct _FringeHeapNode *heap;
	/*+0x4*/   long heapSize;
public:
	void Init();
	int32_t BreadthFirstSearch(/*packed*/ struct _RGIndex, /*packed*/ struct _RGIndex);
	int32_t DepthFirstSearch(/*packed*/ struct _RGIndex, /*packed*/ struct _RGIndex);
private:
	void PriorityHeapInsert(const /*packed*/ struct _FringeHeapNode*);
	void PriorityHeapRemove(/*packed*/ struct _FringeHeapNode*);
	int32_t FindDistanceFromDestination(/*packed*/ struct _GridCoordinates, /*packed*/ struct _GridCoordinates);
};

// Type: /*packed*/ struct _GridCoordinates;
struct _GridCoordinates{ // packed(0x2 bytes) TI: 0x143c
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
};

// Type: int32_t;

// Type: /*packed*/ struct _RGIndex;
struct _RGIndex{ // packed(0x2 bytes) TI: 0x2ab2
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char yindex; // 0x1 bytes
};

// Type: /*packed*/ struct _FringeHeapNode;
struct _FringeHeapNode{ // packed(0x9 bytes) TI: 0x2ab0
	/*+0x0*/   unsigned char xCurr; // 0x1 bytes
	/*+0x1*/   unsigned char yindexCurr; // 0x1 bytes
	/*+0x2*/   unsigned char edgeIndexPrev; // 0x1 bytes
	/*+0x3*/   unsigned char xPrev; // 0x1 bytes
	/*+0x4*/   unsigned char yindexPrev; // 0x1 bytes
	/*+0x5*/   long cost;
};

// Type: /*packed*/ struct RGVertex (forward reference);
struct RGVertex{ // packed(0x33 bytes) TI: 0x1776
	/*+0x0*/   unsigned char x; // 0x1 bytes
	/*+0x1*/   unsigned char y; // 0x1 bytes
	/*+0x2*/   LfBitfield @ 0x11f58:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1771
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x0
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 turnFlags;
	/*+0x2*/   LfBitfield @ 0x11f60:
	[90m   LB.[32m[  0.  1][m [95mlength[m = 0x4
	[90m   LB.[95mTI[m = 0x1772
	[90m   LB.[32m[  1.  1][m [95mposition[m = 0x4
	[90m   LB.[32m[  2.  2][m [95mtype[m = 0x206
	 deadEndFlags;
	/*+0x3*/   unsigned char fElevated; // 0x1 bytes
	/*+0x4*/   /*packed*/ struct Edge edge[4]; // 0x28 bytes
	/*+0x2c*/  unsigned char yindexPrev; // 0x1 bytes
	/*+0x2d*/  unsigned char xPrev; // 0x1 bytes
	/*+0x2e*/  unsigned char edgeIndexPrev; // 0x1 bytes
	/*+0x2f*/  int32_t STVisited;
};

// Type: /*packed*/ struct Edge (forward reference);
struct Edge{ // packed(0xa bytes) TI: 0x176b
	/*+0x0*/   unsigned char yindex; // 0x1 bytes
	/*+0x1*/   unsigned char x; // 0x1 bytes
	/*+0x2*/   unsigned short Time; // 0x2 bytes
	/*+0x4*/   unsigned short numElementsToPath; // 0x2 bytes
	/*+0x6*/   /*packed*/ struct Road *roadArray;
};

// Type: /*packed*/ struct _FringeHeapNode (forward reference);
struct _FringeHeapNode{ // packed(0x9 bytes) TI: 0x2ab0
	/*+0x0*/   unsigned char xCurr; // 0x1 bytes
	/*+0x1*/   unsigned char yindexCurr; // 0x1 bytes
	/*+0x2*/   unsigned char edgeIndexPrev; // 0x1 bytes
	/*+0x3*/   unsigned char xPrev; // 0x1 bytes
	/*+0x4*/   unsigned char yindexPrev; // 0x1 bytes
	/*+0x5*/   long cost;
};

// Type: void;



// Contribution: 1:00142690-00142f6c Module: 151, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00543690
int32_t ShortestPath::FindDistanceFromDestination(/*packed*/ struct _GridCoordinates here, /*packed*/ struct _GridCoordinates destination) {
	/*bp-0x4*/   int32_t x;
	/*bp-0x8*/   int32_t y;

// LINE 16:
	__asm        xor    eax, eax;
	__asm        mov    al, destination.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, here.x;
	__asm        sub    eax, ecx;
	__asm        mov    x, eax;
// LINE 17:
	__asm        xor    eax, eax;
	__asm        mov    al, destination.y;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, here.y;
	__asm        sub    eax, ecx;
	__asm        mov    y, eax;
// LINE 19:
	__asm        mov    eax, x;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    x, eax;
// LINE 20:
	__asm        mov    eax, y;
	__asm        cdq;
	__asm        xor    eax, edx;
	__asm        sub    eax, edx;
	__asm        mov    y, eax;
// LINE 22:
	__asm        mov    eax, x;
	__asm        cmp    y, eax;
	__asm        jge    _T5f;
// LINE 24:
	return ((y >> 0x1) + x);
// LINE 26:
	__asm        jmp    __RETURN;
// LINE 28:
_T5f:
	return ((x >> 0x1) + y);
// LINE 30:
__RETURN:
}

// FUNCTION: COPTER_D 0x00543704
int32_t ShortestPath::BreadthFirstSearch(/*packed*/ struct _RGIndex startVertex, /*packed*/ struct _RGIndex destVertex) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode scratch; // 0x9 bytes
	/*bp-0x10*/  /*packed*/ struct RGVertex *pRGV;
	/*bp-0x1c*/  /*packed*/ struct _FringeHeapNode path; // 0x9 bytes
	/*bp-0x20*/  int32_t x;
	/*bp-0x24*/  int32_t pathFoundFlag;

// LINE 37:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 40:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T74;

	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T74;
// LINE 42:
	pRGV->edgeIndexPrev = 0xff;
// LINE 43:
	__asm        mov    al, destVertex.yindex;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2C], al;
// LINE 44:
	__asm        mov    al, destVertex.x;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2D], al;
// LINE 45:
	return 0x1;
// LINE 49:
_T74:
	pathFoundFlag = 0x0;
// LINE 52:
	this->heap = 0x5c3ab0;
// LINE 53:
	this->heap->cost = 0xffffffff;
// LINE 54:
	this->heapSize = 0x0;
// LINE 57:
_FOR_a6:
	for (x = 0x0; (x < 0x80); x++) {
		// LINE 59:
		// Block start:
			/*bp-0x28*/  int32_t yindex;
		_FOR_c2:
			yindex = 0x0;
			__asm        jmp    _FOR_COND_c2;
		_FOR_NEXT_c2:
			yindex++;
		_FOR_COND_c2:
			__asm        mov    eax, x;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, gRoadGraph.RGLength[eax];
			__asm        cmp    ecx, yindex;
			__asm        jle    _T113;
		// LINE 61:
		// Block start:
			/*bp-0x2c*/  /*packed*/ struct RGVertex *pRGV;
			__asm        mov    eax, x;
			__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
			__asm        mov    ecx, yindex;
			__asm        mov    edx, ecx;
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [edx+ecx*2];
			__asm        add    eax, ecx;
			__asm        mov    pRGV, eax;
		// LINE 62:
			pRGV->STVisited = 0x0;
		// LINE 63:
			pRGV->xPrev = 0xff;
		// LINE 64:
			pRGV->yindexPrev = 0xff;
		// LINE 65:
		// Block end:
			__asm        jmp    _FOR_NEXT_c2;
		// LINE 66:
		// Block end:
		_T113:
	}
// LINE 70:
_T118:
	__asm        mov    al, startVertex.yindex;
	__asm        mov    scratch.yindexCurr, al;
// LINE 71:
	__asm        mov    al, startVertex.x;
	__asm        mov    scratch.xCurr, al;
// LINE 72:
	scratch.edgeIndexPrev = 0xff;
// LINE 73:
	scratch.yindexPrev = 0xff;
// LINE 74:
	scratch.xPrev = 0xff;
// LINE 75:
	scratch.cost = 0x0;
// LINE 76:
	this->ShortestPath::PriorityHeapInsert(scratch.xCurr);
// LINE 81:
__WHILE_143:
	while ((this->heapSize != 0x0)) {

			__asm        cmp    pathFoundFlag, 0;
			__asm        jne    _T2a8;
		// LINE 85:
			this->ShortestPath::PriorityHeapRemove(path.xCurr);
		// LINE 87:
			__asm        xor    eax, eax;
			__asm        mov    al, path.xCurr;
			__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, path.yindexCurr;
			__asm        mov    edx, ecx;
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [edx+ecx*2];
			__asm        add    eax, ecx;
			__asm        mov    pRGV, eax;
		// LINE 88:
			__asm        mov    eax, pRGV;
			__asm        cmp    dword ptr [eax+0x2F], 0;
			__asm        jne    _T2a3;
		// LINE 92:
			__asm        mov    al, path.xPrev;
			__asm        mov    ecx, pRGV;
			__asm        mov    [ecx+0x2D], al;
		// LINE 93:
			__asm        mov    al, path.yindexPrev;
			__asm        mov    ecx, pRGV;
			__asm        mov    [ecx+0x2C], al;
		// LINE 94:
			__asm        mov    al, path.edgeIndexPrev;
			__asm        mov    ecx, pRGV;
			__asm        mov    [ecx+0x2E], al;
		// LINE 95:
			pRGV->STVisited = 0x1;
		// LINE 99:
			__asm        xor    eax, eax;
			__asm        mov    al, path.xCurr;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, destVertex.x;
			__asm        cmp    eax, ecx;
			__asm        jne    _FOR_1f5;

			__asm        xor    eax, eax;
			__asm        mov    al, path.yindexCurr;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, destVertex.yindex;
			__asm        cmp    eax, ecx;
			__asm        jne    _FOR_1f5;
		// LINE 101:
			pathFoundFlag = 0x1;
		// LINE 104:
			__asm        jmp    _T2a3;
		// LINE 108:
		// Block start:
			/*bp-0x30*/  int32_t i;
		_FOR_1f5:
			for (i = 0x0; (i < 0x4); i++) {
				// LINE 111:
				// Block start:
					/*bp-0x34*/  /*packed*/ struct Edge *pEdge;
					__asm        mov    eax, pRGV;
					__asm        mov    al, [eax+2];
					__asm        and    al, 0xF;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, al;
					__asm        mov    eax, i;
					__asm        test   IndexToType[0][eax*4], ecx;
					__asm        jne    _T223;
				// LINE 112:
					__asm        jmp    _FOR_NEXT_1f5;
				// LINE 115:
				_T223:
					__asm        mov    eax, i;
					__asm        lea    eax, [eax+eax*4];
					__asm        add    eax, eax;
					__asm        add    eax, pRGV;
					__asm        add    eax, 4;
					__asm        mov    pEdge, eax;
				// LINE 116:
					__asm        mov    eax, pEdge;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [eax+1];
					__asm        mov    eax, gRoadGraph.RGArray[0][ecx*4];
					__asm        mov    ecx, pEdge;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ecx];
					__asm        mov    ecx, edx;
					__asm        lea    edx, [edx+edx*4];
					__asm        lea    edx, [edx+edx*4];
					__asm        lea    ecx, [ecx+edx*2];
					__asm        cmp    dword ptr [eax+ecx+0x2F], 0;
					__asm        jne    _T29e;
				// LINE 118:
					__asm        mov    eax, pEdge;
					__asm        mov    al, [eax+1];
					__asm        mov    scratch.xCurr, al;
				// LINE 119:
					__asm        mov    eax, pEdge;
					__asm        mov    al, [eax];
					__asm        mov    scratch.yindexCurr, al;
				// LINE 120:
					__asm        mov    eax, pEdge;
					__asm        xor    ecx, ecx;
					__asm        mov    cx, [eax+2];
					__asm        add    ecx, path.cost;
					__asm        mov    scratch.cost, ecx;
				// LINE 121:
					__asm        mov    al, reinterpret_cast<uint8_t>(i);
					__asm        mov    scratch.edgeIndexPrev, al;
				// LINE 122:
					__asm        mov    al, path.xCurr;
					__asm        mov    scratch.xPrev, al;
				// LINE 123:
					__asm        mov    al, path.yindexCurr;
					__asm        mov    scratch.yindexPrev, al;
				// LINE 124:
					this->ShortestPath::PriorityHeapInsert(scratch.xCurr);
				// LINE 126:
				// Block end:
				_T29e:
			}
		// LINE 129:
		// Block end:
		_T2a3:
	}
// LINE 131:
_T2a8:
	return pathFoundFlag;
// LINE 132:
}

// FUNCTION: COPTER_D 0x005439bb
int32_t ShortestPath::DepthFirstSearch(/*packed*/ struct _RGIndex startVertex, /*packed*/ struct _RGIndex destVertex) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode scratch; // 0x9 bytes
	/*bp-0x10*/  /*packed*/ struct RGVertex *pRGV;
	/*bp-0x1c*/  /*packed*/ struct _FringeHeapNode path; // 0x9 bytes
	/*bp-0x20*/  int32_t x;
	/*bp-0x24*/  /*packed*/ struct _GridCoordinates currLoc;
	/*bp-0x28*/  int32_t pathFoundFlag;
	/*bp-0x2c*/  /*packed*/ struct _GridCoordinates destLoc;

// LINE 139:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, destVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 142:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax];
	__asm        mov    destLoc.x, al;
// LINE 143:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+1];
	__asm        mov    destLoc.y, al;
// LINE 146:
	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.x;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.x;
	__asm        cmp    eax, ecx;
	__asm        jne    _T85;

	__asm        xor    eax, eax;
	__asm        mov    al, destVertex.yindex;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        cmp    eax, ecx;
	__asm        jne    _T85;
// LINE 148:
	pRGV->edgeIndexPrev = 0xff;
// LINE 149:
	__asm        mov    al, destVertex.yindex;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2C], al;
// LINE 150:
	__asm        mov    al, destVertex.x;
	__asm        mov    ecx, pRGV;
	__asm        mov    [ecx+0x2D], al;
// LINE 151:
	return 0x1;
// LINE 155:
_T85:
	pathFoundFlag = 0x0;
// LINE 158:
	this->heap = 0x5c3ab0;
// LINE 159:
	this->heap->cost = 0xffffffff;
// LINE 160:
	this->heapSize = 0x0;
// LINE 163:
_FOR_b7:
	for (x = 0x0; (x < 0x80); x++) {
		// LINE 165:
		// Block start:
			/*bp-0x30*/  int32_t yindex;
		_FOR_d3:
			yindex = 0x0;
			__asm        jmp    _FOR_COND_d3;
		_FOR_NEXT_d3:
			yindex++;
		_FOR_COND_d3:
			__asm        mov    eax, x;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, gRoadGraph.RGLength[eax];
			__asm        cmp    ecx, yindex;
			__asm        jle    _T124;
		// LINE 167:
		// Block start:
			/*bp-0x34*/  /*packed*/ struct RGVertex *pRGV;
			__asm        mov    eax, x;
			__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
			__asm        mov    ecx, yindex;
			__asm        mov    edx, ecx;
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [edx+ecx*2];
			__asm        add    eax, ecx;
			__asm        mov    pRGV, eax;
		// LINE 168:
			pRGV->STVisited = 0x0;
		// LINE 169:
			pRGV->xPrev = 0xff;
		// LINE 170:
			pRGV->yindexPrev = 0xff;
		// LINE 171:
		// Block end:
			__asm        jmp    _FOR_NEXT_d3;
		// LINE 172:
		// Block end:
		_T124:
	}
// LINE 176:
_T129:
	__asm        xor    eax, eax;
	__asm        mov    al, startVertex.x;
	__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
	__asm        xor    ecx, ecx;
	__asm        mov    cl, startVertex.yindex;
	__asm        mov    edx, ecx;
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [ecx+ecx*4];
	__asm        lea    ecx, [edx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    pRGV, eax;
// LINE 177:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax];
	__asm        mov    currLoc.x, al;
// LINE 178:
	__asm        mov    eax, pRGV;
	__asm        mov    al, [eax+1];
	__asm        mov    currLoc.y, al;
// LINE 180:
	__asm        mov    al, startVertex.x;
	__asm        mov    scratch.xCurr, al;
// LINE 181:
	__asm        mov    al, startVertex.yindex;
	__asm        mov    scratch.yindexCurr, al;
// LINE 182:
	scratch.edgeIndexPrev = 0xff;
// LINE 183:
	scratch.yindexPrev = 0xff;
// LINE 184:
	scratch.xPrev = 0xff;
// LINE 185:
	scratch.cost = this->ShortestPath::FindDistanceFromDestination(currLoc.x, destLoc.x);
// LINE 186:
	this->ShortestPath::PriorityHeapInsert(scratch.xCurr);
// LINE 191:
__WHILE_192:
	while ((this->heapSize != 0x0)) {

			__asm        cmp    pathFoundFlag, 0;
			__asm        jne    _T313;
		// LINE 195:
			this->ShortestPath::PriorityHeapRemove(path.xCurr);
		// LINE 197:
			__asm        xor    eax, eax;
			__asm        mov    al, path.xCurr;
			__asm        mov    eax, gRoadGraph.RGArray[0][eax*4];
			__asm        xor    ecx, ecx;
			__asm        mov    cl, path.yindexCurr;
			__asm        mov    edx, ecx;
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [ecx+ecx*4];
			__asm        lea    ecx, [edx+ecx*2];
			__asm        add    eax, ecx;
			__asm        mov    pRGV, eax;
		// LINE 199:
			__asm        mov    eax, pRGV;
			__asm        cmp    dword ptr [eax+0x2F], 0;
			__asm        jne    _T30e;
		// LINE 203:
			__asm        mov    al, path.xPrev;
			__asm        mov    ecx, pRGV;
			__asm        mov    [ecx+0x2D], al;
		// LINE 204:
			__asm        mov    al, path.yindexPrev;
			__asm        mov    ecx, pRGV;
			__asm        mov    [ecx+0x2C], al;
		// LINE 205:
			__asm        mov    al, path.edgeIndexPrev;
			__asm        mov    ecx, pRGV;
			__asm        mov    [ecx+0x2E], al;
		// LINE 206:
			pRGV->STVisited = 0x1;
		// LINE 210:
			__asm        xor    eax, eax;
			__asm        mov    al, path.xCurr;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, destVertex.x;
			__asm        cmp    eax, ecx;
			__asm        jne    _FOR_244;

			__asm        xor    eax, eax;
			__asm        mov    al, path.yindexCurr;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, destVertex.yindex;
			__asm        cmp    eax, ecx;
			__asm        jne    _FOR_244;
		// LINE 212:
			pathFoundFlag = 0x1;
		// LINE 215:
			__asm        jmp    _T30e;
		// LINE 219:
		// Block start:
			/*bp-0x38*/  int32_t i;
		_FOR_244:
			for (i = 0x0; (i < 0x4); i++) {
				// LINE 222:
				// Block start:
					/*bp-0x3c*/  /*packed*/ struct Edge *pEdge;
					/*bp-0x40*/  /*packed*/ struct RGVertex *pCurrRGV;
					__asm        mov    eax, pRGV;
					__asm        mov    al, [eax+2];
					__asm        and    al, 0xF;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, al;
					__asm        mov    eax, i;
					__asm        test   IndexToType[0][eax*4], ecx;
					__asm        jne    _T272;
				// LINE 223:
					__asm        jmp    _FOR_NEXT_244;
				// LINE 226:
				_T272:
					__asm        mov    eax, i;
					__asm        lea    eax, [eax+eax*4];
					__asm        add    eax, eax;
					__asm        add    eax, pRGV;
					__asm        add    eax, 4;
					__asm        mov    pEdge, eax;
				// LINE 227:
					__asm        mov    eax, pEdge;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [eax+1];
					__asm        mov    eax, gRoadGraph.RGArray[0][ecx*4];
					__asm        mov    ecx, pEdge;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ecx];
					__asm        mov    ecx, edx;
					__asm        lea    edx, [edx+edx*4];
					__asm        lea    edx, [edx+edx*4];
					__asm        lea    ecx, [ecx+edx*2];
					__asm        add    eax, ecx;
					__asm        mov    pCurrRGV, eax;
				// LINE 228:
					__asm        mov    eax, pCurrRGV;
					__asm        cmp    dword ptr [eax+0x2F], 0;
					__asm        jne    _T309;
				// LINE 230:
					__asm        mov    eax, pCurrRGV;
					__asm        mov    al, [eax];
					__asm        mov    currLoc.x, al;
				// LINE 231:
					__asm        mov    eax, pCurrRGV;
					__asm        mov    al, [eax+1];
					__asm        mov    currLoc.y, al;
				// LINE 233:
					__asm        mov    eax, pEdge;
					__asm        mov    al, [eax+1];
					__asm        mov    scratch.xCurr, al;
				// LINE 234:
					__asm        mov    eax, pEdge;
					__asm        mov    al, [eax];
					__asm        mov    scratch.yindexCurr, al;
				// LINE 235:
					scratch.cost = this->ShortestPath::FindDistanceFromDestination(currLoc.x, destLoc.x);
				// LINE 236:
					__asm        mov    al, reinterpret_cast<uint8_t>(i);
					__asm        mov    scratch.edgeIndexPrev, al;
				// LINE 237:
					__asm        mov    al, path.xCurr;
					__asm        mov    scratch.xPrev, al;
				// LINE 238:
					__asm        mov    al, path.yindexCurr;
					__asm        mov    scratch.yindexPrev, al;
				// LINE 239:
					this->ShortestPath::PriorityHeapInsert(scratch.xCurr);
				// LINE 241:
				// Block end:
				_T309:
			}
		// LINE 244:
		// Block end:
		_T30e:
	}
// LINE 246:
_T313:
	return pathFoundFlag;
// LINE 247:
}

// FUNCTION: COPTER_D 0x00543cdd
void ShortestPath::PriorityHeapInsert(const /*packed*/ struct _FringeHeapNode *pInsertNode) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode tempNode; // 0x9 bytes
	/*bp-0x10*/  int32_t index;

// LINE 255:
	this->heapSize++;
	index = this->heapSize;
// LINE 258:
	__asm        mov    eax, pInsertNode;
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        add    ecx, [edx];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 264:
__WHILE_39:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, index;
	__asm        lea    edx, [edx+edx*8];
	__asm        mov    ebx, this;
	__asm        mov    ebx, [ebx];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jle    _Te2;
// LINE 266:
	__asm        mov    eax, index;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 267:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        add    ecx, [edx];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 268:
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        lea    eax, [eax+eax*8];
	__asm        mov    edx, this;
	__asm        add    eax, [edx];
	__asm        mov    edx, [ecx];
	__asm        mov    [eax], edx;
	__asm        mov    edx, [ecx+4];
	__asm        mov    [eax+4], edx;
	__asm        mov    cl, [ecx+8];
	__asm        mov    [eax+8], cl;
// LINE 269:
	__asm        mov    eax, index;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    index, eax;
// LINE 270:
	__asm        jmp    __WHILE_39;
// LINE 271:
_Te2:
	return;
}

// FUNCTION: COPTER_D 0x00543dcb
void ShortestPath::PriorityHeapRemove(/*packed*/ struct _FringeHeapNode *pRemovedNode) {
	/*bp-0xc*/   /*packed*/ struct _FringeHeapNode tempNode; // 0x9 bytes
	/*bp-0x10*/  int32_t parent;
	/*bp-0x14*/  int32_t child;
	/*bp-0x18*/  int32_t index;

// LINE 281:
	index = this->heapSize;
	this->heapSize--;
// LINE 282:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        add    eax, 9;
	__asm        mov    ecx, pRemovedNode;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 283:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, index;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        add    ecx, 9;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        add    eax, 9;
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 287:
	parent = 0x1;
// LINE 290:
__WHILE_83:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        cmp    eax, parent;
	__asm        jl     _T176;
// LINE 293:
	child = (parent + parent);
// LINE 296:
	__asm        mov    eax, this;
	__asm        mov    ecx, child;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _Td8;

	__asm        mov    eax, child;
	__asm        lea    eax, [eax+eax*8+9];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    ebx, child;
	__asm        lea    ebx, [ebx+ebx*8];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jge    _Td8;
// LINE 297:
	child++;
// LINE 300:
_Td8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, parent;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        mov    edx, this;
	__asm        mov    edx, [edx];
	__asm        mov    ebx, child;
	__asm        lea    ebx, [ebx+ebx*8];
	__asm        mov    edx, [edx+ebx+5];
	__asm        cmp    [eax+ecx+5], edx;
	__asm        jg     _T101;
// LINE 301:
	__asm        jmp    _T176;
// LINE 304:
_T101:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, parent;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        lea    ecx, tempNode.xCurr;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 305:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, child;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 306:
	__asm        lea    eax, tempNode.xCurr;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, child;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 309:
	parent = child;
// LINE 310:
	__asm        jmp    __WHILE_83;
// LINE 313:
_T176:
	__asm        lea    eax, tempNode.xCurr;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, parent;
	__asm        lea    edx, [edx+edx*8];
	__asm        add    ecx, edx;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    al, [eax+8];
	__asm        mov    [ecx+8], al;
// LINE 314:
	return;
}



// Contribution: 2:000044f8-00004507 Module: 151, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x005934f8
static const enum DirectionTypes IndexToType[4] = { 0 /* todo */ };

