// Module: S3explod.obj
// Source: C:\Copter\source\game\S3explod.c
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ struct _EXPLODE_DATA (forward reference);
struct _EXPLODE_DATA{ // packed(0x34 bytes) TI: 0x3162
	long flags;
	int32_t width;
	int32_t height;
	/*packed*/ struct Point3d loc;
	long animseq;
	int32_t firstface;
	/*packed*/ struct _DYOBJ_INST *dy2d;
	/*packed*/ struct _DYOBJ_INST *dysmoke;
	long scale;
	/*packed*/ struct _CELL_INFO *cptr;
	long mission_id;
};

// Type: /*packed*/ struct _SMOKE_DATA (forward reference);
struct _SMOKE_DATA{ // packed(0x1c bytes) TI: 0x3160
	long flags;
	/*packed*/ struct _DYOBJ_INST *dysmoke;
	int32_t timetolive;
	/*packed*/ struct _CELL_INFO *cptr;
	int32_t firstface;
	int32_t speed;
	long mission_id;
};

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	int32_t x;
	int32_t y;
	int32_t z;
};

// Type: /*packed*/ struct VRBmpHdr (forward reference);
struct VRBmpHdr{ // packed(0x10 bytes) TI: 0x2312
	/*packed*/ struct VRBmpInfo info;
	int32_t ScanOffset[1];
};

// Type: long;

// Type: void;

// Type: char *;

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	int32_t x;
	int32_t y;
	int32_t z;
};

// Type: int32_t;

// Type: /*packed*/ struct _CELL_INFO (forward reference);
struct _CELL_INFO{ // packed(0x18 bytes) TI: 0x1b03
	short flags;
	short x;
	short y;
	short z;
	short size;
	short ctr;
	/*packed*/ struct _STOBJ_INST *stptr;
	/*packed*/ struct _DYOBJ_INST *dyptr;
	/*packed*/ struct _DYOBJ_INST *vwptr;
};

// Type: /*packed*/ struct VRFaceInfo;
struct VRFaceInfo{ // packed(0x20 bytes) TI: 0x30c0
	int32_t Face;
	int32_t Verts;
	int32_t Attribute;
	int32_t Plotter;
	/*packed*/ struct VRBmpHdr *Bitmap;
	int32_t * VertList;
	/*packed*/ struct MapVert *MapVList;
	/*packed*/ struct MapVert *BarryPtr;
};

// Type: /*packed*/ struct VRview;
struct VRview{ // packed(0x58 bytes) TI: 0x2ecc
	/*packed*/ struct Point3d loc;
	/*packed*/ struct Point3d scale;
	int32_t matrix[4][4];
};

// Type: /*packed*/ struct _DYOBJ_INST (forward reference);
struct _DYOBJ_INST{ // packed(0x64 bytes) TI: 0x1deb
	/*packed*/ struct _DYOBJ_INST *next;
	/*packed*/ struct _DYOBJ_INST *vnext;
	void * __ptr32 mesh;
	short flags;
	short user1;
	long radius;
	long height;
	/*packed*/ struct Point3d loc;
	int32_t matrix[4][4];
};

// Type: /*packed*/ struct Point2d;
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	int32_t x;
	int32_t y;
};



// Contribution: 1:00122910-001235ed Module: 166, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00523910
void S3ExplosionReset() {
	/*bp-0x4*/   /*packed*/ struct _SMOKE_DATA *sd;
	/*bp-0x8*/   long i;
	/*bp-0xc*/   /*packed*/ struct _EXPLODE_DATA *ed;

// LINE 59:
	S_num_expls = 0x0;
// LINE 60:
	S_num_smoke = 0x0;
// LINE 63:
	__asm        mov    i, 0;
	__asm        mov    ed, 0x62A578;
	__asm        jmp    _T37;
_T30:
	__asm        inc    i;
	__asm        add    ed, 0x34;
_T37:
	__asm        cmp    i, 0x14;
	__asm        jge    _T4f;
// LINE 66:
	ed->flags = 0x0;
// LINE 67:
	__asm        jmp    _T30;
// LINE 70:
_T4f:
	__asm        mov    i, 0;
	__asm        mov    sd, 0x62AA58;
	__asm        jmp    _T69;
_T62:
	__asm        inc    i;
	__asm        add    sd, 0x1C;
_T69:
	__asm        cmp    i, 0x64;
	__asm        jge    _T81;
// LINE 73:
	sd->flags = 0x0;
// LINE 75:
	__asm        jmp    _T62;
// LINE 77:
_T81:
}

// FUNCTION: COPTER_D 0x00523996
void S3ExplosionInit() {
	/*bp-0x40*/  int32_t mat[4][4]; // 0x40 bytes
	/*bp-0x44*/  long size;
	/*bp-0x50*/  /*packed*/ struct Point3d vec; // 0xc bytes
	/*bp-0x54*/  /*packed*/ struct _SMOKE_DATA *sd;
	/*bp-0x58*/  long i;
	/*bp-0x5c*/  char * mem;
	/*bp-0x60*/  /*packed*/ struct _EXPLODE_DATA *ed;

// LINE 96:
	__asm        push   0x7F;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRGetObjDupMemReq;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 103:
	__asm        mov    i, 0;
	__asm        mov    ed, 0x62A578;
	__asm        jmp    _T39;
_T32:
	__asm        inc    i;
	__asm        add    ed, 0x34;
_T39:
	__asm        cmp    i, 0x14;
	__asm        jge    _T14a;
// LINE 106:
	ed->flags = 0x0;
// LINE 107:
	ed->width = 0x0;
// LINE 108:
	ed->height = 0x0;
// LINE 109:
	ed->loc.x = 0x0;
// LINE 110:
	ed->loc.y = 0x0;
// LINE 111:
	ed->loc.z = 0x0;
// LINE 112:
	ed->animseq = 0x0;
// LINE 115:
	__asm        push   0x7F;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRGetObjDupMemReq;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 117:
	__asm        push   0x64;
	__asm        mov    eax, G_dyobjmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    ecx, ed;
	__asm        mov    [ecx+0x20], eax;
// LINE 118:
	ed->dy2d->flags = 0x61;
// LINE 120:
	__asm        mov    eax, size;
	__asm        push   eax;
	__asm        mov    eax, G_dyobjmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    mem, eax;
// LINE 121:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x7F;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRCreateObjDuplicate;
	__asm        add    esp, 8;
	__asm        mov    ecx, ed;
	__asm        mov    ecx, [ecx+0x20];
	__asm        mov    [ecx+8], eax;
// LINE 122:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 125:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    ecx, ed;
	__asm        mov    [ecx+0x1C], eax;
// LINE 126:
	__asm        push   2;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D6970;
	__asm        add    esp, 8;
// LINE 129:
	ed->dy2d->next = 0x0;
// LINE 130:
	__asm        jmp    _T32;
// LINE 133:
_T14a:
	__asm        push   0x148;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRGetObjDupMemReq;
	__asm        add    esp, 4;
	__asm        mov    size, eax;
// LINE 140:
	__asm        mov    i, 0;
	__asm        mov    sd, 0x62AA58;
	__asm        jmp    _T17d;
_T176:
	__asm        inc    i;
	__asm        add    sd, 0x1C;
_T17d:
	__asm        cmp    i, 0x64;
	__asm        jge    _T236;
// LINE 143:
	sd->flags = 0x0;
// LINE 144:
	sd->timetolive = 0x0;
// LINE 147:
	__asm        push   0x64;
	__asm        mov    eax, G_dyobjmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+4], eax;
// LINE 148:
	sd->dysmoke->flags = 0x61;
// LINE 149:
	sd->dysmoke->radius = 0x200000;
// LINE 152:
	__asm        mov    eax, size;
	__asm        push   eax;
	__asm        mov    eax, G_dyobjmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    mem, eax;
// LINE 153:
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        push   0x148;
	__asm        call   0x004D8821;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        call   VRCreateObjDuplicate;
	__asm        add    esp, 8;
	__asm        mov    ecx, sd;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx+8], eax;
// LINE 156:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D85CD;
	__asm        add    esp, 4;
	__asm        mov    ecx, sd;
	__asm        mov    [ecx+0x10], eax;
// LINE 157:
	__asm        mov    eax, G_main_mp;
	__asm        push   eax;
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D84DB;
	__asm        add    esp, 8;
// LINE 159:
	__asm        jmp    _T176;
// LINE 162:
_T236:
	__asm        push   0xF;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[0], eax;
// LINE 163:
	__asm        push   0x10;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[1], eax;
// LINE 164:
	__asm        push   0x11;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[2], eax;
// LINE 165:
	__asm        push   0x12;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[3], eax;
// LINE 166:
	__asm        push   0x19;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[4], eax;
// LINE 167:
	__asm        push   0x1A;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[5], eax;
// LINE 168:
	__asm        push   0x1B;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[6], eax;
// LINE 169:
	__asm        push   0x1C;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[7], eax;
// LINE 170:
	__asm        push   0x1D;
	__asm        mov    eax, G_restex;
	__asm        push   eax;
	__asm        call   VRInt2BmpHdr;
	__asm        add    esp, 8;
	__asm        mov    S_explseq[8], eax;
// LINE 173:
	__asm        mov    eax, 0x59B4F8;
	__asm        mov    ecx, 0x62A988;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 174:
	__asm        mov    eax, 0x59B508;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0xC;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 175:
	__asm        mov    eax, 0x59B518;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 176:
	__asm        mov    eax, 0x59B4F8;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x24;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 177:
	__asm        mov    eax, 0x59B508;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x30;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 178:
	__asm        mov    eax, 0x59B518;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x3C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 179:
	__asm        mov    eax, X_axis.x;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[3].x, eax;
// LINE 180:
	__asm        mov    eax, Y_axis.y;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[4].y, eax;
// LINE 181:
	__asm        mov    eax, Z_axis.z;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[5].z, eax;
// LINE 183:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 184:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0x1C20000;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 185:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0x1C20000;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 186:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B508;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 187:
	__asm        lea    eax, vec.x;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x48;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 188:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[7].x, eax;
// LINE 189:
	__asm        mov    eax, vec.y;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[7].y, eax;
// LINE 190:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[7].z, eax;
// LINE 192:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 193:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0xFE3E0000;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 194:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0x1C20000;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 195:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B508;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 196:
	__asm        lea    eax, vec.x;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x60;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 197:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[9].x, eax;
// LINE 198:
	__asm        mov    eax, vec.y;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[9].y, eax;
// LINE 199:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[9].z, eax;
// LINE 201:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 202:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0x1C20000;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 203:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0xFE3E0000;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 204:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B508;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 205:
	__asm        lea    eax, vec.x;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x78;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 206:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[11].x, eax;
// LINE 207:
	__asm        mov    eax, vec.y;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[11].y, eax;
// LINE 208:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[11].z, eax;
// LINE 210:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 211:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0xFE3E0000;
	__asm        call   0x004D2034;
	__asm        add    esp, 8;
// LINE 212:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        push   0xFE3E0000;
	__asm        call   0x004D2004;
	__asm        add    esp, 8;
// LINE 213:
	__asm        lea    eax, mat[0][0];
	__asm        push   eax;
	__asm        lea    eax, vec.x;
	__asm        push   eax;
	__asm        push   0x59B508;
	__asm        call   0x004D2094;
	__asm        add    esp, 0xC;
// LINE 214:
	__asm        lea    eax, vec.x;
	__asm        mov    ecx, 0x62A988;
	__asm        add    ecx, 0x90;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 215:
	__asm        mov    eax, vec.x;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[13].x, eax;
// LINE 216:
	__asm        mov    eax, vec.y;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[13].y, eax;
// LINE 217:
	__asm        mov    eax, vec.z;
	__asm        neg    eax;
	__asm        mov    S_spark_vectors[13].z, eax;
// LINE 220:
}

// FUNCTION: COPTER_D 0x00523f50
void S3ExplosionStart(/*packed*/ struct _CELL_INFO *cptr, int32_t x, int32_t y, int32_t z, long scale, long mission_id) {
	/*bp-0x4*/   long dim;
	/*bp-0x24*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes
	/*bp-0x28*/  long i;
	/*bp-0x2c*/  /*packed*/ struct _EXPLODE_DATA *ed;

// LINE 240:
	__asm        mov    i, 0;
	__asm        mov    ed, 0x62A578;
	__asm        jmp    _T23;
_T1c:
	__asm        inc    i;
	__asm        add    ed, 0x34;
_T23:
	__asm        cmp    i, 0x14;
	__asm        jge    _T43;
// LINE 242:
	__asm        mov    eax, ed;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T3e;
// LINE 243:
	__asm        jmp    _T43;
// LINE 244:
_T3e:
	__asm        jmp    _T1c;
// LINE 248:
_T43:
	__asm        cmp    i, 0x14;
	__asm        jne    _T52;
// LINE 249:
	__asm        jmp    _T187;
// LINE 254:
_T52:
	__asm        cmp    cptr, 0;
	__asm        jne    _T61;
// LINE 255:
	__asm        jmp    _T187;
// LINE 258:
_T61:
	__asm        mov    eax, 4;
	__asm        mov    cl, reinterpret_cast<uint8_t>(scale);
	__asm        shl    eax, cl;
	__asm        mov    dim, eax;
// LINE 261:
	__asm        mov    eax, ed;
	__asm        or     dword ptr [eax], 1;
// LINE 264:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 265:
	finfo.Bitmap = S_explseq[0];
// LINE 266:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 268:
	ed->animseq = 0xffffffff;
// LINE 269:
	ed->cptr = cptr;
// LINE 270:
	ed->mission_id = mission_id;
// LINE 271:
	ed->scale = scale;
// LINE 274:
	__asm        mov    eax, dim;
	__asm        push   eax;
	__asm        mov    eax, dim;
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   VRObjResize2dFace;
	__asm        add    esp, 0xC;
// LINE 283:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+2];
	__asm        shl    eax, 0x10;
	__asm        add    eax, x;
	__asm        mov    ecx, ed;
	__asm        mov    [ecx+0xC], eax;
// LINE 284:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+4];
	__asm        shl    eax, 0x10;
	__asm        add    eax, y;
	__asm        mov    ecx, ed;
	__asm        mov    [ecx+0x10], eax;
// LINE 285:
	__asm        mov    eax, cptr;
	__asm        movsx  eax, word ptr [eax+6];
	__asm        shl    eax, 0x10;
	__asm        add    eax, z;
	__asm        mov    ecx, ed;
	__asm        mov    [ecx+0x14], eax;
// LINE 288:
	__asm        mov    eax, ed;
	__asm        add    eax, 0xC;
	__asm        mov    ecx, ed;
	__asm        mov    ecx, [ecx+0x20];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 290:
	__asm        mov    eax, dim;
	__asm        shl    eax, 0x10;
	__asm        mov    ecx, ed;
	__asm        mov    ecx, [ecx+0x20];
	__asm        mov    [ecx+0x10], eax;
// LINE 294:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        sub    dword ptr [eax+0x1C], 0x200000;
// LINE 297:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 300:
	ed->dy2d->next = cptr->dyptr;
// LINE 301:
	cptr->dyptr = ed->dy2d;
// LINE 303:
	__asm        inc    S_num_expls;
// LINE 304:
_T187:
}

// FUNCTION: COPTER_D 0x005240dc
void S3ExplosionSmokeStart(/*packed*/ struct _CELL_INFO *cptr, /*packed*/ struct Point3d *loc, long smoke_size) {
	/*bp-0x4*/   /*packed*/ struct _SMOKE_DATA *sd;
	/*bp-0x24*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes
	/*bp-0x28*/  long i;

// LINE 319:
	__asm        mov    i, 0;
	__asm        mov    sd, 0x62AA58;
	__asm        jmp    _T23;
_T1c:
	__asm        inc    i;
	__asm        add    sd, 0x1C;
_T23:
	__asm        cmp    i, 0x64;
	__asm        jge    _T43;
// LINE 321:
	__asm        mov    eax, sd;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T3e;
// LINE 322:
	__asm        jmp    _T43;
// LINE 323:
_T3e:
	__asm        jmp    _T1c;
// LINE 327:
_T43:
	__asm        cmp    i, 0x64;
	__asm        jne    _T52;
// LINE 328:
	__asm        jmp    _T1bc;
// LINE 333:
_T52:
	__asm        cmp    cptr, 0;
	__asm        jne    _T61;
// LINE 334:
	__asm        jmp    _T1bc;
// LINE 337:
_T61:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 338:
	finfo.Bitmap = smoke_size;
// LINE 339:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 342:
	__asm        mov    eax, sd;
	__asm        or     dword ptr [eax], 1;
// LINE 343:
	sd->cptr = cptr;
// LINE 344:
	sd->timetolive = 0x20000;
// LINE 347:
	__asm        mov    eax, loc;
	__asm        mov    ecx, sd;
	__asm        mov    ecx, [ecx+4];
	__asm        add    ecx, 0x18;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 349:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, 0x24;
	__asm        push   eax;
	__asm        call   0x004D1FF1;
	__asm        add    esp, 4;
// LINE 352:
	sd->dysmoke->next = cptr->dyptr;
// LINE 353:
	cptr->dyptr = sd->dysmoke;
// LINE 356:
	__asm        mov    eax, smoke_size;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T176;
// LINE 359:
	sd->speed = 0xd0000;
// LINE 360:
	__asm        jmp    _T1b6;
// LINE 362:
	sd->speed = 0xa0000;
// LINE 363:
	__asm        jmp    _T1b6;
// LINE 365:
	sd->speed = 0x190000;
// LINE 366:
	__asm        jmp    _T1b6;
// LINE 368:
	sd->speed = 0x1e0000;
// LINE 369:
	__asm        jmp    _T1b6;
// LINE 371:
	sd->speed = 0x110000;
// LINE 372:
	__asm        jmp    _T1b6;
// LINE 374:
	sd->speed = 0x190000;
// LINE 375:
	__asm        jmp    _T1b6;
// LINE 377:
	sd->speed = 0x140000;
// LINE 378:
	__asm        jmp    _T1b6;
// LINE 384:
_T162:
	sd->speed = 0xf0000;
// LINE 385:
	__asm        jmp    _T1b6;
// LINE 386:
	__asm        jmp    _T1b6;
_T176:
	__asm        cmp    dword ptr [ebp-0x2C], 0xA;
	__asm        ja     _T162;

	__asm        mov    eax, [ebp-0x2C];
	__asm        jmp    SwitchPointers5390950[0][eax*4];
// Switch pointers
// LINE 388:
_T1b6:
	__asm        inc    S_num_smoke;
// LINE 389:
_T1bc:
}

// FUNCTION: COPTER_D 0x0052429d
void S3ExplosionDriver() {
	/*bp-0x4*/   /*packed*/ struct _SMOKE_DATA *sd;
	/*bp-0x24*/  /*packed*/ struct VRFaceInfo finfo; // 0x20 bytes
	/*bp-0x2c*/  /*packed*/ struct Point2d celloc; // 0x8 bytes
	/*bp-0x30*/  long i;
	/*bp-0x34*/  long j;
	/*bp-0x38*/  /*packed*/ struct _DYOBJ_INST **dyptrptr;
	/*bp-0x90*/  /*packed*/ struct VRview pos; // 0x58 bytes
	/*bp-0x94*/  /*packed*/ struct _EXPLODE_DATA *ed;

// LINE 410:
	__asm        mov    i, 0;
	__asm        mov    ed, 0x62A578;
	__asm        jmp    _T2c;
_T22:
	__asm        inc    i;
	__asm        add    ed, 0x34;
_T2c:
	__asm        cmp    S_num_expls, 0;
	__asm        jle    _T218;

	__asm        cmp    i, 0x14;
	__asm        jge    _T218;
// LINE 412:
	__asm        mov    eax, ed;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T57;
// LINE 413:
	__asm        jmp    _T22;
// LINE 416:
_T57:
	__asm        mov    eax, ed;
	__asm        inc    dword ptr [eax+0x18];
// LINE 420:
	__asm        mov    eax, ed;
	__asm        cmp    dword ptr [eax+0x18], 1;
	__asm        jne    _Tff;
// LINE 422:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0xC];
	__asm        add    eax, 0x20000000;
	__asm        sar    eax, 0x16;
	__asm        mov    celloc.x, eax;
// LINE 423:
	__asm        mov    eax, 0x20000000;
	__asm        mov    ecx, ed;
	__asm        sub    eax, [ecx+0x14];
	__asm        sar    eax, 0x16;
	__asm        mov    celloc.y, eax;
// LINE 424:
	__asm        mov    j, 0;
	__asm        jmp    _Ta7;
_Ta4:
	__asm        inc    j;
_Ta7:
	__asm        cmp    j, 0xE;
	__asm        jge    _Tff;
// LINE 435:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x30];
	__asm        push   eax;
	__asm        push   0x140000;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x28];
	__asm        push   eax;
	__asm        mov    eax, j;
	__asm        lea    eax, [eax+eax*2];
	__asm        lea    eax, S_spark_vectors[0].x[eax*4];
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        add    eax, 0xC;
	__asm        push   eax;
	__asm        lea    eax, celloc.x;
	__asm        push   eax;
	__asm        push   9;
	__asm        call   S3MissileStart;
	__asm        add    esp, 0x20;
// LINE 436:
	__asm        jmp    _Ta4;
// LINE 440:
_Tff:
	__asm        mov    eax, ed;
	__asm        cmp    dword ptr [eax+0x18], 9;
	__asm        jl     _T17e;
// LINE 443:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x2C];
	__asm        add    eax, 0x10;
	__asm        mov    dyptrptr, eax;
// LINE 444:
_T11e:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T160;
// LINE 446:
	__asm        mov    eax, ed;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+0x20], ecx;
	__asm        jne    _T153;
// LINE 448:
	dyptrptr-> = ed->dy2d->next;
// LINE 449:
	__asm        jmp    _T160;
// LINE 451:
_T153:
	dyptrptr = dyptrptr->;
// LINE 452:
	__asm        jmp    _T11e;
// LINE 454:
_T160:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax];
	__asm        and    eax, 0xFFFFFFFE;
	__asm        mov    ecx, ed;
	__asm        mov    [ecx], eax;
// LINE 455:
	__asm        dec    S_num_expls;
// LINE 456:
	__asm        jmp    _T22;
// LINE 460:
_T17e:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   0x004D6905;
	__asm        add    esp, 8;
// LINE 461:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    eax, S_explseq[0][eax*4];
	__asm        mov    finfo.Bitmap, eax;
// LINE 462:
	__asm        lea    eax, finfo.Face;
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   0x004D6941;
	__asm        add    esp, 8;
// LINE 465:
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 466:
	__asm        mov    eax, ed;
	__asm        mov    esi, [eax+0x20];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 467:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, ed;
	__asm        mov    eax, [eax+0x20];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 469:
	__asm        jmp    _T22;
// LINE 472:
_T218:
	__asm        mov    i, 0;
	__asm        mov    sd, 0x62AA58;
	__asm        jmp    _T232;
_T22b:
	__asm        inc    i;
	__asm        add    sd, 0x1C;
_T232:
	__asm        cmp    S_num_smoke, 0;
	__asm        jle    _T347;

	__asm        cmp    i, 0x64;
	__asm        jge    _T347;
// LINE 474:
	__asm        mov    eax, sd;
	__asm        test   byte ptr [eax], 1;
	__asm        jne    _T25a;
// LINE 475:
	__asm        jmp    _T22b;
// LINE 478:
_T25a:
	__asm        xor    eax, eax;
	__asm        sub    eax, G_AvLoopTime;
	__asm        neg    eax;
	__asm        mov    ecx, sd;
	__asm        sub    [ecx+8], eax;
// LINE 481:
	__asm        mov    eax, sd;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jg     _T2d7;
// LINE 484:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0xC];
	__asm        add    eax, 0x10;
	__asm        mov    dyptrptr, eax;
// LINE 485:
_T283:
	__asm        mov    eax, dyptrptr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T2bf;
// LINE 487:
	__asm        mov    eax, sd;
	__asm        mov    ecx, dyptrptr;
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax+4], ecx;
	__asm        jne    _T2b2;
// LINE 489:
	dyptrptr-> = sd->dysmoke->next;
// LINE 490:
	__asm        jmp    _T2bf;
// LINE 492:
_T2b2:
	dyptrptr = dyptrptr->;
// LINE 493:
	__asm        jmp    _T283;
// LINE 495:
_T2bf:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax];
	__asm        and    eax, 0xFFFFFFFE;
	__asm        mov    ecx, sd;
	__asm        mov    [ecx], eax;
// LINE 496:
	__asm        dec    S_num_smoke;
// LINE 497:
	__asm        jmp    _T22b;
// LINE 501:
_T2d7:
	__asm        mov    eax, G_AvLoopTime;
	__asm        push   eax;
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+0x14];
	__asm        push   eax;
	__asm        call   0x004D19BD;
	__asm        add    esp, 8;
	__asm        mov    ecx, sd;
	__asm        mov    ecx, [ecx+4];
	__asm        add    [ecx+0x1C], eax;
// LINE 504:
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, 0x18;
	__asm        lea    ecx, pos.loc.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 505:
	__asm        mov    eax, sd;
	__asm        mov    esi, [eax+4];
	__asm        lea    edi, pos.matrix[0][0];
	__asm        add    esi, 0x24;
	__asm        mov    ecx, 0x10;
	__asm        rep movsd;
// LINE 506:
	__asm        push   3;
	__asm        lea    eax, pos.loc.x;
	__asm        push   eax;
	__asm        mov    eax, sd;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   0x004D8781;
	__asm        add    esp, 0xC;
// LINE 508:
	__asm        jmp    _T22b;
// LINE 510:
_T347:
	__asm        jmp    near ptr 0x005245E9;
// LINE 511:
}



// Contribution: 3:00020380-00020387 Module: 166, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005b7380
static long S_num_expls = 0;

// GLOBAL: COPTER_D 0x005b7384
static long S_num_smoke = 0;



// Contribution: 3:00093578-00094547 Module: 166, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x0062a578
static /*packed*/ struct _EXPLODE_DATA S_explosions[20];

// GLOBAL: COPTER_D 0x0062a988
static /*packed*/ struct Point3d S_spark_vectors[14];

// GLOBAL: COPTER_D 0x0062aa30
static /*packed*/ struct VRBmpHdr *S_explseq[9];

// GLOBAL: COPTER_D 0x0062aa58
static /*packed*/ struct _SMOKE_DATA S_smoke[100];

