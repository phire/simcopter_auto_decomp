// Module: Frustrum.obj
// Source: C:\Copter\Source\Engine\Frustrum.c
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: void;



// Contribution: 1:000d56c0-000d57db Module: 143, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004d66c0
void VRFrustSetNormals() {
	/*bp-0xc*/   /*packed*/ struct Point3d vect; // 0xc bytes
	/*bp-0x10*/  int32_t distx;
	/*bp-0x14*/  int32_t disty;
	/*bp-0x18*/  int32_t shigh;
	/*bp-0x1c*/  int32_t swide;

// LINE 74:
	distx = (HALF_WIDTH << 0x4);
// LINE 75:
	disty = (HALF_ASPECT << 0x4);
// LINE 76:
	swide = (CLIP_RITE << 0x4);
// LINE 77:
	shigh = (CLIP_BOTM << 0x4);
// LINE 81:
	__asm        mov    eax, distx;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, swide;
	__asm        push   eax;
	__asm        call   _FixedDiv;
	__asm        add    esp, 8;
	__asm        mov    vect.x, eax;
// LINE 82:
	vect.y = 0x0;
// LINE 83:
	vect.z = 0x10000;
// LINE 86:
	MTNormalize(vect.x);
// LINE 89:
	__asm        mov    eax, vect.z;
	__asm        neg    eax;
	__asm        mov    VRFrusRiteNorm.x, eax;
// LINE 90:
	VRFrusRiteNorm.z = vect.x;
// LINE 91:
	VRFrusRiteNorm.y = 0x0;
// LINE 94:
	__asm        mov    eax, 0x6663D0;
	__asm        mov    ecx, 0x6663C0;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 95:
	__asm        mov    eax, VRFrusLeftNorm.x;
	__asm        neg    eax;
	__asm        mov    VRFrusLeftNorm.x, eax;
// LINE 99:
	__asm        mov    eax, disty;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, shigh;
	__asm        push   eax;
	__asm        call   _FixedDiv;
	__asm        add    esp, 8;
	__asm        mov    vect.y, eax;
// LINE 100:
	vect.x = 0x0;
// LINE 101:
	vect.z = 0x10000;
// LINE 104:
	MTNormalize(vect.x);
// LINE 107:
	__asm        mov    eax, vect.z;
	__asm        neg    eax;
	__asm        mov    VRFrusTopNorm.y, eax;
// LINE 108:
	VRFrusTopNorm.z = vect.y;
// LINE 109:
	VRFrusTopNorm.x = 0x0;
// LINE 112:
	__asm        mov    eax, 0x6663B0;
	__asm        mov    ecx, 0x6663E0;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 113:
	__asm        mov    eax, VRFrusTopNorm.y;
	__asm        neg    eax;
	__asm        mov    VRFrusBotNorm.y, eax;
// LINE 114:
}

