// Module: Frustrum.obj
// Source: C:\Copter\Source\Engine\Frustrum.c
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	int32_t x;
	int32_t y;
	int32_t z;
};

// Type: void;



// Contribution: 1:000d56c0-000d57db Module: 143, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004d66c0
void VRFrustSetNormals() {
	/*bp-0xc*/   /*packed*/ struct Point3d vect; // 0xc bytes
	/*bp-0x10*/  int32_t distx;
	/*bp-0x14*/  int32_t disty;
	/*bp-0x18*/  int32_t shigh;
	/*bp-0x1c*/  int32_t swide;

// LINE 74:
	__asm        mov    eax, HALF_WIDTH;
	__asm        shl    eax, 4;
	__asm        mov    distx, eax;
// LINE 75:
	__asm        mov    eax, HALF_ASPECT;
	__asm        shl    eax, 4;
	__asm        mov    disty, eax;
// LINE 76:
	__asm        mov    eax, CLIP_RITE;
	__asm        shl    eax, 4;
	__asm        mov    swide, eax;
// LINE 77:
	__asm        mov    eax, CLIP_BOTM;
	__asm        shl    eax, 4;
	__asm        mov    shigh, eax;
// LINE 81:
	__asm        mov    eax, distx;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, swide;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    vect.x, eax;
// LINE 82:
	vect.y = 0x0;
// LINE 83:
	vect.z = 0x10000;
// LINE 86:
	__asm        lea    eax, vect.x;
	__asm        push   eax;
	__asm        call   MTNormalize;
	__asm        add    esp, 4;
// LINE 89:
	__asm        mov    eax, vect.z;
	__asm        neg    eax;
	__asm        mov    VRFrusRiteNorm.x, eax;
// LINE 90:
	VRFrusRiteNorm.z = vect.x;
// LINE 91:
	VRFrusRiteNorm.y = 0x0;
// LINE 94:
	__asm        mov    eax, 0x6663D0;
	__asm        mov    ecx, 0x6663C0;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 95:
	__asm        mov    eax, VRFrusLeftNorm.x;
	__asm        neg    eax;
	__asm        mov    VRFrusLeftNorm.x, eax;
// LINE 99:
	__asm        mov    eax, disty;
	__asm        add    eax, eax;
	__asm        push   eax;
	__asm        mov    eax, shigh;
	__asm        push   eax;
	__asm        call   0x004D19DF;
	__asm        add    esp, 8;
	__asm        mov    vect.y, eax;
// LINE 100:
	vect.x = 0x0;
// LINE 101:
	vect.z = 0x10000;
// LINE 104:
	__asm        lea    eax, vect.x;
	__asm        push   eax;
	__asm        call   MTNormalize;
	__asm        add    esp, 4;
// LINE 107:
	__asm        mov    eax, vect.z;
	__asm        neg    eax;
	__asm        mov    VRFrusTopNorm.y, eax;
// LINE 108:
	VRFrusTopNorm.z = vect.y;
// LINE 109:
	VRFrusTopNorm.x = 0x0;
// LINE 112:
	__asm        mov    eax, 0x6663B0;
	__asm        mov    ecx, 0x6663E0;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 113:
	__asm        mov    eax, VRFrusTopNorm.y;
	__asm        neg    eax;
	__asm        mov    VRFrusBotNorm.y, eax;
// LINE 114:
}

