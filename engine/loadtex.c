// Module: Loadtex.obj
// Source: C:\Copter\source\engine\Loadtex.c
// autogenerated by simcopter_tool from PDB file

// Type: char *;

// Type: int32_t;

// Type: /*packed*/ struct BMPFileHdr;
struct BMPFileHdr{ // packed(0x10 bytes) TI: 0x2edb
	/*+0x0*/   int32_t MaxBmpFileSize;
	/*+0x4*/   int32_t MinBmpFileSize;
	/*+0x8*/   int32_t BmpCount;
	/*+0xc*/   int32_t StaticCount;
};

// Type: /*packed*/ struct TEXT_Resource (forward reference);
struct TEXT_Resource{ // packed(0x18 bytes) TI: 0x2ec2
	/*+0x0*/   /*packed*/ struct VRResource res; // 0x10 bytes
	/*+0x10*/  int32_t count;
	/*+0x14*/  uint32_t * bmpcolors;
	/*+0x18*/  /*packed*/ struct VRBITMAP bmp[0]; // 0x0 bytes
};

// Type: /*packed*/ struct VRBmpInfo (forward reference);
struct VRBmpInfo{ // packed(0xc bytes) TI: 0x230e
	/*+0x0*/   int32_t width;
	/*+0x4*/   int32_t height;
	/*+0x8*/   short attrib; // 0x2 bytes
	/*+0xa*/   short scale; // 0x2 bytes
};

// Type: /*packed*/ struct VRResource (forward reference);
struct VRResource{ // packed(0x10 bytes) TI: 0x18ae
	/*+0x0*/   char * mem;
	/*+0x4*/   int32_t mempoolid;
	/*+0x8*/   int32_t type;
	/*+0xc*/   int32_t entry;
};

// Type: /*packed*/ struct VRBmpHdr (forward reference);
struct VRBmpHdr{ // packed(0x10 bytes) TI: 0x2312
	/*+0x0*/   /*packed*/ struct VRBmpInfo info; // 0xc bytes
	/*+0xc*/   int32_t ScanOffset[1];
};

// Type: unsigned char *;



// Contribution: 1:000d5060-000d560b Module: 145, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004d6060
/*packed*/ struct VRResource* LoadImages(char * name) {
	/*bp-0x4*/   int32_t r;
	/*bp-0x8*/   /*packed*/ struct VRBmpInfo *bhdr;
	/*bp-0xc*/   int32_t s;
	/*bp-0x10*/  char * group;
	/*bp-0x14*/  char * byteptr;
	/*bp-0x18*/  /*packed*/ struct TEXT_Resource *res;
	/*bp-0x1c*/  int32_t i;
	/*bp-0x2c*/  /*packed*/ struct BMPFileHdr bmp; // 0x10 bytes
	/*bp-0x30*/  int32_t file;

// LINE 77:
	__asm        push   0x8000;
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        call   _open;
	__asm        add    esp, 8;
	__asm        mov    file, eax;
	__asm        cmp    file, 0xFFFFFFFF;
	__asm        jne    _T38;
// LINE 79:
	GlobalError = 0x1;
// LINE 81:
	return 0x0;
// LINE 86:
_T38:
	__asm        push   0x10;
	__asm        lea    eax, bmp.MaxBmpFileSize;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    r, eax;
	__asm        cmp    r, 0x10;
	__asm        je     _T74;
// LINE 87:
	_close(file);
// LINE 89:
	GlobalError = 0x2;
// LINE 91:
	return 0x0;
// LINE 143:
_T74:
	__asm        mov    eax, bmp.BmpCount;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    eax, 0x18;
	__asm        push   eax;
	__asm        mov    eax, G_currmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    res, eax;
// LINE 144:
	__asm        cmp    res, 0;
	__asm        jne    _Tad;
// LINE 145:
	GlobalError = 0x4;
// LINE 147:
	return 0x0;
// LINE 169:
_Tad:
	s = _filelength(file);
// LINE 176:
	__asm        mov    eax, s;
	__asm        push   eax;
	__asm        mov    eax, G_currmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    group, eax;
	__asm        cmp    group, 0;
	__asm        jne    _Tf8;
// LINE 177:
	GlobalError = 0x4;
// LINE 179:
	_close(file);
// LINE 180:
	return 0x0;
// LINE 183:
_Tf8:
	byteptr = group;
// LINE 184:
	__asm        mov    eax, bmp.BmpCount;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, byteptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        add    r, eax;
// LINE 185:
	_read((s - r), byteptr, file);
// LINE 186:
	_close(file);
// LINE 188:
	i = 0x0;
	__asm        jmp    _T14d;
_T14a:
	i++;
_T14d:
	__asm        mov    eax, i;
	__asm        cmp    bmp.BmpCount, eax;
	__asm        jle    _T1b4;
// LINE 189:
	bhdr = byteptr;
// LINE 198:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, i;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, res;
	__asm        mov    [edx+ecx*4+0x18], eax;
// LINE 199:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, i;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, res;
	__asm        mov    [edx+ecx*4+0x1C], eax;
// LINE 200:
	__asm        mov    eax, bhdr;
	__asm        mov    ecx, i;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, res;
	__asm        mov    [edx+ecx*4+0x20], eax;
// LINE 201:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, bhdr;
	__asm        imul   eax, [ecx];
	__asm        mov    ecx, bhdr;
	__asm        mov    ecx, [ecx+4];
	__asm        lea    eax, [eax+ecx*4];
	__asm        add    eax, 0xC;
	__asm        add    byteptr, eax;
// LINE 202:
	__asm        jmp    _T14a;
// LINE 206:
_T1b4:
	res->res.mem = group;
// LINE 207:
	res->res.type = 0x3;
// LINE 208:
	res->res.entry = 0x0;
// LINE 209:
	res->count = bmp.BmpCount;
// LINE 210:
	return res;
// LINE 212:
}

// FUNCTION: COPTER_D 0x004d6246
/*packed*/ struct VRBmpHdr* VRInt2BmpHdr(/*packed*/ struct VRResource *res, int32_t i) {
	/*bp-0x4*/   /*packed*/ struct VRBmpHdr *bhdr;
	/*bp-0x8*/   int32_t j;
	/*bp-0xc*/   /*packed*/ struct TEXT_Resource *hdr;

// LINE 228:
	hdr = res;
// LINE 230:
	j = (i >> 0x10);
// LINE 232:
	__asm        cmp    j, 0;
	__asm        je     _T48;
// LINE 235:
	__asm        and    i, 0xFFFF;
// LINE 236:
	__asm        mov    eax, j;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, hdr;
	__asm        mov    eax, [ecx+eax*4+0x20];
	__asm        mov    bhdr, eax;
// LINE 237:
	__asm        mov    eax, i;
	__asm        mov    ecx, bhdr;
	__asm        lea    eax, [ecx+eax*8+0xC];
	__asm        jmp    __RETURN;
// LINE 241:
_T48:
	__asm        mov    eax, i;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, hdr;
	__asm        mov    eax, [ecx+eax*4+0x20];
	__asm        jmp    __RETURN;
// LINE 243:
__RETURN:
}

// FUNCTION: COPTER_D 0x004d62a5
int32_t VRGetResTextureCnt(/*packed*/ struct VRResource *res) {
	/*bp-0x4*/   /*packed*/ struct TEXT_Resource *hdr;

// LINE 257:
	hdr = res;
// LINE 258:
	return hdr->count;
// LINE 259:
}

// FUNCTION: COPTER_D 0x004d62c4
int32_t VRSetBmpToTiled(/*packed*/ struct VRResource *res, int32_t mask, int32_t bmpid, unsigned char * basearg) {
	/*bp-0x4*/   int32_t rowshift;
	/*bp-0x8*/   int32_t col;
	/*bp-0xc*/   int32_t row;
	/*bp-0x10*/  int32_t notiles;
	/*bp-0x14*/  /*packed*/ struct VRBmpHdr *bhdr;
	/*bp-0x18*/  int32_t colmask;
	/*bp-0x1c*/  int32_t i;
	/*bp-0x20*/  /*packed*/ struct TEXT_Resource *hdr;
	/*bp-0x24*/  unsigned char * tptr;
	/*bp-0x28*/  unsigned char * baseptr;

// LINE 290:
	hdr = res;
// LINE 292:
	__asm        mov    eax, bmpid;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, hdr;
	__asm        mov    eax, [ecx+eax*4+0x20];
	__asm        mov    bhdr, eax;
// LINE 302:
	__asm        mov    eax, mask;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _Tc3;
// LINE 305:
_T2a:
	notiles = 0x40;
// LINE 306:
	bhdr->info.height = 0x20;
	bhdr->info.width = bhdr->info.height;
// LINE 307:
	colmask = 0x7;
// LINE 308:
	rowshift = 0x3;
// LINE 309:
	__asm        jmp    _Tef;
// LINE 311:
_T59:
	notiles = 0x10;
// LINE 312:
	bhdr->info.height = 0x40;
	bhdr->info.width = bhdr->info.height;
// LINE 313:
	colmask = 0x3;
// LINE 314:
	rowshift = 0x2;
// LINE 315:
	__asm        jmp    _Tef;
// LINE 317:
_T88:
	notiles = 0x4;
// LINE 318:
	bhdr->info.height = 0x80;
	bhdr->info.width = bhdr->info.height;
// LINE 319:
	colmask = 0x1;
// LINE 320:
	rowshift = 0x1;
// LINE 321:
	__asm        jmp    _Tef;
// LINE 323:
_Tb7:
	return 0x0;
// LINE 324:
	__asm        jmp    _Tef;
_Tc3:
	__asm        cmp    dword ptr [ebp-0x2C], 0x1F1F;
	__asm        je     _T2a;

	__asm        cmp    dword ptr [ebp-0x2C], 0x3F3F;
	__asm        je     _T59;

	__asm        cmp    dword ptr [ebp-0x2C], 0x7F7F;
	__asm        je     _T88;

	__asm        jmp    _Tb7;
// LINE 326:
_Tef:
	__asm        mov    eax, bhdr;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        or     eax, 4;
	__asm        mov    ecx, bhdr;
	__asm        mov    [ecx+8], ax;
// LINE 333:
	__asm        cmp    basearg, 0;
	__asm        jne    _T11c;
// LINE 335:
	baseptr = bhdr;
// LINE 336:
	baseptr += 0x40c;
// LINE 338:
	__asm        jmp    _T122;
// LINE 340:
_T11c:
	baseptr = basearg;
// LINE 346:
_T122:
	i = 0x0;
	__asm        jmp    _T131;
_T12e:
	i++;
_T131:
	__asm        mov    eax, notiles;
	__asm        cmp    i, eax;
	__asm        jge    _T18d;
// LINE 348:
	__asm        mov    eax, mask;
	__asm        mov    ecx, i;
	__asm        mov    edx, bhdr;
	__asm        mov    [edx+ecx*8+0xC], eax;
// LINE 349:
	col = (colmask & i);
// LINE 350:
	row = (i >> reinterpret_cast<uint8_t>(rowshift));
// LINE 353:
	tptr = ((((bhdr->info.width * row) << 0x8) + (bhdr->info.width * col)) + baseptr);
// LINE 354:
	__asm        mov    eax, tptr;
	__asm        mov    ecx, i;
	__asm        mov    edx, bhdr;
	__asm        mov    [edx+ecx*8+0x10], eax;
// LINE 355:
	__asm        jmp    _T12e;
// LINE 357:
_T18d:
	return 0x1;
// LINE 358:
}

// FUNCTION: COPTER_D 0x004d6460
int32_t VRLoadAlignedBmp(char * name, /*packed*/ struct VRResource *res, int32_t mask, int32_t bmpid) {
	/*bp-0x4*/   int32_t r;
	/*bp-0x8*/   /*packed*/ struct VRBmpInfo *bhdr;
	/*bp-0xc*/   unsigned char * alignptr;
	/*bp-0x1c*/  /*packed*/ struct BMPFileHdr bmp; // 0x10 bytes
	/*bp-0x20*/  int32_t file;

// LINE 391:
	alignptr = S2AllocAligned();
// LINE 392:
	__asm        cmp    alignptr, 0;
	__asm        jne    _T22;
// LINE 393:
	return 0x0;
// LINE 396:
_T22:
	__asm        push   0x8000;
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        call   _open;
	__asm        add    esp, 8;
	__asm        mov    file, eax;
	__asm        cmp    file, 0xFFFFFFFF;
	__asm        jne    _T51;
// LINE 398:
	GlobalError = 0x1;
// LINE 399:
	return 0x0;
// LINE 406:
_T51:
	__asm        push   0x10;
	__asm        lea    eax, bmp.MaxBmpFileSize;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    r, eax;
	__asm        cmp    r, 0x10;
	__asm        je     _T8d;
// LINE 407:
	_close(file);
// LINE 408:
	GlobalError = 0x2;
// LINE 409:
	return 0x0;
// LINE 448:
_T8d:
	__asm        cmp    bmp.BmpCount, 1;
	__asm        je     _Tb4;
// LINE 450:
	_close(file);
// LINE 451:
	GlobalError = 0x2;
// LINE 452:
	return 0x0;
// LINE 456:
_Tb4:
	__asm        mov    eax, bmp.BmpCount;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, alignptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
// LINE 459:
	_read(0xc, alignptr, file);
// LINE 462:
	bhdr = alignptr;
// LINE 471:
	__asm        mov    eax, bhdr;
	__asm        cmp    dword ptr [eax], 0x100;
	__asm        jne    _T105;

	__asm        mov    eax, bhdr;
	__asm        cmp    dword ptr [eax+4], 0x100;
	__asm        je     _T122;
// LINE 473:
_T105:
	_close(file);
// LINE 474:
	GlobalError = 0x2;
// LINE 475:
	return 0x0;
// LINE 479:
_T122:
	_read(0x400, alignptr, file);
// LINE 482:
	r = _read(0x10000, alignptr, file);
// LINE 483:
	__asm        cmp    r, 0x10000;
	__asm        je     _T179;
// LINE 485:
	_close(file);
// LINE 486:
	GlobalError = 0x2;
// LINE 487:
	return 0x0;
// LINE 490:
_T179:
	_close(file);
// LINE 493:
	VRSetBmpToTiled(alignptr, bmpid, mask, res);
// LINE 495:
	return 0x1;
// LINE 496:
}

