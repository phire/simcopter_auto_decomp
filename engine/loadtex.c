// Module: Loadtex.obj
// Source: C:\Copter\source\engine\Loadtex.c
// autogenerated by simcopter_tool from PDB file

// Type: char *;

// Type: int32_t;

// Type: struct BMPFileHdr;
struct BMPFileHdr{
	int32_t MaxBmpFileSize;
	int32_t MinBmpFileSize;
	int32_t BmpCount;
	int32_t StaticCount;
};

// Type: struct TEXT_Resource (forward reference);
struct TEXT_Resource{
	struct VRResource res;
	int32_t count;
	uint32_t * bmpcolors;
	struct VRBITMAP bmp[0];
};

// Type: struct VRBmpInfo (forward reference);
struct VRBmpInfo{
	int32_t width;
	int32_t height;
	short attrib;
	short scale;
};

// Type: struct VRResource (forward reference);
struct VRResource{
	char * mem;
	int32_t mempoolid;
	int32_t type;
	int32_t entry;
};

// Type: struct VRBmpHdr (forward reference);
struct VRBmpHdr{
	struct VRBmpInfo info;
	int32_t ScanOffset[1];
};

// Type: unsigned char *;



// Contribution: 1:000d5060-000d560b Module: 145, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004d6060
struct VRResource* LoadImages(char * name) {
	int32_t file;
	struct BMPFileHdr bmp;
	int32_t i;
	struct TEXT_Resource *res;
	char * byteptr;
	char * group;
	int32_t s;
	struct VRBmpInfo *bhdr;
	int32_t r;

// LINE 77:
	__asm        push   0x8000;
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        call   _open;
	__asm        add    esp, 8;
	__asm        mov    file, eax;
	__asm        cmp    file, 0xFFFFFFFF;
	__asm        jne    _T38;
// LINE 79:
	GlobalError = 0x1;
// LINE 81:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e1;
// LINE 86:
_T38:
	__asm        push   0x10;
	__asm        lea    eax, bmp.MaxBmpFileSize;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    r, eax;
	__asm        cmp    r, 0x10;
	__asm        je     _T74;
// LINE 87:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 89:
	GlobalError = 0x2;
// LINE 91:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e1;
// LINE 143:
_T74:
	__asm        mov    eax, bmp.BmpCount;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    eax, 0x18;
	__asm        push   eax;
	__asm        mov    eax, G_currmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    res, eax;
// LINE 144:
	__asm        cmp    res, 0;
	__asm        jne    _Tad;
// LINE 145:
	GlobalError = 0x4;
// LINE 147:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e1;
// LINE 169:
_Tad:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _filelength;
	__asm        add    esp, 4;
	__asm        mov    s, eax;
// LINE 176:
	__asm        mov    eax, s;
	__asm        push   eax;
	__asm        mov    eax, G_currmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    group, eax;
	__asm        cmp    group, 0;
	__asm        jne    _Tf8;
// LINE 177:
	GlobalError = 0x4;
// LINE 179:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 180:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e1;
// LINE 183:
_Tf8:
	byteptr = group;
// LINE 184:
	__asm        mov    eax, bmp.BmpCount;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, byteptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        add    r, eax;
// LINE 185:
	__asm        mov    eax, s;
	__asm        sub    eax, r;
	__asm        push   eax;
	__asm        mov    eax, byteptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
// LINE 186:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 188:
	__asm        mov    i, 0;
	__asm        jmp    _T14d;
_T14a:
	__asm        inc    i;
_T14d:
	__asm        mov    eax, i;
	__asm        cmp    bmp.BmpCount, eax;
	__asm        jle    _T1b4;
// LINE 189:
	bhdr = byteptr;
// LINE 198:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, i;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, res;
	__asm        mov    [edx+ecx*4+0x18], eax;
// LINE 199:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, i;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, res;
	__asm        mov    [edx+ecx*4+0x1C], eax;
// LINE 200:
	__asm        mov    eax, bhdr;
	__asm        mov    ecx, i;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        mov    edx, res;
	__asm        mov    [edx+ecx*4+0x20], eax;
// LINE 201:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, bhdr;
	__asm        imul   eax, [ecx];
	__asm        mov    ecx, bhdr;
	__asm        mov    ecx, [ecx+4];
	__asm        lea    eax, [eax+ecx*4];
	__asm        add    eax, 0xC;
	__asm        add    byteptr, eax;
// LINE 202:
	__asm        jmp    _T14a;
// LINE 206:
_T1b4:
	res->res.mem = group;
// LINE 207:
	res->res.type = 0x3;
// LINE 208:
	res->res.entry = 0x0;
// LINE 209:
	res->count = bmp.BmpCount;
// LINE 210:
	__asm        mov    eax, res;
	__asm        jmp    _T1e1;
// LINE 212:
_T1e1:
}

// FUNCTION: COPTER_D 0x004d6246
struct VRBmpHdr* VRInt2BmpHdr(struct VRResource *res, int32_t i) {
	struct TEXT_Resource *hdr;
	int32_t j;
	struct VRBmpHdr *bhdr;

// LINE 228:
	hdr = res;
// LINE 230:
	__asm        mov    eax, i;
	__asm        sar    eax, 0x10;
	__asm        mov    j, eax;
// LINE 232:
	__asm        cmp    j, 0;
	__asm        je     _T48;
// LINE 235:
	__asm        and    i, 0xFFFF;
// LINE 236:
	__asm        mov    eax, j;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, hdr;
	__asm        mov    eax, [ecx+eax*4+0x20];
	__asm        mov    bhdr, eax;
// LINE 237:
	__asm        mov    eax, i;
	__asm        mov    ecx, bhdr;
	__asm        lea    eax, [ecx+eax*8+0xC];
	__asm        jmp    _T5a;
// LINE 241:
_T48:
	__asm        mov    eax, i;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, hdr;
	__asm        mov    eax, [ecx+eax*4+0x20];
	__asm        jmp    _T5a;
// LINE 243:
_T5a:
}

// FUNCTION: COPTER_D 0x004d62a5
int32_t VRGetResTextureCnt(struct VRResource *res) {
	struct TEXT_Resource *hdr;

// LINE 257:
	hdr = res;
// LINE 258:
	__asm        mov    eax, hdr;
	__asm        mov    eax, [eax+0x10];
	__asm        jmp    near ptr 0x004D62BF;
// LINE 259:
}

// FUNCTION: COPTER_D 0x004d62c4
int32_t VRSetBmpToTiled(struct VRResource *res, int32_t mask, int32_t bmpid, unsigned char * basearg) {
	unsigned char * baseptr;
	unsigned char * tptr;
	struct TEXT_Resource *hdr;
	int32_t i;
	int32_t colmask;
	struct VRBmpHdr *bhdr;
	int32_t notiles;
	int32_t row;
	int32_t col;
	int32_t rowshift;

// LINE 290:
	hdr = res;
// LINE 292:
	__asm        mov    eax, bmpid;
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, hdr;
	__asm        mov    eax, [ecx+eax*4+0x20];
	__asm        mov    bhdr, eax;
// LINE 302:
	__asm        mov    eax, mask;
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _Tc3;
// LINE 305:
_T2a:
	notiles = 0x40;
// LINE 306:
	__asm        mov    eax, bhdr;
	__asm        mov    dword ptr [eax+4], 0x20;
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, bhdr;
	__asm        mov    [ecx], eax;
// LINE 307:
	colmask = 0x7;
// LINE 308:
	rowshift = 0x3;
// LINE 309:
	__asm        jmp    _Tef;
// LINE 311:
_T59:
	notiles = 0x10;
// LINE 312:
	__asm        mov    eax, bhdr;
	__asm        mov    dword ptr [eax+4], 0x40;
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, bhdr;
	__asm        mov    [ecx], eax;
// LINE 313:
	colmask = 0x3;
// LINE 314:
	rowshift = 0x2;
// LINE 315:
	__asm        jmp    _Tef;
// LINE 317:
_T88:
	notiles = 0x4;
// LINE 318:
	__asm        mov    eax, bhdr;
	__asm        mov    dword ptr [eax+4], 0x80;
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, bhdr;
	__asm        mov    [ecx], eax;
// LINE 319:
	colmask = 0x1;
// LINE 320:
	rowshift = 0x1;
// LINE 321:
	__asm        jmp    _Tef;
// LINE 323:
_Tb7:
	__asm        xor    eax, eax;
	__asm        jmp    _T197;
// LINE 324:
	__asm        jmp    _Tef;
_Tc3:
	__asm        cmp    dword ptr [ebp-0x2C], 0x1F1F;
	__asm        je     _T2a;

	__asm        cmp    dword ptr [ebp-0x2C], 0x3F3F;
	__asm        je     _T59;

	__asm        cmp    dword ptr [ebp-0x2C], 0x7F7F;
	__asm        je     _T88;

	__asm        jmp    _Tb7;
// LINE 326:
_Tef:
	__asm        mov    eax, bhdr;
	__asm        movsx  eax, word ptr [eax+8];
	__asm        or     eax, 4;
	__asm        mov    ecx, bhdr;
	__asm        mov    [ecx+8], ax;
// LINE 333:
	__asm        cmp    basearg, 0;
	__asm        jne    _T11c;
// LINE 335:
	baseptr = bhdr;
// LINE 336:
	__asm        add    baseptr, 0x40C;
// LINE 338:
	__asm        jmp    _T122;
// LINE 340:
_T11c:
	baseptr = basearg;
// LINE 346:
_T122:
	__asm        mov    i, 0;
	__asm        jmp    _T131;
_T12e:
	__asm        inc    i;
_T131:
	__asm        mov    eax, notiles;
	__asm        cmp    i, eax;
	__asm        jge    _T18d;
// LINE 348:
	bhdr->info.width = mask;
// LINE 349:
	__asm        mov    eax, colmask;
	__asm        and    eax, i;
	__asm        mov    col, eax;
// LINE 350:
	__asm        mov    eax, i;
	__asm        mov    cl, reinterpret_cast<uint8_t>(rowshift);
	__asm        sar    eax, cl;
	__asm        mov    row, eax;
// LINE 353:
	__asm        mov    eax, bhdr;
	__asm        mov    eax, [eax];
	__asm        imul   eax, row;
	__asm        shl    eax, 8;
	__asm        mov    ecx, bhdr;
	__asm        mov    ecx, [ecx];
	__asm        imul   ecx, col;
	__asm        add    eax, ecx;
	__asm        add    eax, baseptr;
	__asm        mov    tptr, eax;
// LINE 354:
	bhdr->info.width = tptr;
// LINE 355:
	__asm        jmp    _T12e;
// LINE 357:
_T18d:
	__asm        mov    eax, 1;
	__asm        jmp    _T197;
// LINE 358:
_T197:
}

// FUNCTION: COPTER_D 0x004d6460
int32_t VRLoadAlignedBmp(char * name, struct VRResource *res, int32_t mask, int32_t bmpid) {
	int32_t file;
	struct BMPFileHdr bmp;
	unsigned char * alignptr;
	struct VRBmpInfo *bhdr;
	int32_t r;

// LINE 391:
	__asm        call   S2AllocAligned;
	__asm        mov    alignptr, eax;
// LINE 392:
	__asm        cmp    alignptr, 0;
	__asm        jne    _T22;
// LINE 393:
	__asm        xor    eax, eax;
	__asm        jmp    _T1a7;
// LINE 396:
_T22:
	__asm        push   0x8000;
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        call   _open;
	__asm        add    esp, 8;
	__asm        mov    file, eax;
	__asm        cmp    file, 0xFFFFFFFF;
	__asm        jne    _T51;
// LINE 398:
	GlobalError = 0x1;
// LINE 399:
	__asm        xor    eax, eax;
	__asm        jmp    _T1a7;
// LINE 406:
_T51:
	__asm        push   0x10;
	__asm        lea    eax, bmp.MaxBmpFileSize;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    r, eax;
	__asm        cmp    r, 0x10;
	__asm        je     _T8d;
// LINE 407:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 408:
	GlobalError = 0x2;
// LINE 409:
	__asm        xor    eax, eax;
	__asm        jmp    _T1a7;
// LINE 448:
_T8d:
	__asm        cmp    bmp.BmpCount, 1;
	__asm        je     _Tb4;
// LINE 450:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 451:
	GlobalError = 0x2;
// LINE 452:
	__asm        xor    eax, eax;
	__asm        jmp    _T1a7;
// LINE 456:
_Tb4:
	__asm        mov    eax, bmp.BmpCount;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, alignptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
// LINE 459:
	__asm        push   0xC;
	__asm        mov    eax, alignptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
// LINE 462:
	bhdr = alignptr;
// LINE 471:
	__asm        mov    eax, bhdr;
	__asm        cmp    dword ptr [eax], 0x100;
	__asm        jne    _T105;

	__asm        mov    eax, bhdr;
	__asm        cmp    dword ptr [eax+4], 0x100;
	__asm        je     _T122;
// LINE 473:
_T105:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 474:
	GlobalError = 0x2;
// LINE 475:
	__asm        xor    eax, eax;
	__asm        jmp    _T1a7;
// LINE 479:
_T122:
	__asm        push   0x400;
	__asm        mov    eax, alignptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
// LINE 482:
	__asm        push   0x10000;
	__asm        mov    eax, alignptr;
	__asm        push   eax;
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    r, eax;
// LINE 483:
	__asm        cmp    r, 0x10000;
	__asm        je     _T179;
// LINE 485:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 486:
	GlobalError = 0x2;
// LINE 487:
	__asm        xor    eax, eax;
	__asm        jmp    _T1a7;
// LINE 490:
_T179:
	__asm        mov    eax, file;
	__asm        push   eax;
	__asm        call   _close;
	__asm        add    esp, 4;
// LINE 493:
	__asm        mov    eax, alignptr;
	__asm        push   eax;
	__asm        mov    eax, bmpid;
	__asm        push   eax;
	__asm        mov    eax, mask;
	__asm        push   eax;
	__asm        mov    eax, res;
	__asm        push   eax;
	__asm        call   VRSetBmpToTiled;
	__asm        add    esp, 0x10;
// LINE 495:
	__asm        mov    eax, 1;
	__asm        jmp    _T1a7;
// LINE 496:
_T1a7:
}

