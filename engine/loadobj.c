// Module: Loadobj.obj
// Source: C:\Copter\source\engine\Loadobj.c
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ struct _BSPtree (forward reference);
struct _BSPtree{ // packed(0x1c bytes) TI: 0x2ec5
	/*+0x0*/   /*packed*/ struct _FaceHdr *Polygon;
	/*+0x4*/   /*packed*/ struct _PlaneType Plane; // 0x10 bytes
	/*+0x14*/  /*packed*/ struct _BSPtree *infront;
	/*+0x18*/  /*packed*/ struct _BSPtree *behind;
};

// Type: unsigned short;

// Type: int32_t;

// Type: char *;

// Type: /*packed*/ struct ObjInfo (forward reference);
struct ObjInfo{ // packed(0x1c bytes) TI: 0x2f03
	/*+0x0*/   int32_t TreeCount;
	/*+0x4*/   int32_t VertCount;
	/*+0x8*/   int32_t Face2dCnt;
	/*+0xc*/   int32_t Face2dSub;
	/*+0x10*/  int32_t FaceCount;
	/*+0x14*/  int32_t XYZCount;
	/*+0x18*/  int32_t Untextured;
};

// Type: /*packed*/ struct GEOM_Resource (forward reference);
struct GEOM_Resource{ // packed(0x18 bytes) TI: 0x2f05
	/*+0x0*/   /*packed*/ struct VRResource res; // 0x10 bytes
	/*+0x10*/  int32_t count;
	/*+0x14*/  int32_t barrymempool;
	/*+0x18*/  int32_t pointer[0]; // 0x0 bytes
};

// Type: /*packed*/ struct VRResource (forward reference);
struct VRResource{ // packed(0x10 bytes) TI: 0x18ae
	/*+0x0*/   char * mem;
	/*+0x4*/   int32_t mempoolid;
	/*+0x8*/   int32_t type;
	/*+0xc*/   int32_t entry;
};

// Type: /*packed*/ struct VRMemPool (forward reference);
struct VRMemPool{ // packed(0x20 bytes) TI: 0x2453
	/*+0x0*/   int32_t ObjCount;
	/*+0x4*/   int32_t entry;
	/*+0x8*/   char * Reset_Xf;
	/*+0xc*/   char * Reset_2d;
	/*+0x10*/  char * Current_Xf;
	/*+0x14*/  char * Current_2d;
	/*+0x18*/  char * End_Xf;
	/*+0x1c*/  char * End_2d;
};

// Type: void;

// Type: /*packed*/ struct Point3d (forward reference);
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct GameObjectHdrType;
struct GameObjectHdrType{ // packed(0x7c bytes) TI: 0x2f0f
	/*+0x0*/   char Id[4];
	/*+0x4*/   long Size;
	/*+0x8*/   short NVerts; // 0x2 bytes
	/*+0xa*/   short NFaces; // 0x2 bytes
	/*+0xc*/   unsigned long Attrib;
	/*+0x10*/  long Radius;
	/*+0x14*/  long YRadius;
	/*+0x18*/  char ObjName[24]; // 0x18 bytes
	/*+0x30*/  char TextureFile[64]; // 0x40 bytes
	/*+0x70*/  long ObjAnimCnt;
	/*+0x74*/  long ObjAnimPtr;
	/*+0x78*/  int32_t ID;
};

// Type: int32_t *;

// Type: short;

// Type: /*packed*/ struct FileBSPTreeHdrType;
struct FileBSPTreeHdrType{ // packed(0xa bytes) TI: 0x2f12
	/*+0x0*/   char Id[4];
	/*+0x4*/   long Size;
	/*+0x8*/   short NNodes; // 0x2 bytes
};

// Type: /*packed*/ struct _FaceHdr (forward reference);
struct _FaceHdr{ // packed(0x30 bytes) TI: 0x2e99
	/*+0x0*/   /*packed*/ struct _FaceHdr *NextFace;
	/*+0x4*/   int32_t Nverts;
	/*+0x8*/   int32_t Attrib1;
	/*+0xc*/   int32_t Attrib2;
	/*+0x10*/  int32_t Plotter;
	/*+0x14*/  int32_t Count2d;
	/*+0x18*/  /*packed*/ struct Clip3d *Verts2d;
	/*+0x1c*/  int32_t PlyVerts;
	/*+0x20*/  /*packed*/ struct MapVert *MapVerts;
	/*+0x24*/  int32_t Bitmap;
	/*+0x28*/  /*packed*/ struct MapVert *Barrys;
	/*+0x2c*/  /*packed*/ struct Project3d *Normal;
};

// Type: /*packed*/ struct FileFaceHdrType;
struct FileFaceHdrType{ // packed(0x15 bytes) TI: 0x2f14
	/*+0x0*/   char Id[4];
	/*+0x4*/   long Size;
	/*+0x8*/   short NVerts; // 0x2 bytes
	/*+0xa*/   unsigned long Attrib;
	/*+0xe*/   unsigned long AuxAttrib;
	/*+0x12*/  unsigned char Color; // 0x1 bytes
	/*+0x13*/  short TextureId; // 0x2 bytes
};

// Type: /*packed*/ struct ObjectHdr (forward reference);
struct ObjectHdr{ // packed(0x90 bytes) TI: 0x2ebb
	/*+0x0*/   int32_t Attrib;
	/*+0x4*/   int32_t NVerts;
	/*+0x8*/   /*packed*/ struct Point3d *VertsPtr;
	/*+0xc*/   int32_t MemPool;
	/*+0x10*/  int32_t NFaces;
	/*+0x14*/  int32_t PolyVerts;
	/*+0x18*/  /*packed*/ struct Point3d CenterOrg; // 0xc bytes
	/*+0x24*/  /*packed*/ struct Point3d Center; // 0xc bytes
	/*+0x30*/  int32_t Radius;
	/*+0x34*/  /*packed*/ struct _BSPtree *bsptree;
	/*+0x38*/  int32_t StaticCnt;
	/*+0x3c*/  int32_t StaticPtr;
	/*+0x40*/  int32_t MiscReg1;
	/*+0x44*/  int32_t ID;
	/*+0x48*/  int32_t Entry;
	/*+0x4c*/  /*packed*/ struct _FaceHdr *FacePtr;
	/*+0x50*/  int32_t Matrix[4][4]; // 0x40 bytes
};

// Type: /*packed*/ struct Point3d;
struct Point3d{ // packed(0xc bytes) TI: 0x18b0
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
};

// Type: /*packed*/ struct TEXT_Resource (forward reference);
struct TEXT_Resource{ // packed(0x18 bytes) TI: 0x2ec2
	/*+0x0*/   /*packed*/ struct VRResource res; // 0x10 bytes
	/*+0x10*/  int32_t count;
	/*+0x14*/  uint32_t * bmpcolors;
	/*+0x18*/  /*packed*/ struct VRBITMAP bmp[0]; // 0x0 bytes
};

// Type: /*packed*/ struct VRObjInfo;
struct VRObjInfo{ // packed(0x24 bytes) TI: 0x2ea8
	/*+0x0*/   int32_t Faces;
	/*+0x4*/   int32_t Verts;
	/*+0x8*/   int32_t Attribute;
	/*+0xc*/   int32_t Radius;
	/*+0x10*/  /*packed*/ struct Point3d *ObjCenter;
	/*+0x14*/  /*packed*/ struct Point3d *VertsPtr;
	/*+0x18*/  /*packed*/ struct Xform3d *VertsXfm;
	/*+0x1c*/  /*packed*/ struct Point3d *OrgVerts;
	/*+0x20*/  int32_t *Matrix[4][4];
};

// Type: /*packed*/ struct VRBmpHdr (forward reference);
struct VRBmpHdr{ // packed(0x10 bytes) TI: 0x2312
	/*+0x0*/   /*packed*/ struct VRBmpInfo info; // 0xc bytes
	/*+0xc*/   int32_t ScanOffset[1];
};

// Type: /*packed*/ struct MapVert (forward reference);
struct MapVert{ // packed(0x8 bytes) TI: 0x2e89
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ struct Project3d (forward reference);
struct Project3d{ // packed(0x10 bytes) TI: 0x2e8d
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
	/*+0x8*/   int32_t z;
	/*+0xc*/   /*packed*/ struct Point3d *p;
};

// Type: /*packed*/ struct FPoint3d;
struct FPoint3d{ // packed(0x18 bytes) TI: 0x2f28
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double y; // 0x8 bytes
	/*+0x10*/  double z; // 0x8 bytes
};

// Type: double;



// Contribution: 1:000d1180-000d42ba Module: 147, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004d2180
/*packed*/ struct VRResource* LoadGroup(/*packed*/ struct ObjInfo *info, int32_t objs) {
	/*bp-0x4*/   char * group;
	/*bp-0x8*/   /*packed*/ struct GEOM_Resource *res;
	/*bp-0xc*/   int32_t i;

// LINE 152:
	res = S2Alloc(G_currmempool, ((objs << 0x2) + 0x18));
// LINE 153:
	__asm        cmp    res, 0;
	__asm        jne    _T3f;
// LINE 154:
	GlobalError = 0x4;
// LINE 155:
	return 0x0;
// LINE 166:
_T3f:
	__asm        mov    eax, info;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, info;
	__asm        mov    ecx, [ecx+4];
	__asm        shl    ecx, 2;
	__asm        lea    eax, [ecx+eax*8];
	__asm        mov    ecx, info;
	__asm        mov    ecx, [ecx];
	__asm        mov    edx, ecx;
	__asm        shl    ecx, 3;
	__asm        sub    ecx, edx;
	__asm        lea    eax, [eax+ecx*4];
	__asm        mov    ecx, info;
	__asm        mov    ecx, [ecx+0x14];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    eax, [eax+ecx*4];
	__asm        mov    ecx, info;
	__asm        mov    ecx, [ecx+8];
	__asm        shl    ecx, 5;
	__asm        add    eax, ecx;
	__asm        mov    ecx, info;
	__asm        mov    ecx, [ecx+0xC];
	__asm        shl    ecx, 5;
	__asm        add    eax, ecx;
	__asm        mov    ecx, info;
	__asm        mov    ecx, [ecx+0x10];
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        add    eax, ecx;
	__asm        mov    ecx, info;
	__asm        mov    ecx, [ecx+0x10];
	__asm        shl    ecx, 4;
	__asm        add    eax, ecx;
	__asm        mov    ecx, objs;
	__asm        lea    ecx, [ecx+ecx*8];
	__asm        shl    ecx, 4;
	__asm        add    eax, ecx;
	__asm        mov    ObjDataSize, eax;
// LINE 168:
	res->barrymempool = S2AllocPool((info->VertCount << 0x3));
// LINE 169:
	__asm        mov    eax, res;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        jge    _Te1;
// LINE 171:
	GlobalError = 0x4;
// LINE 172:
	return 0x0;
// LINE 175:
_Te1:
	__asm        mov    eax, ObjDataSize;
	__asm        push   eax;
	__asm        mov    eax, G_currmempool;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    group, eax;
	__asm        cmp    group, 0;
	__asm        jne    _T113;
// LINE 176:
	GlobalError = 0x4;
// LINE 177:
	return 0x0;
// LINE 180:
_T113:
	ObjData = group;
// LINE 184:
	FaceArray = 0x0;
// LINE 185:
_FOR_131:
	for (i = 0x0; (i < objs); i++) {
		// LINE 186:
			__asm        mov    eax, ObjData;
			__asm        mov    ecx, i;
			__asm        mov    edx, res;
			__asm        mov    [edx+ecx*4+0x18], eax;
		// LINE 187:
			__asm        mov    eax, res;
			__asm        mov    eax, [eax+0x14];
			__asm        push   eax;
			__asm        call   LoadObjtType;
			__asm        add    esp, 4;
			__asm        test   eax, eax;
			__asm        jne    _T196;
		// LINE 189:
			__asm        cmp    FaceArray, 0;
			__asm        je     _T181;
		// LINE 190:
			free(FaceArray);
		// LINE 191:
		_T181:
			S2AllocReset(G_currmempool);
		// LINE 192:
			return 0x0;
		// LINE 194:
		_T196:
	}
// LINE 196:
_T19b:
	__asm        cmp    ObjDataSize, 0;
	__asm        jge    _T1c7;
// LINE 198:
	S2AllocReset(G_currmempool);
// LINE 199:
	GlobalError = 0xa;
// LINE 200:
	return 0x0;
// LINE 208:
_T1c7:
	res->res.mem = group;
// LINE 209:
	res->res.type = 0x1;
// LINE 210:
	res->res.entry = 0x0;
// LINE 211:
	res->count = objs;
// LINE 212:
	return res;
// LINE 214:
}

// FUNCTION: COPTER_D 0x004d2379
void VRAssignMemPoolToRes(/*packed*/ struct VRResource *res, /*packed*/ struct VRMemPool *mem) {
	/*bp-0x4*/   int32_t i;
	/*bp-0x8*/   /*packed*/ struct GEOM_Resource *geo;

// LINE 229:
	geo = res;
// LINE 230:
_FOR_1b:
	for (i = 0x0; (geo->count > i); i++) {
		// LINE 231:
			__asm        mov    eax, mem;
			__asm        push   eax;
			__asm        mov    eax, i;
			__asm        mov    ecx, geo;
			__asm        mov    eax, [ecx+eax*4+0x18];
			__asm        push   eax;
			__asm        call   _VRAddObjToMemPool;
			__asm        add    esp, 8;
	}
// LINE 233:
__RETURN:
}

// FUNCTION: COPTER_D 0x004d23c7
int32_t VRGetResObjectCnt(/*packed*/ struct VRResource *res) {
	/*bp-0x4*/   /*packed*/ struct GEOM_Resource *geo;

// LINE 247:
	geo = res;
// LINE 248:
	return geo->count;
// LINE 250:
}

// FUNCTION: COPTER_D 0x004d23e6
int32_t VRGetResObject(/*packed*/ struct VRResource *res, int32_t i) {
	/*bp-0x4*/   /*packed*/ struct GEOM_Resource *geo;

// LINE 264:
	geo = res;
// LINE 265:
	__asm        mov    eax, i;
	__asm        mov    ecx, geo;
	__asm        mov    eax, [ecx+eax*4+0x18];
	__asm        jmp    __RETURN;
// LINE 267:
__RETURN:
}

// FUNCTION: COPTER_D 0x004d2409
int32_t LoadObjtType(int32_t barrymempool) {
	/*bp-0x4*/   /*packed*/ struct Point3d *v1;
	/*bp-0x8*/   int32_t uses_gouraud;
	/*bp-0xc*/   /*packed*/ struct ObjectHdr *ObjectPtr;
	/*bp-0x24*/  /*packed*/ struct FileFaceHdrType filefacehdr; // 0x15 bytes
	/*bp-0x28*/  /*packed*/ struct _FaceHdr *faceptr;
	/*bp-0x2c*/  int32_t lobyte;
	/*bp-0x38*/  /*packed*/ struct FileBSPTreeHdrType treehdr; // 0xa bytes
	/*bp-0x138*/ short w[128]; // 0x100 bytes
	/*bp-0x13c*/ int32_t * FaceVertPtr;
	/*bp-0x140*/ int32_t x;
	/*bp-0x144*/ int32_t hibyte;
	/*bp-0x148*/ int32_t y;
	/*bp-0x14c*/ int32_t VertCount;
	/*bp-0x150*/ /*packed*/ struct Point3d *vlst;
	/*bp-0x1cc*/ /*packed*/ struct GameObjectHdrType fileobjhdr; // 0x7c bytes
	/*bp-0x1d0*/ char * dataptr;
	/*bp-0x1d4*/ /*packed*/ struct Point3d *v0;

// LINE 296:
	uses_gouraud = 0x0;
// LINE 299:
	ObjectPtr = ObjData;
// LINE 300:
	dataptr = (ObjectPtr + 0x90);
// LINE 301:
	__asm        mov    eax, ObjectPtr;
	__asm        push   eax;
	__asm        call   _InsertVR3dObj;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T4e;
// LINE 302:
	GlobalError = 0x9;
// LINE 303:
	return 0x0;
// LINE 307:
_T4e:
	__asm        push   0x7C;
	__asm        lea    eax, fileobjhdr.Id[0];
	__asm        push   eax;
	__asm        call   ReadResource;
	__asm        add    esp, 8;
	__asm        test   eax, eax;
	__asm        jne    _T6e;
// LINE 308:
	return 0x0;
// LINE 375:
_T6e:
	ObjectPtr->Attrib = fileobjhdr.Attrib;
// LINE 376:
	ObjectPtr->NVerts = (reinterpret_cast<int16_t>(fileobjhdr.NVerts) - 1);
// LINE 377:
	ObjectPtr->NFaces = reinterpret_cast<int16_t>(fileobjhdr.NFaces);
// LINE 378:
	ObjectPtr->ID = fileobjhdr.ID;
// LINE 379:
	ObjectPtr->Radius = fileobjhdr.Radius;
// LINE 380:
	ObjectPtr->VertsPtr = dataptr;
// LINE 381:
	ObjectPtr->MiscReg1 = 0x0;
// LINE 389:
	__asm        push   0xC;
	__asm        mov    eax, ObjectPtr;
	__asm        add    eax, 0x18;
	__asm        push   eax;
	__asm        call   ReadResource;
	__asm        add    esp, 8;
	__asm        test   eax, eax;
	__asm        jne    _Te2;
// LINE 390:
	return 0x0;
// LINE 413:
_Te2:
	__asm        mov    eax, ObjectPtr;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, dataptr;
	__asm        push   eax;
	__asm        call   ReadResource;
	__asm        add    esp, 8;
	__asm        test   eax, eax;
	__asm        jne    _T10d;
// LINE 414:
	return 0x0;
// LINE 415:
_T10d:
	__asm        mov    eax, ObjectPtr;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    dataptr, eax;
// LINE 448:
	__asm        test   reinterpret_cast<uint8_t>(fileobjhdr.Attrib), 1;
	__asm        je     _T168;
// LINE 450:
	__asm        movsx  eax, fileobjhdr.NFaces;
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, ScratchPoolIndex;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    FaceArray, eax;
	__asm        cmp    FaceArray, 0;
	__asm        jne    _T168;
// LINE 452:
	GlobalError = 0x4;
// LINE 453:
	return 0x0;
// LINE 459:
_T168:
	ObjectPtr->FacePtr = dataptr;
// LINE 460:
_FOR_18d:
	x = 0x0;
	VertCount = 0x0;
	__asm        jmp    _FOR_COND_18d;
_FOR_NEXT_18d:
	for (; (reinterpret_cast<int16_t>(fileobjhdr.NFaces) > x); x++) {
		// LINE 461:
			faceptr = dataptr;
		// LINE 464:
			__asm        push   0x15;
			__asm        lea    eax, filefacehdr.Id[0];
			__asm        push   eax;
			__asm        call   ReadResource;
			__asm        add    esp, 8;
			__asm        test   eax, eax;
			__asm        jne    _T1da;
		// LINE 466:
			S2AllocReset(ScratchPoolIndex);
		// LINE 467:
			return 0x0;
		// LINE 505:
		_T1da:
			__asm        push   4;
			__asm        push   0x59C218;
			__asm        lea    eax, filefacehdr.Id[0];
			__asm        push   eax;
			__asm        call   strncmp;
			__asm        add    esp, 0xC;
			__asm        test   eax, eax;
			__asm        je     _T214;
		// LINE 506:
			GlobalError = 0x6;
		// LINE 507:
			S2AllocReset(ScratchPoolIndex);
		// LINE 508:
			return 0x0;
		// LINE 512:
		_T214:
			VertCount += reinterpret_cast<int16_t>(filefacehdr.NVerts);
		// LINE 513:
			faceptr->Nverts = reinterpret_cast<int16_t>(filefacehdr.NVerts);
		// LINE 514:
			faceptr->Attrib1 = filefacehdr.Attrib;
		// LINE 515:
			faceptr->Attrib2 = filefacehdr.AuxAttrib;
		// LINE 516:
			__asm        xor    eax, eax;
			__asm        mov    al, filefacehdr.Color;
			__asm        mov    ecx, faceptr;
			__asm        mov    [ecx+0x10], eax;
		// LINE 517:
			hibyte = (reinterpret_cast<int16_t>(filefacehdr.TextureId) & 0xff00);
		// LINE 518:
			lobyte = (reinterpret_cast<int16_t>(filefacehdr.TextureId) & 0xff);
		// LINE 519:
			faceptr->Bitmap = ((hibyte << 0x8) | lobyte);
		// LINE 520:
			dataptr += 0x30;
		// LINE 528:
			__asm        mov    eax, faceptr;
			__asm        test   byte ptr [eax+9], 0x40;
			__asm        je     _T28d;
		// LINE 529:
			uses_gouraud = 0x1;
		// LINE 532:
		_T28d:
			__asm        mov    eax, faceptr;
			__asm        test   byte ptr [eax+8], 4;
			__asm        je     _T2a4;
		// LINE 533:
			y = 0x0;
		// LINE 539:
		_T2a4:
			faceptr->PlyVerts = dataptr;
		// LINE 540:
			FaceVertPtr = dataptr;
		// LINE 544:
			__asm        movsx  eax, filefacehdr.NVerts;
			__asm        add    eax, eax;
			__asm        push   eax;
			__asm        lea    eax, w[0];
			__asm        push   eax;
			__asm        call   ReadResource;
			__asm        add    esp, 8;
			__asm        test   eax, eax;
			__asm        jne    _FOR_2f0;
		// LINE 545:
			return 0x0;
		// LINE 566:
		_FOR_2f0:
			for (y = 0x0; (reinterpret_cast<int16_t>(filefacehdr.NVerts) > y); y++) {
				// LINE 568:
					__asm        mov    eax, y;
					__asm        dec    word ptr [ebp+eax*2-0x138];
				// LINE 569:
					__asm        mov    eax, y;
					__asm        movsx  eax, word ptr [ebp+eax*2-0x138];
					__asm        shl    eax, 4;
					__asm        mov    ecx, FaceVertPtr;
					__asm        mov    [ecx], eax;
					__asm        add    FaceVertPtr, 4;
			}
		// LINE 571:
		_T339:
			dataptr = FaceVertPtr;
		// LINE 577:
			faceptr->MapVerts = dataptr;
		// LINE 581:
			__asm        movsx  eax, filefacehdr.NVerts;
			__asm        shl    eax, 3;
			__asm        push   eax;
			__asm        mov    eax, dataptr;
			__asm        push   eax;
			__asm        call   ReadResource;
			__asm        add    esp, 8;
			__asm        test   eax, eax;
			__asm        jne    _T385;
		// LINE 583:
			S2AllocReset(ScratchPoolIndex);
		// LINE 584:
			return 0x0;
		// LINE 586:
		_T385:
			dataptr += (reinterpret_cast<int16_t>(filefacehdr.NVerts) << 0x3);
		// LINE 608:
			faceptr->Barrys = S2Alloc(barrymempool, (reinterpret_cast<int16_t>(filefacehdr.NVerts) << 0x3));
		// LINE 609:
			memcpy(faceptr->Barrys, faceptr->MapVerts, (reinterpret_cast<int16_t>(filefacehdr.NVerts) << 0x3));
		// LINE 617:
			faceptr->Normal = dataptr;
		// LINE 618:
			dataptr += 0x10;
		// LINE 619:
			__asm        movsx  eax, w[0];
			__asm        lea    eax, [eax+eax*2];
			__asm        shl    eax, 2;
			__asm        mov    ecx, ObjectPtr;
			__asm        add    eax, [ecx+8];
			__asm        mov    v0, eax;
		// LINE 620:
			__asm        movsx  eax, w[1];
			__asm        lea    eax, [eax+eax*2];
			__asm        shl    eax, 2;
			__asm        mov    ecx, ObjectPtr;
			__asm        add    eax, [ecx+8];
			__asm        mov    v1, eax;
		// LINE 621:
			__asm        movsx  eax, filefacehdr.NVerts;
			__asm        movsx  eax, word ptr [ebp+eax*2-0x13A];
			__asm        lea    eax, [eax+eax*2];
			__asm        shl    eax, 2;
			__asm        mov    ecx, ObjectPtr;
			__asm        add    eax, [ecx+8];
			__asm        mov    vlst, eax;
		// LINE 622:
			FaceCalcNormal(v0, v1, vlst, faceptr->Normal);
		// LINE 627:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax], 0;
			__asm        jne    _T4af;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0;
			__asm        jne    _T4af;
		// LINE 629:
			__asm        mov    eax, faceptr;
			__asm        or     dword ptr [eax+8], 0x10000000;
		// LINE 630:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+8];
			__asm        mov    [ebp-0x1D8], eax;
			__asm        fild   dword ptr [ebp-0x1D8];
			__asm        fdiv   qword ptr ds:[0x592460];
			__asm        fcomp  qword ptr ds:[0x592468];
			__asm        fnstsw ax;
			__asm        test   ah, 0x41;
			__asm        jne    _T4aa;
		// LINE 631:
			__asm        mov    eax, faceptr;
			__asm        or     dword ptr [eax+8], 0x20000000;
		// LINE 633:
		_T4aa:
			__asm        jmp    _T581;
		_T4af:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax], 0;
			__asm        jne    _T513;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+8], 0;
			__asm        jne    _T513;
		// LINE 635:
			__asm        mov    eax, faceptr;
			__asm        or     dword ptr [eax+8], 0x8000000;
		// LINE 636:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+4];
			__asm        mov    [ebp-0x1DC], eax;
			__asm        fild   dword ptr [ebp-0x1DC];
			__asm        fdiv   qword ptr ds:[0x592460];
			__asm        fcomp  qword ptr ds:[0x592468];
			__asm        fnstsw ax;
			__asm        test   ah, 0x41;
			__asm        jne    _T50e;
		// LINE 637:
			__asm        mov    eax, faceptr;
			__asm        or     dword ptr [eax+8], 0x20000000;
		// LINE 639:
		_T50e:
			__asm        jmp    _T581;
		_T513:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0;
			__asm        jne    _T577;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+8], 0;
			__asm        jne    _T577;
		// LINE 641:
			__asm        mov    eax, faceptr;
			__asm        or     dword ptr [eax+8], 0x4000000;
		// LINE 642:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax];
			__asm        mov    [ebp-0x1E0], eax;
			__asm        fild   dword ptr [ebp-0x1E0];
			__asm        fdiv   qword ptr ds:[0x592460];
			__asm        fcomp  qword ptr ds:[0x592468];
			__asm        fnstsw ax;
			__asm        test   ah, 0x41;
			__asm        jne    _T572;
		// LINE 643:
			__asm        mov    eax, faceptr;
			__asm        or     dword ptr [eax+8], 0x20000000;
		// LINE 645:
		_T572:
			__asm        jmp    _T581;
		// LINE 646:
		_T577:
			__asm        mov    eax, faceptr;
			__asm        or     dword ptr [eax+8], 0x40000000;
		// LINE 648:
		_T581:
			faceptr->Normal->p = v0;
		// LINE 650:
			faceptr->NextFace = dataptr;
		// LINE 651:
			__asm        test   reinterpret_cast<uint8_t>(fileobjhdr.Attrib), 1;
			__asm        je     _T5ba;
		// LINE 652:
			FaceArray-> = faceptr;
		// LINE 653:
		_T5ba:
	}
// LINE 658:
_T5bf:
	__asm        test   reinterpret_cast<uint8_t>(fileobjhdr.Attrib), 1;
	__asm        je     _T62f;
// LINE 659:
	Tree = dataptr;
// LINE 662:
	__asm        push   0xA;
	__asm        lea    eax, treehdr.Id[0];
	__asm        push   eax;
	__asm        call   ReadResource;
	__asm        add    esp, 8;
	__asm        test   eax, eax;
	__asm        jne    _T602;
// LINE 664:
	S2AllocReset(ScratchPoolIndex);
// LINE 665:
	return 0x0;
// LINE 687:
_T602:
	BSPIndex = 0x0;
// LINE 688:
	ObjectPtr->bsptree = ReadTree();
// LINE 689:
	dataptr += (((reinterpret_cast<int16_t>(treehdr.NNodes) << 0x3) - reinterpret_cast<int16_t>(treehdr.NNodes)) << 0x2);
// LINE 691:
	__asm        jmp    _T639;
_T62f:
	ObjectPtr->bsptree = 0x0;
// LINE 693:
_T639:
	S2AllocReset(ScratchPoolIndex);
// LINE 694:
	FaceArray = 0x0;
// LINE 700:
	ObjectPtr->PolyVerts = VertCount;
// LINE 701:
	ObjDataSize -= (dataptr - ObjData);
// LINE 702:
	ObjData = dataptr;
// LINE 703:
	__asm        mov    eax, ObjectPtr;
	__asm        test   byte ptr [eax], 2;
	__asm        je     _T698;

	NormalizeObj(ObjectPtr);
// LINE 706:
_T698:
	__asm        cmp    uses_gouraud, 1;
	__asm        jne    _T6ae;
// LINE 707:
	ObjCalcVnormsAndShade(ObjectPtr);
// LINE 709:
_T6ae:
	return 0x1;
// LINE 711:
}

// FUNCTION: COPTER_D 0x004d2ac6
int32_t VRGetDyObjAlt(int32_t obj, int32_t *dymat[4][4], /*packed*/ struct Point3d *loc, int32_t dim) {
	/*bp-0x4*/   int32_t flags;
	/*bp-0x44*/  int32_t tmat[4][4]; // 0x40 bytes
	/*bp-0x50*/  /*packed*/ struct Point3d tloc; // 0xc bytes

// LINE 733:
	flags = 0x0;
// LINE 736:
	_VRTranspose(dymat, tmat[0][0]);
// LINE 739:
	_VRRotateP3d(loc, tloc.x, tmat[0][0]);
// LINE 743:
	return VRGetObjAlt(obj, tloc.x, tloc.y, tloc.z, flags, dim, 0x0, 0x0);
// LINE 744:
}

// FUNCTION: COPTER_D 0x004d2b28
int32_t VRGetObjAlt(int32_t obj, int32_t x, int32_t y, int32_t z, int32_t * flags, int32_t dim, /*packed*/ struct Point3d *collisvec, int32_t * landable) {
	/*bp-0x4*/   int32_t check_for_overhang;
	/*bp-0x8*/   /*packed*/ struct _FaceHdr *faceptr;
	/*bp-0xc*/   /*packed*/ struct Point3d *vert2;
	/*bp-0x10*/  int32_t * vertno;
	/*bp-0x14*/  int32_t normaldir;
	/*bp-0x18*/  /*packed*/ struct Point3d *vert;
	/*bp-0x1c*/  int32_t altydown;
	/*bp-0x20*/  int32_t planed;
	/*bp-0x24*/  int32_t scalar;
	/*bp-0x28*/  int32_t altyupabove;
	/*bp-0x2c*/  int32_t minx;
	/*bp-0x30*/  int32_t i;
	/*bp-0x34*/  int32_t miny;
	/*bp-0x38*/  int32_t j;
	/*bp-0x3c*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x40*/  int32_t minz;
	/*bp-0x44*/  int32_t overhang;
	/*bp-0x48*/  int32_t maxx;
	/*bp-0x4c*/  int32_t altyupbelow;
	/*bp-0x50*/  int32_t facealt;
	/*bp-0x54*/  int32_t maxy;
	/*bp-0x58*/  int32_t maxz;
	/*bp-0x5c*/  char * dataptr;

// LINE 776:
	oh = obj;
// LINE 788:
	overhang = 0x0;
// LINE 789:
	check_for_overhang = 0x0;
// LINE 793:
	__asm        mov    eax, oh;
	__asm        mov    eax, [eax+0x30];
	__asm        add    eax, eax;
	__asm        add    eax, 0x50000;
	__asm        cmp    eax, y;
	__asm        jge    _T41;
// LINE 794:
	return (oh->Radius >> 0x3);
// LINE 796:
_T41:
	__asm        mov    eax, flags;
	__asm        test   byte ptr [eax+1], 2;
	__asm        je     _T55;
// LINE 797:
	check_for_overhang = 0x1;
// LINE 799:
_T55:
	__asm        cmp    landable, 0;
	__asm        je     _T68;
// LINE 800:
	landable[0] = 0x0;
// LINE 803:
_T68:
	__asm        cmp    obj, 0;
	__asm        jne    _T79;
// LINE 804:
	return 0x0;
// LINE 807:
_T79:
	altydown = 0x75300000;
// LINE 808:
	altyupabove = 0x75300000;
// LINE 809:
	altyupbelow = 0x0;
// LINE 812:
	faceptr = oh->FacePtr;
// LINE 813:
_FOR_a3:
	for (i = 0x0; (oh->NFaces > i); i++) {
		// LINE 816:
			__asm        mov    eax, faceptr;
			__asm        test   byte ptr [eax+8], 4;
			__asm        je     _Tc7;
		// LINE 817:
			__asm        jmp    do_2d_face;
		// LINE 819:
		_Tc7:
			__asm        mov    eax, faceptr;
			__asm        test   dword ptr [eax+8], 0x18000;
			__asm        je     _Tdc;
		// LINE 820:
			__asm        jmp    next_face;
		// LINE 823:
		_Tdc:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0xFFFFFF9C;
			__asm        jge    _Tf8;
		// LINE 824:
			normaldir = 0x1;
		// LINE 825:
			__asm        jmp    _T12d;
		_Tf8:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0x64;
			__asm        jle    _T128;
		// LINE 826:
			__asm        cmp    check_for_overhang, 0;
			__asm        jne    _T11c;
		// LINE 827:
			__asm        jmp    next_face;
		// LINE 828:
			__asm        jmp    _T123;
		// LINE 829:
		_T11c:
			normaldir = 0xffffffff;
		// LINE 830:
		_T123:
			__asm        jmp    _T12d;
		// LINE 831:
		_T128:
			__asm        jmp    next_face;
		// LINE 834:
		_T12d:
			dataptr = faceptr;
		// LINE 835:
			dataptr += 0x30;
		// LINE 836:
			vertno = faceptr->PlyVerts;
		// LINE 839:
			minz = 0x75300000;
			miny = minz;
			minx = miny;
		// LINE 840:
			maxz = 0x8ad00000;
			maxy = maxz;
			maxx = maxy;
		// LINE 845:
		_FOR_172:
			for (j = 0x0; (faceptr->Nverts > j); j++) {
				// LINE 851:
					__asm        mov    eax, vertno;
					__asm        mov    eax, [eax];
					__asm        shr    eax, 4;
					__asm        lea    eax, [eax+eax*2];
					__asm        shl    eax, 2;
					__asm        mov    ecx, oh;
					__asm        add    eax, [ecx+8];
					__asm        mov    vert, eax;
				// LINE 855:
					vertno += 0x4;
				// LINE 858:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minx;
					__asm        cmp    [eax], ecx;
					__asm        jge    _T1b5;

					minx = vert->x;
				// LINE 859:
				_T1b5:
					__asm        mov    eax, vert;
					__asm        mov    ecx, miny;
					__asm        cmp    [eax+4], ecx;
					__asm        jge    _T1cd;

					miny = vert->y;
				// LINE 860:
				_T1cd:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minz;
					__asm        cmp    [eax+8], ecx;
					__asm        jge    _T1e5;

					minz = vert->z;
				// LINE 861:
				_T1e5:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxx;
					__asm        cmp    [eax], ecx;
					__asm        jle    _T1fb;

					maxx = vert->x;
				// LINE 862:
				_T1fb:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxy;
					__asm        cmp    [eax+4], ecx;
					__asm        jle    _T213;

					maxy = vert->y;
				// LINE 863:
				_T213:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxz;
					__asm        cmp    [eax+8], ecx;
					__asm        jle    _T22b;

					maxz = vert->z;
				// LINE 864:
				_T22b:
			}
		// LINE 868:
		_T230:
			__asm        mov    eax, dim;
			__asm        add    eax, x;
			__asm        cmp    eax, minx;
			__asm        jl     next_face;

			__asm        mov    eax, x;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxx;
			__asm        jg     next_face;

			__asm        mov    eax, dim;
			__asm        add    eax, z;
			__asm        cmp    eax, minz;
			__asm        jl     next_face;

			__asm        mov    eax, z;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxz;
			__asm        jg     next_face;
		// LINE 877:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+4];
			__asm        push   eax;
			__asm        mov    eax, vert;
			__asm        mov    eax, [eax+4];
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        mov    ebx, eax;
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+8];
			__asm        push   eax;
			__asm        mov    eax, vert;
			__asm        mov    eax, [eax+8];
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        add    ebx, eax;
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax];
			__asm        push   eax;
			__asm        mov    eax, vert;
			__asm        mov    eax, [eax];
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        add    ebx, eax;
			__asm        mov    planed, ebx;
		// LINE 883:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+8];
			__asm        push   eax;
			__asm        mov    eax, z;
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        mov    ebx, eax;
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax];
			__asm        push   eax;
			__asm        mov    eax, x;
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        add    ebx, eax;
			__asm        mov    scalar, ebx;
		// LINE 888:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+4];
			__asm        push   eax;
			__asm        mov    eax, planed;
			__asm        sub    eax, scalar;
			__asm        push   eax;
			__asm        call   _FixedDiv;
			__asm        add    esp, 8;
			__asm        mov    facealt, eax;
		// LINE 890:
			__asm        mov    eax, maxy;
			__asm        cmp    facealt, eax;
			__asm        jg     _T324;

			__asm        mov    eax, miny;
			__asm        cmp    facealt, eax;
			__asm        jge    _T330;
		// LINE 891:
		_T324:
			facealt = ((maxy + miny) >> 0x1);
		// LINE 893:
		_T330:
			__asm        cmp    check_for_overhang, 0;
			__asm        jne    _T40b;
		// LINE 895:
			__asm        mov    eax, facealt;
			__asm        cmp    altyupbelow, eax;
			__asm        jge    _T406;
		// LINE 897:
			altyupbelow = facealt;
		// LINE 898:
			flags[0] = faceptr->Attrib2;
		// LINE 902:
			__asm        cmp    collisvec, 0;
			__asm        je     _T38e;
		// LINE 904:
			collisvec->x = (((minx + maxx) >> 0x1) - x);
		// LINE 905:
			collisvec->z = (((maxz + minz) >> 0x1) - z);
		// LINE 906:
			collisvec->y = 0x0;
		// LINE 912:
		_T38e:
			__asm        cmp    landable, 0;
			__asm        je     _T406;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0xFFFF15A0;
			__asm        jge    _T406;
		// LINE 915:
			__asm        mov    eax, x;
			__asm        sub    eax, 0x20000;
			__asm        cmp    eax, minx;
			__asm        jl     _T3fd;

			__asm        mov    eax, x;
			__asm        add    eax, 0x20000;
			__asm        cmp    eax, maxx;
			__asm        jg     _T3fd;

			__asm        mov    eax, z;
			__asm        sub    eax, 0x20000;
			__asm        cmp    eax, minz;
			__asm        jl     _T3fd;

			__asm        mov    eax, z;
			__asm        add    eax, 0x20000;
			__asm        cmp    eax, maxz;
			__asm        jg     _T3fd;
		// LINE 917:
			landable[0] = 0x1;
		// LINE 919:
			__asm        jmp    _T406;
		// LINE 921:
		_T3fd:
			landable[0] = 0x0;
		// LINE 925:
		_T406:
			__asm        jmp    next_face;
		// LINE 929:
		_T40b:
			__asm        cmp    normaldir, 0;
			__asm        jle    _T515;
		// LINE 932:
			__asm        mov    eax, y;
			__asm        cmp    facealt, eax;
			__asm        jge    _T4f2;

			__asm        mov    eax, facealt;
			__asm        cmp    altyupbelow, eax;
			__asm        jge    _T4f2;
		// LINE 934:
			altyupbelow = facealt;
		// LINE 937:
			flags[0] = faceptr->Attrib2;
		// LINE 941:
			__asm        cmp    collisvec, 0;
			__asm        je     _T475;
		// LINE 943:
			collisvec->x = (((minx + maxx) >> 0x1) - x);
		// LINE 944:
			collisvec->z = (((maxz + minz) >> 0x1) - z);
		// LINE 945:
			collisvec->y = 0x0;
		// LINE 950:
		_T475:
			__asm        cmp    landable, 0;
			__asm        je     _T4ed;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0xFFFF15A0;
			__asm        jge    _T4ed;
		// LINE 953:
			__asm        mov    eax, x;
			__asm        sub    eax, 0x10000;
			__asm        cmp    eax, minx;
			__asm        jl     _T4e4;

			__asm        mov    eax, x;
			__asm        add    eax, 0x10000;
			__asm        cmp    eax, maxx;
			__asm        jg     _T4e4;

			__asm        mov    eax, z;
			__asm        sub    eax, 0x10000;
			__asm        cmp    eax, minz;
			__asm        jl     _T4e4;

			__asm        mov    eax, z;
			__asm        add    eax, 0x10000;
			__asm        cmp    eax, maxz;
			__asm        jg     _T4e4;
		// LINE 955:
			landable[0] = 0x1;
		// LINE 957:
			__asm        jmp    _T4ed;
		// LINE 959:
		_T4e4:
			landable[0] = 0x0;
		// LINE 964:
		_T4ed:
			__asm        jmp    _T510;
		_T4f2:
			__asm        mov    eax, y;
			__asm        cmp    facealt, eax;
			__asm        jl     _T510;

			__asm        mov    eax, altyupabove;
			__asm        cmp    facealt, eax;
			__asm        jge    _T510;
		// LINE 966:
			altyupabove = facealt;
		// LINE 971:
		_T510:
			__asm        jmp    next_face;
		// LINE 978:
		_T515:
			__asm        mov    eax, y;
			__asm        add    eax, 0xA0000;
			__asm        cmp    eax, facealt;
			__asm        jle    _T52b;
		// LINE 979:
			__asm        jmp    next_face;
		// LINE 981:
		_T52b:
			overhang = 0x1;
		// LINE 984:
			__asm        mov    eax, facealt;
			__asm        cmp    altydown, eax;
			__asm        jle    next_face;
		// LINE 986:
			altydown = facealt;
		// LINE 994:
		next_face:
			faceptr = faceptr->NextFace;
	}
// LINE 1003:
do_2d_face:
	vertno = faceptr->PlyVerts;
// LINE 1005:
	__asm        mov    eax, vertno;
	__asm        mov    eax, [eax];
	__asm        shr    eax, 4;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    ecx, oh;
	__asm        add    eax, [ecx+8];
	__asm        mov    vert, eax;
// LINE 1010:
	vertno += 0x4;
// LINE 1012:
	__asm        mov    eax, vertno;
	__asm        mov    eax, [eax];
	__asm        shr    eax, 4;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    ecx, oh;
	__asm        add    eax, [ecx+8];
	__asm        mov    vert2, eax;
// LINE 1021:
	__asm        mov    eax, vert;
	__asm        mov    eax, [eax];
	__asm        sub    eax, 0x40000;
	__asm        mov    ecx, dim;
	__asm        add    ecx, x;
	__asm        cmp    eax, ecx;
	__asm        jg     _T649;

	__asm        mov    eax, vert;
	__asm        mov    eax, [eax];
	__asm        add    eax, 0x40000;
	__asm        mov    ecx, x;
	__asm        sub    ecx, dim;
	__asm        cmp    eax, ecx;
	__asm        jl     _T649;

	__asm        mov    eax, vert;
	__asm        mov    eax, [eax+8];
	__asm        sub    eax, 0x40000;
	__asm        mov    ecx, dim;
	__asm        add    ecx, z;
	__asm        cmp    eax, ecx;
	__asm        jg     _T649;

	__asm        mov    eax, vert;
	__asm        mov    eax, [eax+8];
	__asm        add    eax, 0x40000;
	__asm        mov    ecx, z;
	__asm        sub    ecx, dim;
	__asm        cmp    eax, ecx;
	__asm        jl     _T649;
// LINE 1023:
	__asm        mov    eax, vert2;
	__asm        mov    ecx, altyupbelow;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _T649;
// LINE 1025:
	altyupbelow = vert2->y;
// LINE 1027:
	__asm        cmp    landable, 0;
	__asm        je     _T619;
// LINE 1029:
	landable[0] = 0x0;
// LINE 1032:
_T619:
	__asm        cmp    collisvec, 0;
	__asm        je     _T649;
// LINE 1034:
	collisvec->x = (vert->x - x);
// LINE 1035:
	collisvec->z = (vert->z - z);
// LINE 1036:
	collisvec->y = 0x0;
// LINE 1042:
_T649:
	faceptr = faceptr->NextFace;
// LINE 1044:
	__asm        jmp    _FOR_NEXT_a3;
// LINE 1046:
_T656:
	__asm        cmp    check_for_overhang, 0;
	__asm        jne    _T668;
// LINE 1048:
	return altyupbelow;
// LINE 1053:
_T668:
	__asm        cmp    overhang, 1;
	__asm        jne    _T698;
// LINE 1055:
	__asm        mov    eax, altyupabove;
	__asm        cmp    altydown, eax;
	__asm        jle    _T68b;
// LINE 1056:
	return altyupabove;
// LINE 1057:
	__asm        jmp    _T693;
// LINE 1058:
_T68b:
	return altyupbelow;
// LINE 1060:
_T693:
	__asm        jmp    __RETURN;
// LINE 1062:
_T698:
	__asm        cmp    altyupabove, 0x75300000;
	__asm        je     _T6b2;
// LINE 1063:
	return altyupabove;
// LINE 1064:
	__asm        jmp    __RETURN;
// LINE 1065:
_T6b2:
	return altyupbelow;
// LINE 1067:
__RETURN:
}

// FUNCTION: COPTER_D 0x004d31e7
int32_t VRGetObjAlt2(int32_t obj, int32_t x, int32_t y, int32_t z, int32_t * flags, int32_t dim, int32_t ydim, /*packed*/ struct Point3d *collisvec, int32_t * landable) {
	/*bp-0x4*/   int32_t check_for_overhang;
	/*bp-0x8*/   /*packed*/ struct _FaceHdr *faceptr;
	/*bp-0xc*/   /*packed*/ struct Point3d *vert2;
	/*bp-0x10*/  int32_t * vertno;
	/*bp-0x14*/  int32_t normaldir;
	/*bp-0x18*/  /*packed*/ struct Point3d *vert;
	/*bp-0x1c*/  int32_t altydown;
	/*bp-0x20*/  int32_t planed;
	/*bp-0x24*/  int32_t scalar;
	/*bp-0x28*/  int32_t altyupabove;
	/*bp-0x2c*/  int32_t minx;
	/*bp-0x30*/  int32_t i;
	/*bp-0x34*/  int32_t miny;
	/*bp-0x38*/  int32_t j;
	/*bp-0x3c*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x40*/  int32_t minz;
	/*bp-0x44*/  int32_t overhang;
	/*bp-0x48*/  int32_t maxx;
	/*bp-0x4c*/  int32_t altyupbelow;
	/*bp-0x50*/  int32_t facealt;
	/*bp-0x54*/  int32_t maxy;
	/*bp-0x58*/  int32_t maxz;
	/*bp-0x5c*/  char * dataptr;

// LINE 1088:
	oh = obj;
// LINE 1100:
	overhang = 0x0;
// LINE 1101:
	check_for_overhang = 0x0;
// LINE 1105:
	__asm        mov    eax, oh;
	__asm        mov    eax, [eax+0x30];
	__asm        add    eax, eax;
	__asm        add    eax, 0x50000;
	__asm        cmp    eax, y;
	__asm        jge    _T41;
// LINE 1106:
	return (oh->Radius >> 0x3);
// LINE 1108:
_T41:
	__asm        mov    eax, flags;
	__asm        test   byte ptr [eax+1], 2;
	__asm        je     _T55;
// LINE 1109:
	check_for_overhang = 0x1;
// LINE 1111:
_T55:
	__asm        cmp    landable, 0;
	__asm        je     _T68;
// LINE 1112:
	landable[0] = 0x0;
// LINE 1115:
_T68:
	__asm        cmp    obj, 0;
	__asm        jne    _T79;
// LINE 1116:
	return 0x0;
// LINE 1119:
_T79:
	altydown = 0x75300000;
// LINE 1120:
	altyupabove = 0x75300000;
// LINE 1121:
	altyupbelow = 0x0;
// LINE 1124:
	faceptr = oh->FacePtr;
// LINE 1125:
_FOR_a3:
	for (i = 0x0; (oh->NFaces > i); i++) {
		// LINE 1128:
			__asm        mov    eax, faceptr;
			__asm        test   byte ptr [eax+8], 4;
			__asm        je     _Tc7;
		// LINE 1129:
			__asm        jmp    do_2d_face;
		// LINE 1131:
		_Tc7:
			__asm        mov    eax, faceptr;
			__asm        test   dword ptr [eax+8], 0x18004;
			__asm        je     _Tdc;
		// LINE 1132:
			__asm        jmp    next_face;
		// LINE 1135:
		_Tdc:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0xFFFFFF9C;
			__asm        jge    _Tf8;
		// LINE 1137:
			normaldir = 0x1;
		// LINE 1139:
			__asm        jmp    _T143;
		_Tf8:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0x64;
			__asm        jle    _T128;
		// LINE 1141:
			__asm        cmp    check_for_overhang, 0;
			__asm        jne    _T11c;
		// LINE 1142:
			__asm        jmp    next_face;
		// LINE 1143:
			__asm        jmp    _T123;
		// LINE 1144:
		_T11c:
			normaldir = 0xffffffff;
		// LINE 1146:
		_T123:
			__asm        jmp    _T143;
		// LINE 1149:
		_T128:
			__asm        cmp    check_for_overhang, 1;
			__asm        jne    _T13e;
		// LINE 1150:
			normaldir = 0x0;
		// LINE 1151:
			__asm        jmp    _T143;
		// LINE 1152:
		_T13e:
			__asm        jmp    next_face;
		// LINE 1156:
		_T143:
			dataptr = faceptr;
		// LINE 1157:
			dataptr += 0x30;
		// LINE 1158:
			vertno = faceptr->PlyVerts;
		// LINE 1161:
			minz = 0x75300000;
			miny = minz;
			minx = miny;
		// LINE 1162:
			maxz = 0x8ad00000;
			maxy = maxz;
			maxx = maxy;
		// LINE 1167:
		_FOR_188:
			for (j = 0x0; (faceptr->Nverts > j); j++) {
				// LINE 1173:
					__asm        mov    eax, vertno;
					__asm        mov    eax, [eax];
					__asm        shr    eax, 4;
					__asm        lea    eax, [eax+eax*2];
					__asm        shl    eax, 2;
					__asm        mov    ecx, oh;
					__asm        add    eax, [ecx+8];
					__asm        mov    vert, eax;
				// LINE 1177:
					vertno += 0x4;
				// LINE 1180:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minx;
					__asm        cmp    [eax], ecx;
					__asm        jge    _T1cb;

					minx = vert->x;
				// LINE 1181:
				_T1cb:
					__asm        mov    eax, vert;
					__asm        mov    ecx, miny;
					__asm        cmp    [eax+4], ecx;
					__asm        jge    _T1e3;

					miny = vert->y;
				// LINE 1182:
				_T1e3:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minz;
					__asm        cmp    [eax+8], ecx;
					__asm        jge    _T1fb;

					minz = vert->z;
				// LINE 1183:
				_T1fb:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxx;
					__asm        cmp    [eax], ecx;
					__asm        jle    _T211;

					maxx = vert->x;
				// LINE 1184:
				_T211:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxy;
					__asm        cmp    [eax+4], ecx;
					__asm        jle    _T229;

					maxy = vert->y;
				// LINE 1185:
				_T229:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxz;
					__asm        cmp    [eax+8], ecx;
					__asm        jle    _T241;

					maxz = vert->z;
				// LINE 1186:
				_T241:
			}
		// LINE 1190:
		_T246:
			__asm        mov    eax, dim;
			__asm        add    eax, x;
			__asm        cmp    eax, minx;
			__asm        jl     next_face;

			__asm        mov    eax, x;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxx;
			__asm        jg     next_face;

			__asm        mov    eax, dim;
			__asm        add    eax, z;
			__asm        cmp    eax, minz;
			__asm        jl     next_face;

			__asm        mov    eax, z;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxz;
			__asm        jg     next_face;
		// LINE 1195:
			__asm        cmp    normaldir, 0;
			__asm        je     _T355;
		// LINE 1201:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+8];
			__asm        push   eax;
			__asm        mov    eax, vert;
			__asm        mov    eax, [eax+8];
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        mov    ebx, eax;
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+4];
			__asm        push   eax;
			__asm        mov    eax, vert;
			__asm        mov    eax, [eax+4];
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        add    ebx, eax;
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax];
			__asm        push   eax;
			__asm        mov    eax, vert;
			__asm        mov    eax, [eax];
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        add    ebx, eax;
			__asm        mov    planed, ebx;
		// LINE 1207:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+8];
			__asm        push   eax;
			__asm        mov    eax, z;
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        mov    ebx, eax;
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax];
			__asm        push   eax;
			__asm        mov    eax, x;
			__asm        push   eax;
			__asm        call   _FixedMul;
			__asm        add    esp, 8;
			__asm        add    ebx, eax;
			__asm        mov    scalar, ebx;
		// LINE 1212:
			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        mov    eax, [eax+4];
			__asm        push   eax;
			__asm        mov    eax, planed;
			__asm        sub    eax, scalar;
			__asm        push   eax;
			__asm        call   _FixedDiv;
			__asm        add    esp, 8;
			__asm        mov    facealt, eax;
		// LINE 1214:
			__asm        mov    eax, maxy;
			__asm        cmp    facealt, eax;
			__asm        jg     _T344;

			__asm        mov    eax, miny;
			__asm        cmp    facealt, eax;
			__asm        jge    _T350;
		// LINE 1215:
		_T344:
			facealt = ((maxy + miny) >> 0x1);
		// LINE 1217:
		_T350:
			__asm        jmp    _T386;
		// LINE 1220:
		_T355:
			__asm        mov    eax, ydim;
			__asm        add    eax, y;
			__asm        cmp    eax, miny;
			__asm        jle    _T381;

			__asm        mov    eax, y;
			__asm        cmp    maxy, eax;
			__asm        jle    _T381;
		// LINE 1221:
			facealt = ((maxy + y) >> 0x1);
		// LINE 1222:
			__asm        jmp    _T386;
		// LINE 1223:
		_T381:
			__asm        jmp    next_face;
		// LINE 1226:
		_T386:
			__asm        cmp    check_for_overhang, 0;
			__asm        jne    _T461;
		// LINE 1228:
			__asm        mov    eax, facealt;
			__asm        cmp    altyupbelow, eax;
			__asm        jge    _T45c;
		// LINE 1230:
			altyupbelow = facealt;
		// LINE 1231:
			flags[0] = faceptr->Attrib2;
		// LINE 1235:
			__asm        cmp    collisvec, 0;
			__asm        je     _T3e4;
		// LINE 1237:
			collisvec->x = (((maxx + minx) >> 0x1) - x);
		// LINE 1238:
			collisvec->z = (((maxz + minz) >> 0x1) - z);
		// LINE 1239:
			collisvec->y = 0x0;
		// LINE 1245:
		_T3e4:
			__asm        cmp    landable, 0;
			__asm        je     _T45c;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0xFFFF15A0;
			__asm        jge    _T45c;
		// LINE 1248:
			__asm        mov    eax, x;
			__asm        sub    eax, 0x20000;
			__asm        cmp    eax, minx;
			__asm        jl     _T453;

			__asm        mov    eax, x;
			__asm        add    eax, 0x20000;
			__asm        cmp    eax, maxx;
			__asm        jg     _T453;

			__asm        mov    eax, z;
			__asm        sub    eax, 0x20000;
			__asm        cmp    eax, minz;
			__asm        jl     _T453;

			__asm        mov    eax, z;
			__asm        add    eax, 0x20000;
			__asm        cmp    eax, maxz;
			__asm        jg     _T453;
		// LINE 1250:
			landable[0] = 0x1;
		// LINE 1252:
			__asm        jmp    _T45c;
		// LINE 1254:
		_T453:
			landable[0] = 0x0;
		// LINE 1258:
		_T45c:
			__asm        jmp    next_face;
		// LINE 1262:
		_T461:
			__asm        cmp    normaldir, 0;
			__asm        jl     _T5a0;
		// LINE 1265:
			__asm        mov    eax, y;
			__asm        cmp    facealt, eax;
			__asm        jge    _T57d;

			__asm        mov    eax, facealt;
			__asm        cmp    altyupbelow, eax;
			__asm        jge    _T57d;
		// LINE 1267:
			altyupbelow = facealt;
		// LINE 1270:
			flags[0] = faceptr->Attrib2;
		// LINE 1274:
			__asm        cmp    collisvec, 0;
			__asm        je     _T500;
		// LINE 1276:
			__asm        cmp    normaldir, 0;
			__asm        jle    _T4da;
		// LINE 1278:
			collisvec->x = (((maxx + minx) >> 0x1) - x);
		// LINE 1279:
			collisvec->z = (((maxz + minz) >> 0x1) - z);
		// LINE 1280:
			collisvec->y = 0x0;
		// LINE 1282:
			__asm        jmp    _T500;
		// LINE 1284:
		_T4da:
			collisvec->x = faceptr->Normal->x;
		// LINE 1285:
			collisvec->z = faceptr->Normal->z;
		// LINE 1286:
			collisvec->y = 0x0;
		// LINE 1292:
		_T500:
			__asm        cmp    landable, 0;
			__asm        je     _T578;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+4], 0xFFFF15A0;
			__asm        jge    _T578;
		// LINE 1295:
			__asm        mov    eax, x;
			__asm        sub    eax, 0x10000;
			__asm        cmp    eax, minx;
			__asm        jl     _T56f;

			__asm        mov    eax, x;
			__asm        add    eax, 0x10000;
			__asm        cmp    eax, maxx;
			__asm        jg     _T56f;

			__asm        mov    eax, z;
			__asm        sub    eax, 0x10000;
			__asm        cmp    eax, minz;
			__asm        jl     _T56f;

			__asm        mov    eax, z;
			__asm        add    eax, 0x10000;
			__asm        cmp    eax, maxz;
			__asm        jg     _T56f;
		// LINE 1297:
			landable[0] = 0x1;
		// LINE 1299:
			__asm        jmp    _T578;
		// LINE 1301:
		_T56f:
			landable[0] = 0x0;
		// LINE 1306:
		_T578:
			__asm        jmp    _T59b;
		_T57d:
			__asm        mov    eax, y;
			__asm        cmp    facealt, eax;
			__asm        jl     _T59b;

			__asm        mov    eax, altyupabove;
			__asm        cmp    facealt, eax;
			__asm        jge    _T59b;
		// LINE 1308:
			altyupabove = facealt;
		// LINE 1313:
		_T59b:
			__asm        jmp    next_face;
		// LINE 1320:
		_T5a0:
			__asm        mov    eax, ydim;
			__asm        add    eax, y;
			__asm        cmp    eax, facealt;
			__asm        jle    _T5b4;
		// LINE 1321:
			__asm        jmp    next_face;
		// LINE 1323:
		_T5b4:
			overhang = 0x1;
		// LINE 1326:
			__asm        mov    eax, facealt;
			__asm        cmp    altydown, eax;
			__asm        jle    next_face;
		// LINE 1328:
			altydown = facealt;
		// LINE 1336:
		next_face:
			faceptr = faceptr->NextFace;
	}
// LINE 1345:
do_2d_face:
	vertno = faceptr->PlyVerts;
// LINE 1347:
	__asm        mov    eax, vertno;
	__asm        mov    eax, [eax];
	__asm        shr    eax, 4;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    ecx, oh;
	__asm        add    eax, [ecx+8];
	__asm        mov    vert, eax;
// LINE 1352:
	vertno += 0x4;
// LINE 1354:
	__asm        mov    eax, vertno;
	__asm        mov    eax, [eax];
	__asm        shr    eax, 4;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    ecx, oh;
	__asm        add    eax, [ecx+8];
	__asm        mov    vert2, eax;
// LINE 1363:
	__asm        mov    eax, vert;
	__asm        mov    eax, [eax];
	__asm        sub    eax, 0x40000;
	__asm        mov    ecx, dim;
	__asm        add    ecx, x;
	__asm        cmp    eax, ecx;
	__asm        jg     _T6d2;

	__asm        mov    eax, vert;
	__asm        mov    eax, [eax];
	__asm        add    eax, 0x40000;
	__asm        mov    ecx, x;
	__asm        sub    ecx, dim;
	__asm        cmp    eax, ecx;
	__asm        jl     _T6d2;

	__asm        mov    eax, vert;
	__asm        mov    eax, [eax+8];
	__asm        sub    eax, 0x40000;
	__asm        mov    ecx, dim;
	__asm        add    ecx, z;
	__asm        cmp    eax, ecx;
	__asm        jg     _T6d2;

	__asm        mov    eax, vert;
	__asm        mov    eax, [eax+8];
	__asm        add    eax, 0x40000;
	__asm        mov    ecx, z;
	__asm        sub    ecx, dim;
	__asm        cmp    eax, ecx;
	__asm        jl     _T6d2;
// LINE 1365:
	__asm        mov    eax, vert2;
	__asm        mov    ecx, altyupbelow;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _T6d2;
// LINE 1367:
	altyupbelow = vert2->y;
// LINE 1369:
	__asm        cmp    landable, 0;
	__asm        je     _T6a2;
// LINE 1371:
	landable[0] = 0x0;
// LINE 1374:
_T6a2:
	__asm        cmp    collisvec, 0;
	__asm        je     _T6d2;
// LINE 1376:
	collisvec->x = (vert->x - x);
// LINE 1377:
	collisvec->z = (vert->z - z);
// LINE 1378:
	collisvec->y = 0x0;
// LINE 1384:
_T6d2:
	faceptr = faceptr->NextFace;
// LINE 1386:
	__asm        jmp    _FOR_NEXT_a3;
// LINE 1388:
_T6df:
	__asm        cmp    check_for_overhang, 0;
	__asm        jne    _T6f1;
// LINE 1390:
	return altyupbelow;
// LINE 1395:
_T6f1:
	__asm        cmp    overhang, 1;
	__asm        jne    _T721;
// LINE 1397:
	__asm        mov    eax, altyupabove;
	__asm        cmp    altydown, eax;
	__asm        jle    _T714;
// LINE 1398:
	return altyupabove;
// LINE 1399:
	__asm        jmp    _T71c;
// LINE 1400:
_T714:
	return altyupbelow;
// LINE 1402:
_T71c:
	__asm        jmp    __RETURN;
// LINE 1404:
_T721:
	__asm        cmp    altyupabove, 0x75300000;
	__asm        je     _T73b;
// LINE 1405:
	return altyupabove;
// LINE 1406:
	__asm        jmp    __RETURN;
// LINE 1407:
_T73b:
	return altyupbelow;
// LINE 1409:
__RETURN:
}

// FUNCTION: COPTER_D 0x004d392f
int32_t VRGetObjZdist(int32_t obj, int32_t x, int32_t y, int32_t dir, int32_t dim) {
	/*bp-0x4*/   /*packed*/ struct _FaceHdr *faceptr;
	/*bp-0x8*/   int32_t * vertno;
	/*bp-0xc*/   /*packed*/ struct Point3d *vert;
	/*bp-0x10*/  int32_t facez;
	/*bp-0x14*/  int32_t minx;
	/*bp-0x18*/  int32_t i;
	/*bp-0x1c*/  int32_t miny;
	/*bp-0x20*/  int32_t j;
	/*bp-0x24*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x28*/  int32_t minz;
	/*bp-0x2c*/  int32_t maxx;
	/*bp-0x30*/  int32_t distz;
	/*bp-0x34*/  int32_t maxy;
	/*bp-0x38*/  int32_t maxz;
	/*bp-0x3c*/  char * dataptr;

// LINE 1424:
	oh = obj;
// LINE 1435:
	__asm        cmp    obj, 0;
	__asm        jne    _T20;
// LINE 1436:
	return 0x0;
// LINE 1439:
_T20:
	distz = 0x0;
// LINE 1442:
	faceptr = oh->FacePtr;
// LINE 1443:
_FOR_3c:
	for (i = 0x0; (oh->NFaces > i); i++) {
		// LINE 1446:
			__asm        mov    eax, faceptr;
			__asm        test   byte ptr [eax+8], 4;
			__asm        je     _T60;

			__asm        jmp    next_face;
		// LINE 1449:
		_T60:
			__asm        cmp    dir, 0;
			__asm        jge    _T82;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+8], 0xFFFFD8F0;
			__asm        jle    _T82;
		// LINE 1450:
			__asm        jmp    next_face;
		// LINE 1451:
		_T82:
			__asm        cmp    dir, 0;
			__asm        jle    _Ta4;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax+8], 0x2710;
			__asm        jge    _Ta4;
		// LINE 1452:
			__asm        jmp    next_face;
		// LINE 1455:
		_Ta4:
			dataptr = faceptr;
		// LINE 1456:
			dataptr += 0x30;
		// LINE 1457:
			vertno = dataptr;
		// LINE 1460:
			minz = 0x75300000;
			miny = minz;
			minx = miny;
		// LINE 1461:
			maxz = 0x8ad00000;
			maxy = maxz;
			maxx = maxy;
		// LINE 1466:
		_FOR_e6:
			for (j = 0x0; (faceptr->Nverts > j); j++) {
				// LINE 1472:
					__asm        mov    eax, vertno;
					__asm        mov    eax, [eax];
					__asm        shr    eax, 4;
					__asm        lea    eax, [eax+eax*2];
					__asm        shl    eax, 2;
					__asm        mov    ecx, oh;
					__asm        add    eax, [ecx+8];
					__asm        mov    vert, eax;
				// LINE 1476:
					vertno += 0x4;
				// LINE 1479:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minx;
					__asm        cmp    [eax], ecx;
					__asm        jge    _T129;

					minx = vert->x;
				// LINE 1480:
				_T129:
					__asm        mov    eax, vert;
					__asm        mov    ecx, miny;
					__asm        cmp    [eax+4], ecx;
					__asm        jge    _T141;

					miny = vert->y;
				// LINE 1481:
				_T141:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minz;
					__asm        cmp    [eax+8], ecx;
					__asm        jge    _T159;

					minz = vert->z;
				// LINE 1482:
				_T159:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxx;
					__asm        cmp    [eax], ecx;
					__asm        jle    _T16f;

					maxx = vert->x;
				// LINE 1483:
				_T16f:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxy;
					__asm        cmp    [eax+4], ecx;
					__asm        jle    _T187;

					maxy = vert->y;
				// LINE 1484:
				_T187:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxz;
					__asm        cmp    [eax+8], ecx;
					__asm        jle    _T19f;

					maxz = vert->z;
				// LINE 1485:
				_T19f:
			}
		// LINE 1489:
		_T1a4:
			__asm        mov    eax, dim;
			__asm        add    eax, y;
			__asm        cmp    eax, miny;
			__asm        jl     next_face;

			__asm        mov    eax, y;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxy;
			__asm        jg     next_face;

			__asm        mov    eax, x;
			__asm        add    eax, dim;
			__asm        cmp    eax, minx;
			__asm        jl     next_face;

			__asm        mov    eax, x;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxx;
			__asm        jg     next_face;
		// LINE 1492:
			facez = ((maxz + minz) >> 0x1);
		// LINE 1493:
			distz = facez;
		// LINE 1494:
			return distz;
		// LINE 1506:
		next_face:
			faceptr = faceptr->NextFace;
	}
// LINE 1509:
_T207:
	return distz;
// LINE 1511:
}

// FUNCTION: COPTER_D 0x004d3b43
int32_t VRGetObjXdist(int32_t obj, int32_t y, int32_t z, int32_t dir, int32_t dim) {
	/*bp-0x4*/   /*packed*/ struct _FaceHdr *faceptr;
	/*bp-0x8*/   int32_t * vertno;
	/*bp-0xc*/   int32_t facex;
	/*bp-0x10*/  /*packed*/ struct Point3d *vert;
	/*bp-0x14*/  int32_t minx;
	/*bp-0x18*/  int32_t i;
	/*bp-0x1c*/  int32_t miny;
	/*bp-0x20*/  int32_t j;
	/*bp-0x24*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x28*/  int32_t distx;
	/*bp-0x2c*/  int32_t minz;
	/*bp-0x30*/  int32_t maxx;
	/*bp-0x34*/  int32_t maxy;
	/*bp-0x38*/  int32_t maxz;
	/*bp-0x3c*/  char * dataptr;

// LINE 1526:
	oh = obj;
// LINE 1537:
	__asm        cmp    obj, 0;
	__asm        jne    _T20;
// LINE 1538:
	return 0x0;
// LINE 1541:
_T20:
	distx = 0x0;
// LINE 1544:
	faceptr = oh->FacePtr;
// LINE 1545:
_FOR_3c:
	for (i = 0x0; (oh->NFaces > i); i++) {
		// LINE 1548:
			__asm        mov    eax, faceptr;
			__asm        test   byte ptr [eax+8], 4;
			__asm        je     _T60;

			__asm        jmp    next_face;
		// LINE 1551:
		_T60:
			__asm        cmp    dir, 0;
			__asm        jge    _T81;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax], 0xFFFFD8F0;
			__asm        jle    _T81;
		// LINE 1552:
			__asm        jmp    next_face;
		// LINE 1553:
		_T81:
			__asm        cmp    dir, 0;
			__asm        jle    _Ta2;

			__asm        mov    eax, faceptr;
			__asm        mov    eax, [eax+0x2C];
			__asm        cmp    dword ptr [eax], 0x2710;
			__asm        jge    _Ta2;
		// LINE 1554:
			__asm        jmp    next_face;
		// LINE 1557:
		_Ta2:
			dataptr = faceptr;
		// LINE 1558:
			dataptr += 0x30;
		// LINE 1559:
			vertno = dataptr;
		// LINE 1562:
			minz = 0x75300000;
			miny = minz;
			minx = miny;
		// LINE 1563:
			maxz = 0x8ad00000;
			maxy = maxz;
			maxx = maxy;
		// LINE 1568:
		_FOR_e4:
			for (j = 0x0; (faceptr->Nverts > j); j++) {
				// LINE 1574:
					__asm        mov    eax, vertno;
					__asm        mov    eax, [eax];
					__asm        shr    eax, 4;
					__asm        lea    eax, [eax+eax*2];
					__asm        shl    eax, 2;
					__asm        mov    ecx, oh;
					__asm        add    eax, [ecx+8];
					__asm        mov    vert, eax;
				// LINE 1578:
					vertno += 0x4;
				// LINE 1581:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minx;
					__asm        cmp    [eax], ecx;
					__asm        jge    _T127;

					minx = vert->x;
				// LINE 1582:
				_T127:
					__asm        mov    eax, vert;
					__asm        mov    ecx, miny;
					__asm        cmp    [eax+4], ecx;
					__asm        jge    _T13f;

					miny = vert->y;
				// LINE 1583:
				_T13f:
					__asm        mov    eax, vert;
					__asm        mov    ecx, minz;
					__asm        cmp    [eax+8], ecx;
					__asm        jge    _T157;

					minz = vert->z;
				// LINE 1584:
				_T157:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxx;
					__asm        cmp    [eax], ecx;
					__asm        jle    _T16d;

					maxx = vert->x;
				// LINE 1585:
				_T16d:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxy;
					__asm        cmp    [eax+4], ecx;
					__asm        jle    _T185;

					maxy = vert->y;
				// LINE 1586:
				_T185:
					__asm        mov    eax, vert;
					__asm        mov    ecx, maxz;
					__asm        cmp    [eax+8], ecx;
					__asm        jle    _T19d;

					maxz = vert->z;
				// LINE 1587:
				_T19d:
			}
		// LINE 1591:
		_T1a2:
			__asm        mov    eax, dim;
			__asm        add    eax, y;
			__asm        cmp    eax, miny;
			__asm        jl     next_face;

			__asm        mov    eax, y;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxy;
			__asm        jg     next_face;

			__asm        mov    eax, dim;
			__asm        add    eax, z;
			__asm        cmp    eax, minz;
			__asm        jl     next_face;

			__asm        mov    eax, z;
			__asm        sub    eax, dim;
			__asm        cmp    eax, maxz;
			__asm        jg     next_face;
		// LINE 1594:
			facex = ((minx + maxx) >> 0x1);
		// LINE 1595:
			distx = facex;
		// LINE 1596:
			return distx;
		// LINE 1608:
		next_face:
			faceptr = faceptr->NextFace;
	}
// LINE 1611:
_T205:
	return distx;
// LINE 1613:
}

// FUNCTION: COPTER_D 0x004d3d55
void VRObjResize2dFace(int32_t obj, int32_t width, int32_t height) {
	/*bp-0x4*/   /*packed*/ struct Point3d *vert1;
	/*bp-0x8*/   /*packed*/ struct _FaceHdr *faceptr;
	/*bp-0xc*/   /*packed*/ struct Point3d *vert2;
	/*bp-0x10*/  int32_t * vertno;
	/*bp-0x14*/  int32_t i;
	/*bp-0x18*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x1c*/  char * dataptr;

// LINE 1630:
	oh = obj;
// LINE 1637:
	faceptr = oh->FacePtr;
// LINE 1639:
	faceptr = oh->FacePtr;
// LINE 1640:
_FOR_2d:
	for (i = 0x0; (oh->NFaces > i); i++) {
		// LINE 1642:
			__asm        mov    eax, faceptr;
			__asm        test   byte ptr [eax+8], 4;
			__asm        jne    _T51;
		// LINE 1643:
			__asm        jmp    next_face;
		// LINE 1646:
		_T51:
			dataptr = faceptr;
		// LINE 1647:
			dataptr += 0x30;
		// LINE 1650:
			vertno = dataptr;
		// LINE 1652:
			__asm        mov    eax, vertno;
			__asm        mov    eax, [eax];
			__asm        shr    eax, 4;
			__asm        lea    eax, [eax+eax*2];
			__asm        shl    eax, 2;
			__asm        mov    ecx, oh;
			__asm        add    eax, [ecx+8];
			__asm        mov    vert1, eax;
		// LINE 1657:
			vertno += 0x4;
		// LINE 1659:
			__asm        mov    eax, vertno;
			__asm        mov    eax, [eax];
			__asm        shr    eax, 4;
			__asm        lea    eax, [eax+eax*2];
			__asm        shl    eax, 2;
			__asm        mov    ecx, oh;
			__asm        add    eax, [ecx+8];
			__asm        mov    vert2, eax;
		// LINE 1665:
			vert2->x = (((width << 0x10) >> 0x1) + vert1->x);
		// LINE 1666:
			vert2->y = (vert1->y + ((height << 0x10) >> 0x1));
		// LINE 1670:
		next_face:
			faceptr = faceptr->NextFace;
	}
// LINE 1673:
__RETURN:
}

// FUNCTION: COPTER_D 0x004d3e24
void VR3dObjLocate(int32_t obj, int32_t x, int32_t y, int32_t z) {
	/*bp-0x4*/   /*packed*/ struct Point3d *vert;
	/*bp-0x8*/   int32_t i;
	/*bp-0xc*/   /*packed*/ struct ObjectHdr *oh;

// LINE 1685:
	oh = obj;
// LINE 1689:
_FOR_24:
	i = 0x0;
	vert = oh->VertsPtr;
	__asm        jmp    _FOR_COND_24;
_FOR_NEXT_24:
	i++;
	vert += 0xc;
_FOR_COND_24:
	__asm        mov    eax, oh;
	__asm        mov    ecx, i;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _T59;
// LINE 1691:
	vert->x += x;
// LINE 1692:
	vert->y += y;
// LINE 1693:
	vert->z += z;
// LINE 1694:
	__asm        jmp    _FOR_NEXT_24;
// LINE 1697:
_T59:
	oh->CenterOrg.x += x;
// LINE 1698:
	oh->CenterOrg.y += y;
// LINE 1699:
	oh->CenterOrg.z += z;
// LINE 1701:
}

// FUNCTION: COPTER_D 0x004d3e9d
int32_t VRObjGetHeight(int32_t obj) {
	/*bp-0x4*/   /*packed*/ struct Point3d *vert;
	/*bp-0x8*/   int32_t i;
	/*bp-0xc*/   /*packed*/ struct ObjectHdr *oh;
	/*bp-0x10*/  int32_t maxy;

// LINE 1713:
	oh = obj;
// LINE 1716:
	maxy = 0x80000000;
// LINE 1718:
_FOR_2b:
	i = 0x0;
	vert = oh->VertsPtr;
	__asm        jmp    _FOR_COND_2b;
_FOR_NEXT_2b:
	i++;
	vert += 0xc;
_FOR_COND_2b:
	__asm        mov    eax, oh;
	__asm        mov    ecx, i;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _T5e;
// LINE 1720:
	__asm        mov    eax, vert;
	__asm        mov    ecx, maxy;
	__asm        cmp    [eax+4], ecx;
	__asm        jle    _T59;
// LINE 1721:
	maxy = vert->y;
// LINE 1722:
_T59:
	__asm        jmp    _FOR_NEXT_2b;
// LINE 1724:
_T5e:
	return maxy;
// LINE 1725:
}

// FUNCTION: COPTER_D 0x004d3f08
void VR2dObjLocate(int32_t obj, int32_t x, int32_t y, int32_t z) {
	/*bp-0x4*/   int32_t ydiff;
	/*bp-0x8*/   /*packed*/ struct Point3d *vert1;
	/*bp-0xc*/   /*packed*/ struct _FaceHdr *faceptr;
	/*bp-0x10*/  /*packed*/ struct Point3d *vert2;
	/*bp-0x14*/  int32_t * vertno;
	/*bp-0x18*/  int32_t xdiff;
	/*bp-0x1c*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x20*/  char * dataptr;

// LINE 1740:
	oh = obj;
// LINE 1747:
	faceptr = oh->FacePtr;
// LINE 1749:
	__asm        mov    eax, faceptr;
	__asm        test   byte ptr [eax+8], 4;
	__asm        jne    _T2a;
// LINE 1750:
	return;
// LINE 1752:
_T2a:
	dataptr = faceptr;
// LINE 1753:
	dataptr += 0x30;
// LINE 1754:
	vertno = dataptr;
// LINE 1758:
	__asm        mov    eax, vertno;
	__asm        mov    eax, [eax];
	__asm        shr    eax, 4;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    ecx, oh;
	__asm        add    eax, [ecx+8];
	__asm        mov    vert1, eax;
// LINE 1762:
	vertno += 0x4;
// LINE 1764:
	__asm        mov    eax, vertno;
	__asm        mov    eax, [eax];
	__asm        shr    eax, 4;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    ecx, oh;
	__asm        add    eax, [ecx+8];
	__asm        mov    vert2, eax;
// LINE 1770:
	xdiff = (vert2->x - vert1->x);
// LINE 1771:
	ydiff = (vert2->y - vert1->y);
// LINE 1775:
	vert1->x = x;
// LINE 1776:
	vert1->y = y;
// LINE 1777:
	vert1->z = z;
// LINE 1779:
	vert2->x = (x + xdiff);
// LINE 1780:
	vert2->y = (y + ydiff);
// LINE 1781:
	vert2->z = z;
// LINE 1783:
	oh->CenterOrg.x = x;
// LINE 1784:
	oh->CenterOrg.y = y;
// LINE 1785:
	oh->CenterOrg.z = z;
// LINE 1787:
}

// FUNCTION: COPTER_D 0x004d3fea
/*packed*/ struct _BSPtree* ReadTree() {
	/*bp-0x4*/   unsigned short ThisIndex;
	/*bp-0x8*/   unsigned short FaceIndex;

// LINE 1803:
	ReadResource(FaceIndex, 0x2);
// LINE 1810:
	__asm        mov    eax, reinterpret_cast<uint32_t>(FaceIndex);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0xFFFF;
	__asm        je     _Teb;
// LINE 1811:
	__asm        mov    ax, BSPIndex;
	__asm        mov    ThisIndex, ax;
// LINE 1812:
	BSPIndex++;
// LINE 1813:
	__asm        mov    eax, reinterpret_cast<uint32_t>(FaceIndex);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, FaceArray;
	__asm        mov    eax, [ecx+eax*4];
	__asm        mov    ecx, reinterpret_cast<uint32_t>(ThisIndex);
	__asm        and    ecx, 0xFFFF;
	__asm        mov    edx, ecx;
	__asm        shl    ecx, 3;
	__asm        sub    ecx, edx;
	__asm        mov    edx, Tree;
	__asm        mov    [edx+ecx*4], eax;
// LINE 1815:
	ReadResource(((((((reinterpret_cast<uint32_t>(ThisIndex) & 0xffff) << 0x3) - (reinterpret_cast<uint32_t>(ThisIndex) & 0xffff)) << 0x2) + Tree) + 0x4), 0x10);
// LINE 1827:
	__asm        call   ReadTree;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(ThisIndex);
	__asm        and    ecx, 0xFFFF;
	__asm        mov    edx, ecx;
	__asm        shl    ecx, 3;
	__asm        sub    ecx, edx;
	__asm        mov    edx, Tree;
	__asm        mov    [edx+ecx*4+0x14], eax;
// LINE 1828:
	__asm        call   ReadTree;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(ThisIndex);
	__asm        and    ecx, 0xFFFF;
	__asm        mov    edx, ecx;
	__asm        shl    ecx, 3;
	__asm        sub    ecx, edx;
	__asm        mov    edx, Tree;
	__asm        mov    [edx+ecx*4+0x18], eax;
// LINE 1829:
	return (((((reinterpret_cast<uint32_t>(ThisIndex) & 0xffff) << 0x3) - (reinterpret_cast<uint32_t>(ThisIndex) & 0xffff)) << 0x2) + Tree);
// LINE 1831:
	__asm        jmp    __RETURN;
_Teb:
	return 0x0;
// LINE 1833:
__RETURN:
}

// FUNCTION: COPTER_D 0x004d40e1
void NormalizeObj(/*packed*/ struct ObjectHdr *obj) {
	/*bp-0x4*/   /*packed*/ struct Point3d *s;
	/*bp-0x10*/  /*packed*/ struct Point3d c; // 0xc bytes
	/*bp-0x14*/  /*packed*/ struct Point3d *d;
	/*bp-0x18*/  int32_t i;

// LINE 1848:
	__asm        mov    eax, obj;
	__asm        add    eax, 0x18;
	__asm        lea    ecx, c.x;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 1849:
	s = obj->VertsPtr;
// LINE 1850:
	d = obj->VertsPtr;
// LINE 1851:
_FOR_40:
	for (i = 0x0; (obj->NVerts > i); i++) {
		// LINE 1852:
			d->x = (s->x - c.x);
		// LINE 1853:
			d->y = (s->y - c.y);
		// LINE 1854:
			d->z = (s->z - c.z);
		// LINE 1855:
			d += 0xc;
		// LINE 1856:
			s += 0xc;
	}
// LINE 1858:
_T8a:
	obj->CenterOrg.z = 0x0;
	obj->CenterOrg.y = obj->CenterOrg.z;
	obj->CenterOrg.x = obj->CenterOrg.y;
// LINE 1859:
}

// FUNCTION: COPTER_D 0x004d4192
int32_t VRAssignTextureResToGroup(/*packed*/ struct VRResource *g, /*packed*/ struct VRResource *b) {
	/*bp-0x4*/   int32_t loword;
	/*bp-0x28*/  /*packed*/ struct VRObjInfo oinfo; // 0x24 bytes
	/*bp-0x2c*/  int32_t face;
	/*bp-0x30*/  /*packed*/ struct _FaceHdr *fh;
	/*bp-0x34*/  int32_t i;
	/*bp-0x38*/  int32_t j;
	/*bp-0x3c*/  int32_t hiword;
	/*bp-0x40*/  /*packed*/ struct TEXT_Resource *bmp;
	/*bp-0x44*/  /*packed*/ struct GEOM_Resource *geo;
	/*bp-0x48*/  int32_t k;
	/*bp-0x4c*/  int32_t obj;

// LINE 1880:
	geo = g;
// LINE 1881:
	bmp = b;
// LINE 1882:
_FOR_21:
	for (i = 0x0; (geo->count > i); i++) {
		// LINE 1883:
			__asm        mov    eax, i;
			__asm        mov    ecx, geo;
			__asm        mov    eax, [ecx+eax*4+0x18];
			__asm        mov    obj, eax;
		// LINE 1884:
			_VRGetObjInfo(obj, oinfo.Faces);
		// LINE 1885:
			__asm        mov    eax, obj;
			__asm        push   eax;
			__asm        call   _VRGetFirstFace;
			__asm        add    esp, 4;
			__asm        mov    face, eax;
		// LINE 1886:
		_FOR_6b:
			for (j = 0x0; (oinfo.Faces > j); j++) {
				// LINE 1887:
					fh = face;
				// LINE 1893:
					__asm        mov    eax, fh;
					__asm        test   byte ptr [eax+8], 1;
					__asm        je     _T9a;

					__asm        mov    eax, fh;
					__asm        test   byte ptr [eax+8], 4;
					__asm        je     _Tce;
				_T9a:
					__asm        mov    eax, fh;
					__asm        test   byte ptr [eax+9], 8;
					__asm        jne    _Tce;

					__asm        mov    eax, fh;
					__asm        test   byte ptr [eax+9], 0x80;
					__asm        jne    _Tce;

					__asm        mov    eax, fh;
					__asm        test   byte ptr [eax+0xA], 1;
					__asm        jne    _Tce;

					__asm        mov    eax, fh;
					__asm        test   byte ptr [eax+9], 0x40;
					__asm        je     _Td3;
				// LINE 1894:
				_Tce:
					__asm        jmp    next_face;
				// LINE 1895:
				_Td3:
					__asm        mov    eax, face;
					__asm        push   eax;
					__asm        call   _VRGetFaceTexture;
					__asm        add    esp, 4;
					__asm        mov    k, eax;
				// LINE 1896:
					hiword = (k >> 0x10);
				// LINE 1897:
					loword = (k & 0xffff);
				// LINE 1901:
					__asm        cmp    hiword, 0;
					__asm        je     _T143;
				// LINE 1903:
					__asm        mov    eax, bmp;
					__asm        mov    ecx, hiword;
					__asm        cmp    [eax+0x10], ecx;
					__asm        jge    _T120;
				// LINE 1905:
					GlobalError = 0xd;
				// LINE 1906:
					return 0x0;
				// LINE 1909:
				_T120:
					__asm        mov    eax, loword;
					__asm        push   eax;
					__asm        mov    eax, hiword;
					__asm        lea    eax, [eax+eax*2];
					__asm        mov    ecx, bmp;
					__asm        mov    eax, [ecx+eax*4+0x20];
					__asm        push   eax;
					__asm        mov    eax, fh;
					__asm        push   eax;
					__asm        call   VRBCApplyTiledMap;
					__asm        add    esp, 0xC;
				// LINE 1911:
					__asm        jmp    next_face;
				// LINE 1913:
				_T143:
					__asm        mov    eax, bmp;
					__asm        mov    ecx, k;
					__asm        cmp    [eax+0x10], ecx;
					__asm        jge    _T163;
				// LINE 1914:
					GlobalError = 0xd;
				// LINE 1915:
					return 0x0;
				// LINE 1917:
				_T163:
					__asm        mov    eax, k;
					__asm        lea    eax, [eax+eax*2];
					__asm        mov    ecx, bmp;
					__asm        mov    eax, [ecx+eax*4+0x20];
					__asm        push   eax;
					__asm        mov    eax, face;
					__asm        push   eax;
					__asm        call   _VRBCApplyMap;
					__asm        add    esp, 8;
				// LINE 1919:
				next_face:
					__asm        mov    eax, face;
					__asm        push   eax;
					__asm        call   _VRGetNextFace;
					__asm        add    esp, 4;
					__asm        mov    face, eax;
			}
		// LINE 1921:
		_T191:
	}
// LINE 1922:
_T196:
	return 0x1;
// LINE 1923:
}

// FUNCTION: COPTER_D 0x004d4337
void VRBCApplyTiledMap(/*packed*/ struct _FaceHdr *fh, /*packed*/ struct VRBmpHdr *bmp, int32_t tileid) {
	/*bp-0x4*/   /*packed*/ struct MapVert *mv;
	/*bp-0x8*/   /*packed*/ struct MapVert *barry;
	/*bp-0xc*/   int32_t w;
	/*bp-0x10*/  int32_t h;
	/*bp-0x14*/  int32_t i;

// LINE 1937:
	mv = fh->MapVerts;
// LINE 1938:
	barry = fh->Barrys;
// LINE 1940:
	w = bmp->info.width;
// LINE 1941:
	h = bmp->info.height;
// LINE 1946:
_FOR_38:
	for (i = 0x0; (fh->Nverts > i); i++) {
		// LINE 1948:
			mv->x = (barry->x * w);
		// LINE 1949:
			mv->y = (barry->y * h);
		// LINE 1950:
			mv += 0x8;
		// LINE 1951:
			barry += 0x8;
	}
// LINE 1958:
_T75:
	fh->Bitmap = (((tileid << 0x3) + bmp) + 0xc);
// LINE 1959:
}

// FUNCTION: COPTER_D 0x004d43c3
/*packed*/ struct VRMemPool* VRCreateMemPool(int32_t xf, int32_t d2) {
	/*bp-0x4*/   /*packed*/ struct VRMemPool *mp;

// LINE 1975:
	__asm        mov    eax, d2;
	__asm        add    eax, xf;
	__asm        add    eax, 0xA0;
	__asm        push   eax;
	__asm        call   malloc;
	__asm        add    esp, 4;
	__asm        mov    mp, eax;
	__asm        cmp    mp, 0;
	__asm        jne    _T3b;
// LINE 1976:
	GlobalError = 0x4;
// LINE 1977:
	return 0x0;
// LINE 1982:
_T3b:
	mp->ObjCount = 0x0;
// LINE 1983:
	mp->Reset_Xf = ((mp + 0x30) & -0x10);
// LINE 1984:
	mp->Reset_2d = (((mp->Reset_Xf + xf) + 0x10) & -0x10);
// LINE 1985:
	mp->End_Xf = mp->Reset_2d;
// LINE 1986:
	mp->End_2d = (((mp->Reset_2d + d2) + 0x10) & -0x10);
// LINE 1988:
	__asm        mov    eax, d2;
	__asm        add    eax, xf;
	__asm        add    eax, 0xA0;
	__asm        add    G_alloc_curr, eax;
	__asm        mov    eax, G_alloc_curr;
	__asm        cmp    G_alloc_max, eax;
	__asm        jae    _Tb5;

	G_alloc_max = G_alloc_curr;
// LINE 1989:
_Tb5:
	G_alloc_used += ((d2 + xf) + 0xa0);
// LINE 1992:
	__asm        mov    eax, mp;
	__asm        push   eax;
	__asm        call   _InsertMemPool;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _Teb;
// LINE 1993:
	GlobalError = 0xe;
// LINE 1994:
	return 0x0;
// LINE 1996:
_Teb:
	return mp;
// LINE 1997:
}

// FUNCTION: COPTER_D 0x004d44bb
void VRFreeMemPool(/*packed*/ struct VRMemPool *mp) {
// LINE 2010:
	_RemoveMemPool(mp);
// LINE 2011:
	free(mp);
// LINE 2012:
}

// FUNCTION: COPTER_D 0x004d44de
void FaceCalcNormal(/*packed*/ struct Point3d *v0, /*packed*/ struct Point3d *v1, /*packed*/ struct Point3d *vlst, /*packed*/ struct Project3d *norm) {
	/*bp-0x18*/  /*packed*/ struct FPoint3d fV1; // 0x18 bytes
	/*bp-0x30*/  /*packed*/ struct FPoint3d fV2; // 0x18 bytes
	/*bp-0x48*/  /*packed*/ struct FPoint3d fv0; // 0x18 bytes
	/*bp-0x50*/  double tmpX; // 0x8 bytes
	/*bp-0x68*/  /*packed*/ struct FPoint3d fv1; // 0x18 bytes
	/*bp-0x70*/  double tmpY; // 0x8 bytes
	/*bp-0x78*/  double tmpZ; // 0x8 bytes
	/*bp-0x80*/  double length; // 0x8 bytes
	/*bp-0x98*/  /*packed*/ struct FPoint3d fvlst; // 0x18 bytes

// LINE 2034:
	__asm        mov    eax, v0;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x9C], eax;
	__asm        fild   dword ptr [ebp-0x9C];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fv0.x;
// LINE 2035:
	__asm        mov    eax, v0;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xA0], eax;
	__asm        fild   dword ptr [ebp-0xA0];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fv0.y;
// LINE 2036:
	__asm        mov    eax, v0;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0xA4], eax;
	__asm        fild   dword ptr [ebp-0xA4];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fv0.z;
// LINE 2037:
	__asm        mov    eax, v1;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xA8], eax;
	__asm        fild   dword ptr [ebp-0xA8];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fv1.x;
// LINE 2038:
	__asm        mov    eax, v1;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xAC], eax;
	__asm        fild   dword ptr [ebp-0xAC];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fv1.y;
// LINE 2039:
	__asm        mov    eax, v1;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0xB0], eax;
	__asm        fild   dword ptr [ebp-0xB0];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fv1.z;
// LINE 2040:
	__asm        mov    eax, vlst;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xB4], eax;
	__asm        fild   dword ptr [ebp-0xB4];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fvlst.x;
// LINE 2041:
	__asm        mov    eax, vlst;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xB8], eax;
	__asm        fild   dword ptr [ebp-0xB8];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fvlst.y;
// LINE 2042:
	__asm        mov    eax, vlst;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0xBC], eax;
	__asm        fild   dword ptr [ebp-0xBC];
	__asm        fdiv   qword ptr ds:[0x592460];
	__asm        fstp   fvlst.z;
// LINE 2047:
	__asm        fld    fvlst.x;
	__asm        fsub   fv0.x;
	__asm        fstp   fV2.x;
// LINE 2048:
	__asm        fld    fvlst.y;
	__asm        fsub   fv0.y;
	__asm        fstp   fV2.y;
// LINE 2049:
	__asm        fld    fvlst.z;
	__asm        fsub   fv0.z;
	__asm        fstp   fV2.z;
// LINE 2050:
	__asm        fld    fv1.x;
	__asm        fsub   fv0.x;
	__asm        fstp   fV1.x;
// LINE 2051:
	__asm        fld    fv1.y;
	__asm        fsub   fv0.y;
	__asm        fstp   fV1.y;
// LINE 2052:
	__asm        fld    fv1.z;
	__asm        fsub   fv0.z;
	__asm        fst    fV1.z;
// LINE 2057:
	__asm        fmul   fV2.y;
	__asm        fld    fV1.y;
	__asm        fmul   fV2.z;
	__asm        fsubp;
	__asm        fstp   tmpX;
// LINE 2058:
	__asm        fld    fV2.z;
	__asm        fmul   fV1.x;
	__asm        fld    fV1.z;
	__asm        fmul   fV2.x;
	__asm        fsubp;
	__asm        fstp   tmpY;
// LINE 2059:
	__asm        fld    fV1.y;
	__asm        fmul   fV2.x;
	__asm        fld    fV1.x;
	__asm        fmul   fV2.y;
	__asm        fsubp;
	__asm        fst    tmpZ;
// LINE 2062:
	__asm        fmul   tmpZ;
	__asm        fld    tmpY;
	__asm        fmul   tmpY;
	__asm        faddp;
	__asm        fld    tmpX;
	__asm        fmul   tmpX;
	__asm        faddp;
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        call   _sqrt;
	__asm        add    esp, 8;
	__asm        fst    length;
// LINE 2064:
	__asm        fdivr  tmpX;
	__asm        fmul   qword ptr ds:[0x592460];
	__asm        call   __ftol;
	__asm        mov    ecx, norm;
	__asm        mov    [ecx], eax;
// LINE 2065:
	__asm        fld    tmpY;
	__asm        fdiv   length;
	__asm        fmul   qword ptr ds:[0x592460];
	__asm        call   __ftol;
	__asm        mov    ecx, norm;
	__asm        mov    [ecx+4], eax;
// LINE 2066:
	__asm        fld    tmpZ;
	__asm        fdiv   length;
	__asm        fmul   qword ptr ds:[0x592460];
	__asm        call   __ftol;
	__asm        mov    ecx, norm;
	__asm        mov    [ecx+8], eax;
// LINE 2067:
}

// FUNCTION: COPTER_D 0x004d46bc
void ObjCalcVnormsAndShade(/*packed*/ struct ObjectHdr *obj) {
	/*bp-0x8*/   double tmpX; // 0x8 bytes
	/*bp-0x10*/  double tmpY; // 0x8 bytes
	/*bp-0x18*/  double tmpZ; // 0x8 bytes
	/*bp-0x1c*/  int32_t vertid;
	/*bp-0x24*/  double length; // 0x8 bytes
	/*bp-0x28*/  int32_t * faceverts;
	/*bp-0x2c*/  int32_t i;
	/*bp-0x30*/  /*packed*/ struct Point3d *vnorms;
	/*bp-0x34*/  int32_t j;
	/*bp-0x38*/  int32_t k;
	/*bp-0x3c*/  /*packed*/ struct _FaceHdr *fp;

// LINE 2105:
	__asm        mov    eax, obj;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        call   malloc;
	__asm        add    esp, 4;
	__asm        mov    vnorms, eax;
// LINE 2106:
	__asm        cmp    vnorms, 0;
	__asm        jne    _T30;
// LINE 2107:
	return;
// LINE 2109:
_T30:
	__asm        mov    eax, obj;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    G_alloc_curr, eax;
	__asm        mov    eax, G_alloc_curr;
	__asm        cmp    G_alloc_max, eax;
	__asm        jae    _T5d;

	G_alloc_max = G_alloc_curr;
// LINE 2110:
_T5d:
	__asm        mov    eax, obj;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    G_alloc_used, eax;
// LINE 2116:
_FOR_7b:
	for (i = 0x0; (obj->NVerts > i); i++) {
		// LINE 2118:
		// Block start:
			/*bp-0x40*/  int32_t no_vert_faces;
			/*bp-0x44*/  /*packed*/ struct Point3d *vn;
			no_vert_faces = 0x0;
		// LINE 2119:
			__asm        mov    eax, i;
			__asm        lea    eax, [eax+eax*2];
			__asm        shl    eax, 2;
			__asm        add    eax, vnorms;
			__asm        mov    vn, eax;
		// LINE 2121:
			vn->z = 0x0;
			vn->y = vn->z;
			vn->x = vn->y;
		// LINE 2129:
			vertid = (i << 0x4);
		// LINE 2136:
			fp = obj->FacePtr;
		// LINE 2137:
		_FOR_e2:
			for (j = 0x0; (obj->NFaces > j); j++) {
				// LINE 2139:
				// Block start:
					/*bp-0x48*/  /*packed*/ struct Project3d *fn;
					fn = fp->Normal;
				// LINE 2141:
					faceverts = fp->PlyVerts;
				// LINE 2147:
				_FOR_112:
					for (k = 0x0; (fp->Nverts > k); k++) {
						// LINE 2149:
							__asm        mov    eax, k;
							__asm        mov    ecx, faceverts;
							__asm        mov    edx, vertid;
							__asm        cmp    [ecx+eax*4], edx;
							__asm        jne    _T160;
						// LINE 2151:
							no_vert_faces++;
						// LINE 2152:
							vn->x += fn->x;
						// LINE 2153:
							vn->y += fn->y;
						// LINE 2154:
							vn->z += fn->z;
						// LINE 2155:
							__asm        jmp    _T165;
						// LINE 2157:
						_T160:
					}
				// LINE 2160:
				_T165:
					fp = fp->NextFace;
			}
		// LINE 2168:
		_T172:
			__asm        cmp    no_vert_faces, 0;
			__asm        jle    _T23a;
		// LINE 2171:
			__asm        mov    eax, vn;
			__asm        mov    eax, [eax];
			__asm        mov    [ebp-0x4C], eax;
			__asm        fild   dword ptr [ebp-0x4C];
			__asm        fdiv   qword ptr ds:[0x592460];
			__asm        mov    eax, no_vert_faces;
			__asm        mov    [ebp-0x50], eax;
			__asm        fidiv  dword ptr [ebp-0x50];
			__asm        fstp   tmpX;
		// LINE 2172:
			__asm        mov    eax, vn;
			__asm        mov    eax, [eax+4];
			__asm        mov    [ebp-0x54], eax;
			__asm        fild   dword ptr [ebp-0x54];
			__asm        fdiv   qword ptr ds:[0x592460];
			__asm        mov    eax, no_vert_faces;
			__asm        mov    [ebp-0x58], eax;
			__asm        fidiv  dword ptr [ebp-0x58];
			__asm        fstp   tmpY;
		// LINE 2173:
			__asm        mov    eax, vn;
			__asm        mov    eax, [eax+8];
			__asm        mov    [ebp-0x5C], eax;
			__asm        fild   dword ptr [ebp-0x5C];
			__asm        fdiv   qword ptr ds:[0x592460];
			__asm        mov    eax, no_vert_faces;
			__asm        mov    [ebp-0x60], eax;
			__asm        fidiv  dword ptr [ebp-0x60];
			__asm        fst    tmpZ;
		// LINE 2175:
			__asm        fmul   tmpZ;
			__asm        fld    tmpY;
			__asm        fmul   tmpY;
			__asm        faddp;
			__asm        fld    tmpX;
			__asm        fmul   tmpX;
			__asm        faddp;
			__asm        sub    esp, 8;
			__asm        fstp   qword ptr [esp];
			__asm        call   _sqrt;
			__asm        add    esp, 8;
			__asm        fst    length;
		// LINE 2176:
			__asm        fdivr  tmpX;
			__asm        fmul   qword ptr ds:[0x592460];
			__asm        call   __ftol;
			__asm        mov    ecx, vn;
			__asm        mov    [ecx], eax;
		// LINE 2177:
			__asm        fld    tmpY;
			__asm        fdiv   length;
			__asm        fmul   qword ptr ds:[0x592460];
			__asm        call   __ftol;
			__asm        mov    ecx, vn;
			__asm        mov    [ecx+4], eax;
		// LINE 2178:
			__asm        fld    tmpZ;
			__asm        fdiv   length;
			__asm        fmul   qword ptr ds:[0x592460];
			__asm        call   __ftol;
			__asm        mov    ecx, vn;
			__asm        mov    [ecx+8], eax;
		// LINE 2182:
		// Block end:
		_T23a:
	}
// LINE 2185:
_T23f:
	VRObjSetGouraudShade(obj, vnorms);
// LINE 2189:
	free(vnorms);
// LINE 2190:
	__asm        xor    eax, eax;
	__asm        mov    ecx, obj;
	__asm        mov    ecx, [ecx+4];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    G_alloc_curr, eax;
// LINE 2191:
	__asm        xor    eax, eax;
	__asm        mov    ecx, obj;
	__asm        mov    ecx, [ecx+4];
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        shl    ecx, 2;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    G_alloc_used, eax;
// LINE 2192:
}

// FUNCTION: COPTER_D 0x004d494c
void VRObjAssignLowRes(int32_t dest, int32_t src) {
	/*bp-0x4*/   /*packed*/ struct ObjectHdr *destptr;

// LINE 2204:
	destptr = dest;
// LINE 2206:
	destptr->MiscReg1 = src;
// LINE 2207:
	return;
// LINE 2208:
}

// FUNCTION: COPTER_D 0x004d496e
int32_t VRObjCreateRope(int32_t nverts, int32_t color, int32_t seglen) {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   int32_t * iptr;
	/*bp-0xc*/   /*packed*/ struct Point3d *vert;
	/*bp-0x10*/  /*packed*/ struct _FaceHdr *fh;
	/*bp-0x14*/  int32_t i;
	/*bp-0x18*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x1c*/  /*packed*/ struct MapVert *mvert;
	/*bp-0x20*/  char * dataptr;

// LINE 2238:
	__asm        mov    eax, nverts;
	__asm        mov    ecx, nverts;
	__asm        dec    ecx;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    eax, [ecx+eax*8-8];
	__asm        mov    ecx, nverts;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    eax, [eax+ecx*4];
	__asm        add    eax, 0xA0;
	__asm        mov    ObjDataSize, eax;
// LINE 2241:
	__asm        mov    eax, ObjDataSize;
	__asm        push   eax;
	__asm        mov    eax, MainPoolIndex;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    dataptr, eax;
	__asm        cmp    dataptr, 0;
	__asm        jne    _T5f;
// LINE 2244:
	GlobalError = 0x4;
// LINE 2245:
	return 0x0;
// LINE 2248:
_T5f:
	__asm        mov    eax, dataptr;
	__asm        push   eax;
	__asm        call   _InsertVR3dObj;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T84;
// LINE 2250:
	GlobalError = 0x9;
// LINE 2251:
	return 0x0;
// LINE 2254:
_T84:
	memset(dataptr, 0x0, ObjDataSize);
// LINE 2256:
	ptr = dataptr;
// LINE 2259:
	oh = ptr;
// LINE 2260:
	ptr += 0x90;
// LINE 2261:
	oh->Attrib = 0x0;
// LINE 2262:
	oh->NVerts = nverts;
// LINE 2263:
	oh->NFaces = (nverts - 1);
// LINE 2264:
	oh->ID = 0x0;
// LINE 2265:
	oh->Radius = ((seglen * nverts) >> 0x1);
// LINE 2266:
	oh->VertsPtr = ptr;
// LINE 2267:
	oh->MiscReg1 = 0x0;
// LINE 2270:
	vert = ptr;
// LINE 2271:
	__asm        mov    eax, nverts;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    ptr, eax;
// LINE 2272:
_FOR_112:
	for (i = 0x0; (nverts > i); i++) {
		// LINE 2274:
			vert->z = 0x0;
			vert->x = vert->z;
		// LINE 2275:
			vert->y = -(seglen * i);
		// LINE 2276:
			vert += 0xc;
	}
// LINE 2281:
_T14e:
	mvert = ptr;
// LINE 2282:
	ptr += 0x10;
// LINE 2285:
	oh->FacePtr = ptr;
// LINE 2286:
	fh = ptr;
// LINE 2287:
	ptr += 0x30;
// LINE 2288:
_FOR_177:
	for (i = 0x0; ((nverts - 1) > i); i++) {
		// LINE 2291:
			iptr = ptr;
		// LINE 2292:
			ptr += 0x8;
		// LINE 2295:
			fh->Nverts = 0x2;
		// LINE 2296:
			fh->Attrib1 = 0x8002;
		// LINE 2297:
			fh->Attrib2 = color;
		// LINE 2298:
			fh->Plotter = 0x14;
		// LINE 2299:
			fh->Bitmap = color;
		// LINE 2300:
			fh->MapVerts = mvert;
		// LINE 2301:
			fh->NextFace = ptr;
		// LINE 2302:
			fh->PlyVerts = iptr;
		// LINE 2305:
			iptr[0] = (i << 0x4);
			iptr += 0x4;
		// LINE 2306:
			iptr[0] = ((i + 1) << 0x4);
		// LINE 2309:
			fh = ptr;
		// LINE 2310:
			ptr += 0x30;
	}
// LINE 2313:
_T205:
	return dataptr;
// LINE 2314:
}

// FUNCTION: COPTER_D 0x004d4b80
int32_t VRObjCreatePoint(int32_t nverts, int32_t plotter) {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   int32_t * iptr;
	/*bp-0xc*/   /*packed*/ struct Point3d *vert;
	/*bp-0x10*/  /*packed*/ struct _FaceHdr *fh;
	/*bp-0x14*/  int32_t i;
	/*bp-0x18*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x1c*/  /*packed*/ struct MapVert *mvert;
	/*bp-0x20*/  char * dataptr;

// LINE 2343:
	__asm        mov    eax, nverts;
	__asm        mov    ecx, nverts;
	__asm        shl    ecx, 4;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    eax, [ecx+eax*4];
	__asm        mov    ecx, nverts;
	__asm        lea    ecx, [ecx+ecx*2];
	__asm        lea    eax, [eax+ecx*4];
	__asm        add    eax, 0x98;
	__asm        mov    ObjDataSize, eax;
// LINE 2346:
	__asm        mov    eax, ObjDataSize;
	__asm        push   eax;
	__asm        mov    eax, MainPoolIndex;
	__asm        push   eax;
	__asm        call   S2Alloc;
	__asm        add    esp, 8;
	__asm        mov    dataptr, eax;
	__asm        cmp    dataptr, 0;
	__asm        jne    _T5d;
// LINE 2349:
	GlobalError = 0x4;
// LINE 2350:
	return 0x0;
// LINE 2353:
_T5d:
	__asm        mov    eax, dataptr;
	__asm        push   eax;
	__asm        call   _InsertVR3dObj;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T82;
// LINE 2355:
	GlobalError = 0x9;
// LINE 2356:
	return 0x0;
// LINE 2359:
_T82:
	memset(dataptr, 0x0, ObjDataSize);
// LINE 2361:
	ptr = dataptr;
// LINE 2364:
	oh = ptr;
// LINE 2365:
	ptr += 0x90;
// LINE 2366:
	oh->Attrib = 0x0;
// LINE 2367:
	oh->NVerts = nverts;
// LINE 2368:
	oh->NFaces = nverts;
// LINE 2369:
	oh->ID = 0x0;
// LINE 2370:
	oh->Radius = 0x0;
// LINE 2371:
	oh->VertsPtr = ptr;
// LINE 2372:
	oh->MiscReg1 = 0x0;
// LINE 2375:
	vert = ptr;
// LINE 2376:
	__asm        mov    eax, nverts;
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    ptr, eax;
// LINE 2377:
_FOR_109:
	for (i = 0x0; (nverts > i); i++) {
		// LINE 2379:
			vert->z = 0x0;
			vert->x = vert->z;
			vert->y = vert->x;
		// LINE 2380:
			vert += 0xc;
	}
// LINE 2385:
_T141:
	mvert = ptr;
// LINE 2386:
	ptr += 0x8;
// LINE 2389:
	oh->FacePtr = ptr;
// LINE 2390:
	fh = ptr;
// LINE 2391:
	ptr += 0x30;
// LINE 2392:
_FOR_16a:
	for (i = 0x0; (nverts > i); i++) {
		// LINE 2395:
			iptr = ptr;
		// LINE 2396:
			ptr += 0x4;
		// LINE 2399:
			fh->Nverts = 0x1;
		// LINE 2400:
			fh->Attrib1 = 0x10002;
		// LINE 2401:
			fh->Attrib2 = i;
		// LINE 2402:
			fh->Plotter = plotter;
		// LINE 2403:
			fh->Bitmap = i;
		// LINE 2404:
			fh->MapVerts = mvert;
		// LINE 2405:
			fh->NextFace = ptr;
		// LINE 2406:
			fh->PlyVerts = iptr;
		// LINE 2409:
			iptr[0] = (i << 0x4);
		// LINE 2412:
			fh = ptr;
		// LINE 2413:
			ptr += 0x30;
	}
// LINE 2416:
_T1e6:
	return dataptr;
// LINE 2417:
}

// FUNCTION: COPTER_D 0x004d4d73
int32_t VRGetObjDupMemReq(int32_t obj) {
	/*bp-0x4*/   int32_t size1;
	/*bp-0x8*/   int32_t size2;
	/*bp-0xc*/   /*packed*/ struct ObjectHdr *oh;
	/*bp-0x10*/  int32_t size3;

// LINE 2434:
	oh = obj;
// LINE 2436:
	__asm        mov    eax, obj;
	__asm        push   eax;
	__asm        call   _VRGetObjInstanceMemReq;
	__asm        add    esp, 4;
	__asm        mov    size1, eax;
// LINE 2437:
	__asm        mov    eax, oh;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        mov    size2, eax;
// LINE 2438:
	size3 = (oh->PolyVerts << 0x2);
// LINE 2440:
	return ((size3 + size2) + size1);
// LINE 2441:
}

// FUNCTION: COPTER_D 0x004d4dbf
int32_t VRCreateObjDuplicate(int32_t obj, char * mem) {
	/*bp-0x4*/   char * to;
	/*bp-0x8*/   /*packed*/ struct _FaceHdr *fh;
	/*bp-0xc*/   int32_t i;
	/*bp-0x10*/  /*packed*/ struct _FaceHdr *fh2;
	/*bp-0x14*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x18*/  /*packed*/ struct ObjectHdr *oh2;

// LINE 2452:
	oh = obj;
// LINE 2458:
	to = mem;
// LINE 2459:
	oh2 = to;
// LINE 2461:
	__asm        mov    eax, to;
	__asm        push   eax;
	__asm        call   _InsertVR3dObj;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    _T40;
// LINE 2463:
	GlobalError = 0x9;
// LINE 2464:
	return 0x0;
// LINE 2468:
_T40:
	memcpy(to, oh, 0x90);
// LINE 2469:
	to += 0x90;
// LINE 2471:
	oh2->VertsPtr = to;
// LINE 2474:
	__asm        mov    eax, oh;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, oh;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, to;
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
// LINE 2475:
	__asm        mov    eax, oh;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [eax+eax*2];
	__asm        shl    eax, 2;
	__asm        add    to, eax;
// LINE 2478:
	oh2->FacePtr = to;
// LINE 2481:
	fh = oh->FacePtr;
// LINE 2482:
_FOR_b2:
	for (i = 0x0; (oh->NFaces > i); i++) {
		// LINE 2485:
			memcpy(to, fh, 0x30);
		// LINE 2486:
			fh2 = to;
		// LINE 2487:
			to += 0x30;
		// LINE 2490:
			memcpy(to, fh->PlyVerts, (fh->Nverts << 0x2));
		// LINE 2491:
			fh2->PlyVerts = to;
		// LINE 2492:
			to += (fh->Nverts << 0x2);
		// LINE 2495:
			memcpy(to, fh->MapVerts, (fh->Nverts << 0x3));
		// LINE 2496:
			fh2->MapVerts = to;
		// LINE 2497:
			to += (fh->Nverts << 0x3);
		// LINE 2500:
			fh2->NextFace = to;
		// LINE 2503:
			fh = fh->NextFace;
	}
// LINE 2506:
_T159:
	return mem;
// LINE 2508:
}

// FUNCTION: COPTER_D 0x004d4f25
int32_t VRStObjPolyHit(/*packed*/ struct Point3d *sloc, /*packed*/ struct Point3d *svec, int32_t dist, /*packed*/ struct Point3d *tloc, int32_t tobj, /*packed*/ struct Point3d **nptrptr) {
	/*bp-0xc*/   /*packed*/ struct Point3d iloc; // 0xc bytes
	/*bp-0x10*/  int32_t dotp1;
	/*bp-0x14*/  int32_t dotp2;
	/*bp-0x18*/  int32_t dotp3;
	/*bp-0x1c*/  int32_t * vertno;
	/*bp-0x20*/  /*packed*/ struct _FaceHdr *fh;
	/*bp-0x24*/  int32_t minx;
	/*bp-0x28*/  int32_t i;
	/*bp-0x34*/  /*packed*/ struct Point3d loc; // 0xc bytes
	/*bp-0x38*/  int32_t miny;
	/*bp-0x3c*/  int32_t j;
	/*bp-0x40*/  /*packed*/ struct ObjectHdr *oh;
	/*bp-0x44*/  int32_t minz;
	/*bp-0x48*/  int32_t tval;
	/*bp-0x4c*/  int32_t maxx;
	/*bp-0x50*/  int32_t maxy;
	/*bp-0x54*/  int32_t maxz;
	/*bp-0x58*/  /*packed*/ struct Point3d *v0;

// LINE 2529:
	oh = tobj;
// LINE 2540:
	loc.x = (sloc->x - tloc->x);
// LINE 2541:
	loc.y = (sloc->y - tloc->y);
// LINE 2542:
	loc.z = (sloc->z - tloc->z);
// LINE 2546:
	fh = oh->FacePtr;
// LINE 2547:
_FOR_4f:
	i = 0x0;
	__asm        jmp    _FOR_COND_4f;
_FOR_NEXT_4f:
	i++;
	fh = fh->NextFace;
_FOR_COND_4f:
	__asm        mov    eax, oh;
	__asm        mov    ecx, i;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jle    _T387;
// LINE 2552:
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, svec;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, svec;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, svec;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    dotp1, ebx;
// LINE 2557:
	__asm        cmp    dotp1, 0xFFFFFAE2;
	__asm        jl     _Tcf;
// LINE 2558:
	__asm        jmp    _FOR_NEXT_4f;
// LINE 2562:
_Tcf:
	v0 = fh->Normal->p;
// LINE 2565:
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, v0;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, v0;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, v0;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    dotp2, ebx;
// LINE 2570:
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, loc.y;
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        mov    ebx, eax;
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, loc.z;
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        mov    eax, fh;
	__asm        mov    eax, [eax+0x2C];
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, loc.x;
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        add    ebx, eax;
	__asm        neg    ebx;
	__asm        mov    dotp3, ebx;
// LINE 2574:
	__asm        mov    eax, dotp1;
	__asm        push   eax;
	__asm        mov    eax, dotp3;
	__asm        add    eax, dotp2;
	__asm        push   eax;
	__asm        call   _FixedDiv;
	__asm        add    esp, 8;
	__asm        neg    eax;
	__asm        mov    tval, eax;
// LINE 2577:
	__asm        mov    eax, dist;
	__asm        add    eax, 0x50000;
	__asm        cmp    eax, tval;
	__asm        jge    _T1a7;
// LINE 2578:
	__asm        jmp    _FOR_NEXT_4f;
// LINE 2581:
_T1a7:
	__asm        mov    eax, svec;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, tval;
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        mov    ecx, loc.x;
	__asm        add    ecx, eax;
	__asm        mov    iloc.x, ecx;
// LINE 2582:
	__asm        mov    eax, svec;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, tval;
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        mov    ecx, loc.y;
	__asm        add    ecx, eax;
	__asm        mov    iloc.y, ecx;
// LINE 2583:
	__asm        mov    eax, svec;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, tval;
	__asm        push   eax;
	__asm        call   _FixedMul;
	__asm        add    esp, 8;
	__asm        mov    ecx, loc.z;
	__asm        add    ecx, eax;
	__asm        mov    iloc.z, ecx;
// LINE 2587:
	minz = 0x7ff80000;
	miny = minz;
	minx = miny;
// LINE 2588:
	maxz = 0x80080000;
	maxy = maxz;
	maxx = maxy;
// LINE 2593:
	vertno = fh->PlyVerts;
// LINE 2594:
_FOR_232:
	for (j = 0x0; (fh->Nverts > j); j++) {
		// LINE 2600:
			__asm        mov    eax, vertno;
			__asm        mov    eax, [eax];
			__asm        shr    eax, 4;
			__asm        lea    eax, [eax+eax*2];
			__asm        shl    eax, 2;
			__asm        mov    ecx, oh;
			__asm        add    eax, [ecx+8];
			__asm        mov    v0, eax;
		// LINE 2604:
			vertno += 0x4;
		// LINE 2607:
			__asm        mov    eax, v0;
			__asm        mov    ecx, minx;
			__asm        cmp    [eax], ecx;
			__asm        jge    _T275;

			minx = v0->x;
		// LINE 2608:
		_T275:
			__asm        mov    eax, v0;
			__asm        mov    ecx, miny;
			__asm        cmp    [eax+4], ecx;
			__asm        jge    _T28d;

			miny = v0->y;
		// LINE 2609:
		_T28d:
			__asm        mov    eax, v0;
			__asm        mov    ecx, minz;
			__asm        cmp    [eax+8], ecx;
			__asm        jge    _T2a5;

			minz = v0->z;
		// LINE 2610:
		_T2a5:
			__asm        mov    eax, v0;
			__asm        mov    ecx, maxx;
			__asm        cmp    [eax], ecx;
			__asm        jle    _T2bb;

			maxx = v0->x;
		// LINE 2611:
		_T2bb:
			__asm        mov    eax, v0;
			__asm        mov    ecx, maxy;
			__asm        cmp    [eax+4], ecx;
			__asm        jle    _T2d3;

			maxy = v0->y;
		// LINE 2612:
		_T2d3:
			__asm        mov    eax, v0;
			__asm        mov    ecx, maxz;
			__asm        cmp    [eax+8], ecx;
			__asm        jle    _T2eb;

			maxz = v0->z;
		// LINE 2613:
		_T2eb:
	}
// LINE 2617:
_T2f0:
	__asm        mov    eax, maxz;
	__asm        add    eax, 0x20000;
	__asm        cmp    iloc.z, eax;
	__asm        jg     _T312;

	__asm        mov    eax, minz;
	__asm        sub    eax, 0x20000;
	__asm        cmp    iloc.z, eax;
	__asm        jge    _T317;
// LINE 2618:
_T312:
	__asm        jmp    _FOR_NEXT_4f;
// LINE 2619:
_T317:
	__asm        mov    eax, maxy;
	__asm        add    eax, 0x20000;
	__asm        cmp    iloc.y, eax;
	__asm        jg     _T339;

	__asm        mov    eax, miny;
	__asm        sub    eax, 0x20000;
	__asm        cmp    iloc.y, eax;
	__asm        jge    _T33e;
// LINE 2620:
_T339:
	__asm        jmp    _FOR_NEXT_4f;
// LINE 2621:
_T33e:
	__asm        mov    eax, maxx;
	__asm        add    eax, 0x20000;
	__asm        cmp    iloc.x, eax;
	__asm        jg     _T360;

	__asm        mov    eax, minx;
	__asm        sub    eax, 0x20000;
	__asm        cmp    eax, iloc.x;
	__asm        jle    _T365;
// LINE 2622:
_T360:
	__asm        jmp    _FOR_NEXT_4f;
// LINE 2626:
_T365:
	__asm        cmp    nptrptr, 0;
	__asm        je     _T37a;
// LINE 2627:
	nptrptr-> = fh->Normal;
// LINE 2629:
_T37a:
	return tval;
// LINE 2631:
	__asm        jmp    _FOR_NEXT_4f;
// LINE 2635:
_T387:
	return 0xffffffff;
// LINE 2637:
}



// Contribution: 2:00003460-0000346f Module: 147, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00005218-0000521c Module: 147, 4 byte alignment, initialized_data, read, write, 


// Contribution: 3:0006fa5c-0006fa69 Module: 147, 4 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00606a5c
static int32_t ObjDataSize;

// GLOBAL: COPTER_D 0x00606a60
static char * ObjData;

// GLOBAL: COPTER_D 0x00606a64
static /*packed*/ struct _BSPtree *Tree;

// GLOBAL: COPTER_D 0x00606a68
static unsigned short BSPIndex;



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.

// WARNING: this global might actually belong to: C:\Copter\source\common\S2alloc.c
// GLOBAL: COPTER_D 0x0063a858
int32_t MainPoolIndex; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\common\S2alloc.c
// GLOBAL: COPTER_D 0x0063a854
int32_t ScratchPoolIndex; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\engine\Resource.c
// GLOBAL: COPTER_D 0x006666b0
/*packed*/ struct GEOM_Header GEOM_hdr; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\engine\Resource.c
// GLOBAL: COPTER_D 0x00666698
/*packed*/ struct GEOM_DirGroup *GEOM_GPdir; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\engine\Resource.c
// GLOBAL: COPTER_D 0x0066669c
/*packed*/ struct GEOM_DirId *GEOM_IDdir; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\engine\Resource.c
// GLOBAL: COPTER_D 0x006666a4
/*packed*/ struct CMAP_Header CMAP_hdr; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\engine\Resource.c
// GLOBAL: COPTER_D 0x00666690
/*packed*/ struct CMAP_Dir *CMAP_directory; // Contrib missing


// WARNING: this global might actually belong to: C:\Copter\source\engine\Resource.c
// GLOBAL: COPTER_D 0x006666c0
/*packed*/ struct _FaceHdr **FaceArray; // Contrib missing

