// Module: scxload.obj
// Source: C:\Copter\Source\Common\scxload.cpp
// autogenerated by simcopter_tool from PDB file

// Type: unsigned char *;

// Type: /*packed*/ class cLZAPFileBitStream (forward reference);
// VTABLE: COPTER_D 0x00592418
class cLZAPFileBitStream : public cGZXBitstream
{ // packed(0xc bytes) TI: 0x2d27
public:
	void cLZAPFileBitStream();
	void ~cLZAPFileBitStream();
	virtual int32_t OpenRead(char *); // vtable+0x1c
	virtual void Close(); // vtable+0x20
	virtual unsigned long Read(unsigned char *, unsigned long) /* override */;
	virtual unsigned long Write(unsigned char *, unsigned long) /* override */;
	virtual void Rewind() /* override */;
	virtual void RewindToMark() /* override */;
	virtual void Mark() /* override */;
	virtual long Size() /* override */;
	virtual void FreeAll() /* override */;
private:
	/*+0x4*/   /*packed*/ class PFile *m_file;
	/*+0x8*/   unsigned long m_mark;
};

// Type: void;

// Type: char *;

// Type: int32_t;

// Type: unsigned long;

// Type: long;

// Type: /*packed*/ class cGZXBitstream (forward reference);
// VTABLE: COPTER_D 0x005923f8
class cGZXBitstream{ // packed(0x4 bytes) TI: 0x2d06
public:
	virtual unsigned long Read(unsigned char *, unsigned long); // vtable+0x0
	virtual unsigned long Write(unsigned char *, unsigned long); // vtable+0x4
	virtual void Rewind(); // vtable+0x8
	virtual void RewindToMark(); // vtable+0xc
	virtual void Mark(); // vtable+0x10
	virtual long Size(); // vtable+0x14
	virtual void FreeAll(); // vtable+0x18
};

// Type: /*packed*/ struct SCXNeighborData (forward reference);
struct SCXNeighborData{ // packed(0x2e bytes) TI: 0x2d72
	/*+0x0*/   char name[32]; // 0x20 bytes
	/*+0x20*/  short nameIndex; // 0x2 bytes
	/*+0x22*/  unsigned long val;
	/*+0x26*/  unsigned long pop;
	/*+0x2a*/  unsigned long fame;
};

// Type: /*packed*/ class cLZAPFileBitStream;
// VTABLE: COPTER_D 0x00592418
class cLZAPFileBitStream : public cGZXBitstream
{ // packed(0xc bytes) TI: 0x2d27
public:
	void cLZAPFileBitStream();
	void ~cLZAPFileBitStream();
	virtual int32_t OpenRead(char *); // vtable+0x1c
	virtual void Close(); // vtable+0x20
	virtual unsigned long Read(unsigned char *, unsigned long) /* override */;
	virtual unsigned long Write(unsigned char *, unsigned long) /* override */;
	virtual void Rewind() /* override */;
	virtual void RewindToMark() /* override */;
	virtual void Mark() /* override */;
	virtual long Size() /* override */;
	virtual void FreeAll() /* override */;
private:
	/*+0x4*/   /*packed*/ class PFile *m_file;
	/*+0x8*/   unsigned long m_mark;
};

// Type: /*packed*/ struct ReadSCXFile::__unnamed;
struct ReadSCXFile::__unnamed{ // packed(0x9 bytes) TI: 0x2d29
	/*+0x0*/   unsigned char type; // 0x1 bytes
	/*+0x1*/   unsigned char owner; // 0x1 bytes
	/*+0x2*/   unsigned char stat0; // 0x1 bytes
	/*+0x3*/   short stat1; // 0x2 bytes
	/*+0x5*/   short stat2; // 0x2 bytes
	/*+0x7*/   short stat3; // 0x2 bytes
};

// Type: /*packed*/ class cGZXParamBitstream<t_alloc,t_free>;
class cGZXParamBitstream<t_alloc,t_free> : public cGZXBitstream
{ // packed(0x3c bytes) TI: 0x2d3d
protected:
	/*+0x4*/   unsigned long curPos;
	/*+0x8*/   unsigned long markPos;
	/*+0xc*/   short nodeNo; // 0x2 bytes
	/*+0xe*/   short markNode; // 0x2 bytes
	/*+0x10*/  short maxNode; // 0x2 bytes
	/*+0x12*/  unsigned long maxPos;
	using tNodeList = /*packed*/ class vector<tGZXBitstreamNode>;
protected:
	/*+0x16*/  /*packed*/ class vector<tGZXBitstreamNode> nodeList; // 0xc bytes
	/*+0x22*/  /*packed*/ struct t_alloc m_rawAllocate; // 0x1 bytes
	/*+0x23*/  /*packed*/ struct t_free m_rawFree; // 0x1 bytes
	class cGZXParamBitstream<t_alloc,t_free>::stream_iterator{ // packed(0xa bytes) TI: 0x2d64
	public:
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>*, short, unsigned long);
		void stream_iterator();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator=(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		int32_t operator==(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		unsigned char& operator*();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator++();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator operator++(int32_t);
	private:
		/*+0x0*/   /*packed*/ class cGZXParamBitstream<t_alloc,t_free> *m_stream;
		/*+0x4*/   /*packed*/ class CPropertyType<unsigned long> m_pos;
		/*+0x8*/   /*packed*/ class CPropertyType<short> m_node; // 0x2 bytes
	};
	class cGZXParamBitstream<t_alloc,t_free>::stream_iterator{ // packed(0xa bytes) TI: 0x2d64
	public:
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>*, short, unsigned long);
		void stream_iterator();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator=(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		int32_t operator==(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		unsigned char& operator*();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator++();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator operator++(int32_t);
	private:
		/*+0x0*/   /*packed*/ class cGZXParamBitstream<t_alloc,t_free> *m_stream;
		/*+0x4*/   /*packed*/ class CPropertyType<unsigned long> m_pos;
		/*+0x8*/   /*packed*/ class CPropertyType<short> m_node; // 0x2 bytes
	};
public:
	/*+0x24*/  /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator starting_iterator; // 0xa bytes
	/*+0x2e*/  /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator ending_iterator; // 0xa bytes
	/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& begin();
	/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& end();
	void cGZXParamBitstream<t_alloc,t_free>(/*packed*/ struct tGZXBitstreamNode*);
	void cGZXParamBitstream<t_alloc,t_free>(uint32_t);
	void ~cGZXParamBitstream<t_alloc,t_free>();
	virtual void FreeAll() /* override */;
	virtual unsigned long Read(unsigned char *, unsigned long) /* override */;
	virtual unsigned long Write(unsigned char *, unsigned long) /* override */;
	virtual void Rewind() /* override */;
	virtual void RewindToMark() /* override */;
	virtual void Mark() /* override */;
	virtual long Size() /* override */;
	/*+0x38*/  /*packed*/ class CPropertyType<long> PageSize;
};

// Type: /*packed*/ struct tSCXSaveFileHdr;
struct tSCXSaveFileHdr{ // packed(0x2c bytes) TI: 0x2d3f
	/*+0x0*/   char type[4];
	/*+0x4*/   char product[32]; // 0x20 bytes
	/*+0x24*/  long version;
	/*+0x28*/  long time;
};

// Type: /*packed*/ class vector<tGZXBitstreamNode> (forward reference);
class vector<tGZXBitstreamNode>{ // packed(0xc bytes) TI: 0x2da6
	using vector_allocator = /*packed*/ class allocator<tGZXBitstreamNode>;
	using value_type = /*packed*/ struct tGZXBitstreamNode;
	using pointer = /*packed*/ struct tGZXBitstreamNode*;
	using iterator = /*packed*/ struct tGZXBitstreamNode*;
	using const_iterator = const /*packed*/ struct tGZXBitstreamNode*;
	using reference = /*packed*/ struct tGZXBitstreamNode&;
	using const_reference = const /*packed*/ struct tGZXBitstreamNode&;
	using size_type = uint32_t;
	using difference_type = int32_t;
	using const_reverse_iterator = /*unpacked*/ class reverse_iterator<tGZXBitstreamNode const *,tGZXBitstreamNode,tGZXBitstreamNode const &,int>;
	using reverse_iterator = /*unpacked*/ class reverse_iterator<tGZXBitstreamNode *,tGZXBitstreamNode,tGZXBitstreamNode &,int>;
protected:
	static /*packed*/ class allocator<tGZXBitstreamNode> static_allocator;
	/*+0x0*/   /*packed*/ struct tGZXBitstreamNode *start;
	/*+0x4*/   /*packed*/ struct tGZXBitstreamNode *finish;
	/*+0x8*/   /*packed*/ struct tGZXBitstreamNode *end_of_storage;
	void insert_aux(/*packed*/ struct tGZXBitstreamNode*, const /*packed*/ struct tGZXBitstreamNode&);
public:
	const /*packed*/ struct tGZXBitstreamNode* begin();
	/*packed*/ struct tGZXBitstreamNode* begin();
	const /*packed*/ struct tGZXBitstreamNode* end();
	/*packed*/ struct tGZXBitstreamNode* end();
	/*unpacked*/ class reverse_iterator<tGZXBitstreamNode const *,tGZXBitstreamNode,tGZXBitstreamNode const &,int> rbegin();
	/*unpacked*/ class reverse_iterator<tGZXBitstreamNode *,tGZXBitstreamNode,tGZXBitstreamNode &,int> rbegin();
	/*unpacked*/ class reverse_iterator<tGZXBitstreamNode const *,tGZXBitstreamNode,tGZXBitstreamNode const &,int> rend();
	/*unpacked*/ class reverse_iterator<tGZXBitstreamNode *,tGZXBitstreamNode,tGZXBitstreamNode &,int> rend();
	uint32_t size();
	uint32_t max_size();
	uint32_t capacity();
	int32_t empty();
	const /*packed*/ struct tGZXBitstreamNode& operator[](uint32_t);
	/*packed*/ struct tGZXBitstreamNode& operator[](uint32_t);
	void vector<tGZXBitstreamNode>(const /*packed*/ struct tGZXBitstreamNode*, const /*packed*/ struct tGZXBitstreamNode*);
	void vector<tGZXBitstreamNode>(const /*packed*/ class vector<tGZXBitstreamNode>&);
	void vector<tGZXBitstreamNode>(uint32_t, const /*packed*/ struct tGZXBitstreamNode&);
	void vector<tGZXBitstreamNode>();
	void ~vector<tGZXBitstreamNode>();
	/*packed*/ class vector<tGZXBitstreamNode>& operator=(const /*packed*/ class vector<tGZXBitstreamNode>&);
	void reserve(uint32_t);
	const /*packed*/ struct tGZXBitstreamNode& front();
	/*packed*/ struct tGZXBitstreamNode& front();
	const /*packed*/ struct tGZXBitstreamNode& back();
	/*packed*/ struct tGZXBitstreamNode& back();
	void push_back(const /*packed*/ struct tGZXBitstreamNode&);
	void swap(/*packed*/ class vector<tGZXBitstreamNode>&);
	void insert(/*packed*/ struct tGZXBitstreamNode*, uint32_t, const /*packed*/ struct tGZXBitstreamNode&);
	void insert(/*packed*/ struct tGZXBitstreamNode*, const /*packed*/ struct tGZXBitstreamNode*, const /*packed*/ struct tGZXBitstreamNode*);
	/*packed*/ struct tGZXBitstreamNode* insert(/*packed*/ struct tGZXBitstreamNode*, const /*packed*/ struct tGZXBitstreamNode&);
	void pop_back();
	void erase(/*packed*/ struct tGZXBitstreamNode*, /*packed*/ struct tGZXBitstreamNode*);
	void erase(/*packed*/ struct tGZXBitstreamNode*);
};

// Type: /*packed*/ class cGZXParamBitstream<t_alloc,t_free> (forward reference);
class cGZXParamBitstream<t_alloc,t_free> : public cGZXBitstream
{ // packed(0x3c bytes) TI: 0x2d3d
protected:
	/*+0x4*/   unsigned long curPos;
	/*+0x8*/   unsigned long markPos;
	/*+0xc*/   short nodeNo; // 0x2 bytes
	/*+0xe*/   short markNode; // 0x2 bytes
	/*+0x10*/  short maxNode; // 0x2 bytes
	/*+0x12*/  unsigned long maxPos;
	using tNodeList = /*packed*/ class vector<tGZXBitstreamNode>;
protected:
	/*+0x16*/  /*packed*/ class vector<tGZXBitstreamNode> nodeList; // 0xc bytes
	/*+0x22*/  /*packed*/ struct t_alloc m_rawAllocate; // 0x1 bytes
	/*+0x23*/  /*packed*/ struct t_free m_rawFree; // 0x1 bytes
	class cGZXParamBitstream<t_alloc,t_free>::stream_iterator{ // packed(0xa bytes) TI: 0x2d64
	public:
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>*, short, unsigned long);
		void stream_iterator();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator=(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		int32_t operator==(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		unsigned char& operator*();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator++();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator operator++(int32_t);
	private:
		/*+0x0*/   /*packed*/ class cGZXParamBitstream<t_alloc,t_free> *m_stream;
		/*+0x4*/   /*packed*/ class CPropertyType<unsigned long> m_pos;
		/*+0x8*/   /*packed*/ class CPropertyType<short> m_node; // 0x2 bytes
	};
	class cGZXParamBitstream<t_alloc,t_free>::stream_iterator{ // packed(0xa bytes) TI: 0x2d64
	public:
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		void stream_iterator(/*packed*/ class cGZXParamBitstream<t_alloc,t_free>*, short, unsigned long);
		void stream_iterator();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator=(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		int32_t operator==(const /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator&);
		unsigned char& operator*();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& operator++();
		/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator operator++(int32_t);
	private:
		/*+0x0*/   /*packed*/ class cGZXParamBitstream<t_alloc,t_free> *m_stream;
		/*+0x4*/   /*packed*/ class CPropertyType<unsigned long> m_pos;
		/*+0x8*/   /*packed*/ class CPropertyType<short> m_node; // 0x2 bytes
	};
public:
	/*+0x24*/  /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator starting_iterator; // 0xa bytes
	/*+0x2e*/  /*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator ending_iterator; // 0xa bytes
	/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& begin();
	/*packed*/ class cGZXParamBitstream<t_alloc,t_free>::stream_iterator& end();
	void cGZXParamBitstream<t_alloc,t_free>(/*packed*/ struct tGZXBitstreamNode*);
	void cGZXParamBitstream<t_alloc,t_free>(uint32_t);
	void ~cGZXParamBitstream<t_alloc,t_free>();
	virtual void FreeAll() /* override */;
	virtual unsigned long Read(unsigned char *, unsigned long) /* override */;
	virtual unsigned long Write(unsigned char *, unsigned long) /* override */;
	virtual void Rewind() /* override */;
	virtual void RewindToMark() /* override */;
	virtual void Mark() /* override */;
	virtual long Size() /* override */;
	/*+0x38*/  /*packed*/ class CPropertyType<long> PageSize;
};

// Type: uint32_t;

// Type: /*packed*/ struct tGZXBitstreamNode (forward reference);
struct tGZXBitstreamNode{ // packed(0x8 bytes) TI: 0x2d18
	/*+0x0*/   unsigned char * data;
	/*+0x4*/   unsigned long size;
	void tGZXBitstreamNode(unsigned char *, unsigned long);
};

// Type: /*packed*/ class cGZXBitstream;
// VTABLE: COPTER_D 0x005923f8
class cGZXBitstream{ // packed(0x4 bytes) TI: 0x2d06
public:
	virtual unsigned long Read(unsigned char *, unsigned long); // vtable+0x0
	virtual unsigned long Write(unsigned char *, unsigned long); // vtable+0x4
	virtual void Rewind(); // vtable+0x8
	virtual void RewindToMark(); // vtable+0xc
	virtual void Mark(); // vtable+0x10
	virtual long Size(); // vtable+0x14
	virtual void FreeAll(); // vtable+0x18
};



// Contribution: 1:000ca880-000cc535 Module: 89, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004cb880
void cLZAPFileBitStream::cLZAPFileBitStream() {

	this-><cLZAPFileBitStream+0x00> = 0x5923f8;
	__asm        jmp    _T1a;
_T1a:
	this-><cLZAPFileBitStream+0x00> = 0x592418;
// LINE 86:
	this->m_file = 0x0;
// LINE 87:
	this->m_mark = 0x0;
// LINE 88:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004cb8c4
void cLZAPFileBitStream::~cLZAPFileBitStream() {

	this-><cLZAPFileBitStream+0x00> = 0x592418;
// LINE 91:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T3f;

	__asm        push   1;
	__asm        mov    eax, [ebp-4];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-4];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T3f;
// LINE 92:
_T3f:
	return;
}

// FUNCTION: COPTER_D 0x004cb90d
int32_t cLZAPFileBitStream::OpenRead(char * filePath) {
// LINE 96:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T36;

	__asm        push   1;
	__asm        mov    eax, [ebp-4];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-4];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T36;
// LINE 97:
_T36:
	__asm        push   0x110;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T97;

	__asm        mov    eax, [ebp-0xC];
	__asm        mov    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    dword ptr [eax+0x10C], 0;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    dword ptr [eax], 0x590468;
	__asm        mov    _fmode, 0x8000;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    byte ptr [eax+4], 0;
	__asm        jmp    _T89;
_T89:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _Ta1;
_T97:
	this->m_file = 0x0;
// LINE 98:
_Ta1:
	return this->m_file->PFile::Open(filePath, 0x0, 0x180, 0x0);
// LINE 99:
}

// FUNCTION: COPTER_D 0x004cb9d2
void cLZAPFileBitStream::Close() {
// LINE 103:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T36;

	__asm        push   1;
	__asm        mov    eax, [ebp-4];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-4];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T36;
// LINE 104:
_T36:
	this->m_file = 0x0;
// LINE 105:
	return;
}

// FUNCTION: COPTER_D 0x004cba1c
unsigned long cLZAPFileBitStream::Read(unsigned char * buffer, unsigned long nBytes) {
// LINE 109:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T72;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T31;

	__asm        jmp    _T36;
_T31:
	__asm        jmp    _T72;
_T36:
	__asm        jmp    _T45;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T72;
// LINE 110:
_T45:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T53;
_T53:
	__asm        mov    eax, nBytes;
	__asm        push   eax;
	__asm        mov    eax, buffer;
	__asm        push   eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        jmp    __RETURN;
// LINE 111:
_T72:
	return 0x0;
// LINE 112:
__RETURN:
}

// FUNCTION: COPTER_D 0x004cba9c
unsigned long cLZAPFileBitStream::Write(unsigned char * buffer, unsigned long nBytes) {
// LINE 116:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T72;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T31;

	__asm        jmp    _T36;
_T31:
	__asm        jmp    _T72;
_T36:
	__asm        jmp    _T45;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T72;
// LINE 117:
_T45:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T53;
_T53:
	__asm        mov    eax, nBytes;
	__asm        push   eax;
	__asm        mov    eax, buffer;
	__asm        push   eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _write;
	__asm        add    esp, 0xC;
	__asm        jmp    __RETURN;
// LINE 118:
_T72:
	return 0x0;
// LINE 119:
__RETURN:
}

// FUNCTION: COPTER_D 0x004cbb1c
void cLZAPFileBitStream::Rewind() {
// LINE 123:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T3d;
// LINE 124:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-4], eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, [ebp-4];
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _T3d;
// LINE 125:
_T3d:
	return;
}

// FUNCTION: COPTER_D 0x004cbb63
void cLZAPFileBitStream::RewindToMark() {
// LINE 129:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T48;
// LINE 130:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-4], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        push   0;
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _T48;
// LINE 131:
_T48:
	return;
}

// FUNCTION: COPTER_D 0x004cbbb5
void cLZAPFileBitStream::Mark() {
// LINE 134:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T44;
// LINE 135:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-4], eax;
	__asm        jmp    _T27;
_T27:
	__asm        mov    eax, [ebp-4];
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _tell;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
// LINE 136:
	__asm        jmp    _T4e;
// LINE 137:
_T44:
	this->m_mark = 0x0;
// LINE 138:
_T4e:
	return;
}

// FUNCTION: COPTER_D 0x004cbc0d
long cLZAPFileBitStream::Size() {
// LINE 141:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T29;
// LINE 142:
	return this->m_file->PFile::Length();
// LINE 143:
_T29:
	return 0x0;
// LINE 144:
}

// FUNCTION: COPTER_D 0x004cbc42
void cLZAPFileBitStream::FreeAll() {

	return;
}

// FUNCTION: COPTER_D 0x004cbc58
void SCXReadBudget(/*packed*/ class cGZXBitstream *AStream, unsigned char * data) {
// LINE 170:
	__asm        push   0x71A;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 172:
	return;
}

// FUNCTION: COPTER_D 0x004cbc7b
void SCXReadGraphData(/*packed*/ class cGZXBitstream *AStream, unsigned char * data) {
// LINE 185:
	__asm        push   0xD40;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 186:
	return;
}

// FUNCTION: COPTER_D 0x004cbc9e
void SCXReadPlayer(/*packed*/ class cGZXBitstream *AStream, unsigned char * data) {
// LINE 197:
	SCXReadBudget(AStream, scxbuf);
// LINE 198:
	__asm        push   0x108;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 199:
	__asm        push   0x20;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 200:
	__asm        push   0x44;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 201:
	__asm        push   4;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 202:
	__asm        push   0xC8;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 203:
	__asm        push   0x10;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 204:
	SCXReadGraphData(AStream, scxbuf);
// LINE 205:
	return;
}

// FUNCTION: COPTER_D 0x004cbd38
void SCXReadNeighbors(/*packed*/ class cGZXBitstream *AStream, unsigned char * data) {
	/*bp-0x4*/   /*packed*/ struct SCXNeighborData *pData;
	/*bp-0x8*/   long loop;
	/*bp-0xc*/   long num;

// LINE 225:
	pData = data;
// LINE 227:
	__asm        push   4;
	__asm        lea    eax, num;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 230:
_FOR_2b:
	for (loop = 0x0; (loop < num); loop++) {
		// LINE 231:
			__asm        push   0x20;
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        add    eax, pData;
			__asm        push   eax;
			__asm        mov    eax, AStream;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, AStream;
			__asm        call   dword ptr [eax];
			__asm        jmp    _FOR_NEXT_2b;
	}
// LINE 232:
_FOR_68:
	for (loop = 0x0; (loop < num); loop++) {
		// LINE 233:
			__asm        push   2;
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        add    eax, pData;
			__asm        add    eax, 0x20;
			__asm        push   eax;
			__asm        mov    eax, AStream;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, AStream;
			__asm        call   dword ptr [eax];
			__asm        jmp    _FOR_NEXT_68;
	}
// LINE 234:
_FOR_a8:
	for (loop = 0x0; (loop < num); loop++) {
		// LINE 235:
			__asm        push   4;
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        add    eax, pData;
			__asm        add    eax, 0x22;
			__asm        push   eax;
			__asm        mov    eax, AStream;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, AStream;
			__asm        call   dword ptr [eax];
			__asm        jmp    _FOR_NEXT_a8;
	}
// LINE 236:
_FOR_e8:
	for (loop = 0x0; (loop < num); loop++) {
		// LINE 237:
			__asm        push   4;
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        add    eax, pData;
			__asm        add    eax, 0x26;
			__asm        push   eax;
			__asm        mov    eax, AStream;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, AStream;
			__asm        call   dword ptr [eax];
			__asm        jmp    _FOR_NEXT_e8;
	}
// LINE 238:
_FOR_128:
	for (loop = 0x0; (loop < num); loop++) {
		// LINE 239:
			__asm        push   4;
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        add    eax, pData;
			__asm        add    eax, 0x2A;
			__asm        push   eax;
			__asm        mov    eax, AStream;
			__asm        mov    eax, [eax];
			__asm        mov    ecx, AStream;
			__asm        call   dword ptr [eax];
			__asm        jmp    _FOR_NEXT_128;
	}
// LINE 242:
_FOR_168:
	for (loop = 0x0; (loop < 0x4); loop++) {
		// LINE 244:
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        mov    ecx, pData;
			__asm        mov    ax, [eax+ecx+0x20];
			__asm        mov    ecx, loop;
			__asm        mov    edx, NeighborName;
			__asm        mov    [edx+ecx*2], ax;
		// LINE 245:
			__asm        mov    eax, loop;
			__asm        mov    ecx, NeighborName;
			__asm        movsx  eax, word ptr [ecx+eax*2];
			__asm        test   eax, eax;
			__asm        jne    _T1d8;
		// LINE 246:
			strcpy((((loop << 0x5) + 0x639250) + 1), 0x59c168);
		// LINE 247:
			__asm        mov    eax, loop;
			__asm        shl    eax, 5;
			__asm        mov    Neighbor[0][eax], 5;
		// LINE 249:
			__asm        jmp    _T221;
		// LINE 250:
		_T1d8:
			__asm        mov    eax, loop;
			__asm        mov    ecx, NeighborName;
			__asm        mov    ax, [ecx+eax*2];
			__asm        push   eax;
			__asm        push   0x3E8;
			__asm        mov    eax, loop;
			__asm        shl    eax, 5;
			__asm        add    eax, 0x639250;
			__asm        inc    eax;
			__asm        push   eax;
			__asm        call   GetStringResource;
			__asm        add    esp, 0xC;
		// LINE 251:
			__asm        mov    eax, loop;
			__asm        shl    eax, 5;
			__asm        add    eax, 0x639250;
			__asm        inc    eax;
			__asm        push   eax;
			__asm        call   strlen;
			__asm        add    esp, 4;
			__asm        mov    ecx, loop;
			__asm        shl    ecx, 5;
			__asm        mov    Neighbor[0][ecx], al;
		// LINE 254:
		_T221:
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        mov    ecx, pData;
			__asm        mov    eax, [eax+ecx+0x26];
			__asm        mov    ecx, loop;
			__asm        mov    edx, NeighborPop;
			__asm        mov    [edx+ecx*4], eax;
		// LINE 255:
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        mov    ecx, pData;
			__asm        mov    eax, [eax+ecx+0x22];
			__asm        mov    ecx, loop;
			__asm        mov    edx, NeighborValue;
			__asm        mov    [edx+ecx*4], eax;
		// LINE 256:
			__asm        mov    eax, loop;
			__asm        mov    ecx, eax;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*8];
			__asm        add    eax, ecx;
			__asm        mov    ecx, pData;
			__asm        mov    eax, [eax+ecx+0x2A];
			__asm        mov    ecx, loop;
			__asm        mov    edx, NeighborFame;
			__asm        mov    [edx+ecx*4], eax;
	}
// LINE 258:
_T286:
	return;
}

// FUNCTION: COPTER_D 0x004cbfc8
void SCXReadContracts(/*packed*/ class cGZXBitstream *AStream, unsigned char * data) {
	/*bp-0x4*/   long num;

// LINE 282:
	__asm        push   4;
	__asm        lea    eax, num;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 283:
	__asm        mov    eax, num;
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        push   eax;
	__asm        mov    eax, data;
	__asm        push   eax;
	__asm        mov    eax, AStream;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, AStream;
	__asm        call   dword ptr [eax];
// LINE 284:
	return;
}

// FUNCTION: COPTER_D 0x004cc003
int32_t ReadSCXFile(char * filePath) {
	/*bp-0x2c*/  /*packed*/ struct tSCXSaveFileHdr header; // 0x2c bytes
	/*bp-0x68*/  /*packed*/ class cGZXParamBitstream<t_alloc,t_free> memstrm; // 0x3c bytes
	/*bp-0x6c*/  long loop;
	/*bp-0x134*/ long longBonds[50]; // 0xc8 bytes
	/*bp-0x138*/ long tempLong;
	/*bp-0x144*/ /*packed*/ struct ReadSCXFile::__unnamed SCXMicroRecord; // 0x9 bytes
	/*bp-0x150*/ /*packed*/ class cLZAPFileBitStream fileStream; // 0xc bytes
	/*bp-0x550*/ long scxTileCount[256]; // 0x400 bytes
	/*bp-0x57c*/ long scxInd[11]; // 0x2c bytes

// LINE 296:
	S2CityFree();
// LINE 297:
	S2CityAlloc();
// LINE 299:
	scxbuf = operator new(0xffff);
// LINE 301:
	fileStream<cLZAPFileBitStream+0x00>->cLZAPFileBitStream::cLZAPFileBitStream();
// LINE 302:
	__asm        mov    eax, filePath;
	__asm        push   eax;
	__asm        lea    ecx, fileStream<cLZAPFileBitStream+0x00>;
	__asm        call   cLZAPFileBitStream::OpenRead;
	__asm        test   eax, eax;
	__asm        jne    _T6a;
// LINE 303:
	__asm        mov    dword ptr [ebp-0x580], 0;
	__asm        lea    ecx, fileStream<cLZAPFileBitStream+0x00>;
	__asm        call   cLZAPFileBitStream::~cLZAPFileBitStream;
	__asm        mov    eax, [ebp-0x580];
	__asm        jmp    __RETURN;
// LINE 306:
_T6a:
	fileStream<cLZAPFileBitStream+0x00>->cLZAPFileBitStream::Read(header.type[0], 0x2c);
// LINE 308:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::cGZXParamBitstream<t_alloc,t_free>(0xffff);
// LINE 309:
	__asm        lea    eax, memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>;
	__asm        push   eax;
	__asm        lea    eax, fileStream<cLZAPFileBitStream+0x00>;
	__asm        push   eax;
	__asm        call   LZAExpand;
	__asm        add    esp, 8;
	__asm        movsx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _Te2;
// LINE 310:
	__asm        mov    dword ptr [ebp-0x584], 0;
	__asm        mov    memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>, 0x592440;
	__asm        lea    ecx, memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>;
	__asm        call   cGZXParamBitstream<t_alloc,t_free>::FreeAll;
	__asm        jmp    _Tc4;
_Tc4:
	__asm        lea    ecx, memstrm.nodeList.start;
	__asm        call   vector<tGZXBitstreamNode>::~vector<tGZXBitstreamNode>;
	__asm        lea    ecx, fileStream<cLZAPFileBitStream+0x00>;
	__asm        call   cLZAPFileBitStream::~cLZAPFileBitStream;
	__asm        mov    eax, [ebp-0x584];
	__asm        jmp    __RETURN;
// LINE 314:
_Te2:
	memstrm.curPos = 0x0;
	memstrm.nodeNo = 0x0;
	__asm        jmp    _Tf4;
// LINE 317:
_Tf4:
	__asm        mov    dword ptr [ebp-0x594], 0;
__WHILE_fe:
	__asm        cmp    dword ptr [ebp-0x594], 4;
	__asm        jae    _T1a9;

	__asm        jmp    _T110;
_T110:
	__asm        jmp    _T115;
_T115:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T12b;

	__asm        jmp    _FOR_1ba;
_T12b:
	__asm        jmp    _T130;
_T130:
	__asm        jmp    _T135;
_T135:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T174;

	memstrm.nodeNo++;
	__asm        jmp    _T152;
_T152:
	__asm        jmp    _T157;
_T157:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T16d;

	__asm        jmp    _FOR_1ba;
_T16d:
	memstrm.curPos = 0x0;
_T174:
	__asm        jmp    _T179;
_T179:
	__asm        jmp    _T17e;
_T17e:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x594];
	__asm        mov    [ebp+ecx-0x138], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x594];
	__asm        jmp    __WHILE_fe;
_T17e:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x594];
	__asm        mov    [ebp+ecx-0x138], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x594];
	__asm        jmp    __WHILE_fe;
_T1a9:
	__asm        jmp    _FOR_1ba;
// LINE 318:
_FOR_1ba:
	for (loop = 0x0; (loop < tempLong); loop++) {
		// LINE 319:
			SCXReadPlayer(memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>, scxbuf);
	}
// LINE 322:
_T1e3:
	SCXReadBudget(memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>, budgetList);
// LINE 325:
	SCXReadNeighbors(memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>, scxbuf);
// LINE 328:
	__asm        mov    eax, scxbuf;
	__asm        push   eax;
	__asm        lea    eax, memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>;
	__asm        push   eax;
	__asm        call   SCXReadContracts;
	__asm        add    esp, 8;
	__asm        mov    eax, CityNameString;
	__asm        mov    [ebp-0x59C], eax;
// LINE 331:
	__asm        mov    dword ptr [ebp-0x598], 0;
__WHILE_22e:
	__asm        cmp    dword ptr [ebp-0x598], 0x20;
	__asm        jae    _T2db;

	__asm        jmp    _T240;
_T240:
	__asm        jmp    _T245;
_T245:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T25b;

	__asm        jmp    _T2e0;
_T25b:
	__asm        jmp    _T260;
_T260:
	__asm        jmp    _T265;
_T265:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T2a4;

	memstrm.nodeNo++;
	__asm        jmp    _T282;
_T282:
	__asm        jmp    _T287;
_T287:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T29d;

	__asm        jmp    _T2e0;
_T29d:
	memstrm.curPos = 0x0;
_T2a4:
	__asm        jmp    _T2a9;
_T2a9:
	__asm        jmp    _T2ae;
_T2ae:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x598];
	__asm        mov    edx, [ebp-0x59C];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x598];
	__asm        jmp    __WHILE_22e;
_T2ae:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x598];
	__asm        mov    edx, [ebp-0x59C];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x598];
	__asm        jmp    __WHILE_22e;
_T2db:
	__asm        jmp    _T2e0;
// LINE 334:
_T2e0:
	__asm        mov    dword ptr [ebp-0x5A0], 0;
__WHILE_2ea:
	__asm        cmp    dword ptr [ebp-0x5A0], 4;
	__asm        jae    _T395;

	__asm        jmp    _T2fc;
_T2fc:
	__asm        jmp    _T301;
_T301:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T317;

	__asm        jmp    _T39a;
_T317:
	__asm        jmp    _T31c;
_T31c:
	__asm        jmp    _T321;
_T321:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T360;

	memstrm.nodeNo++;
	__asm        jmp    _T33e;
_T33e:
	__asm        jmp    _T343;
_T343:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T359;

	__asm        jmp    _T39a;
_T359:
	memstrm.curPos = 0x0;
_T360:
	__asm        jmp    _T365;
_T365:
	__asm        jmp    _T36a;
_T36a:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5A0];
	__asm        mov    [ebp+ecx-0x138], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5A0];
	__asm        jmp    __WHILE_2ea;
_T36a:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5A0];
	__asm        mov    [ebp+ecx-0x138], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5A0];
	__asm        jmp    __WHILE_2ea;
_T395:
	__asm        jmp    _T39a;
// LINE 337:
_T39a:
	__asm        mov    dword ptr [ebp-0x5A4], 0;
__WHILE_3a4:
	__asm        cmp    dword ptr [ebp-0x5A4], 0x10;
	__asm        jae    _T44e;

	__asm        jmp    _T3b6;
_T3b6:
	__asm        jmp    _T3bb;
_T3bb:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T3d1;

	__asm        jmp    _T453;
_T3d1:
	__asm        jmp    _T3d6;
_T3d6:
	__asm        jmp    _T3db;
_T3db:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T41a;

	memstrm.nodeNo++;
	__asm        jmp    _T3f8;
_T3f8:
	__asm        jmp    _T3fd;
_T3fd:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T413;

	__asm        jmp    _T453;
_T413:
	memstrm.curPos = 0x0;
_T41a:
	__asm        jmp    _T41f;
_T41f:
	__asm        jmp    _T424;
_T424:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5A4];
	__asm        mov    reinterpret_cast<uint8_t>(Valve[0])[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5A4];
	__asm        jmp    __WHILE_3a4;
_T424:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5A4];
	__asm        mov    reinterpret_cast<uint8_t>(Valve[0])[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5A4];
	__asm        jmp    __WHILE_3a4;
_T44e:
	__asm        jmp    _T453;
// LINE 340:
_T453:
	__asm        mov    dword ptr [ebp-0x5A8], 0;
__WHILE_45d:
	__asm        cmp    dword ptr [ebp-0x5A8], 0x22;
	__asm        jae    _T507;

	__asm        jmp    _T46f;
_T46f:
	__asm        jmp    _T474;
_T474:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T48a;

	__asm        jmp    _T50c;
_T48a:
	__asm        jmp    _T48f;
_T48f:
	__asm        jmp    _T494;
_T494:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T4d3;

	memstrm.nodeNo++;
	__asm        jmp    _T4b1;
_T4b1:
	__asm        jmp    _T4b6;
_T4b6:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T4cc;

	__asm        jmp    _T50c;
_T4cc:
	memstrm.curPos = 0x0;
_T4d3:
	__asm        jmp    _T4d8;
_T4d8:
	__asm        jmp    _T4dd;
_T4dd:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5A8];
	__asm        mov    reinterpret_cast<uint8_t>(Invent[0])[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5A8];
	__asm        jmp    __WHILE_45d;
_T4dd:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5A8];
	__asm        mov    reinterpret_cast<uint8_t>(Invent[0])[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5A8];
	__asm        jmp    __WHILE_45d;
_T507:
	__asm        jmp    _T50c;
// LINE 343:
_T50c:
	__asm        mov    dword ptr [ebp-0x5AC], 0;
__WHILE_516:
	__asm        cmp    dword ptr [ebp-0x5AC], 4;
	__asm        jae    _T5c0;

	__asm        jmp    _T528;
_T528:
	__asm        jmp    _T52d;
_T52d:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T543;

	__asm        jmp    _T5c5;
_T543:
	__asm        jmp    _T548;
_T548:
	__asm        jmp    _T54d;
_T54d:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T58c;

	memstrm.nodeNo++;
	__asm        jmp    _T56a;
_T56a:
	__asm        jmp    _T56f;
_T56f:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T585;

	__asm        jmp    _T5c5;
_T585:
	memstrm.curPos = 0x0;
_T58c:
	__asm        jmp    _T591;
_T591:
	__asm        jmp    _T596;
_T596:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5AC];
	__asm        mov    reinterpret_cast<uint8_t>(TotalFunds)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5AC];
	__asm        jmp    __WHILE_516;
_T596:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5AC];
	__asm        mov    reinterpret_cast<uint8_t>(TotalFunds)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5AC];
	__asm        jmp    __WHILE_516;
_T5c0:
	__asm        jmp    _T5c5;
// LINE 346:
_T5c5:
	__asm        mov    dword ptr [ebp-0x5B0], 0;
__WHILE_5cf:
	__asm        cmp    dword ptr [ebp-0x5B0], 4;
	__asm        jae    _T679;

	__asm        jmp    _T5e1;
_T5e1:
	__asm        jmp    _T5e6;
_T5e6:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T5fc;

	__asm        jmp    _T67e;
_T5fc:
	__asm        jmp    _T601;
_T601:
	__asm        jmp    _T606;
_T606:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T645;

	memstrm.nodeNo++;
	__asm        jmp    _T623;
_T623:
	__asm        jmp    _T628;
_T628:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T63e;

	__asm        jmp    _T67e;
_T63e:
	memstrm.curPos = 0x0;
_T645:
	__asm        jmp    _T64a;
_T64a:
	__asm        jmp    _T64f;
_T64f:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5B0];
	__asm        mov    reinterpret_cast<uint8_t>(TotalBonds)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5B0];
	__asm        jmp    __WHILE_5cf;
_T64f:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5B0];
	__asm        mov    reinterpret_cast<uint8_t>(TotalBonds)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5B0];
	__asm        jmp    __WHILE_5cf;
_T679:
	__asm        jmp    _T67e;
// LINE 349:
_T67e:
	__asm        mov    dword ptr [ebp-0x5B4], 0;
__WHILE_688:
	__asm        cmp    dword ptr [ebp-0x5B4], 4;
	__asm        jae    _T732;

	__asm        jmp    _T69a;
_T69a:
	__asm        jmp    _T69f;
_T69f:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T6b5;

	__asm        jmp    _T737;
_T6b5:
	__asm        jmp    _T6ba;
_T6ba:
	__asm        jmp    _T6bf;
_T6bf:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T6fe;

	memstrm.nodeNo++;
	__asm        jmp    _T6dc;
_T6dc:
	__asm        jmp    _T6e1;
_T6e1:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T6f7;

	__asm        jmp    _T737;
_T6f7:
	memstrm.curPos = 0x0;
_T6fe:
	__asm        jmp    _T703;
_T703:
	__asm        jmp    _T708;
_T708:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5B4];
	__asm        mov    reinterpret_cast<uint8_t>(TotalPop)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5B4];
	__asm        jmp    __WHILE_688;
_T708:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5B4];
	__asm        mov    reinterpret_cast<uint8_t>(TotalPop)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5B4];
	__asm        jmp    __WHILE_688;
_T732:
	__asm        jmp    _T737;
// LINE 354:
_T737:
	__asm        mov    dword ptr [ebp-0x5B8], 0;
__WHILE_741:
	__asm        cmp    dword ptr [ebp-0x5B8], 0xC8;
	__asm        jae    _T7ef;

	__asm        jmp    _T756;
_T756:
	__asm        jmp    _T75b;
_T75b:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T771;

	__asm        jmp    _FOR_800;
_T771:
	__asm        jmp    _T776;
_T776:
	__asm        jmp    _T77b;
_T77b:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T7ba;

	memstrm.nodeNo++;
	__asm        jmp    _T798;
_T798:
	__asm        jmp    _T79d;
_T79d:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T7b3;

	__asm        jmp    _FOR_800;
_T7b3:
	memstrm.curPos = 0x0;
_T7ba:
	__asm        jmp    _T7bf;
_T7bf:
	__asm        jmp    _T7c4;
_T7c4:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5B8];
	__asm        mov    [ebp+ecx-0x134], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5B8];
	__asm        jmp    __WHILE_741;
_T7c4:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5B8];
	__asm        mov    [ebp+ecx-0x134], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5B8];
	__asm        jmp    __WHILE_741;
_T7ef:
	__asm        jmp    _FOR_800;
// LINE 355:
_FOR_800:
	for (loop = 0x0; (loop < 0x32); loop++) {
		// LINE 356:
			__asm        mov    eax, loop;
			__asm        mov    eax, [ebp+eax*4-0x134];
			__asm        mov    ecx, loop;
			__asm        mov    BondRate[ecx*2], ax;
			__asm        jmp    _FOR_NEXT_800;
	}
// LINE 359:
_T827:
	__asm        mov    dword ptr [ebp-0x5BC], 0;
__WHILE_831:
	__asm        cmp    dword ptr [ebp-0x5BC], 4;
	__asm        jae    _T8db;

	__asm        jmp    _T843;
_T843:
	__asm        jmp    _T848;
_T848:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T85e;

	__asm        jmp    _T8e0;
_T85e:
	__asm        jmp    _T863;
_T863:
	__asm        jmp    _T868;
_T868:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T8a7;

	memstrm.nodeNo++;
	__asm        jmp    _T885;
_T885:
	__asm        jmp    _T88a;
_T88a:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T8a0;

	__asm        jmp    _T8e0;
_T8a0:
	memstrm.curPos = 0x0;
_T8a7:
	__asm        jmp    _T8ac;
_T8ac:
	__asm        jmp    _T8b1;
_T8b1:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5BC];
	__asm        mov    reinterpret_cast<uint8_t>(TotalRate)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5BC];
	__asm        jmp    __WHILE_831;
_T8b1:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5BC];
	__asm        mov    reinterpret_cast<uint8_t>(TotalRate)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5BC];
	__asm        jmp    __WHILE_831;
_T8db:
	__asm        jmp    _T8e0;
// LINE 362:
_T8e0:
	__asm        mov    dword ptr [ebp-0x5C0], 0;
__WHILE_8ea:
	__asm        cmp    dword ptr [ebp-0x5C0], 2;
	__asm        jae    _T994;

	__asm        jmp    _T8fc;
_T8fc:
	__asm        jmp    _T901;
_T901:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T917;

	__asm        jmp    _T999;
_T917:
	__asm        jmp    _T91c;
_T91c:
	__asm        jmp    _T921;
_T921:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _T960;

	memstrm.nodeNo++;
	__asm        jmp    _T93e;
_T93e:
	__asm        jmp    _T943;
_T943:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T959;

	__asm        jmp    _T999;
_T959:
	memstrm.curPos = 0x0;
_T960:
	__asm        jmp    _T965;
_T965:
	__asm        jmp    _T96a;
_T96a:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5C0];
	__asm        mov    reinterpret_cast<uint8_t>(baseYear)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5C0];
	__asm        jmp    __WHILE_8ea;
_T96a:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5C0];
	__asm        mov    reinterpret_cast<uint8_t>(baseYear)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5C0];
	__asm        jmp    __WHILE_8ea;
_T994:
	__asm        jmp    _T999;
// LINE 365:
_T999:
	__asm        mov    dword ptr [ebp-0x5C4], 0;
__WHILE_9a3:
	__asm        cmp    dword ptr [ebp-0x5C4], 2;
	__asm        jae    _Ta4d;

	__asm        jmp    _T9b5;
_T9b5:
	__asm        jmp    _T9ba;
_T9ba:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _T9d0;

	__asm        jmp    _Ta52;
_T9d0:
	__asm        jmp    _T9d5;
_T9d5:
	__asm        jmp    _T9da;
_T9da:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Ta19;

	memstrm.nodeNo++;
	__asm        jmp    _T9f7;
_T9f7:
	__asm        jmp    _T9fc;
_T9fc:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Ta12;

	__asm        jmp    _Ta52;
_Ta12:
	memstrm.curPos = 0x0;
_Ta19:
	__asm        jmp    _Ta1e;
_Ta1e:
	__asm        jmp    _Ta23;
_Ta23:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5C4];
	__asm        mov    reinterpret_cast<uint8_t>(month)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5C4];
	__asm        jmp    __WHILE_9a3;
_Ta23:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5C4];
	__asm        mov    reinterpret_cast<uint8_t>(month)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5C4];
	__asm        jmp    __WHILE_9a3;
_Ta4d:
	__asm        jmp    _Ta52;
// LINE 368:
_Ta52:
	__asm        mov    dword ptr [ebp-0x5C8], 0;
__WHILE_a5c:
	__asm        cmp    dword ptr [ebp-0x5C8], 2;
	__asm        jae    _Tb06;

	__asm        jmp    _Ta6e;
_Ta6e:
	__asm        jmp    _Ta73;
_Ta73:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Ta89;

	__asm        jmp    _Tb0b;
_Ta89:
	__asm        jmp    _Ta8e;
_Ta8e:
	__asm        jmp    _Ta93;
_Ta93:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Tad2;

	memstrm.nodeNo++;
	__asm        jmp    _Tab0;
_Tab0:
	__asm        jmp    _Tab5;
_Tab5:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tacb;

	__asm        jmp    _Tb0b;
_Tacb:
	memstrm.curPos = 0x0;
_Tad2:
	__asm        jmp    _Tad7;
_Tad7:
	__asm        jmp    _Tadc;
_Tadc:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5C8];
	__asm        mov    reinterpret_cast<uint8_t>(year)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5C8];
	__asm        jmp    __WHILE_a5c;
_Tadc:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5C8];
	__asm        mov    reinterpret_cast<uint8_t>(year)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5C8];
	__asm        jmp    __WHILE_a5c;
_Tb06:
	__asm        jmp    _Tb0b;
// LINE 371:
_Tb0b:
	__asm        mov    dword ptr [ebp-0x5CC], 0;
__WHILE_b15:
	__asm        cmp    dword ptr [ebp-0x5CC], 2;
	__asm        jae    _Tbbf;

	__asm        jmp    _Tb27;
_Tb27:
	__asm        jmp    _Tb2c;
_Tb2c:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tb42;

	__asm        jmp    _Tbc4;
_Tb42:
	__asm        jmp    _Tb47;
_Tb47:
	__asm        jmp    _Tb4c;
_Tb4c:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Tb8b;

	memstrm.nodeNo++;
	__asm        jmp    _Tb69;
_Tb69:
	__asm        jmp    _Tb6e;
_Tb6e:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tb84;

	__asm        jmp    _Tbc4;
_Tb84:
	memstrm.curPos = 0x0;
_Tb8b:
	__asm        jmp    _Tb90;
_Tb90:
	__asm        jmp    _Tb95;
_Tb95:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5CC];
	__asm        mov    reinterpret_cast<uint8_t>(season)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5CC];
	__asm        jmp    __WHILE_b15;
_Tb95:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5CC];
	__asm        mov    reinterpret_cast<uint8_t>(season)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5CC];
	__asm        jmp    __WHILE_b15;
_Tbbf:
	__asm        jmp    _Tbc4;
// LINE 374:
_Tbc4:
	__asm        mov    dword ptr [ebp-0x5D0], 0;
__WHILE_bce:
	__asm        cmp    dword ptr [ebp-0x5D0], 2;
	__asm        jae    _Tc78;

	__asm        jmp    _Tbe0;
_Tbe0:
	__asm        jmp    _Tbe5;
_Tbe5:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tbfb;

	__asm        jmp    _Tc7d;
_Tbfb:
	__asm        jmp    _Tc00;
_Tc00:
	__asm        jmp    _Tc05;
_Tc05:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Tc44;

	memstrm.nodeNo++;
	__asm        jmp    _Tc22;
_Tc22:
	__asm        jmp    _Tc27;
_Tc27:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tc3d;

	__asm        jmp    _Tc7d;
_Tc3d:
	memstrm.curPos = 0x0;
_Tc44:
	__asm        jmp    _Tc49;
_Tc49:
	__asm        jmp    _Tc4e;
_Tc4e:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5D0];
	__asm        mov    reinterpret_cast<uint8_t>(CityStatus)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5D0];
	__asm        jmp    __WHILE_bce;
_Tc4e:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5D0];
	__asm        mov    reinterpret_cast<uint8_t>(CityStatus)[ecx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5D0];
	__asm        jmp    __WHILE_bce;
_Tc78:
	__asm        jmp    _Tc7d;
_Tc7d:
	__asm        mov    eax, TrafficMap[0];
	__asm        mov    [ebp-0x5D8], eax;
// LINE 377:
	__asm        mov    dword ptr [ebp-0x5D4], 0;
__WHILE_c92:
	__asm        cmp    dword ptr [ebp-0x5D4], 0x1000;
	__asm        jae    _Td42;

	__asm        jmp    _Tca7;
_Tca7:
	__asm        jmp    _Tcac;
_Tcac:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tcc2;

	__asm        jmp    _Td47;
_Tcc2:
	__asm        jmp    _Tcc7;
_Tcc7:
	__asm        jmp    _Tccc;
_Tccc:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Td0b;

	memstrm.nodeNo++;
	__asm        jmp    _Tce9;
_Tce9:
	__asm        jmp    _Tcee;
_Tcee:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Td04;

	__asm        jmp    _Td47;
_Td04:
	memstrm.curPos = 0x0;
_Td0b:
	__asm        jmp    _Td10;
_Td10:
	__asm        jmp    _Td15;
_Td15:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5D4];
	__asm        mov    edx, [ebp-0x5D8];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5D4];
	__asm        jmp    __WHILE_c92;
_Td15:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5D4];
	__asm        mov    edx, [ebp-0x5D8];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5D4];
	__asm        jmp    __WHILE_c92;
_Td42:
	__asm        jmp    _Td47;
_Td47:
	__asm        mov    eax, PolluteMap[0];
	__asm        mov    [ebp-0x5E0], eax;
// LINE 378:
	__asm        mov    dword ptr [ebp-0x5DC], 0;
__WHILE_d5c:
	__asm        cmp    dword ptr [ebp-0x5DC], 0x1000;
	__asm        jae    _Te0c;

	__asm        jmp    _Td71;
_Td71:
	__asm        jmp    _Td76;
_Td76:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Td8c;

	__asm        jmp    _Te11;
_Td8c:
	__asm        jmp    _Td91;
_Td91:
	__asm        jmp    _Td96;
_Td96:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Tdd5;

	memstrm.nodeNo++;
	__asm        jmp    _Tdb3;
_Tdb3:
	__asm        jmp    _Tdb8;
_Tdb8:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tdce;

	__asm        jmp    _Te11;
_Tdce:
	memstrm.curPos = 0x0;
_Tdd5:
	__asm        jmp    _Tdda;
_Tdda:
	__asm        jmp    _Tddf;
_Tddf:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5DC];
	__asm        mov    edx, [ebp-0x5E0];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5DC];
	__asm        jmp    __WHILE_d5c;
_Tddf:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5DC];
	__asm        mov    edx, [ebp-0x5E0];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5DC];
	__asm        jmp    __WHILE_d5c;
_Te0c:
	__asm        jmp    _Te11;
_Te11:
	__asm        mov    eax, ValueMap[0];
	__asm        mov    [ebp-0x5E8], eax;
// LINE 379:
	__asm        mov    dword ptr [ebp-0x5E4], 0;
__WHILE_e26:
	__asm        cmp    dword ptr [ebp-0x5E4], 0x1000;
	__asm        jae    _Ted6;

	__asm        jmp    _Te3b;
_Te3b:
	__asm        jmp    _Te40;
_Te40:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Te56;

	__asm        jmp    _Tedb;
_Te56:
	__asm        jmp    _Te5b;
_Te5b:
	__asm        jmp    _Te60;
_Te60:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Te9f;

	memstrm.nodeNo++;
	__asm        jmp    _Te7d;
_Te7d:
	__asm        jmp    _Te82;
_Te82:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Te98;

	__asm        jmp    _Tedb;
_Te98:
	memstrm.curPos = 0x0;
_Te9f:
	__asm        jmp    _Tea4;
_Tea4:
	__asm        jmp    _Tea9;
_Tea9:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5E4];
	__asm        mov    edx, [ebp-0x5E8];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5E4];
	__asm        jmp    __WHILE_e26;
_Tea9:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5E4];
	__asm        mov    edx, [ebp-0x5E8];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5E4];
	__asm        jmp    __WHILE_e26;
_Ted6:
	__asm        jmp    _Tedb;
_Tedb:
	__asm        mov    eax, CrimeMap[0];
	__asm        mov    [ebp-0x5F0], eax;
// LINE 380:
	__asm        mov    dword ptr [ebp-0x5EC], 0;
__WHILE_ef0:
	__asm        cmp    dword ptr [ebp-0x5EC], 0x1000;
	__asm        jae    _Tfa0;

	__asm        jmp    _Tf05;
_Tf05:
	__asm        jmp    _Tf0a;
_Tf0a:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tf20;

	__asm        jmp    _Tfa5;
_Tf20:
	__asm        jmp    _Tf25;
_Tf25:
	__asm        jmp    _Tf2a;
_Tf2a:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    edx, memstrm.curPos;
	__asm        cmp    [ecx+eax*8+4], edx;
	__asm        ja     _Tf69;

	memstrm.nodeNo++;
	__asm        jmp    _Tf47;
_Tf47:
	__asm        jmp    _Tf4c;
_Tf4c:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        cmp    dword ptr [ecx+eax*8], 0;
	__asm        jne    _Tf62;

	__asm        jmp    _Tfa5;
_Tf62:
	memstrm.curPos = 0x0;
_Tf69:
	__asm        jmp    _Tf6e;
_Tf6e:
	__asm        jmp    _Tf73;
_Tf73:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5EC];
	__asm        mov    edx, [ebp-0x5F0];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5EC];
	__asm        jmp    __WHILE_ef0;
_Tf73:
	__asm        movsx  eax, memstrm.nodeNo;
	__asm        mov    ecx, memstrm.nodeList.start;
	__asm        mov    eax, [ecx+eax*8];
	__asm        mov    ecx, memstrm.curPos;
	__asm        mov    al, [eax+ecx];
	__asm        mov    ecx, [ebp-0x5EC];
	__asm        mov    edx, [ebp-0x5F0];
	__asm        mov    [ecx+edx], al;
	__asm        inc    memstrm.curPos;
	__asm        inc    dword ptr [ebp-0x5EC];
	__asm        jmp    __WHILE_ef0;
_Tfa0:
	__asm        jmp    _Tfa5;
// LINE 383:
_Tfa5:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(PoliceMap[0], 0x400);
// LINE 384:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(FireMap[0], 0x400);
// LINE 385:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(PopMap[0], 0x400);
// LINE 386:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(ROGMap[0], 0x400);
// LINE 389:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(BitsMap[0], 0x4000);
// LINE 390:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(BuildMap[0], 0x4000);
// LINE 391:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(scxbuf, 0x4000);
// LINE 392:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(ZoneMap[0], 0x4000);
// LINE 393:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(TerrainMap[0], 0x4000);
// LINE 394:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(UnderMap[0], 0x4000);
// LINE 395:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(TextMap[0], 0x4000);
// LINE 396:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(AltMap[0], 0x8000);
// LINE 400:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 401:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 404:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 405:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 409:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(scxTileCount[0], 0x400);
// LINE 410:
_FOR_10ed:
	for (loop = 0x0; (loop < 0x100); loop++) {
		// LINE 411:
			__asm        mov    eax, loop;
			__asm        mov    eax, [ebp+eax*4-0x550];
			__asm        mov    ecx, loop;
			__asm        mov    edx, TileCnt;
			__asm        mov    [edx+ecx*2], ax;
			__asm        jmp    _FOR_NEXT_10ed;
	}
// LINE 414:
_T1119:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 415:
	__asm        mov    eax, tempLong;
	__asm        mov    NationalTax, ax;
// LINE 418:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 419:
	__asm        mov    eax, tempLong;
	__asm        mov    NationalTrend, ax;
// LINE 422:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x638f60, 0x4);
// LINE 425:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x63930c, 0x4);
// LINE 428:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(PopRatio, 0x50);
// LINE 431:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(EducateRatio, 0x50);
// LINE 434:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(HealthRatio, 0x50);
// LINE 437:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 438:
	__asm        mov    eax, tempLong;
	__asm        mov    GlobalSeaLevel, ax;
// LINE 441:
_FOR_11ca:
	for (loop = 0x0; (loop < 0x32); loop++) {
		// LINE 442:
			__asm        push   0x19;
			__asm        mov    eax, loop;
			__asm        lea    eax, [eax+eax*4];
			__asm        lea    eax, [eax+eax*4];
			__asm        add    eax, LabelArray;
			__asm        push   eax;
			__asm        lea    ecx, memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>;
			__asm        call   cGZXParamBitstream<t_alloc,t_free>::Read;
			__asm        jmp    _FOR_NEXT_11ca;
	}
// LINE 452:
_FOR_1202:
	for (loop = 0x0; (loop < 0x96); loop++) {
		// LINE 454:
			memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(SCXMicroRecord.type, 0x9);
		// LINE 455:
			__asm        mov    al, SCXMicroRecord.type;
			__asm        mov    ecx, loop;
			__asm        mov    edx, MicroRecord;
			__asm        mov    [edx+ecx*8], al;
		// LINE 456:
			__asm        mov    al, SCXMicroRecord.stat0;
			__asm        mov    ecx, loop;
			__asm        mov    edx, MicroRecord;
			__asm        mov    [edx+ecx*8+1], al;
		// LINE 457:
			__asm        mov    ax, SCXMicroRecord.stat1;
			__asm        mov    ecx, loop;
			__asm        mov    edx, MicroRecord;
			__asm        mov    [edx+ecx*8+2], ax;
		// LINE 458:
			__asm        mov    ax, SCXMicroRecord.stat2;
			__asm        mov    ecx, loop;
			__asm        mov    edx, MicroRecord;
			__asm        mov    [edx+ecx*8+4], ax;
		// LINE 459:
			__asm        mov    ax, SCXMicroRecord.stat3;
			__asm        mov    ecx, loop;
			__asm        mov    edx, MicroRecord;
			__asm        mov    [edx+ecx*8+6], ax;
	}
// LINE 463:
_T128c:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x639ab2, 0x1);
// LINE 464:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x638eda, 0x1);
// LINE 465:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x63a6c0, 0x1);
// LINE 466:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x63924a, 0x1);
// LINE 470:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 471:
	__asm        mov    eax, tempLong;
	__asm        mov    IndustryConnect, ax;
// LINE 474:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 475:
	__asm        mov    eax, tempLong;
	__asm        mov    CommerceConnect, ax;
// LINE 478:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 479:
	__asm        mov    eax, tempLong;
	__asm        mov    SubwayCnt, ax;
// LINE 482:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 483:
	__asm        mov    eax, tempLong;
	__asm        mov    CityCentX, ax;
// LINE 484:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 485:
	__asm        mov    eax, tempLong;
	__asm        mov    CityCentY, ax;
// LINE 488:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x639234, 0x4);
// LINE 491:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x639dd8, 0x4);
// LINE 494:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(0x639aa0, 0x4);
// LINE 497:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 498:
	__asm        mov    eax, tempLong;
	__asm        mov    PolluteBonus, ax;
// LINE 501:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 502:
	__asm        mov    eax, tempLong;
	__asm        mov    IndustryBonus, ax;
// LINE 505:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 506:
	__asm        mov    eax, tempLong;
	__asm        mov    PoliceBonus, ax;
// LINE 509:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(tempLong, 0x4);
// LINE 510:
	__asm        mov    eax, tempLong;
	__asm        mov    SewerBonus, ax;
// LINE 514:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(scxInd[0], 0x2c);
// LINE 515:
_FOR_1417:
	for (loop = 0x0; (loop < 0xb); loop++) {
		// LINE 516:
			__asm        mov    eax, loop;
			__asm        mov    eax, [ebp+eax*4-0x57C];
			__asm        mov    ecx, loop;
			__asm        mov    edx, IndDemand;
			__asm        mov    [edx+ecx*2], ax;
			__asm        jmp    _FOR_NEXT_1417;
	}
// LINE 519:
_T1440:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(scxInd[0], 0x2c);
// LINE 520:
_FOR_145d:
	for (loop = 0x0; (loop < 0xb); loop++) {
		// LINE 521:
			__asm        mov    eax, loop;
			__asm        movsx  eax, word ptr [ebp+eax*4-0x57C];
			__asm        mov    ecx, loop;
			__asm        mov    edx, IndRatio;
			__asm        mov    [edx+ecx*4], eax;
			__asm        jmp    _FOR_NEXT_145d;
	}
// LINE 524:
_T1486:
	memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>->cGZXParamBitstream<t_alloc,t_free>::Read(GraphMax, 0x40);
// LINE 525:
_FOR_14a2:
	for (loop = 0x0; (loop < 0x10); loop++) {
		// LINE 526:
			__asm        push   0xD0;
			__asm        mov    eax, loop;
			__asm        mov    eax, GraphData[eax*4];
			__asm        push   eax;
			__asm        lea    ecx, memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>;
			__asm        call   cGZXParamBitstream<t_alloc,t_free>::Read;
			__asm        jmp    _FOR_NEXT_14a2;
	}
// LINE 528:
_T14cc:
	__asm        mov    eax, scxbuf;
	__asm        mov    [ebp-0x588], eax;
	__asm        mov    eax, [ebp-0x588];
	__asm        mov    [ebp-0x590], eax;
	__asm        mov    eax, [ebp-0x590];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 530:
	__asm        mov    dword ptr [ebp-0x58C], 1;
	__asm        mov    memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>, 0x592440;
	__asm        lea    ecx, memstrm<cGZXParamBitstream<t_alloc,t_free>+0x00>;
	__asm        call   cGZXParamBitstream<t_alloc,t_free>::FreeAll;
	__asm        jmp    _T1510;
_T1510:
	__asm        lea    ecx, memstrm.nodeList.start;
	__asm        call   vector<tGZXBitstreamNode>::~vector<tGZXBitstreamNode>;
	__asm        lea    ecx, fileStream<cLZAPFileBitStream+0x00>;
	__asm        call   cLZAPFileBitStream::~cLZAPFileBitStream;
	__asm        mov    eax, [ebp-0x58C];
	__asm        jmp    __RETURN;
// LINE 531:
__RETURN:
}



// Contribution: 1:000cc540-000cc59d Module: 89, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004cd540
// vector<tGZXBitstreamNode>::~vector<tGZXBitstreamNode>



// Contribution: 1:000cc5a0-000ccf60 Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000ccf70-000ccf98 Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000ccfa0-000ccfcf Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000ccfd0-000ccfff Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000cd000-000cd0fe Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000cd100-000cd1f1 Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000cd200-000cdf3b Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000cdf40-000cdfac Module: 89, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000cdfb0-000ce018 Module: 89, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004cefb0
// allocate



// Contribution: 1:000ce020-000ce089 Module: 89, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004cf020
// uninitialized_copy



// Contribution: 2:000033f8-00003413 Module: 89, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for cGZXBitstream @ 0x005923f8
//   00: _purecall @ 0x0056cfa0
//   01: _purecall @ 0x0056cfa0
//   02: _purecall @ 0x0056cfa0
//   03: _purecall @ 0x0056cfa0
//   04: _purecall @ 0x0056cfa0
//   05: _purecall @ 0x0056cfa0
//   06: _purecall @ 0x0056cfa0
//   7 entries



// Contribution: 2:00003418-0000343b Module: 89, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for cLZAPFileBitStream @ 0x00592418
//   00: cLZAPFileBitStream::Read @ 0x004cba1c
//   01: cLZAPFileBitStream::Write @ 0x004cba9c
//   02: cLZAPFileBitStream::Rewind @ 0x004cbb1c
//   03: cLZAPFileBitStream::RewindToMark @ 0x004cbb63
//   04: cLZAPFileBitStream::Mark @ 0x004cbbb5
//   05: cLZAPFileBitStream::Size @ 0x004cbc0d
//   06: cLZAPFileBitStream::FreeAll @ 0x004cbc42
//   07: cLZAPFileBitStream::OpenRead @ 0x004cb90d
//   08: cLZAPFileBitStream::Close @ 0x004cb9d2
//   9 entries



// Contribution: 2:00003440-0000345b Module: 89, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for t_free> @ 0x00592440
//   00: cGZXParamBitstream<t_alloc,t_free>::Read @ 0x004ce100
//   01: cGZXParamBitstream<t_alloc,t_free>::Write @ 0x004ce200
//   02: cGZXParamBitstream<t_alloc,t_free>::Rewind @ 0x004cdf70
//   03: cGZXParamBitstream<t_alloc,t_free>::RewindToMark @ 0x004cdfa0
//   04: cGZXParamBitstream<t_alloc,t_free>::Mark @ 0x004cdfd0
//   05: cGZXParamBitstream<t_alloc,t_free>::Size @ 0x004cef40
//   06: cGZXParamBitstream<t_alloc,t_free>::FreeAll @ 0x004ce000
//   7 entries



// Contribution: 3:00005168-0000516d Module: 89, 4 byte alignment, initialized_data, read, write, 


// Contribution: 3:0006fa58-0006fa5b Module: 89, 4 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00606a58
static unsigned char * scxbuf;



// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.

// WARNING: this global might actually belong to: C:\Copter\source\common\S2lodsav.c
// GLOBAL: COPTER_D 0x0063a578
short * NeighborName; // Contrib missing

