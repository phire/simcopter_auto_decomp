// Module: S2alloc.obj
// Source: C:\Copter\source\common\S2alloc.c
// autogenerated by simcopter_tool from PDB file

// Type: uint32_t;

// Type: /*packed*/ struct alloc_root_s (forward reference);
struct alloc_root_s{ // packed(0x8 bytes) TI: 0x2e36
	/*+0x0*/   /*packed*/ struct alloc_hdr_s *first;
	/*+0x4*/   /*packed*/ struct alloc_hdr_s *current;
};

// Type: int32_t;

// Type: void * __ptr32;

// Type: unsigned long;

// Type: /*packed*/ struct alloc_handle_t (forward reference);
struct alloc_handle_t{ // packed(0x4 bytes) TI: 0x2e3a
	/*+0x0*/   int32_t dummy;
};

// Type: char *;

// Type: /*packed*/ struct alloc_hdr_s (forward reference);
struct alloc_hdr_s{ // packed(0x10 bytes) TI: 0x2e38
	/*+0x0*/   /*packed*/ struct alloc_hdr_s *next;
	/*+0x4*/   char * block;
	/*+0x8*/   char * free;
	/*+0xc*/   char * end;
};

// Type: unsigned short;

// Type: void;



// Contribution: 1:000ca2b0-000ca878 Module: 91, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004cb2b0
/*packed*/ struct alloc_handle_t* S2AllocInit(int32_t index, unsigned long poolsize) {
	/*bp-0x4*/   /*packed*/ struct alloc_handle_t *old;

// LINE 268:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    old, eax;
// LINE 270:
	__asm        push   8;
	__asm        call   malloc;
	__asm        add    esp, 4;
	__asm        mov    ecx, index;
	__asm        mov    root[0][ecx*4], eax;
// LINE 272:
	__asm        add    G_alloc_curr, 8;
	__asm        mov    eax, G_alloc_curr;
	__asm        cmp    G_alloc_max, eax;
	__asm        jae    _T4c;

	G_alloc_max = G_alloc_curr;
// LINE 274:
_T4c:
	__asm        mov    eax, poolsize;
	__asm        push   eax;
	__asm        call   S2AllocHdr;
	__asm        add    esp, 4;
	__asm        mov    ecx, index;
	__asm        mov    ecx, root[0][ecx*4];
	__asm        mov    [ecx], eax;
// LINE 276:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T90;
// LINE 277:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, index;
	__asm        mov    ecx, root[0][ecx*4];
	__asm        mov    [ecx+4], eax;
// LINE 279:
_T90:
	return old;
// LINE 280:
}

// FUNCTION: COPTER_D 0x004cb34d
static /*packed*/ struct alloc_hdr_s* S2AllocHdr(unsigned long size) {
	/*bp-0x4*/   /*packed*/ struct alloc_hdr_s *hdr;
	/*bp-0x8*/   char * block;

// LINE 238:
	block = malloc(size);
// LINE 239:
	hdr = malloc(0x10);
// LINE 241:
	__asm        cmp    hdr, 0;
	__asm        je     _T39;

	__asm        cmp    block, 0;
	__asm        jne    _T59;
// LINE 243:
_T39:
	fprintf(0x59b53c, (0x5c0bf8 + 0x40));
// LINE 244:
	exit(0x1);
// LINE 246:
_T59:
	hdr->block = block;
// LINE 247:
	hdr->free = block;
// LINE 248:
	hdr->next = 0x0;
// LINE 249:
	hdr->end = (size + block);
// LINE 251:
	__asm        mov    eax, size;
	__asm        add    eax, 0x10;
	__asm        add    G_alloc_curr, eax;
	__asm        mov    eax, G_alloc_curr;
	__asm        cmp    G_alloc_max, eax;
	__asm        jae    _Ta7;

	G_alloc_max = G_alloc_curr;
// LINE 253:
_Ta7:
	return hdr;
// LINE 254:
}

// FUNCTION: COPTER_D 0x004cb401
int32_t S2AllocPool(unsigned long poolsize) {
	/*bp-0x4*/   /*packed*/ struct alloc_handle_t *lastPool;
	/*bp-0x8*/   int32_t index;

// LINE 295:
	__asm        cmp    poolCount, 0x20;
	__asm        jne    _FOR_2c;
// LINE 296:
	return 0xffffffff;
// LINE 299:
_FOR_2c:
	for (index = 0x0; (index < 0x20); index++) {
		// LINE 301:
			__asm        mov    eax, index;
			__asm        cmp    root[0][eax*4], 0;
			__asm        jne    _T4f;
		// LINE 302:
			__asm        jmp    _T54;
		// LINE 303:
		_T4f:
	}
// LINE 305:
_T54:
	__asm        cmp    index, 0x20;
	__asm        jne    _T68;
// LINE 306:
	return 0xffffffff;
// LINE 308:
_T68:
	lastPool = S2AllocInit(poolsize, index);
// LINE 310:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _T98;
// LINE 311:
	return 0xffffffff;
// LINE 313:
_T98:
	poolCount++;
// LINE 314:
	return index;
// LINE 315:
}

// FUNCTION: COPTER_D 0x004cb4ac
char * S2Alloc(int32_t index, int32_t size) {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   /*packed*/ struct alloc_hdr_s *hdr;

// LINE 331:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    eax, [eax+4];
	__asm        mov    hdr, eax;
// LINE 340:
	size = ((size + 0x3) & -0x4);
// LINE 342:
	ptr = hdr->free;
// LINE 343:
	hdr->free += size;
// LINE 347:
	__asm        mov    eax, hdr;
	__asm        mov    ecx, hdr;
	__asm        mov    ecx, [ecx+0xC];
	__asm        cmp    [eax+8], ecx;
	__asm        jb     _Te9;
// LINE 351:
	__asm        mov    eax, hdr;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T7c;
// LINE 354:
	hdr->next->free = hdr->next->block;
// LINE 355:
	__asm        mov    eax, hdr;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, index;
	__asm        mov    ecx, root[0][ecx*4];
	__asm        mov    [ecx+4], eax;
// LINE 357:
	__asm        jmp    _Tc3;
// LINE 360:
_T7c:
	__asm        cmp    size, 0x2000;
	__asm        jle    _T9f;
// LINE 361:
	hdr->next = S2AllocHdr(size);
// LINE 362:
	__asm        jmp    _Tb1;
// LINE 363:
_T9f:
	hdr->next = S2AllocHdr(0x2000);
// LINE 364:
_Tb1:
	__asm        mov    eax, hdr;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, index;
	__asm        mov    ecx, root[0][ecx*4];
	__asm        mov    [ecx+4], eax;
// LINE 368:
_Tc3:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+8];
	__asm        mov    ptr, eax;
// LINE 369:
	__asm        mov    eax, size;
	__asm        mov    ecx, index;
	__asm        mov    ecx, root[0][ecx*4];
	__asm        mov    ecx, [ecx+4];
	__asm        add    [ecx+8], eax;
// LINE 372:
_Te9:
	G_alloc_used += size;
// LINE 383:
	return ptr;
// LINE 384:
}

// FUNCTION: COPTER_D 0x004cb5ab
char * S2AllocMem1(int32_t index, char * name, int32_t size, unsigned short protMem) {
// LINE 399:
	return S2AllocMem(size, name, index);
// LINE 400:
}

// FUNCTION: COPTER_D 0x004cb5cf
char * S2AllocMem(int32_t index, char * name, int32_t size) {
	/*bp-0x4*/   char * ptr;

// LINE 416:
	ptr = S2Alloc(size, index);
// LINE 423:
	return ptr;
// LINE 424:
}

// FUNCTION: COPTER_D 0x004cb5f8
/*packed*/ struct alloc_handle_t* S2AllocSetPool(int32_t index, /*packed*/ struct alloc_handle_t *newPtr) {
	/*bp-0x4*/   /*packed*/ struct alloc_handle_t *old;

// LINE 438:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    old, eax;
// LINE 440:
	__asm        mov    eax, newPtr;
	__asm        mov    ecx, index;
	__asm        mov    root[0][ecx*4], eax;
// LINE 442:
	return old;
// LINE 443:
}

// FUNCTION: COPTER_D 0x004cb628
void S2AllocReset(int32_t index) {
	/*bp-0x4*/   /*packed*/ struct alloc_hdr_s *hdr;

// LINE 459:
	__asm        mov    eax, index;
	__asm        cmp    root[0][eax*4], 0;
	__asm        jne    _T1f;
// LINE 460:
	return;
// LINE 462:
_T1f:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    eax, [eax];
	__asm        mov    hdr, eax;
// LINE 463:
__WHILE_2e:
	while ((hdr != 0x0)) {
		// LINE 465:
			__asm        xor    eax, eax;
			__asm        mov    ecx, hdr;
			__asm        mov    ecx, [ecx+8];
			__asm        mov    edx, hdr;
			__asm        sub    ecx, [edx+4];
			__asm        sub    eax, ecx;
			__asm        neg    eax;
			__asm        sub    G_alloc_used, eax;
		// LINE 466:
			hdr = hdr->next;
		// LINE 467:
			__asm        jmp    __WHILE_2e;
	}
// LINE 469:
_T5d:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, index;
	__asm        mov    ecx, root[0][ecx*4];
	__asm        mov    [ecx+4], eax;
// LINE 470:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, index;
	__asm        mov    ecx, root[0][ecx*4];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx+8], eax;
// LINE 474:
}

// FUNCTION: COPTER_D 0x004cb6c3
void S2AllocFreePool(int32_t index) {
	/*bp-0x4*/   /*packed*/ struct alloc_hdr_s *next_hdr;
	/*bp-0x8*/   /*packed*/ struct alloc_hdr_s *hdr;

// LINE 493:
	__asm        mov    eax, index;
	__asm        cmp    root[0][eax*4], 0;
	__asm        jne    _T1f;
// LINE 494:
	return;
// LINE 496:
_T1f:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        mov    eax, [eax];
	__asm        mov    hdr, eax;
// LINE 498:
__WHILE_2e:
	while ((hdr != 0x0)) {
		// LINE 500:
			next_hdr = hdr->next;
		// LINE 501:
			__asm        xor    eax, eax;
			__asm        mov    ecx, hdr;
			__asm        mov    ecx, [ecx+0xC];
			__asm        mov    edx, hdr;
			__asm        sub    ecx, [edx+4];
			__asm        sub    eax, ecx;
			__asm        neg    eax;
			__asm        sub    G_alloc_curr, eax;
		// LINE 502:
			G_alloc_free += (hdr->end - hdr->block);
		// LINE 503:
			G_alloc_curr -= 0x10;
		// LINE 504:
			G_alloc_free += 0x10;
		// LINE 505:
			free(hdr->block);
		// LINE 506:
			free(hdr);
		// LINE 507:
			hdr = next_hdr;
		// LINE 508:
			__asm        jmp    __WHILE_2e;
	}
// LINE 509:
_T9e:
	__asm        mov    eax, index;
	__asm        mov    eax, root[0][eax*4];
	__asm        push   eax;
	__asm        call   free;
	__asm        add    esp, 4;
// LINE 510:
	G_alloc_curr -= 0x8;
// LINE 511:
	G_alloc_free += 0x8;
// LINE 512:
	__asm        mov    eax, index;
	__asm        mov    root[0][eax*4], 0;
// LINE 513:
	poolCount--;
// LINE 516:
	_heapmin();
// LINE 517:
	_heapchk();
// LINE 523:
}

// FUNCTION: COPTER_D 0x004cb7a5
void * __ptr32 S2AllocAligned() {
// LINE 591:
	return DOSAllocAlignedHack();
// LINE 592:
}

// FUNCTION: COPTER_D 0x004cb7ba
void * __ptr32 DOSAllocAlignedHack() {
	/*bp-0x4*/   void * __ptr32 retaddr;

// LINE 753:
	retaddr = malloc(0x20000);
// LINE 754:
	__asm        cmp    retaddr, 0;
	__asm        jne    _T2a;
// LINE 755:
	return 0x0;
// LINE 759:
_T2a:
	__asm        test   retaddr, 0xFFFF;
	__asm        je     _T49;
// LINE 763:
	retaddr = (retaddr & 0xffff0000);
// LINE 764:
	retaddr += 0x10000;
// LINE 767:
_T49:
	__asm        add    G_alloc_curr, 0x10000;
	__asm        mov    eax, G_alloc_curr;
	__asm        cmp    G_alloc_max, eax;
	__asm        jae    _T6e;

	G_alloc_max = G_alloc_curr;
// LINE 768:
_T6e:
	G_alloc_used += 0x10000;
// LINE 770:
	return retaddr;
// LINE 771:
}

// FUNCTION: COPTER_D 0x004cb83f
void S2FreeAligned(void * __ptr32 mem) {
// LINE 787:
	__asm        push   0x8000;
	__asm        push   0;
	__asm        mov    eax, mem;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3734];
// LINE 789:
	G_alloc_curr -= 0x10000;
// LINE 790:
	G_alloc_used -= 0x10000;
// LINE 791:
	G_alloc_free += 0x10000;
// LINE 797:
}



// Contribution: 3:00004524-0000454a Module: 91, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x0059b524
uint32_t G_alloc_curr = 0;

// GLOBAL: COPTER_D 0x0059b528
uint32_t G_alloc_free = 0;

// GLOBAL: COPTER_D 0x0059b52c
uint32_t G_alloc_max = 0;

// GLOBAL: COPTER_D 0x0059b530
uint32_t G_alloc_used = 0;

// GLOBAL: COPTER_D 0x0059b534
static int32_t poolCount = 0;

// GLOBAL: COPTER_D 0x0059b538
static void * __ptr32 S_alignmem = { 0 /* todo */ };



// Contribution: 3:0006f9d8-0006fa57 Module: 91, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x006069d8
static /*packed*/ struct alloc_root_s *root[32];

