// Module: Defwindo.obj
// Source: C:\Copter\source\sparkal\Defwindo.cpp
// autogenerated by simcopter_tool from PDB file

// Type: class CSparkalWindow (forward reference);
// VTABLE: COPTER_D 0x00590ef8
class CSparkalWindow{ // packed(0x68 bytes) TI: 0x20d9
public:
	void CSparkalWindow(unsigned long, unsigned long, unsigned long, const struct SparkalColor*, char *);
	void CSparkalWindow();
	virtual void ~CSparkalWindow(); // vtable+0x0
	void * __ptr32 GetPlatformData();
	long GetWidth();
	long GetHeight();
	virtual unsigned long GetClientSize(long *, long *); // vtable+0x4
	class ScreenBuffer* GetBackBuffer();
	class ScreenBuffer* SetBackBuffer(class ScreenBuffer*);
	class ICommander* GetCommander();
	class ICommander* SetCommander(class ICommander*);
	virtual unsigned long Draw(); // vtable+0x8
	virtual unsigned long SetCursor(unsigned long); // vtable+0xc
	virtual unsigned long SetCursorFromIndex(int32_t); // vtable+0x10
	virtual unsigned long LoadGameCursors(); // vtable+0x14
	virtual void FreeGameCursors(); // vtable+0x18
	unsigned long DrawBufferText(const const char*, unsigned long, long, long, long *, long *, long *, long *);
	virtual unsigned long Sleep(); // vtable+0x1c
	virtual unsigned long WakeUp(); // vtable+0x20
	unsigned long ScreenScroll(long, long, long, long, long, long);
	unsigned long RectSlideUp(long, long, long, long);
	virtual unsigned long SwapBuffer(long, long, long, long); // vtable+0x24
	virtual unsigned long SwapBuffer(); // vtable+0x28
	virtual void UpdatePalette(long, long, struct SparkalColor*); // vtable+0x2c
protected:
	long mHeight;
	long mWidth;
	unsigned long mStyle;
	class ICommander *mpCommander;
	class ScreenBuffer *mpBackBuffer;
	void * __ptr32 mWindow;
	// calltype: NearStd
	virtual long MySparkalWindowProc(void * __ptr32, uint32_t, uint32_t, long); // vtable+0x30
	void * __ptr32 mPalette;
	void * __ptr32 mhCurrentCursor;
	void * __ptr32 mhCustomCursor;
	void * __ptr32 mCursors[16];
};

// Type: class ICommander (forward reference);
// VTABLE: COPTER_D 0x005912a8
class ICommander{ // packed(0x8 bytes) TI: 0x17ab
public:
	void ICommander();
	virtual void ~ICommander(); // vtable+0x0
	virtual unsigned long Idle(); // vtable+0x4
	virtual unsigned long OnCharacter(char, int32_t); // vtable+0x8
	virtual unsigned long OnMouseDown(int32_t, int32_t); // vtable+0xc
	virtual unsigned long OnMouseUp(int32_t, int32_t); // vtable+0x10
	virtual unsigned long OnMouseMove(int32_t, int32_t); // vtable+0x14
	virtual unsigned long OnWindowActivate(); // vtable+0x18
	virtual unsigned long OnWindowDeactivate(); // vtable+0x1c
	virtual class CSparkalWindow* SetWindow(class CSparkalWindow*); // vtable+0x20
	class CSparkalWindow* GetWindow();
protected:
	class CSparkalWindow *mpWindow;
};

// Type: class ScreenBuffer (forward reference);
// VTABLE: COPTER_D 0x005915b0
class ScreenBuffer : public CBackBuffer
{ // packed(0x16a bytes) TI: 0x1919
public:
	class CSparkalWindow *pWindow;
	long bOK;
	void ScreenBuffer(class CSparkalWindow*, long, long, struct SparkalColor*, int32_t, enum tagModeType, int32_t);
	void ScreenBuffer();
	virtual void ~ScreenBuffer(); // vtable+0x64
	virtual unsigned long Swap(class CSparkalWindow*, long, long) /* override */;
	virtual int32_t DeleteSurfaces(); // vtable+0x68
	virtual int32_t CreateSurfaces(); // vtable+0x6c
	virtual int32_t ClearSurfaces(int32_t); // vtable+0x70
	virtual int32_t UsePalette(struct SparkalColor*); // vtable+0x74
	virtual void FreePalette(); // vtable+0x78
	virtual void SetPalette(); // vtable+0x7c
	virtual unsigned long FillRect(long, struct SparkalRect*) /* override */;
	virtual void SetWindowRect(struct SparkalRect*); // vtable+0x80
	virtual void SetNewModeType(enum tagModeType); // vtable+0x84
	virtual void WaitTillReadyToFlip(); // vtable+0x88
protected:
	struct SparkalRect rectBuffer;
	short nBackBuffers;
	enum tagModeType nCurrentModeType;
	int32_t bUsingFlipping;
	struct IDirectDrawClipper *lpClipper;
	struct tagRECT rectDirectDrawBackBuffer;
};

// Type: unsigned long;

// Type: long;



// Contribution: 1:00031260-000314d4 Module: 61, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00432260
class ICommander* CSparkalWindow::SetCommander(class ICommander *pCommander) {
	class ICommander *ReturnCommander;

// LINE 19:
	ReturnCommander = this->mpCommander;
// LINE 21:
	__asm        mov    eax, this;
	__asm        mov    ecx, pCommander;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T30;
// LINE 22:
	ReturnCommander = 0x0;
// LINE 23:
	__asm        jmp    _T68;
// LINE 25:
_T30:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T50;
// LINE 26:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x20];
// LINE 28:
_T50:
	this->mpCommander = pCommander;
// LINE 29:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, pCommander;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pCommander;
	__asm        call   dword ptr [eax+0x20];
// LINE 32:
_T68:
	__asm        mov    eax, ReturnCommander;
	__asm        jmp    near ptr 0x004322D0;
// LINE 33:
}

// FUNCTION: COPTER_D 0x004322d7
class ScreenBuffer* CSparkalWindow::SetBackBuffer(class ScreenBuffer *pBuffer) {
	class ScreenBuffer *ReturnBuffer;

// LINE 42:
	ReturnBuffer = this->mpBackBuffer;
// LINE 43:
	this->mpBackBuffer = pBuffer;
// LINE 44:
	__asm        mov    eax, ReturnBuffer;
	__asm        jmp    near ptr 0x004322FD;
// LINE 45:
}

// FUNCTION: COPTER_D 0x00432304
unsigned long CSparkalWindow::Draw() {
// LINE 55:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x28];
	__asm        jmp    near ptr 0x00432320;
// LINE 56:
}

// FUNCTION: COPTER_D 0x00432325
unsigned long CSparkalWindow::SwapBuffer() {
// LINE 64:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T5b;
// LINE 65:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx];
	__asm        test   eax, eax;
	__asm        je     _T5b;
// LINE 66:
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x1C];
// LINE 67:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
// LINE 70:
_T5b:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x00432387;
// LINE 71:
}

// FUNCTION: COPTER_D 0x0043238c
unsigned long CSparkalWindow::SwapBuffer(long Left, long Top, long Right, long Bottom) {
	unsigned long Error;

// LINE 81:
	Error = 0x0;
// LINE 86:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T13a;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx];
	__asm        test   eax, eax;
	__asm        je     _T13a;
// LINE 92:
// Block start:
	long Step;
	long ChunkHeight;
	long DestTop;
	__asm        mov    eax, Bottom;
	__asm        sub    eax, Top;
	__asm        mov    ecx, 0xA;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    Step, eax;
// LINE 93:
	ChunkHeight = Step;
// LINE 94:
	__asm        mov    eax, Bottom;
	__asm        sub    eax, ChunkHeight;
	__asm        mov    DestTop, eax;
// LINE 97:
	__asm        mov    eax, DestTop;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, ChunkHeight;
	__asm        add    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 99:
	__asm        cmp    Step, 0;
	__asm        jne    _Tab;

	__asm        push   0x63;
	__asm        push   0x59836C;
	__asm        push   0x598394;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tb0;
_Tab:
	__asm        jmp    _Tb0;
// LINE 102:
_Tb0:
	__asm        mov    eax, DestTop;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, ChunkHeight;
	__asm        add    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 103:
	__asm        mov    eax, Step;
	__asm        add    ChunkHeight, eax;
// LINE 104:
	__asm        xor    eax, eax;
	__asm        sub    eax, Step;
	__asm        neg    eax;
	__asm        sub    DestTop, eax;
// LINE 105:
	__asm        mov    eax, Top;
	__asm        cmp    DestTop, eax;
	__asm        jg     _Tb0;
// LINE 106:
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, Bottom;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 107:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
// LINE 110:
// Block end:
_T13a:
	__asm        mov    eax, Error;
	__asm        jmp    near ptr 0x004324CE;
// LINE 111:
}



// Contribution: 3:0000136c-00001398 Module: 61, 4 byte alignment, initialized_data, read, write, 
