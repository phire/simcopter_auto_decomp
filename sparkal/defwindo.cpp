// Module: Defwindo.obj
// Source: C:\Copter\source\sparkal\Defwindo.cpp
// autogenerated by simcopter_tool from PDB file

// Type: class CSparkalWindow (forward reference);
class CSparkalWindow{
public:
	void CSparkalWindow(unsigned long, unsigned long, unsigned long, const struct SparkalColor*, char *);
	void CSparkalWindow();
	// vtable: 0
	intro void ~CSparkalWindow();
	void * __ptr32 GetPlatformData();
	long GetWidth();
	long GetHeight();
	// vtable: 4
	intro unsigned long GetClientSize(long *, long *);
	class ScreenBuffer* GetBackBuffer();
	class ScreenBuffer* SetBackBuffer(class ScreenBuffer*);
	class ICommander* GetCommander();
	class ICommander* SetCommander(class ICommander*);
	// vtable: 8
	intro unsigned long Draw();
	// vtable: 12
	intro unsigned long SetCursor(unsigned long);
	// vtable: 16
	intro unsigned long SetCursorFromIndex(int32_t);
	// vtable: 20
	intro unsigned long LoadGameCursors();
	// vtable: 24
	intro void FreeGameCursors();
	unsigned long DrawBufferText(const const char*, unsigned long, long, long, long *, long *, long *, long *);
	// vtable: 28
	intro unsigned long Sleep();
	// vtable: 32
	intro unsigned long WakeUp();
	unsigned long ScreenScroll(long, long, long, long, long, long);
	unsigned long RectSlideUp(long, long, long, long);
	// vtable: 36
	intro unsigned long SwapBuffer(long, long, long, long);
	// vtable: 40
	intro unsigned long SwapBuffer();
	// vtable: 44
	intro void UpdatePalette(long, long, struct SparkalColor*);
protected:
	long mHeight;
	long mWidth;
	unsigned long mStyle;
	class ICommander* mpCommander;
	class ScreenBuffer* mpBackBuffer;
	void * __ptr32 mWindow;
	// vtable: 48
	// calltype: NearStd
	intro long MySparkalWindowProc(void * __ptr32, uint32_t, uint32_t, long);
	void * __ptr32 mPalette;
	void * __ptr32 mhCurrentCursor;
	void * __ptr32 mhCustomCursor;
	void * __ptr32 mCursors[16];
};

// Type: class ICommander (forward reference);
class ICommander{
public:
	void ICommander();
	// vtable: 0
	intro void ~ICommander();
	// vtable: 4
	intro unsigned long Idle();
	// vtable: 8
	intro unsigned long OnCharacter(char, int32_t);
	// vtable: 12
	intro unsigned long OnMouseDown(int32_t, int32_t);
	// vtable: 16
	intro unsigned long OnMouseUp(int32_t, int32_t);
	// vtable: 20
	intro unsigned long OnMouseMove(int32_t, int32_t);
	// vtable: 24
	intro unsigned long OnWindowActivate();
	// vtable: 28
	intro unsigned long OnWindowDeactivate();
	// vtable: 32
	intro class CSparkalWindow* SetWindow(class CSparkalWindow*);
	class CSparkalWindow* GetWindow();
protected:
	class CSparkalWindow* mpWindow;
};

// Type: class ScreenBuffer (forward reference);
class ScreenBuffer : public CBackBuffer
{
public:
	class CSparkalWindow* pWindow;
	long bOK;
	void ScreenBuffer(class CSparkalWindow*, long, long, struct SparkalColor*, int32_t, enum tagModeType, int32_t);
	void ScreenBuffer();
	// vtable: 100
	intro void ~ScreenBuffer();
	virtual unsigned long Swap(class CSparkalWindow*, long, long);
	// vtable: 104
	intro int32_t DeleteSurfaces();
	// vtable: 108
	intro int32_t CreateSurfaces();
	// vtable: 112
	intro int32_t ClearSurfaces(int32_t);
	// vtable: 116
	intro int32_t UsePalette(struct SparkalColor*);
	// vtable: 120
	intro void FreePalette();
	// vtable: 124
	intro void SetPalette();
	virtual unsigned long FillRect(long, struct SparkalRect*);
	// vtable: 128
	intro void SetWindowRect(struct SparkalRect*);
	// vtable: 132
	intro void SetNewModeType(enum tagModeType);
	// vtable: 136
	intro void WaitTillReadyToFlip();
protected:
	struct SparkalRect rectBuffer;
	short nBackBuffers;
	enum tagModeType nCurrentModeType;
	int32_t bUsingFlipping;
	struct IDirectDrawClipper* lpClipper;
	struct tagRECT rectDirectDrawBackBuffer;
};

// Type: unsigned long;

// Type: long;



// Contribution: 1:00031260-000314d4 Module: 61, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00432260
class ICommander* CSparkalWindow::SetCommander(class ICommander* pCommander) {
	class ICommander* ReturnCommander;

// LINE 19:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    ReturnCommander, eax;
// LINE 21:
	__asm        mov    eax, this;
	__asm        mov    ecx, pCommander;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T30;
// LINE 22:
	__asm        mov    ReturnCommander, 0;
// LINE 23:
	__asm        jmp    _T68;
// LINE 25:
_T30:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T50;
// LINE 26:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x20];
// LINE 28:
_T50:
	__asm        mov    eax, pCommander;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x10], eax;
// LINE 29:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, pCommander;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pCommander;
	__asm        call   dword ptr [eax+0x20];
// LINE 32:
_T68:
	__asm        mov    eax, ReturnCommander;
	__asm        jmp    near ptr 0x004322D0;
// LINE 33:
}

// FUNCTION: COPTER_D 0x004322d7
class ScreenBuffer* CSparkalWindow::SetBackBuffer(class ScreenBuffer* pBuffer) {
	class ScreenBuffer* ReturnBuffer;

// LINE 42:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    ReturnBuffer, eax;
// LINE 43:
	__asm        mov    eax, pBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14], eax;
// LINE 44:
	__asm        mov    eax, ReturnBuffer;
	__asm        jmp    near ptr 0x004322FD;
// LINE 45:
}

// FUNCTION: COPTER_D 0x00432304
unsigned long CSparkalWindow::Draw() {
// LINE 55:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x28];
	__asm        jmp    near ptr 0x00432320;
// LINE 56:
}

// FUNCTION: COPTER_D 0x00432325
unsigned long CSparkalWindow::SwapBuffer() {
// LINE 64:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T5b;
// LINE 65:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx];
	__asm        test   eax, eax;
	__asm        je     _T5b;
// LINE 66:
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x1C];
// LINE 67:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
// LINE 70:
_T5b:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x00432387;
// LINE 71:
}

// FUNCTION: COPTER_D 0x0043238c
unsigned long CSparkalWindow::SwapBuffer(long Left, long Top, long Right, long Bottom) {
	unsigned long Error;

// LINE 81:
	__asm        mov    Error, 0;
// LINE 86:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T13a;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx];
	__asm        test   eax, eax;
	__asm        je     _T13a;
// LINE 92:
// Block start:
	long Step;
	long ChunkHeight;
	long DestTop;
	__asm        mov    eax, Bottom;
	__asm        sub    eax, Top;
	__asm        mov    ecx, 0xA;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    Step, eax;
// LINE 93:
	__asm        mov    eax, Step;
	__asm        mov    ChunkHeight, eax;
// LINE 94:
	__asm        mov    eax, Bottom;
	__asm        sub    eax, ChunkHeight;
	__asm        mov    DestTop, eax;
// LINE 97:
	__asm        mov    eax, DestTop;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, ChunkHeight;
	__asm        add    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 99:
	__asm        cmp    Step, 0;
	__asm        jne    _Tab;

	__asm        push   0x63;
	__asm        push   0x59836C;
	__asm        push   0x598394;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tb0;
_Tab:
	__asm        jmp    _Tb0;
// LINE 102:
_Tb0:
	__asm        mov    eax, DestTop;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, ChunkHeight;
	__asm        add    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 103:
	__asm        mov    eax, Step;
	__asm        add    ChunkHeight, eax;
// LINE 104:
	__asm        xor    eax, eax;
	__asm        sub    eax, Step;
	__asm        neg    eax;
	__asm        sub    DestTop, eax;
// LINE 105:
	__asm        mov    eax, Top;
	__asm        cmp    DestTop, eax;
	__asm        jg     _Tb0;
// LINE 106:
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, Bottom;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 107:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
// LINE 110:
// Block end:
_T13a:
	__asm        mov    eax, Error;
	__asm        jmp    near ptr 0x004324CE;
// LINE 111:
}



// Contribution: 3:0000136c-00001398 Module: 61, 4 byte alignment, initialized_data, read, write, 
