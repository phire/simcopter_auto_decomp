// Module: Defwindo.obj
// Source: C:\Copter\source\sparkal\Defwindo.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class CSparkalWindow (forward reference);
// VTABLE: COPTER_D 0x00590ef8
class CSparkalWindow{ // packed(0x68 bytes) TI: 0x20d9
public:
	void CSparkalWindow(unsigned long, unsigned long, unsigned long, const /*packed*/ struct SparkalColor*, char *);
	void CSparkalWindow();
	virtual void ~CSparkalWindow(); // vtable+0x0
	void * __ptr32 GetPlatformData();
	long GetWidth();
	long GetHeight();
	virtual unsigned long GetClientSize(long *, long *); // vtable+0x4
	/*unpacked*/ class ScreenBuffer* GetBackBuffer();
	/*unpacked*/ class ScreenBuffer* SetBackBuffer(/*unpacked*/ class ScreenBuffer*);
	/*unpacked*/ class ICommander* GetCommander();
	/*unpacked*/ class ICommander* SetCommander(/*unpacked*/ class ICommander*);
	virtual unsigned long Draw(); // vtable+0x8
	virtual unsigned long SetCursor(unsigned long); // vtable+0xc
	virtual unsigned long SetCursorFromIndex(int32_t); // vtable+0x10
	virtual unsigned long LoadGameCursors(); // vtable+0x14
	virtual void FreeGameCursors(); // vtable+0x18
	unsigned long DrawBufferText(const const char*, unsigned long, long, long, long *, long *, long *, long *);
	virtual unsigned long Sleep(); // vtable+0x1c
	virtual unsigned long WakeUp(); // vtable+0x20
	unsigned long ScreenScroll(long, long, long, long, long, long);
	unsigned long RectSlideUp(long, long, long, long);
	virtual unsigned long SwapBuffer(long, long, long, long); // vtable+0x24
	virtual unsigned long SwapBuffer(); // vtable+0x28
	virtual void UpdatePalette(long, long, /*packed*/ struct SparkalColor*); // vtable+0x2c
protected:
	/*+0x4*/   long mHeight;
	/*+0x8*/   long mWidth;
	/*+0xc*/   unsigned long mStyle;
	/*+0x10*/  /*unpacked*/ class ICommander *mpCommander;
	/*+0x14*/  /*unpacked*/ class ScreenBuffer *mpBackBuffer;
	/*+0x18*/  void * __ptr32 mWindow;
	// calltype: NearStd
	virtual long MySparkalWindowProc(void * __ptr32, uint32_t, uint32_t, long); // vtable+0x30
	/*+0x1c*/  void * __ptr32 mPalette;
	/*+0x20*/  void * __ptr32 mhCurrentCursor;
	/*+0x24*/  void * __ptr32 mhCustomCursor;
	/*+0x28*/  void * __ptr32 mCursors[16]; // 0x40 bytes
};

// Type: /*unpacked*/ class ICommander (forward reference);
// ICommander Class implementation not found

// Type: /*unpacked*/ class ScreenBuffer (forward reference);
// ScreenBuffer Class implementation not found

// Type: unsigned long;

// Type: long;



// Contribution: 1:00031260-000314d4 Module: 61, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00432260
/*unpacked*/ class ICommander* CSparkalWindow::SetCommander(/*unpacked*/ class ICommander *pCommander) {
	/*bp-0x4*/   /*unpacked*/ class ICommander *ReturnCommander;

// LINE 19:
	ReturnCommander = this->mpCommander;
// LINE 21:
	__asm        mov    eax, this;
	__asm        mov    ecx, pCommander;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T30;
// LINE 22:
	ReturnCommander = 0x0;
// LINE 23:
	__asm        jmp    _T68;
// LINE 25:
_T30:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T50;
// LINE 26:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x20];
// LINE 28:
_T50:
	this->mpCommander = pCommander;
// LINE 29:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, pCommander;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pCommander;
	__asm        call   dword ptr [eax+0x20];
// LINE 32:
_T68:
	return ReturnCommander;
// LINE 33:
}

// FUNCTION: COPTER_D 0x004322d7
/*unpacked*/ class ScreenBuffer* CSparkalWindow::SetBackBuffer(/*unpacked*/ class ScreenBuffer *pBuffer) {
	/*bp-0x4*/   /*unpacked*/ class ScreenBuffer *ReturnBuffer;

// LINE 42:
	ReturnBuffer = this->mpBackBuffer;
// LINE 43:
	this->mpBackBuffer = pBuffer;
// LINE 44:
	return ReturnBuffer;
// LINE 45:
}

// FUNCTION: COPTER_D 0x00432304
unsigned long CSparkalWindow::Draw() {
// LINE 55:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x28];
	__asm        jmp    __RETURN;
// LINE 56:
__RETURN:
}

// FUNCTION: COPTER_D 0x00432325
unsigned long CSparkalWindow::SwapBuffer() {
// LINE 64:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T5b;
// LINE 65:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx];
	__asm        test   eax, eax;
	__asm        je     _T5b;
// LINE 66:
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x1C];
// LINE 67:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
// LINE 70:
_T5b:
	return 0x0;
// LINE 71:
}

// FUNCTION: COPTER_D 0x0043238c
unsigned long CSparkalWindow::SwapBuffer(long Left, long Top, long Right, long Bottom) {
	/*bp-0x4*/   unsigned long Error;

// LINE 81:
	Error = 0x0;
// LINE 86:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T13a;

	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx];
	__asm        test   eax, eax;
	__asm        je     _T13a;
// LINE 92:
// Block start:
	/*bp-0x8*/   long DestTop;
	/*bp-0xc*/   long ChunkHeight;
	/*bp-0x10*/  long Step;
	__asm        mov    eax, Bottom;
	__asm        sub    eax, Top;
	__asm        mov    ecx, 0xA;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    Step, eax;
// LINE 93:
	ChunkHeight = Step;
// LINE 94:
	DestTop = (Bottom - ChunkHeight);
// LINE 97:
	__asm        mov    eax, DestTop;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, ChunkHeight;
	__asm        add    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 99:
	__asm        cmp    Step, 0;
	__asm        jne    _Tab;

	_assert(0x63, 0x59836c, 0x598394);
	__asm        jmp    _Tb0;
_Tab:
	__asm        jmp    _Tb0;
// LINE 102:
_Tb0:
	__asm        mov    eax, DestTop;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, ChunkHeight;
	__asm        add    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 103:
	ChunkHeight += Step;
// LINE 104:
	__asm        xor    eax, eax;
	__asm        sub    eax, Step;
	__asm        neg    eax;
	__asm        sub    DestTop, eax;
// LINE 105:
	__asm        mov    eax, Top;
	__asm        cmp    DestTop, eax;
	__asm        jg     _Tb0;
// LINE 106:
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, Bottom;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x20];
// LINE 107:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
// LINE 110:
// Block end:
_T13a:
	return Error;
// LINE 111:
}



// Contribution: 3:0000136c-00001398 Module: 61, 4 byte alignment, initialized_data, read, write, 
