// Module: gameapp4.obj
// Source: C:\Copter\source\sparkal\gameapp4.cpp
// autogenerated by simcopter_tool from PDB file

// Type: char *;

// Type: /*unpacked*/ class CGameApp (forward reference);
// CGameApp Class implementation not found

// Type: long;

// Type: /*packed*/ class MRect;
class MRect : public SparkalRect
{ // packed(0x10 bytes) TI: 0x1067
public:
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalSize);
	void MRect(/*packed*/ struct SparkalRect*);
	void MRect(/*packed*/ class MRect*);
	void MRect(const /*packed*/ struct SparkalRect&);
	void MRect(long, long, long, long);
	void MRect();
	long Width();
	long Height();
	/*packed*/ class MSize Size();
	const /*packed*/ class MPoint& TopLeft();
	/*packed*/ class MPoint& TopLeft();
	const /*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint CenterPoint();
	/*packed*/ struct SparkalRect* operator struct SparkalRect *();
	/*packed*/ class MRect* operator class MRect *();
	int32_t IsRectEmpty();
	int32_t IsRectNull();
	int32_t PtInRect(/*packed*/ struct SparkalPoint);
	int32_t PtInRect(long, long);
	int32_t DoesRectOverlap(/*packed*/ struct SparkalRect*);
	void SetRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void SetRect(long, long, long, long);
	void SetRectEmpty();
	void CopyRect(/*packed*/ class MRect*);
	int32_t EqualRect(/*packed*/ class MRect*);
	void InflateRect(long, long, long, long);
	void InflateRect(/*packed*/ class MRect*);
	void InflateRect(/*packed*/ struct SparkalSize);
	void InflateRect(long, long);
	void DeflateRect(long, long, long, long);
	void DeflateRect(/*packed*/ class MRect*);
	void DeflateRect(/*packed*/ struct SparkalSize);
	void DeflateRect(long, long);
	void MoveRect(/*packed*/ struct SparkalPoint);
	void MoveRect(long, long);
	void OffsetRect(/*packed*/ struct SparkalPoint);
	void OffsetRect(/*packed*/ struct SparkalSize);
	void OffsetRect(long, long);
	void NormalizeRect();
	int32_t IntersectRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t UnionRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t SubtractRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t operator==(const /*packed*/ struct SparkalRect&);
	int32_t operator!=(const /*packed*/ struct SparkalRect&);
	void operator+=(/*packed*/ class MRect*);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ class MRect*);
	void operator-=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator&=(const /*packed*/ struct SparkalRect&);
	void operator|=(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(/*packed*/ class MRect*);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator-(/*packed*/ class MRect*);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator&(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator|(const /*packed*/ struct SparkalRect&);
};

// Type: char;

// Type: /*packed*/ struct VRAppInitThreadStruct;
struct VRAppInitThreadStruct{ // packed(0x8 bytes) TI: 0x20a4
	long nReturnValue;
	long nCurrentPercentageComplete;
};

// Type: /*packed*/ class Random;
class Random{ // packed(0xe4 bytes) TI: 0x20ab
public:
	void Random(unsigned long);
	unsigned long operator()(unsigned long);
	void seed(unsigned long);
protected:
	unsigned long table[55];
	uint32_t index1;
	uint32_t index2;
};

// Type: int32_t;

// Type: unsigned long;

// Type: void * __ptr32;

// Type: /*packed*/ class basic_string<char>;
class basic_string<char>{ // packed(0x8 bytes) TI: 0x1380
	using reference_class = /*unpacked*/ class basic_string_ref<char>;
	using reference_pointer = /*unpacked*/ class basic_string_ref<char>*;
private:
	char * c_str_ptr;
	/*unpacked*/ class basic_string_ref<char> *reference;
	char * point();
	uint32_t& len();
	uint32_t ref_count();
	// calltype: NearC
	static char eos();
	void assign_str(char *, uint32_t);
	void append_str(char *, uint32_t);
	void insert_str(uint32_t, char *, uint32_t);
	void replace_str(uint32_t, uint32_t, char *, uint32_t);
	int32_t compare_str(uint32_t, char *, uint32_t, uint32_t);
	uint32_t find_str(char *, uint32_t, uint32_t);
	uint32_t rfind_str(char *, uint32_t, uint32_t);
	uint32_t find_first_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_of_str(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of_str(char *, uint32_t, uint32_t);
public:
	void basic_string<char>(const /*packed*/ class vector<char>&);
	void basic_string<char>(char, uint32_t);
	void basic_string<char>(char *);
	void basic_string<char>(char *, uint32_t);
	void basic_string<char>(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	void basic_string<char>(uint32_t, enum capacity);
	void basic_string<char>();
protected:
	void basic_string<char>(char *, uint32_t, uint32_t);
	void delete_ref();
	using char_type = char;
	using baggage_type = /*packed*/ struct string_char_baggage<char>;
public:
	void ~basic_string<char>();
	/*packed*/ class basic_string<char>& operator=(char);
	/*packed*/ class basic_string<char>& operator=(char *);
	/*packed*/ class basic_string<char>& operator=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class basic_string<char>& operator+=(char);
	/*packed*/ class basic_string<char>& operator+=(char *);
	/*packed*/ class basic_string<char>& operator+=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class vector<char> operator class vector<char>();
	/*packed*/ class basic_string<char>& append(char, uint32_t);
	/*packed*/ class basic_string<char>& append(char *);
	/*packed*/ class basic_string<char>& append(char *, uint32_t);
	/*packed*/ class basic_string<char>& append(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& assign(char, uint32_t);
	/*packed*/ class basic_string<char>& assign(char *);
	/*packed*/ class basic_string<char>& assign(char *, uint32_t);
	/*packed*/ class basic_string<char>& assign(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& remove(uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	char get_at(uint32_t);
	void put_at(uint32_t, char);
	char& operator[](uint32_t);
	char operator[](uint32_t);
	char * c_str();
	char * data();
	uint32_t length();
	void resize(uint32_t);
	void resize(uint32_t, char);
	void reserve(uint32_t);
	uint32_t reserve();
	uint32_t copy(char *, uint32_t, uint32_t);
	uint32_t find(char, uint32_t);
	uint32_t find(char *, uint32_t);
	uint32_t find(char *, uint32_t, uint32_t);
	uint32_t find(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t rfind(char, uint32_t);
	uint32_t rfind(char *, uint32_t);
	uint32_t rfind(char *, uint32_t, uint32_t);
	uint32_t rfind(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_of(char, uint32_t);
	uint32_t find_first_of(char *, uint32_t);
	uint32_t find_first_of(char *, uint32_t, uint32_t);
	uint32_t find_first_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_of(char, uint32_t);
	uint32_t find_last_of(char *, uint32_t);
	uint32_t find_last_of(char *, uint32_t, uint32_t);
	uint32_t find_last_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_not_of(char, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_not_of(char, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	/*packed*/ class basic_string<char> substr(uint32_t, uint32_t);
	int32_t compare(char, uint32_t, uint32_t);
	int32_t compare(char *, uint32_t);
	int32_t compare(char *, uint32_t, uint32_t);
	int32_t compare(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
};

// Type: /*unpacked*/ class SmackerBackBuffer (forward reference);
// SmackerBackBuffer Class implementation not found

// Type: /*packed*/ struct VRAppInitThreadStruct (forward reference);
struct VRAppInitThreadStruct{ // packed(0x8 bytes) TI: 0x20a4
	long nReturnValue;
	long nCurrentPercentageComplete;
};

// Type: void;

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	long left;
	long top;
	long right;
	long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};



// Contribution: 1:000baa30-000bb457 Module: 3, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004bba30
unsigned long  CGameApp::FinishGame() {
// LINE 50:
	__asm        mov    ecx, this;
	__asm        call   CGameApp::PaletteUninitialize;
// LINE 51:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x38];
// LINE 53:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x30], 0;
	__asm        jne    _T7d;
// LINE 54:
// Block start:
	long hResult;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x54];
// LINE 57:
	__asm        jmp    near ptr 0x004BBA6C;

	__asm        push   8;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x50];
	__asm        mov    hResult, eax;
// LINE 58:
	__asm        cmp    hResult, 0;
	__asm        je     _T7d;
// LINE 59:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    near ptr 0x004BBAA0;

	__asm        push   0x59AC54;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 63:
// Block end:
_T7d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Ta7;

	__asm        push   1;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   dword ptr [eax];
	__asm        jmp    _Ta7;
// LINE 64:
_Ta7:
	this-><CGameApp+0x50:4> = 0x0;
// LINE 66:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x14], eax;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 67:
	this-><CGameApp+0x04:4> = 0x0;
// LINE 70:
	__asm        call   DDDisable;
// LINE 73:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004BBB12;
// LINE 74:
}

// FUNCTION: COPTER_D 0x004bbb17
int  CGameApp::BackgroundVRAppInit() {
	/*packed*/ class MRect rectText;
	char szVideoPath[260];
	/*packed*/ struct VRAppInitThreadStruct tempVRAppInitThreadStruct;
	/*packed*/ class Random tempRandom;
	int32_t nXPosition;
	int32_t nHeight;
	unsigned long lCurrentInitializationFlag;
	unsigned long lCurrentInitializationIndex;
	void * __ptr32 hAppInitThread;
	/*packed*/ class MRect rectLine;
	int32_t nWidth;
	int32_t nYPosition;
	/*packed*/ class basic_string<char> sCurrentInitializer;
	unsigned long lFullStringIndex;
	/*unpacked*/ class SmackerBackBuffer tempHourglassVideoBuffer;


	__asm        call   clock;
	__asm        mov    [ebp-0x4CC], eax;
// LINE 97:
	__asm        mov    eax, [ebp-0x4CC];
	__asm        push   eax;
	__asm        lea    ecx, tempRandom.table[0];
	__asm        call   Random::seed;
	__asm        jmp    near ptr 0x004BBB4F;
// LINE 98:
	__asm        jmp    near ptr 0x004BBB54;

	__asm        jmp    near ptr 0x004BBB59;
// LINE 99:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::SmackerBackBuffer;
// LINE 102:
	lCurrentInitializationFlag = 0x1;
// LINE 103:
	lCurrentInitializationIndex = 0x1;
// LINE 105:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x4D0], eax;
	__asm        cmp    dword ptr [ebp-0x4D0], 0;
	__asm        je     _Tcc;

	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x4D0];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    near ptr 0x004BBBD2;

	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    sCurrentInitializer.reference, eax;
	__asm        jmp    _Td6;
_Tcc:
	sCurrentInitializer.reference = 0x0;
_Td6:
	__asm        mov    sCurrentInitializer.c_str_ptr, 0;
	__asm        jmp    near ptr 0x004BBBFC;
// LINE 107:
	__asm        jmp    near ptr 0x004BBC01;

	__asm        jmp    near ptr 0x004BBC06;

	__asm        jmp    near ptr 0x004BBC0B;

	__asm        jmp    near ptr 0x004BBC10;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0xC];
	__asm        sub    eax, 0x14;
	__asm        mov    [ebp-0x504], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        add    eax, 0x64;
	__asm        mov    [ebp-0x508], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0xC];
	__asm        sub    eax, 0x28;
	__asm        mov    [ebp-0x50C], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    eax, 0x64;
	__asm        mov    [ebp-0x510], eax;
	__asm        jmp    near ptr 0x004BBC75;

	__asm        mov    eax, [ebp-0x510];
	__asm        mov    rectText.left, eax;
	__asm        mov    eax, [ebp-0x50C];
	__asm        mov    rectText.top, eax;
	__asm        mov    eax, [ebp-0x508];
	__asm        mov    rectText.right, eax;
	__asm        mov    eax, [ebp-0x504];
	__asm        mov    rectText.bottom, eax;
	__asm        jmp    near ptr 0x004BBCAA;
// LINE 110:
	__asm        lea    eax, szVideoPath[0];
	__asm        push   eax;
	__asm        mov    eax, SZ_HOURGLASS_VIDEO_FILE_NAME;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   1;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFile;
// LINE 111:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::SetDirectBlit;
// LINE 112:
	None = 0x1;
// LINE 113:
	__asm        push   0xFFFFFFFF;
	__asm        push   0xFE000;
	__asm        lea    eax, szVideoPath[0];
	__asm        push   eax;
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::Open;
// LINE 114:
	__asm        jmp    near ptr 0x004BBCF8;

	nWidth = None;
// LINE 115:
	__asm        jmp    near ptr 0x004BBD09;

	nHeight = None;
// LINE 116:
	__asm        jmp    near ptr 0x004BBD1A;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    ecx, eax;
	__asm        mov    eax, nWidth;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    nXPosition, ecx;
// LINE 117:
	__asm        jmp    near ptr 0x004BBD47;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0xC];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    ecx, eax;
	__asm        mov    eax, nHeight;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    nYPosition, ecx;
// LINE 119:
	tempVRAppInitThreadStruct.nReturnValue = 0x0;
// LINE 120:
	tempVRAppInitThreadStruct.nCurrentPercentageComplete = 0x0;
// LINE 122:
	__asm        lea    eax, tempVRAppInitThreadStruct.nReturnValue;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x4BC3DB;
	__asm        call   _beginthread;
	__asm        add    esp, 0xC;
	__asm        mov    hAppInitThread, eax;
// LINE 127:
	__asm        mov    byte ptr [ebp-0x4B8], 0;
	__asm        mov    byte ptr [ebp-0x4B7], 0;
	__asm        mov    byte ptr [ebp-0x4B6], 0;
	__asm        jmp    near ptr 0x004BBDB9;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    [ebp-0x4C8], eax;
	__asm        mov    eax, [ebp-0x4B8];
	__asm        mov    ecx, [ebp-0x4C8];
	__asm        mov    [ecx+0x38], eax;
	__asm        jmp    _T2c5;
// LINE 128:
_T2c5:
	__asm        cmp    tempVRAppInitThreadStruct.nReturnValue, 0;
	__asm        jne    _T685;
// LINE 129:
	__asm        mov    eax, nHeight;
	__asm        push   eax;
	__asm        mov    eax, nWidth;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, nYPosition;
	__asm        push   eax;
	__asm        mov    eax, nXPosition;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        lea    ecx, [ebp-0x13C];
	__asm        call   SmackerBackBuffer::Compose;
// LINE 130:
	__asm        mov    eax, G_InitializationProgress;
	__asm        test   lCurrentInitializationFlag, eax;
	__asm        je     _T661;

	__asm        cmp    lCurrentInitializationFlag, 0x8000;
	__asm        jae    _T661;
// LINE 131:
	__asm        inc    lCurrentInitializationIndex;
// LINE 132:
	__asm        shl    lCurrentInitializationFlag, 1;
// LINE 133:
	__asm        push   0;
	__asm        mov    eax, lCurrentInitializationIndex;
	__asm        add    eax, 0x289;
	__asm        push   eax;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    lFullStringIndex, eax;
// LINE 134:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    eax, lFullStringIndex;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1514], eax;
	__asm        cmp    dword ptr [ebp-0x1514], 0;
	__asm        jne    _T40a;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, lFullStringIndex;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1514], eax;
	__asm        jmp    near ptr 0x004BBECD;

	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        lea    ecx, sCurrentInitializer.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    near ptr 0x004BBEF4;

	__asm        jmp    near ptr 0x004BBEF9;

	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sCurrentInitializer.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    near ptr 0x004BBF1C;

	__asm        jmp    _T5cd;
_T40a:
	__asm        jmp    near ptr 0x004BBF26;

	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1530], eax;
	__asm        cmp    dword ptr [ebp-0x1530], 0xFFFFFFFF;
	__asm        jne    _T469;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1524], eax;
	__asm        mov    eax, [ebp-0x1524];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    near ptr 0x004BBF71;

	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T469;
_T469:
	__asm        jmp    near ptr 0x004BBF85;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T4a5;

	__asm        cmp    dword ptr [ebp-0x1530], 0;
	__asm        je     _T56d;

	__asm        jmp    near ptr 0x004BBFA7;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    ecx, [ebp-0x1530];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T56d;
_T4a5:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x151C], eax;
	__asm        cmp    dword ptr [ebp-0x151C], 0;
	__asm        je     _T4e6;

	__asm        mov    eax, [ebp-0x1530];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x151C];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x1518], eax;
	__asm        jmp    _T4f0;
_T4e6:
	None = 0x0;
_T4f0:
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T557;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    [ebp-0x152C], eax;
	__asm        mov    eax, [ebp-0x152C];
	__asm        mov    [ebp-0x1528], eax;
	__asm        cmp    dword ptr [ebp-0x1528], 0;
	__asm        je     _T557;

	__asm        mov    ecx, [ebp-0x1528];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    near ptr 0x004BC055;

	__asm        mov    eax, [ebp-0x1528];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    near ptr 0x004BC069;

	__asm        jmp    _T557;
_T557:
	__asm        jmp    near ptr 0x004BC073;

	__asm        mov    eax, [ebp-0x1518];
	__asm        mov    sCurrentInitializer.reference, eax;
	__asm        jmp    _T5af;
_T56d:
	__asm        cmp    dword ptr [ebp-0x1530], 0;
	__asm        je     _T5af;

	__asm        jmp    near ptr 0x004BC096;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1520], eax;
	__asm        mov    eax, [ebp-0x1530];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1520];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T5af;
_T5af:
	__asm        mov    eax, [ebp-0x1530];
	__asm        mov    ecx, sCurrentInitializer.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    near ptr 0x004BC0DA;

	__asm        jmp    near ptr 0x004BC0DF;

	__asm        jmp    _T5cd;
// LINE 135:
_T5cd:
	__asm        lea    eax, rectText.left;
	__asm        push   eax;
	__asm        push   0x2E;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+0x18];
// LINE 137:
	__asm        jmp    near ptr 0x004BC109;

	__asm        jmp    near ptr 0x004BC10E;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T61f;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x4C4], eax;
	__asm        jmp    _T62e;

	__asm        jmp    _T62e;
_T61f:
	__asm        mov    dword ptr [ebp-0x4C4], 0;
	__asm        jmp    _T62e;
_T62e:
	__asm        push   0;
	__asm        lea    eax, rectText.left;
	__asm        push   eax;
	__asm        push   1;
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x4C4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+0x48];
// LINE 139:
_T661:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x50];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x50];
	__asm        call   dword ptr [edx+8];
// LINE 140:
	__asm        push   0x1E;
	__asm        call   dword ptr ds:[0x6C35D8];
// LINE 141:
	__asm        jmp    _T2c5;
// LINE 142:
_T685:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBuffer::Close;
// LINE 144:
	__asm        cmp    tempVRAppInitThreadStruct.nReturnValue, 0;
	__asm        jge    _T7ae;
// LINE 145:
	__asm        mov    dword ptr [ebp-0x4BC], 0;
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T75a;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    [ebp-0x4E0], eax;
	__asm        mov    eax, [ebp-0x4E0];
	__asm        mov    [ebp-0x4DC], eax;
	__asm        cmp    dword ptr [ebp-0x4DC], 0;
	__asm        je     _T75a;

	__asm        mov    eax, [ebp-0x4DC];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T737;

	__asm        mov    eax, [ebp-0x4DC];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x4E4], eax;
	__asm        mov    eax, [ebp-0x4E4];
	__asm        mov    [ebp-0x4E8], eax;
	__asm        mov    eax, [ebp-0x4E8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x4DC];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x4DC];
	__asm        mov    dword ptr [eax], 0;
_T737:
	__asm        jmp    near ptr 0x004BC253;

	__asm        jmp    near ptr 0x004BC258;

	__asm        mov    eax, [ebp-0x4DC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    near ptr 0x004BC26C;

	__asm        jmp    _T75a;
_T75a:
	__asm        jmp    near ptr 0x004BC276;

	__asm        cmp    sCurrentInitializer.c_str_ptr, 0;
	__asm        je     _T793;

	__asm        mov    eax, sCurrentInitializer.c_str_ptr;
	__asm        mov    [ebp-0x4D4], eax;
	__asm        mov    eax, [ebp-0x4D4];
	__asm        mov    [ebp-0x4D8], eax;
	__asm        mov    eax, [ebp-0x4D8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T793:
	__asm        jmp    near ptr 0x004BC2AF;

	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::~SmackerBackBuffer;
	__asm        mov    eax, [ebp-0x4BC];
	__asm        jmp    _T8bf;
// LINE 146:
_T7ae:
	__asm        mov    dword ptr [ebp-0x4C0], 1;
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T86b;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    [ebp-0x4F8], eax;
	__asm        mov    eax, [ebp-0x4F8];
	__asm        mov    [ebp-0x4F4], eax;
	__asm        cmp    dword ptr [ebp-0x4F4], 0;
	__asm        je     _T86b;

	__asm        mov    eax, [ebp-0x4F4];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T848;

	__asm        mov    eax, [ebp-0x4F4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x4FC], eax;
	__asm        mov    eax, [ebp-0x4FC];
	__asm        mov    [ebp-0x500], eax;
	__asm        mov    eax, [ebp-0x500];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x4F4];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x4F4];
	__asm        mov    dword ptr [eax], 0;
_T848:
	__asm        jmp    near ptr 0x004BC364;

	__asm        jmp    near ptr 0x004BC369;

	__asm        mov    eax, [ebp-0x4F4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    near ptr 0x004BC37D;

	__asm        jmp    _T86b;
_T86b:
	__asm        jmp    near ptr 0x004BC387;

	__asm        cmp    sCurrentInitializer.c_str_ptr, 0;
	__asm        je     _T8a4;

	__asm        mov    eax, sCurrentInitializer.c_str_ptr;
	__asm        mov    [ebp-0x4EC], eax;
	__asm        mov    eax, [ebp-0x4EC];
	__asm        mov    [ebp-0x4F0], eax;
	__asm        mov    eax, [ebp-0x4F0];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T8a4:
	__asm        jmp    near ptr 0x004BC3C0;

	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::~SmackerBackBuffer;
	__asm        mov    eax, [ebp-0x4C0];
	__asm        jmp    _T8bf;
// LINE 150:
_T8bf:
}

// FUNCTION: COPTER_D 0x004bc3db
void AppInitThreadStartRoutine(void * __ptr32 pVRAppInitThreadStruct) {
	/*packed*/ struct VRAppInitThreadStruct *tempVRAppInitThreadStruct;

	// Function registers exception cleanup function at 0x004bc440

	__asm        mov    [ebp-0x10], esp;
// LINE 160:
	tempVRAppInitThreadStruct = pVRAppInitThreadStruct;
// LINE 165:
	None = 0x0;
// LINE 167:
	__asm        call   VRAppInit;
	__asm        mov    ecx, tempVRAppInitThreadStruct;
	__asm        mov    [ecx], eax;
	__asm        jmp    _T4f;
// LINE 171:
_L48858:
	tempVRAppInitThreadStruct->nReturnValue = 0xffffffff;
// LINE 172:
	__asm        mov    eax, 0x4BC42A;
	__asm        ret;
// LINE 174:
_L44245:
_L44245:
_T4f:
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        mov    eax, tempVRAppInitThreadStruct;
	__asm        mov    dword ptr [eax+4], 0x64;
// LINE 178:
	__asm        jmp    _T6f;
_L48859:
	__asm        mov    eax, 0x595CE0;
	__asm        jmp    near ptr 0x0056F590;
_T6f:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    fs:[0], eax;
}



// Contribution: 2:00006ce0-00006d37 Module: 3, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00003c44-00003c95 Module: 3, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x0059ac44
char * SZ_HOURGLASS_VIDEO_FILE_NAME = { 0 /* todo */ };

