// Module: gameapp4.obj
// Source: C:\Copter\source\sparkal\gameapp4.cpp
// autogenerated by simcopter_tool from PDB file

// Type: char *;

// Type: long;

// Type: /*packed*/ class MRect;
class MRect : public SparkalRect
{ // packed(0x10 bytes) TI: 0x1067
public:
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalSize);
	void MRect(/*packed*/ struct SparkalRect*);
	void MRect(/*packed*/ class MRect*);
	void MRect(const /*packed*/ struct SparkalRect&);
	void MRect(long, long, long, long);
	void MRect();
	long Width();
	long Height();
	/*packed*/ class MSize Size();
	const /*packed*/ class MPoint& TopLeft();
	/*packed*/ class MPoint& TopLeft();
	const /*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint CenterPoint();
	/*packed*/ struct SparkalRect* operator struct SparkalRect *();
	/*packed*/ class MRect* operator class MRect *();
	int32_t IsRectEmpty();
	int32_t IsRectNull();
	int32_t PtInRect(/*packed*/ struct SparkalPoint);
	int32_t PtInRect(long, long);
	int32_t DoesRectOverlap(/*packed*/ struct SparkalRect*);
	void SetRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void SetRect(long, long, long, long);
	void SetRectEmpty();
	void CopyRect(/*packed*/ class MRect*);
	int32_t EqualRect(/*packed*/ class MRect*);
	void InflateRect(long, long, long, long);
	void InflateRect(/*packed*/ class MRect*);
	void InflateRect(/*packed*/ struct SparkalSize);
	void InflateRect(long, long);
	void DeflateRect(long, long, long, long);
	void DeflateRect(/*packed*/ class MRect*);
	void DeflateRect(/*packed*/ struct SparkalSize);
	void DeflateRect(long, long);
	void MoveRect(/*packed*/ struct SparkalPoint);
	void MoveRect(long, long);
	void OffsetRect(/*packed*/ struct SparkalPoint);
	void OffsetRect(/*packed*/ struct SparkalSize);
	void OffsetRect(long, long);
	void NormalizeRect();
	int32_t IntersectRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t UnionRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t SubtractRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t operator==(const /*packed*/ struct SparkalRect&);
	int32_t operator!=(const /*packed*/ struct SparkalRect&);
	void operator+=(/*packed*/ class MRect*);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ class MRect*);
	void operator-=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator&=(const /*packed*/ struct SparkalRect&);
	void operator|=(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(/*packed*/ class MRect*);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator-(/*packed*/ class MRect*);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator&(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator|(const /*packed*/ struct SparkalRect&);
};

// Type: char;

// Type: /*packed*/ struct VRAppInitThreadStruct;
struct VRAppInitThreadStruct{ // packed(0x8 bytes) TI: 0x20a4
	/*+0x0*/   long nReturnValue;
	/*+0x4*/   long nCurrentPercentageComplete;
};

// Type: /*packed*/ class Random;
class Random{ // packed(0xe4 bytes) TI: 0x20ab
public:
	void Random(unsigned long);
	unsigned long operator()(unsigned long);
	void seed(unsigned long);
protected:
	/*+0x0*/   unsigned long table[55]; // 0xdc bytes
	/*+0xdc*/  uint32_t index1;
	/*+0xe0*/  uint32_t index2;
};

// Type: int32_t;

// Type: unsigned long;

// Type: void * __ptr32;

// Type: /*packed*/ class basic_string<char>;
class basic_string<char>{ // packed(0x8 bytes) TI: 0x1380
	using reference_class = /*unpacked*/ class basic_string_ref<char>;
	using reference_pointer = /*unpacked*/ class basic_string_ref<char>*;
private:
	/*+0x0*/   char * c_str_ptr;
	/*+0x4*/   /*unpacked*/ class basic_string_ref<char> *reference;
	char * point();
	uint32_t& len();
	uint32_t ref_count();
	// calltype: NearC
	static char eos();
	void assign_str(char *, uint32_t);
	void append_str(char *, uint32_t);
	void insert_str(uint32_t, char *, uint32_t);
	void replace_str(uint32_t, uint32_t, char *, uint32_t);
	int32_t compare_str(uint32_t, char *, uint32_t, uint32_t);
	uint32_t find_str(char *, uint32_t, uint32_t);
	uint32_t rfind_str(char *, uint32_t, uint32_t);
	uint32_t find_first_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_of_str(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of_str(char *, uint32_t, uint32_t);
public:
	void basic_string<char>(const /*packed*/ class vector<char>&);
	void basic_string<char>(char, uint32_t);
	void basic_string<char>(char *);
	void basic_string<char>(char *, uint32_t);
	void basic_string<char>(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	void basic_string<char>(uint32_t, enum capacity);
	void basic_string<char>();
protected:
	void basic_string<char>(char *, uint32_t, uint32_t);
	void delete_ref();
	using char_type = char;
	using baggage_type = /*packed*/ struct string_char_baggage<char>;
public:
	void ~basic_string<char>();
	/*packed*/ class basic_string<char>& operator=(char);
	/*packed*/ class basic_string<char>& operator=(char *);
	/*packed*/ class basic_string<char>& operator=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class basic_string<char>& operator+=(char);
	/*packed*/ class basic_string<char>& operator+=(char *);
	/*packed*/ class basic_string<char>& operator+=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class vector<char> operator class vector<char>();
	/*packed*/ class basic_string<char>& append(char, uint32_t);
	/*packed*/ class basic_string<char>& append(char *);
	/*packed*/ class basic_string<char>& append(char *, uint32_t);
	/*packed*/ class basic_string<char>& append(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& assign(char, uint32_t);
	/*packed*/ class basic_string<char>& assign(char *);
	/*packed*/ class basic_string<char>& assign(char *, uint32_t);
	/*packed*/ class basic_string<char>& assign(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& remove(uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	char get_at(uint32_t);
	void put_at(uint32_t, char);
	char& operator[](uint32_t);
	char operator[](uint32_t);
	char * c_str();
	char * data();
	uint32_t length();
	void resize(uint32_t);
	void resize(uint32_t, char);
	void reserve(uint32_t);
	uint32_t reserve();
	uint32_t copy(char *, uint32_t, uint32_t);
	uint32_t find(char, uint32_t);
	uint32_t find(char *, uint32_t);
	uint32_t find(char *, uint32_t, uint32_t);
	uint32_t find(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t rfind(char, uint32_t);
	uint32_t rfind(char *, uint32_t);
	uint32_t rfind(char *, uint32_t, uint32_t);
	uint32_t rfind(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_of(char, uint32_t);
	uint32_t find_first_of(char *, uint32_t);
	uint32_t find_first_of(char *, uint32_t, uint32_t);
	uint32_t find_first_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_of(char, uint32_t);
	uint32_t find_last_of(char *, uint32_t);
	uint32_t find_last_of(char *, uint32_t, uint32_t);
	uint32_t find_last_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_not_of(char, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_not_of(char, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	/*packed*/ class basic_string<char> substr(uint32_t, uint32_t);
	int32_t compare(char, uint32_t, uint32_t);
	int32_t compare(char *, uint32_t);
	int32_t compare(char *, uint32_t, uint32_t);
	int32_t compare(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
};

// Type: /*unpacked*/ class SmackerBackBuffer (forward reference);
// SmackerBackBuffer Class implementation not found

// Type: /*packed*/ struct VRAppInitThreadStruct (forward reference);
struct VRAppInitThreadStruct{ // packed(0x8 bytes) TI: 0x20a4
	/*+0x0*/   long nReturnValue;
	/*+0x4*/   long nCurrentPercentageComplete;
};

// Type: void;

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};



// Contribution: 1:000baa30-000bb457 Module: 3, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004bba30
unsigned long  CGameApp::FinishGame() {
// LINE 50:
	__asm        mov    ecx, this;
	__asm        call   CGameApp::PaletteUninitialize;
// LINE 51:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x38];
// LINE 53:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x30], 0;
	__asm        jne    _T7d;
// LINE 54:
// Block start:
	/*bp-0x4*/   long hResult;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x54];
// LINE 57:
	__asm        jmp    _T3c;
_T3c:
	__asm        push   8;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x50];
	__asm        mov    hResult, eax;
// LINE 58:
	__asm        cmp    hResult, 0;
	__asm        je     _T7d;
// LINE 59:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T70;
_T70:
	__asm        push   0x59AC54;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 63:
// Block end:
_T7d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Ta7;

	__asm        push   1;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   dword ptr [eax];
	__asm        jmp    _Ta7;
// LINE 64:
_Ta7:
	this-><CGameApp+0x50:4> = 0x0;
// LINE 66:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x14], eax;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 67:
	this-><CGameApp+0x04:4> = 0x0;
// LINE 70:
	__asm        call   DDDisable;
// LINE 73:
	return 0x0;
// LINE 74:
}

// FUNCTION: COPTER_D 0x004bbb17
int  CGameApp::BackgroundVRAppInit() {
	/*bp-0x27c*/ /*unpacked*/ class SmackerBackBuffer tempHourglassVideoBuffer;
	/*bp-0x280*/ unsigned long lFullStringIndex;
	/*bp-0x288*/ /*packed*/ class basic_string<char> sCurrentInitializer; // 0x8 bytes
	/*bp-0x28c*/ int32_t nYPosition;
	/*bp-0x290*/ int32_t nWidth;
	/*bp-0x2a0*/ /*packed*/ class MRect rectLine; // 0x10 bytes
	/*bp-0x2a4*/ void * __ptr32 hAppInitThread;
	/*bp-0x2a8*/ unsigned long lCurrentInitializationIndex;
	/*bp-0x2ac*/ unsigned long lCurrentInitializationFlag;
	/*bp-0x2b0*/ int32_t nHeight;
	/*bp-0x2b4*/ int32_t nXPosition;
	/*bp-0x398*/ /*packed*/ class Random tempRandom; // 0xe4 bytes
	/*bp-0x3a0*/ /*packed*/ struct VRAppInitThreadStruct tempVRAppInitThreadStruct; // 0x8 bytes
	/*bp-0x4a4*/ char szVideoPath[260]; // 0x104 bytes
	/*bp-0x4b4*/ /*packed*/ class MRect rectText; // 0x10 bytes


	__asm        call   clock;
	__asm        mov    [ebp-0x4CC], eax;
// LINE 97:
	__asm        mov    eax, [ebp-0x4CC];
	__asm        push   eax;
	__asm        lea    ecx, tempRandom.table[0];
	__asm        call   Random::seed;
	__asm        jmp    _T38;
// LINE 98:
_T38:
	__asm        jmp    _T3d;
_T3d:
	__asm        jmp    _T42;
// LINE 99:
_T42:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::SmackerBackBuffer;
// LINE 102:
	lCurrentInitializationFlag = 0x1;
// LINE 103:
	lCurrentInitializationIndex = 0x1;
// LINE 105:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x4D0], eax;
	__asm        cmp    dword ptr [ebp-0x4D0], 0;
	__asm        je     _Tcc;

	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x4D0];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _Tbb;
_Tbb:
	__asm        mov    eax, [ebp-0x4D0];
	__asm        mov    sCurrentInitializer.reference, eax;
	__asm        jmp    _Td6;
_Tcc:
	sCurrentInitializer.reference = 0x0;
_Td6:
	__asm        mov    sCurrentInitializer.c_str_ptr, 0;
	__asm        jmp    _Te5;
// LINE 107:
_Te5:
	__asm        jmp    _Tea;
_Tea:
	__asm        jmp    _Tef;
_Tef:
	__asm        jmp    _Tf4;
_Tf4:
	__asm        jmp    _Tf9;
_Tf9:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0xC];
	__asm        sub    eax, 0x14;
	__asm        mov    [ebp-0x504], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        add    eax, 0x64;
	__asm        mov    [ebp-0x508], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0xC];
	__asm        sub    eax, 0x28;
	__asm        mov    [ebp-0x50C], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    eax, 0x64;
	__asm        mov    [ebp-0x510], eax;
	__asm        jmp    _T15e;
_T15e:
	__asm        mov    eax, [ebp-0x510];
	__asm        mov    rectText.left, eax;
	__asm        mov    eax, [ebp-0x50C];
	__asm        mov    rectText.top, eax;
	__asm        mov    eax, [ebp-0x508];
	__asm        mov    rectText.right, eax;
	__asm        mov    eax, [ebp-0x504];
	__asm        mov    rectText.bottom, eax;
	__asm        jmp    _T193;
// LINE 110:
_T193:
	__asm        lea    eax, szVideoPath[0];
	__asm        push   eax;
	__asm        mov    eax, SZ_HOURGLASS_VIDEO_FILE_NAME;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   1;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFile;
// LINE 111:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::SetDirectBlit;
// LINE 112:
	__asm        mov    dword ptr [ebp-0x274], 1;
// LINE 113:
	__asm        push   0xFFFFFFFF;
	__asm        push   0xFE000;
	__asm        lea    eax, szVideoPath[0];
	__asm        push   eax;
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::Open;
// LINE 114:
	__asm        jmp    _T1e1;
_T1e1:
	__asm        mov    eax, [ebp-0x134];
	__asm        mov    nWidth, eax;
// LINE 115:
	__asm        jmp    _T1f2;
_T1f2:
	__asm        mov    eax, [ebp-0x130];
	__asm        mov    nHeight, eax;
// LINE 116:
	__asm        jmp    _T203;
_T203:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    ecx, eax;
	__asm        mov    eax, nWidth;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    nXPosition, ecx;
// LINE 117:
	__asm        jmp    _T230;
_T230:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0xC];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    ecx, eax;
	__asm        mov    eax, nHeight;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    nYPosition, ecx;
// LINE 119:
	tempVRAppInitThreadStruct.nReturnValue = 0x0;
// LINE 120:
	tempVRAppInitThreadStruct.nCurrentPercentageComplete = 0x0;
// LINE 122:
	__asm        lea    eax, tempVRAppInitThreadStruct.nReturnValue;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x4BC3DB;
	__asm        call   _beginthread;
	__asm        add    esp, 0xC;
	__asm        mov    hAppInitThread, eax;
// LINE 127:
	__asm        mov    byte ptr [ebp-0x4B8], 0;
	__asm        mov    byte ptr [ebp-0x4B7], 0;
	__asm        mov    byte ptr [ebp-0x4B6], 0;
	__asm        jmp    _T2a2;
_T2a2:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    [ebp-0x4C8], eax;
	__asm        mov    eax, [ebp-0x4B8];
	__asm        mov    ecx, [ebp-0x4C8];
	__asm        mov    [ecx+0x38], eax;
	__asm        jmp    _T2c5;
// LINE 128:
_T2c5:
	__asm        cmp    tempVRAppInitThreadStruct.nReturnValue, 0;
	__asm        jne    _T685;
// LINE 129:
	__asm        mov    eax, nHeight;
	__asm        push   eax;
	__asm        mov    eax, nWidth;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, nYPosition;
	__asm        push   eax;
	__asm        mov    eax, nXPosition;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        lea    ecx, [ebp-0x13C];
	__asm        call   SmackerBackBuffer::Compose;
// LINE 130:
	__asm        mov    eax, G_InitializationProgress;
	__asm        test   lCurrentInitializationFlag, eax;
	__asm        je     _T661;

	__asm        cmp    lCurrentInitializationFlag, 0x8000;
	__asm        jae    _T661;
// LINE 131:
	lCurrentInitializationIndex++;
// LINE 132:
	__asm        shl    lCurrentInitializationFlag, 1;
// LINE 133:
	__asm        push   0;
	__asm        mov    eax, lCurrentInitializationIndex;
	__asm        add    eax, 0x289;
	__asm        push   eax;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    lFullStringIndex, eax;
// LINE 134:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    eax, lFullStringIndex;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1514], eax;
	__asm        cmp    dword ptr [ebp-0x1514], 0;
	__asm        jne    _T40a;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, lFullStringIndex;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1514], eax;
	__asm        jmp    _T3b6;
_T3b6:
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        lea    ecx, sCurrentInitializer.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T3dd;
_T3dd:
	__asm        jmp    _T3e2;
_T3e2:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sCurrentInitializer.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T405;
_T405:
	__asm        jmp    _T5cd;
_T40a:
	__asm        jmp    _T40f;
_T40f:
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1530], eax;
	__asm        cmp    dword ptr [ebp-0x1530], 0xFFFFFFFF;
	__asm        jne    _T469;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1524], eax;
	__asm        mov    eax, [ebp-0x1524];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T45a;
_T45a:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T469;
_T469:
	__asm        jmp    _T46e;
_T46e:
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T4a5;

	__asm        cmp    dword ptr [ebp-0x1530], 0;
	__asm        je     _T56d;

	__asm        jmp    _T490;
_T490:
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    ecx, [ebp-0x1530];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T56d;
_T4a5:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x151C], eax;
	__asm        cmp    dword ptr [ebp-0x151C], 0;
	__asm        je     _T4e6;

	__asm        mov    eax, [ebp-0x1530];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x151C];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x1518], eax;
	__asm        jmp    _T4f0;
_T4e6:
	__asm        mov    dword ptr [ebp-0x1518], 0;
_T4f0:
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T557;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    [ebp-0x152C], eax;
	__asm        mov    eax, [ebp-0x152C];
	__asm        mov    [ebp-0x1528], eax;
	__asm        cmp    dword ptr [ebp-0x1528], 0;
	__asm        je     _T557;

	__asm        mov    ecx, [ebp-0x1528];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T53e;
_T53e:
	__asm        mov    eax, [ebp-0x1528];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T552;
_T552:
	__asm        jmp    _T557;
_T557:
	__asm        jmp    _T55c;
_T55c:
	__asm        mov    eax, [ebp-0x1518];
	__asm        mov    sCurrentInitializer.reference, eax;
	__asm        jmp    _T5af;
_T56d:
	__asm        cmp    dword ptr [ebp-0x1530], 0;
	__asm        je     _T5af;

	__asm        jmp    _T57f;
_T57f:
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1520], eax;
	__asm        mov    eax, [ebp-0x1530];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1510];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1520];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T5af;
_T5af:
	__asm        mov    eax, [ebp-0x1530];
	__asm        mov    ecx, sCurrentInitializer.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T5c3;
_T5c3:
	__asm        jmp    _T5c8;
_T5c8:
	__asm        jmp    _T5cd;
// LINE 135:
_T5cd:
	__asm        lea    eax, rectText.left;
	__asm        push   eax;
	__asm        push   0x2E;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+0x18];
// LINE 137:
	__asm        jmp    _T5f2;
_T5f2:
	__asm        jmp    _T5f7;
_T5f7:
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T61f;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x4C4], eax;
	__asm        jmp    _T62e;

	__asm        jmp    _T62e;
_T61f:
	__asm        mov    dword ptr [ebp-0x4C4], 0;
	__asm        jmp    _T62e;
_T62e:
	__asm        push   0;
	__asm        lea    eax, rectText.left;
	__asm        push   eax;
	__asm        push   1;
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x4C4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+0x48];
// LINE 139:
_T661:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x50];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x50];
	__asm        call   dword ptr [edx+8];
// LINE 140:
	__asm        push   0x1E;
	__asm        call   dword ptr ds:[0x6C35D8];
// LINE 141:
	__asm        jmp    _T2c5;
// LINE 142:
_T685:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBuffer::Close;
// LINE 144:
	__asm        cmp    tempVRAppInitThreadStruct.nReturnValue, 0;
	__asm        jge    _T7ae;
// LINE 145:
	__asm        mov    dword ptr [ebp-0x4BC], 0;
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T75a;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    [ebp-0x4E0], eax;
	__asm        mov    eax, [ebp-0x4E0];
	__asm        mov    [ebp-0x4DC], eax;
	__asm        cmp    dword ptr [ebp-0x4DC], 0;
	__asm        je     _T75a;

	__asm        mov    eax, [ebp-0x4DC];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T737;

	__asm        mov    eax, [ebp-0x4DC];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x4E4], eax;
	__asm        mov    eax, [ebp-0x4E4];
	__asm        mov    [ebp-0x4E8], eax;
	__asm        mov    eax, [ebp-0x4E8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x4DC];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x4DC];
	__asm        mov    dword ptr [eax], 0;
_T737:
	__asm        jmp    _T73c;
_T73c:
	__asm        jmp    _T741;
_T741:
	__asm        mov    eax, [ebp-0x4DC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T755;
_T755:
	__asm        jmp    _T75a;
_T75a:
	__asm        jmp    _T75f;
_T75f:
	__asm        cmp    sCurrentInitializer.c_str_ptr, 0;
	__asm        je     _T793;

	__asm        mov    eax, sCurrentInitializer.c_str_ptr;
	__asm        mov    [ebp-0x4D4], eax;
	__asm        mov    eax, [ebp-0x4D4];
	__asm        mov    [ebp-0x4D8], eax;
	__asm        mov    eax, [ebp-0x4D8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T793:
	__asm        jmp    _T798;
_T798:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::~SmackerBackBuffer;
	__asm        mov    eax, [ebp-0x4BC];
	__asm        jmp    __RETURN;
// LINE 146:
_T7ae:
	__asm        mov    dword ptr [ebp-0x4C0], 1;
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T86b;

	__asm        mov    eax, sCurrentInitializer.reference;
	__asm        mov    [ebp-0x4F8], eax;
	__asm        mov    eax, [ebp-0x4F8];
	__asm        mov    [ebp-0x4F4], eax;
	__asm        cmp    dword ptr [ebp-0x4F4], 0;
	__asm        je     _T86b;

	__asm        mov    eax, [ebp-0x4F4];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T848;

	__asm        mov    eax, [ebp-0x4F4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x4FC], eax;
	__asm        mov    eax, [ebp-0x4FC];
	__asm        mov    [ebp-0x500], eax;
	__asm        mov    eax, [ebp-0x500];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x4F4];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x4F4];
	__asm        mov    dword ptr [eax], 0;
_T848:
	__asm        jmp    _T84d;
_T84d:
	__asm        jmp    _T852;
_T852:
	__asm        mov    eax, [ebp-0x4F4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T866;
_T866:
	__asm        jmp    _T86b;
_T86b:
	__asm        jmp    _T870;
_T870:
	__asm        cmp    sCurrentInitializer.c_str_ptr, 0;
	__asm        je     _T8a4;

	__asm        mov    eax, sCurrentInitializer.c_str_ptr;
	__asm        mov    [ebp-0x4EC], eax;
	__asm        mov    eax, [ebp-0x4EC];
	__asm        mov    [ebp-0x4F0], eax;
	__asm        mov    eax, [ebp-0x4F0];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T8a4:
	__asm        jmp    _T8a9;
_T8a9:
	__asm        lea    ecx, tempHourglassVideoBuffer<SmackerBackBuffer+0x00:None>;
	__asm        call   SmackerBackBuffer::~SmackerBackBuffer;
	__asm        mov    eax, [ebp-0x4C0];
	__asm        jmp    __RETURN;
// LINE 150:
__RETURN:
}

// FUNCTION: COPTER_D 0x004bc3db
void AppInitThreadStartRoutine(void * __ptr32 pVRAppInitThreadStruct) {
	/*bp-0x14*/  /*packed*/ struct VRAppInitThreadStruct *tempVRAppInitThreadStruct;

	// Function registers exception cleanup function at 0x004bc440

	__asm        mov    [ebp-0x10], esp;
// LINE 160:
	tempVRAppInitThreadStruct = pVRAppInitThreadStruct;
// LINE 165:
	__asm        mov    dword ptr [ebp-4], 0;
// LINE 167:
	__asm        call   VRAppInit;
	__asm        mov    ecx, tempVRAppInitThreadStruct;
	__asm        mov    [ecx], eax;
	__asm        jmp    _L44245;
// LINE 171:
_L48858:
	tempVRAppInitThreadStruct->nReturnValue = 0xffffffff;
// LINE 172:
	__asm        mov    eax, 0x4BC42A;
	__asm        ret;
// LINE 174:
_L44245:
_L44245:
// No fallthrough
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        mov    eax, tempVRAppInitThreadStruct;
	__asm        mov    dword ptr [eax+4], 0x64;
// LINE 178:
	return;
_L48859:
	__asm        mov    eax, 0x595CE0;
	__asm        jmp    near ptr 0x0056F590;

	__asm        mov    eax, [ebp-0xC];
	__asm        mov    fs:[0], eax;
}



// Contribution: 2:00006ce0-00006d37 Module: 3, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00003c44-00003c95 Module: 3, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x0059ac44
char * SZ_HOURGLASS_VIDEO_FILE_NAME = { 0 /* todo */ };

