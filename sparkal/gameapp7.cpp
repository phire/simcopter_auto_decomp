// Module: Gameapp7.obj
// Source: C:\Copter\source\sparkal\Gameapp7.cpp
// autogenerated by simcopter_tool from PDB file

// Type: char *;

// Type: long;

// Type: void;

// Type: /*unpacked*/ class CGameApp (forward reference);
// CGameApp Class implementation not found

// Type: char;

// Type: /*packed*/ class Version;
// VTABLE: COPTER_D 0x0058f5b8
class Version{ // packed(0xc bytes) TI: 0x241c
public:
	void Version();
	virtual void ~Version(); // vtable+0x0
	int32_t GetApplicationName(char *&);
	long GetApplicationVersion(int32_t);
	int32_t GetApplicationVersion(char *&);
	int32_t GetApplicationCopyright(char *&);
	int32_t GetApplicationDebugVersion(char *&);
	// calltype: NearC
	static int32_t GetSystemType();
	// calltype: NearC
	static long GetSystemVersion(int32_t);
	// calltype: NearC
	static int32_t GetSystemVersion(char *);
	// calltype: NearC
	static long GetCPUVersion();
	// calltype: NearC
	static long GetCPUSpeed();
protected:
	/*+0x4*/   unsigned char * lpTransBlock;
	/*+0x8*/   void * __ptr32 lpFVData;
};

// Type: int32_t;

// Type: /*packed*/ struct _MEMORYSTATUS;
struct _MEMORYSTATUS{ // packed(0x20 bytes) TI: 0x241e
	/*+0x0*/   unsigned long dwLength;
	/*+0x4*/   unsigned long dwMemoryLoad;
	/*+0x8*/   unsigned long dwTotalPhys;
	/*+0xc*/   unsigned long dwAvailPhys;
	/*+0x10*/  unsigned long dwTotalPageFile;
	/*+0x14*/  unsigned long dwAvailPageFile;
	/*+0x18*/  unsigned long dwTotalVirtual;
	/*+0x1c*/  unsigned long dwAvailVirtual;
};

// Type: /*packed*/ class basic_string<char>;
class basic_string<char>{ // packed(0x8 bytes) TI: 0x1380
	using reference_class = /*unpacked*/ class basic_string_ref<char>;
	using reference_pointer = /*unpacked*/ class basic_string_ref<char>*;
private:
	/*+0x0*/   char * c_str_ptr;
	/*+0x4*/   /*unpacked*/ class basic_string_ref<char> *reference;
	char * point();
	uint32_t& len();
	uint32_t ref_count();
	// calltype: NearC
	static char eos();
	void assign_str(char *, uint32_t);
	void append_str(char *, uint32_t);
	void insert_str(uint32_t, char *, uint32_t);
	void replace_str(uint32_t, uint32_t, char *, uint32_t);
	int32_t compare_str(uint32_t, char *, uint32_t, uint32_t);
	uint32_t find_str(char *, uint32_t, uint32_t);
	uint32_t rfind_str(char *, uint32_t, uint32_t);
	uint32_t find_first_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_of_str(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of_str(char *, uint32_t, uint32_t);
public:
	void basic_string<char>(const /*packed*/ class vector<char>&);
	void basic_string<char>(char, uint32_t);
	void basic_string<char>(char *);
	void basic_string<char>(char *, uint32_t);
	void basic_string<char>(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	void basic_string<char>(uint32_t, enum capacity);
	void basic_string<char>();
protected:
	void basic_string<char>(char *, uint32_t, uint32_t);
	void delete_ref();
	using char_type = char;
	using baggage_type = /*packed*/ struct string_char_baggage<char>;
public:
	void ~basic_string<char>();
	/*packed*/ class basic_string<char>& operator=(char);
	/*packed*/ class basic_string<char>& operator=(char *);
	/*packed*/ class basic_string<char>& operator=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class basic_string<char>& operator+=(char);
	/*packed*/ class basic_string<char>& operator+=(char *);
	/*packed*/ class basic_string<char>& operator+=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class vector<char> operator class vector<char>();
	/*packed*/ class basic_string<char>& append(char, uint32_t);
	/*packed*/ class basic_string<char>& append(char *);
	/*packed*/ class basic_string<char>& append(char *, uint32_t);
	/*packed*/ class basic_string<char>& append(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& assign(char, uint32_t);
	/*packed*/ class basic_string<char>& assign(char *);
	/*packed*/ class basic_string<char>& assign(char *, uint32_t);
	/*packed*/ class basic_string<char>& assign(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& remove(uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	char get_at(uint32_t);
	void put_at(uint32_t, char);
	char& operator[](uint32_t);
	char operator[](uint32_t);
	char * c_str();
	char * data();
	uint32_t length();
	void resize(uint32_t);
	void resize(uint32_t, char);
	void reserve(uint32_t);
	uint32_t reserve();
	uint32_t copy(char *, uint32_t, uint32_t);
	uint32_t find(char, uint32_t);
	uint32_t find(char *, uint32_t);
	uint32_t find(char *, uint32_t, uint32_t);
	uint32_t find(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t rfind(char, uint32_t);
	uint32_t rfind(char *, uint32_t);
	uint32_t rfind(char *, uint32_t, uint32_t);
	uint32_t rfind(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_of(char, uint32_t);
	uint32_t find_first_of(char *, uint32_t);
	uint32_t find_first_of(char *, uint32_t, uint32_t);
	uint32_t find_first_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_of(char, uint32_t);
	uint32_t find_last_of(char *, uint32_t);
	uint32_t find_last_of(char *, uint32_t, uint32_t);
	uint32_t find_last_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_not_of(char, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_not_of(char, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	/*packed*/ class basic_string<char> substr(uint32_t, uint32_t);
	int32_t compare(char, uint32_t, uint32_t);
	int32_t compare(char *, uint32_t);
	int32_t compare(char *, uint32_t, uint32_t);
	int32_t compare(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
};

// Type: /*packed*/ class basic_string<char> (forward reference);
class basic_string<char>{ // packed(0x8 bytes) TI: 0x1380
	using reference_class = /*unpacked*/ class basic_string_ref<char>;
	using reference_pointer = /*unpacked*/ class basic_string_ref<char>*;
private:
	/*+0x0*/   char * c_str_ptr;
	/*+0x4*/   /*unpacked*/ class basic_string_ref<char> *reference;
	char * point();
	uint32_t& len();
	uint32_t ref_count();
	// calltype: NearC
	static char eos();
	void assign_str(char *, uint32_t);
	void append_str(char *, uint32_t);
	void insert_str(uint32_t, char *, uint32_t);
	void replace_str(uint32_t, uint32_t, char *, uint32_t);
	int32_t compare_str(uint32_t, char *, uint32_t, uint32_t);
	uint32_t find_str(char *, uint32_t, uint32_t);
	uint32_t rfind_str(char *, uint32_t, uint32_t);
	uint32_t find_first_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_of_str(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of_str(char *, uint32_t, uint32_t);
public:
	void basic_string<char>(const /*packed*/ class vector<char>&);
	void basic_string<char>(char, uint32_t);
	void basic_string<char>(char *);
	void basic_string<char>(char *, uint32_t);
	void basic_string<char>(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	void basic_string<char>(uint32_t, enum capacity);
	void basic_string<char>();
protected:
	void basic_string<char>(char *, uint32_t, uint32_t);
	void delete_ref();
	using char_type = char;
	using baggage_type = /*packed*/ struct string_char_baggage<char>;
public:
	void ~basic_string<char>();
	/*packed*/ class basic_string<char>& operator=(char);
	/*packed*/ class basic_string<char>& operator=(char *);
	/*packed*/ class basic_string<char>& operator=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class basic_string<char>& operator+=(char);
	/*packed*/ class basic_string<char>& operator+=(char *);
	/*packed*/ class basic_string<char>& operator+=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class vector<char> operator class vector<char>();
	/*packed*/ class basic_string<char>& append(char, uint32_t);
	/*packed*/ class basic_string<char>& append(char *);
	/*packed*/ class basic_string<char>& append(char *, uint32_t);
	/*packed*/ class basic_string<char>& append(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& assign(char, uint32_t);
	/*packed*/ class basic_string<char>& assign(char *);
	/*packed*/ class basic_string<char>& assign(char *, uint32_t);
	/*packed*/ class basic_string<char>& assign(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& remove(uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	char get_at(uint32_t);
	void put_at(uint32_t, char);
	char& operator[](uint32_t);
	char operator[](uint32_t);
	char * c_str();
	char * data();
	uint32_t length();
	void resize(uint32_t);
	void resize(uint32_t, char);
	void reserve(uint32_t);
	uint32_t reserve();
	uint32_t copy(char *, uint32_t, uint32_t);
	uint32_t find(char, uint32_t);
	uint32_t find(char *, uint32_t);
	uint32_t find(char *, uint32_t, uint32_t);
	uint32_t find(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t rfind(char, uint32_t);
	uint32_t rfind(char *, uint32_t);
	uint32_t rfind(char *, uint32_t, uint32_t);
	uint32_t rfind(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_of(char, uint32_t);
	uint32_t find_first_of(char *, uint32_t);
	uint32_t find_first_of(char *, uint32_t, uint32_t);
	uint32_t find_first_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_of(char, uint32_t);
	uint32_t find_last_of(char *, uint32_t);
	uint32_t find_last_of(char *, uint32_t, uint32_t);
	uint32_t find_last_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_not_of(char, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_not_of(char, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	/*packed*/ class basic_string<char> substr(uint32_t, uint32_t);
	int32_t compare(char, uint32_t, uint32_t);
	int32_t compare(char *, uint32_t);
	int32_t compare(char *, uint32_t, uint32_t);
	int32_t compare(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
};

// Type: /*packed*/ struct SparkalColor;
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: /*packed*/ class MessageBoxWindow (forward reference);
// VTABLE: COPTER_D 0x0058fa80
class MessageBoxWindow : public GraphicWindow
{ // packed(0xa4 bytes) TI: 0x2a45
public:
	void MessageBoxWindow(/*packed*/ class MPoint&, unsigned long, /*packed*/ class basic_string<char>&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t, int32_t, char *, char *, char *);
	void MessageBoxWindow(/*packed*/ class MPoint&, unsigned long, unsigned long, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t, int32_t, char *, char *, char *);
	virtual int32_t Initialize() /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual void SetTextColor(const /*packed*/ struct SparkalColor&); // vtable+0xc4
	virtual void SetButtonTextColor(const /*packed*/ struct SparkalColor*, const /*packed*/ struct SparkalColor*); // vtable+0xc8
protected:
	virtual int32_t ConvertTypeToStringID(long); // vtable+0xcc
	virtual void DrawTextOntoBox(); // vtable+0xd0
	/*+0x74*/  long lMessageID;
	/*+0x78*/  /*packed*/ class basic_string<char> sMessage; // 0x8 bytes
	/*+0x80*/  /*packed*/ class basic_string<char> sButtonImageFileName; // 0x8 bytes
	/*+0x88*/  /*packed*/ class basic_string<char> sAnimationImageFileName; // 0x8 bytes
	/*+0x90*/  long lType;
	/*+0x94*/  int32_t bSelfDeleting;
	/*+0x98*/  /*packed*/ struct SparkalColor colorFont;
	/*+0x9c*/  /*packed*/ struct SparkalColor colorButtonFont;
	/*+0xa0*/  /*packed*/ struct SparkalColor colorButtonFontHighlighted;
};

// Type: /*packed*/ class MessageBoxWindowEdit (forward reference);
// VTABLE: COPTER_D 0x005901f8
class MessageBoxWindowEdit : public MessageBoxWindow
{ // packed(0xa8 bytes) TI: 0x442a
public:
	void MessageBoxWindowEdit(/*packed*/ class MPoint&, unsigned long, /*packed*/ class basic_string<char>&, const /*packed*/ class basic_string<char>&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t, int32_t, char *, char *, char *, char *);
	void MessageBoxWindowEdit(/*packed*/ class MPoint&, unsigned long, unsigned long, const /*packed*/ class basic_string<char>&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t, int32_t, char *, char *, char *, char *);
	virtual int32_t Initialize() /* override */;
	virtual void GetEditText(char *, unsigned long); // vtable+0xd4
	virtual void GetEditText(/*packed*/ class basic_string<char>&); // vtable+0xd8
protected:
	/*+0xa4*/  /*packed*/ class BoneheadTextEditWindow *myTextEditWindow;
};

// Type: uint32_t;

// Type: /*packed*/ struct Point2d (forward reference);
struct Point2d{ // packed(0x8 bytes) TI: 0x18b2
	/*+0x0*/   int32_t x;
	/*+0x4*/   int32_t y;
};

// Type: /*packed*/ class DigitalSound (forward reference);
// VTABLE: COPTER_D 0x0058f488
class DigitalSound : public Sound
{ // packed(0x7a bytes) TI: 0x45d4
protected:
	/*+0x34*/  int32_t nStreamingType;
	/*+0x38*/  int32_t nCompletionEstimationTimerSet;
	static /*packed*/ struct IDirectSound *lpDirectSound;
	/*+0x3c*/  uint32_t cbSize;
	/*+0x40*/  /*packed*/ struct tWAVEFORMATEX waveFormatEx; // 0x12 bytes
	/*+0x52*/  /*packed*/ struct IDirectSoundBuffer *lpSound[8]; // 0x20 bytes
	/*+0x72*/  /*packed*/ struct _STREAMBUFINFO *lpStreamBufferInfo;
	/*+0x76*/  unsigned long dwDesiredBufferDescFlags;
public:
	void DigitalSound(long);
	void DigitalSound(const /*packed*/ class basic_string<char>&, int32_t);
	void DigitalSound();
	virtual void ~DigitalSound() /* override */;
	/*packed*/ class DigitalSound& operator=(/*packed*/ class DigitalSound&);
	virtual void SetSoundFile(const /*packed*/ class basic_string<char>&, int32_t); // vtable+0x2c
	virtual int32_t Load(); // vtable+0x30
	virtual int32_t LoadFromResource(); // vtable+0x34
	virtual int32_t LoadFromFile(); // vtable+0x38
	virtual void Unload(); // vtable+0x3c
	virtual long Play(long, int32_t) /* override */;
	virtual long Stop() /* override */;
	virtual long ShouldWeStream(); // vtable+0x40
	virtual long PlayStream(); // vtable+0x44
	virtual long StopStream(); // vtable+0x48
protected:
	virtual long IsPlaying(/*packed*/ struct IDirectSoundBuffer**); // vtable+0x4c
public:
	virtual long IsPlaying() /* override */;
	virtual int32_t GetVolume(long *) /* override */;
	virtual int32_t SetVolume(long) /* override */;
	virtual int32_t GetPan(long *); // vtable+0x50
	virtual int32_t SetPan(long); // vtable+0x54
	virtual int32_t SetPosition(long, long, long); // vtable+0x58
	virtual long GetOriginalFrequency(); // vtable+0x5c
	virtual int32_t GetFrequency(long *); // vtable+0x60
	virtual int32_t SetFrequency(long); // vtable+0x64
	virtual int32_t GetSoundType() /* override */;
	virtual int32_t SetCompletionNotification(void (*)(long), long) /* override */;
	virtual void StopCompletionNotification() /* override */;
	virtual long EstimateRemainingPlayTime() /* override */;
protected:
	virtual int32_t GetSoundAliasToPlay(/*packed*/ struct IDirectSoundBuffer**); // vtable+0x68
	virtual int32_t CreateSoundBuffer(/*packed*/ struct _DSBUFFERDESC*); // vtable+0x6c
	virtual int32_t CreatePrimarySoundBuffer(); // vtable+0x70
	virtual int32_t ReleaseSoundBuffer(); // vtable+0x74
	virtual long InitializeStreamBuffer(long); // vtable+0x78
	virtual void ProcessStreamingBufferTimerCallback(); // vtable+0x7c
	virtual void ProcessCompletionEstimationTimerCallback(); // vtable+0x80
	virtual void StopCompletionNotificationEstimationTimer(); // vtable+0x84
	virtual int32_t StartCompletionNotificationEstimationTimer(); // vtable+0x88
};

// Type: /*packed*/ struct UserMenuWindowDescription;
struct UserMenuWindowDescription{ // packed(0x54 bytes) TI: 0x101b
	/*+0x0*/   /*packed*/ class basic_string<char> sImageFileName; // 0x8 bytes
	/*+0x8*/   int32_t nTransparentIndex;
	/*+0xc*/   /*packed*/ class MRect rectPosition; // 0x10 bytes
	/*+0x1c*/  long lMenuStringResourceIndex;
	/*+0x20*/  long lMenuStringResourceCount;
	/*+0x24*/  long lSelectionBase;
	/*+0x28*/  /*packed*/ struct SparkalColor colorFont;
	/*+0x2c*/  /*packed*/ struct SparkalColor colorFontHighlighted;
	/*+0x30*/  /*packed*/ class MPoint ptPositionFirstItem; // 0x8 bytes
	/*+0x38*/  int32_t nSizeItemFont;
	/*+0x3c*/  int32_t nLineHeight;
	/*+0x40*/  long lTitleStringResourceIndex;
	/*+0x44*/  int32_t bTitleCentered;
	/*+0x48*/  /*packed*/ class MPoint ptTitlePosition; // 0x8 bytes
	/*+0x50*/  int32_t nSizeTitleFont;
};

// Type: /*packed*/ class UserMenuWindow (forward reference);
// VTABLE: COPTER_D 0x005912f8
class UserMenuWindow : public GraphicWindow
{ // packed(0x152 bytes) TI: 0x45d0
public:
	void UserMenuWindow(/*packed*/ struct UserMenuWindowDescription&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	void UserMenuWindow();
	virtual void ~UserMenuWindow() /* override */;
	virtual int32_t Initialize() /* override */;
	virtual int32_t DrawSelf() /* override */;
	virtual int32_t SetSelectionIndex(int32_t); // vtable+0xc4
	virtual int32_t SetSelectionValue(int32_t); // vtable+0xc8
	virtual int32_t GetSelectionIndex(); // vtable+0xcc
	virtual int32_t GetSelectionValue(); // vtable+0xd0
	virtual int32_t GetLineCount(); // vtable+0xd4
	virtual long DoCharacter(long) /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	virtual long DoCursorDown(long, long, unsigned long) /* override */;
	virtual long DoCursorMove(long, long) /* override */;
	virtual int32_t ExecuteSelection(int32_t); // vtable+0xd8
protected:
	virtual void DrawSelectionIndicators(); // vtable+0xdc
	virtual int32_t DoCursorHitTest(int32_t&, long, long); // vtable+0xe0
	virtual int32_t GetPositionOfNthItem(int32_t, /*packed*/ class MPoint&); // vtable+0xe4
	/*+0x74*/  /*packed*/ struct UserMenuWindowDescription myUserMenuWindowDescription; // 0x54 bytes
	/*+0xc8*/  /*packed*/ class vector<TextWindow *> myTextWindowPtrArray; // 0xc bytes
	/*+0xd4*/  int32_t nCurrentSelection;
	/*+0xd8*/  /*packed*/ class DigitalSound soundSelectionChange; // 0x7a bytes
};

// Type: /*packed*/ class UserInputWindow (forward reference);
// VTABLE: COPTER_D 0x0058f228
class UserInputWindow : public GraphicWindow
{ // packed(0xb0 bytes) TI: 0x28a7
	enum KeyUsageType {
		nKeyUsageTypeFree = 0,
		nKeyUsageTypeReserved = 1,
		nKeyUsageTypeCurrentCommand = 2,
		nKeyUsageTypeOtherCommand = 3,
	};
public:
	void UserInputWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual int32_t Initialize() /* override */;
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	virtual void SetupAllInputDevices(); // vtable+0xc4
	virtual void SetupAllCommands(); // vtable+0xc8
	virtual void ReadShortcuts(/*packed*/ class list<Shortcut>&); // vtable+0xcc
	virtual void WriteShortcutsToPreferenceFile(); // vtable+0xd0
	int32_t HaveCommandsChanged();
	long GetCurrentDevice();
	long GetCurrentCommand();
	enum UserInputWindow::KeyUsageType GetKeyUsageType(long, long);
	void RemoveShortcutFromList(long, long, long);
protected:
	void UpdateDisplay(int32_t);
	int32_t DoJoystickWindowMessage(long, void * __ptr32);
	int32_t DoKeyboardWindowMessage(long, void * __ptr32);
	int32_t DoInputDeviceListBoxWindowMessage(long, void * __ptr32);
	int32_t DoCommandListBoxWindowMessage(long, void * __ptr32);
	void DisplayError(int32_t);
	void ClearDeviceArea();
	void AddJoystickTwinCommand(long, long, long);
	void RemoveJoystickTwinCommand(long, long, long);
	int32_t DoesTwinCommandExistForShortcut(long, long, long);
	/*+0x74*/  /*packed*/ class JoystickWindow *myJoystickWindow;
	/*+0x78*/  /*packed*/ class KeyboardWindow *myKeyboardWindow;
	/*+0x7c*/  /*packed*/ class ListBoxWindow *myInputDeviceListBoxWindow;
	/*+0x80*/  /*packed*/ class ListBoxWindow *myCommandListBoxWindow;
	/*+0x84*/  /*packed*/ class TextWindow *myStatusTextWindow;
	/*+0x88*/  /*packed*/ class list<StringIDAssociation> myInputDeviceStringIDAssociationList; // 0x8 bytes
	/*+0x90*/  /*packed*/ class list<StringIDAssociation> myCommandStringIDAssociationList; // 0x8 bytes
	/*+0x98*/  /*packed*/ class list<Shortcut> myShortcutListNonConfigurable; // 0x8 bytes
	/*+0xa0*/  /*packed*/ class list<Shortcut> myShortcutListConfigurable; // 0x8 bytes
	/*+0xa8*/  int32_t bCommandsHaveChanged;
	/*+0xac*/  int32_t bInitializing;
};

// Type: /*packed*/ class RenderSettingsWindow (forward reference);
// VTABLE: COPTER_D 0x0058fc20
class RenderSettingsWindow : public GraphicWindow
{ // packed(0xb8 bytes) TI: 0x2add
public:
	void RenderSettingsWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual void ~RenderSettingsWindow() /* override */;
	virtual int32_t Initialize() /* override */;
	virtual int32_t CreateImage(int32_t) /* override */;
	virtual void DestroyImage() /* override */;
	virtual int32_t DrawSelf() /* override */;
	int32_t SetCurrentSettings(long, long, long, long, long);
	void GetCurrentSettings(long&, long&, long&, long&, long&);
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	/*+0x74*/  long bShowBuildingTextures;
	/*+0x78*/  long bShowGroundTextures;
	/*+0x7c*/  long bShowSkyAndClouds;
	/*+0x80*/  long lQuadPixelType;
	/*+0x84*/  long lFogCloseness;
protected:
	void SetControlsBasedOnCurrentSettings();
	void DrawPreviewBasedOnCurrentSettings();
	void GetPreviewFileNames(/*packed*/ class basic_string<char>&, /*packed*/ class basic_string<char>&, /*packed*/ class basic_string<char>&);
	/*+0x88*/  /*packed*/ class CheckBoxWindow *myBuildingTexturesCheckBoxWindow;
	/*+0x8c*/  /*packed*/ class CheckBoxWindow *myObjectTexturesCheckBoxWindow;
	/*+0x90*/  /*packed*/ class CheckBoxWindow *mySkyDisplayCheckBoxWindow;
	/*+0x94*/  /*unpacked*/ class ButtonGroup *myDisplayResolutionButtonGroup;
	/*+0x98*/  /*packed*/ class SliderWindow *myFogSliderWindow;
	/*+0x9c*/  /*packed*/ class CBackBuffer *mySkyImage;
	/*+0xa0*/  /*packed*/ class CBackBuffer *myBuildingImage;
	/*+0xa4*/  /*packed*/ class MTimer mySkyTimer; // 0x10 bytes
	/*+0xb4*/  long lSkyImagePanX;
};

// Type: /*packed*/ class SoundSettingsWindow (forward reference);
// VTABLE: COPTER_D 0x0058fce8
class SoundSettingsWindow : public GraphicWindow
{ // packed(0x88 bytes) TI: 0x2a87
public:
	void SoundSettingsWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual int32_t Initialize() /* override */;
	int32_t SetCurrentVolumeSettings(/*unpacked*/ struct SoundPreferences&);
	int32_t SetCurrentRadioSettings(/*packed*/ struct RadioPreferences&, long);
	void GetCurrentVolumeSettings(/*unpacked*/ struct SoundPreferences&);
	void GetCurrentRadioSettings(/*packed*/ struct RadioPreferences&);
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	// calltype: NearC
	static long ConvertSoundValueToSliderValue(long);
	// calltype: NearC
	static long ConvertSliderValueToSoundValue(long);
protected:
	/*+0x74*/  /*packed*/ class SliderWindow *myMasterVolumeSliderWindow;
	/*+0x78*/  /*packed*/ class SliderWindow *myRadioStationSliderWindow;
	/*+0x7c*/  /*packed*/ class SliderWindow *myRadioVolumeSliderWindow;
	/*+0x80*/  /*packed*/ class CheckBoxWindow *myDJCheckBoxWindow;
	/*+0x84*/  /*packed*/ class CheckBoxWindow *myCommercialCheckBoxWindow;
};

// Type: /*packed*/ struct RadioPreferences;
struct RadioPreferences{ // packed(0x1c bytes) TI: 0x2a39
	/*+0x0*/   long lVolume;
	/*+0x4*/   int32_t bPreferToBeOn;
	/*+0x8*/   long lCurrentStation;
	/*+0xc*/   int32_t bOptionDJ;
	/*+0x10*/  int32_t bOptionCommercials;
	/*+0x14*/  int32_t bAutoMute;
	/*+0x18*/  int32_t bOptionPlayEnglishIfDefaultLanguageNotFound;
};

// Type: /*packed*/ struct SoundPreferences;
struct SoundPreferences{ // packed(0x10 bytes) TI: 0x2845
	/*+0x0*/   long lMasterVolume;
	/*+0x4*/   long lDispatchVolume;
	/*+0x8*/   long lSoundEffectsVolume;
	/*+0xc*/   long lVehicleVolume;
};

// Type: /*packed*/ class CitySettingsWindow (forward reference);
// VTABLE: COPTER_D 0x0058fdd0
class CitySettingsWindow : public GraphicWindow
{ // packed(0x94 bytes) TI: 0x2a34
public:
	void CitySettingsWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual int32_t Initialize() /* override */;
	void SetCurrentCitySettings(/*packed*/ struct tagCitySettings*);
	void GetCurrentCitySettings(/*packed*/ struct tagCitySettings*);
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual long DoKeyDown(long, char) /* override */;
protected:
	/*+0x74*/  /*packed*/ class SliderWindow *mySliderWindows[8]; // 0x20 bytes
};

// Type: /*packed*/ class ControlDisplayWindow (forward reference);
// VTABLE: COPTER_D 0x0058f300
class ControlDisplayWindow : public GraphicWindow
{ // packed(0x80 bytes) TI: 0x2adb
public:
	void ControlDisplayWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual int32_t Initialize() /* override */;
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual void ReadShortcuts(/*packed*/ class list<Shortcut>*); // vtable+0xc4
protected:
	void GetCommandString(/*packed*/ class basic_string<char>&, long);
	void AppendKeysString(/*packed*/ class basic_string<char>&, long, long, int32_t);
	/*+0x74*/  int32_t bInitializing;
	/*+0x78*/  /*packed*/ class ListBoxWindow *myCommandListBoxWindow;
	/*+0x7c*/  /*packed*/ class ListBoxWindow *myKeysListBoxWindow;
};

// Type: /*packed*/ class CheckupWindow (forward reference);
// VTABLE: COPTER_D 0x005903a0
class CheckupWindow : public GraphicWindow
{ // packed(0x94 bytes) TI: 0x486b
public:
	void CheckupWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual int32_t Initialize() /* override */;
	void SetCurrentSettings(long *);
	void GetCurrentSettings(long *);
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	void SetTextControlsBasedOnCurrentSliderValues();
	void SetAllControlValuesToDefaults();
	// calltype: NearC
	static int32_t ShouldWeDisplayCheckupWindow();
	int32_t CanUserAffordCurrentSliderValues();
protected:
	/*+0x74*/  /*packed*/ class SliderWindow *mySliderWindows[3]; // 0xc bytes
	/*+0x80*/  /*packed*/ class TextWindow *myTextWindows[5]; // 0x14 bytes
};

// Type: /*unpacked*/ class GraphicWindow (forward reference);
// GraphicWindow Class implementation not found

// Type: /*packed*/ class Sound;
// VTABLE: COPTER_D 0x0058f458
class Sound{ // packed(0x34 bytes) TI: 0x4335
	enum SoundSourceType {
		nSoundSourceTypeResource = 0,
		nSoundSourceTypeFile = 1,
	};
public:
	/*+0x4*/   enum Sound::SoundSourceType nSoundSourceType;
	enum SoundDuplicateType {
		nSoundDuplicateDefault = 0,
		nSoundDuplicateInterrupt = 1,
		nSoundDuplicateContinue = 2,
		nSoundDuplicateOverlap = 3,
	};
public:
	/*+0x8*/   enum Sound::SoundDuplicateType nSoundDuplicateType;
	/*+0xc*/   long lID;
	/*+0x10*/  long lResID;
	/*+0x14*/  /*packed*/ class basic_string<char> sSoundFile; // 0x8 bytes
	/*+0x1c*/  long bLooping;
	/*+0x20*/  long bStreaming;
	/*+0x24*/  long lVolume;
	/*+0x28*/  void (*soundCompletionFunction)(long);
	/*+0x2c*/  long lSoundCompletionData;
	/*+0x30*/  int32_t bUnloadBeforeNextPlay;
	void Sound();
	virtual void ~Sound(); // vtable+0x0
	/*packed*/ class Sound& operator=(const /*packed*/ class Sound&);
	virtual void SetSoundFile(const /*packed*/ class basic_string<char>&); // vtable+0x4
	virtual long Play(long, int32_t); // vtable+0x8
	virtual long Stop(); // vtable+0xc
	virtual long IsPlaying(); // vtable+0x10
	virtual int32_t SetCompletionNotification(void (*)(long), long); // vtable+0x14
	virtual void StopCompletionNotification(); // vtable+0x18
	virtual long EstimateRemainingPlayTime(); // vtable+0x1c
	virtual int32_t GetVolume(long *); // vtable+0x20
	virtual int32_t SetVolume(long); // vtable+0x24
	virtual int32_t GetSoundType(); // vtable+0x28
	// calltype: NearC
	static unsigned long GetTotalMemoryUsage();
	static unsigned long lTotalMemoryUsage;
};

// Type: /*packed*/ class MessageBoxWindow;
// VTABLE: COPTER_D 0x0058fa80
class MessageBoxWindow : public GraphicWindow
{ // packed(0xa4 bytes) TI: 0x2a45
public:
	void MessageBoxWindow(/*packed*/ class MPoint&, unsigned long, /*packed*/ class basic_string<char>&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t, int32_t, char *, char *, char *);
	void MessageBoxWindow(/*packed*/ class MPoint&, unsigned long, unsigned long, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t, int32_t, char *, char *, char *);
	virtual int32_t Initialize() /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual void SetTextColor(const /*packed*/ struct SparkalColor&); // vtable+0xc4
	virtual void SetButtonTextColor(const /*packed*/ struct SparkalColor*, const /*packed*/ struct SparkalColor*); // vtable+0xc8
protected:
	virtual int32_t ConvertTypeToStringID(long); // vtable+0xcc
	virtual void DrawTextOntoBox(); // vtable+0xd0
	/*+0x74*/  long lMessageID;
	/*+0x78*/  /*packed*/ class basic_string<char> sMessage; // 0x8 bytes
	/*+0x80*/  /*packed*/ class basic_string<char> sButtonImageFileName; // 0x8 bytes
	/*+0x88*/  /*packed*/ class basic_string<char> sAnimationImageFileName; // 0x8 bytes
	/*+0x90*/  long lType;
	/*+0x94*/  int32_t bSelfDeleting;
	/*+0x98*/  /*packed*/ struct SparkalColor colorFont;
	/*+0x9c*/  /*packed*/ struct SparkalColor colorButtonFont;
	/*+0xa0*/  /*packed*/ struct SparkalColor colorButtonFontHighlighted;
};



// Contribution: 1:0003d250-00040e21 Module: 53, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0043e250
void SoundCompletionDeletionFunction(long lSoundPointer) {
// LINE 77:
	__asm        mov    eax, lSoundPointer;
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T30;

	__asm        push   1;
	__asm        mov    eax, [ebp-4];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-4];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T30;
// LINE 78:
_T30:
	return;
}

// FUNCTION: COPTER_D 0x0043e28a
void SoundCompletionUnloadFunction(long lSoundPointer) {
// LINE 87:
	__asm        mov    eax, lSoundPointer;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, lSoundPointer;
	__asm        call   dword ptr [eax+0x3C];
// LINE 88:
	return;
}

// FUNCTION: COPTER_D 0x0043e2a5
void CGameApp::ShowVersion() {
	/*bp-0x8*/   /*packed*/ class basic_string<char> sMessage; // 0x8 bytes
	/*bp-0x28*/  /*packed*/ struct _MEMORYSTATUS tempMemoryStatus; // 0x20 bytes
	/*bp-0x2c*/  int32_t nFullStringID;
	/*bp-0x30*/  long lSystemType;
	/*bp-0x3c*/  /*packed*/ class Version tempVersion; // 0xc bytes
	/*bp-0x23c*/ char szFormattedVersionInformation[512]; // 0x200 bytes
	/*bp-0x27c*/ char szUnformattedVersionInformation[64]; // 0x40 bytes
	/*bp-0x280*/ char * szVersionInformation;
	/*bp-0x284*/ long lCPUSpeed;
	/*bp-0x288*/ long lPhysicalMemory;
	/*bp-0x28c*/ long lCPUVersion;

// LINE 106:
	tempVersion<vftable>->Version::Version();
// LINE 107:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x298], eax;
	__asm        cmp    dword ptr [ebp-0x298], 0;
	__asm        je     _T86;

	__asm        mov    eax, [ebp-0x298];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x298];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x298];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x298];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x298];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T78;
_T78:
	__asm        mov    eax, [ebp-0x298];
	__asm        mov    sMessage.reference, eax;
	__asm        jmp    _T8d;
_T86:
	sMessage.reference = 0x0;
_T8d:
	sMessage.c_str_ptr = 0x0;
	__asm        jmp    _T99;
// LINE 108:
_T99:
	szVersionInformation = 0x0;
// LINE 118:
	nFullStringID = LanguageManager::GetFullStringID(0x4, 0x0);
// LINE 119:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x12AC];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x12B0], eax;
	__asm        cmp    dword ptr [ebp-0x12B0], 0;
	__asm        jne    _T15f;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x12AC];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x12B0], eax;
	__asm        jmp    _T111;
_T111:
	__asm        lea    eax, [ebp-0x12AC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x12AC];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T135;
_T135:
	__asm        jmp    _T13a;
_T13a:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T15a;
_T15a:
	__asm        jmp    _T18d;
_T15f:
	__asm        jmp    _T164;
_T164:
	__asm        lea    eax, [ebp-0x12AC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x12AC];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T188;
_T188:
	__asm        jmp    _T18d;
// LINE 120:
_T18d:
	__asm        cmp    sMessage.c_str_ptr, 0;
	__asm        je     _T1bb;

	__asm        mov    eax, sMessage.c_str_ptr;
	__asm        mov    [ebp-0x72CC], eax;
	__asm        mov    eax, [ebp-0x72CC];
	__asm        mov    [ebp-0x72D4], eax;
	__asm        mov    eax, [ebp-0x72D4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T1bb:
	__asm        jmp    _T1c0;
_T1c0:
	sMessage.c_str_ptr = operator new((sMessage.reference-><basic_string_ref<char>+0x04:4> + 1));
	__asm        jmp    _T1d8;
_T1d8:
	__asm        mov    eax, sMessage.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T22f;

	__asm        jmp    _T1ea;
_T1ea:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x72E0], eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        mov    [ebp-0x72E4], eax;
	__asm        mov    eax, sMessage.c_str_ptr;
	__asm        mov    [ebp-0x72E8], eax;
	__asm        mov    eax, [ebp-0x72E0];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x72E4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x72E8];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T22f;
_T22f:
	__asm        jmp    _T234;
_T234:
	__asm        mov    byte ptr [ebp-0x72D0], 0;
	__asm        jmp    _T240;
_T240:
	__asm        lea    eax, [ebp-0x72D0];
	__asm        mov    [ebp-0x72D8], eax;
	__asm        jmp    _T251;
_T251:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, sMessage.c_str_ptr;
	__asm        mov    [ebp-0x72DC], eax;
	__asm        mov    eax, [ebp-0x72D8];
	__asm        mov    al, [eax];
	__asm        mov    ecx, [ebp-0x72DC];
	__asm        mov    [ecx], al;
	__asm        jmp    _T275;
_T275:
	__asm        jmp    _T27a;
_T27a:
	strcpy(szFormattedVersionInformation[0], sMessage.c_str_ptr);
// LINE 121:
	strcat(szFormattedVersionInformation[0], 0x598828);
// LINE 124:
	__asm        lea    eax, szVersionInformation;
	__asm        push   eax;
	__asm        lea    ecx, tempVersion<vftable>;
	__asm        call   Version::GetApplicationVersion;
	__asm        test   eax, eax;
	__asm        je     _T3da;
// LINE 125:
	nFullStringID = LanguageManager::GetFullStringID(0x175, 0x0);
// LINE 126:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x22B0];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x22B4], eax;
	__asm        cmp    dword ptr [ebp-0x22B4], 0;
	__asm        jne    _T377;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x22B0];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x22B4], eax;
	__asm        jmp    _T329;
_T329:
	__asm        lea    eax, [ebp-0x22B0];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x22B0];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T34d;
_T34d:
	__asm        jmp    _T352;
_T352:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T372;
_T372:
	__asm        jmp    _T3a5;
_T377:
	__asm        jmp    _T37c;
_T37c:
	__asm        lea    eax, [ebp-0x22B0];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x22B0];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T3a0;
_T3a0:
	__asm        jmp    _T3a5;
// LINE 127:
_T3a5:
	sprintf(szUnformattedVersionInformation[0], sMessage.c_str_ptr->basic_string<char>::c_str(szVersionInformation), szVersionInformation);
// LINE 128:
	strcat(szFormattedVersionInformation[0], szUnformattedVersionInformation[0]);
// LINE 131:
_T3da:
	__asm        lea    eax, szVersionInformation;
	__asm        push   eax;
	__asm        lea    ecx, tempVersion<vftable>;
	__asm        call   Version::GetApplicationDebugVersion;
	__asm        test   eax, eax;
	__asm        je     _T513;
// LINE 132:
	nFullStringID = LanguageManager::GetFullStringID(0x176, 0x0);
// LINE 133:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x32B4];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x32B8], eax;
	__asm        cmp    dword ptr [ebp-0x32B8], 0;
	__asm        jne    _T4b0;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x32B4];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x32B8], eax;
	__asm        jmp    _T462;
_T462:
	__asm        lea    eax, [ebp-0x32B4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x32B4];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T486;
_T486:
	__asm        jmp    _T48b;
_T48b:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T4ab;
_T4ab:
	__asm        jmp    _T4de;
_T4b0:
	__asm        jmp    _T4b5;
_T4b5:
	__asm        lea    eax, [ebp-0x32B4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x32B4];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T4d9;
_T4d9:
	__asm        jmp    _T4de;
// LINE 134:
_T4de:
	sprintf(szUnformattedVersionInformation[0], sMessage.c_str_ptr->basic_string<char>::c_str(szVersionInformation), szVersionInformation);
// LINE 135:
	strcat(szFormattedVersionInformation[0], szUnformattedVersionInformation[0]);
// LINE 140:
_T513:
	lSystemType = Version::GetSystemType();
// LINE 141:
	nFullStringID = LanguageManager::GetFullStringID((lSystemType + 0x177), 0x0);
// LINE 142:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x42B8];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x42BC], eax;
	__asm        cmp    dword ptr [ebp-0x42BC], 0;
	__asm        jne    _T5de;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x42B8];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x42BC], eax;
	__asm        jmp    _T590;
_T590:
	__asm        lea    eax, [ebp-0x42B8];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x42B8];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T5b4;
_T5b4:
	__asm        jmp    _T5b9;
_T5b9:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T5d9;
_T5d9:
	__asm        jmp    _T60c;
_T5de:
	__asm        jmp    _T5e3;
_T5e3:
	__asm        lea    eax, [ebp-0x42B8];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x42B8];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T607;
_T607:
	__asm        jmp    _T60c;
// LINE 144:
_T60c:
	__asm        push   1;
	__asm        call   Version::GetSystemVersion;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   Version::GetSystemVersion;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::c_str;
	__asm        push   eax;
	__asm        lea    eax, szUnformattedVersionInformation[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x10;
// LINE 145:
	strcat(szFormattedVersionInformation[0], szUnformattedVersionInformation[0]);
// LINE 146:
	strcat(szFormattedVersionInformation[0], 0x59882c);
// LINE 149:
	lPhysicalMemory = 0x0;
// LINE 152:
	tempMemoryStatus.dwLength = 0x20;
// LINE 153:
	__asm        lea    eax, tempMemoryStatus.dwLength;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C362C];
// LINE 154:
	__asm        mov    ecx, 0xFA000;
	__asm        mov    eax, tempMemoryStatus.dwTotalPhys;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        mov    lPhysicalMemory, eax;
// LINE 156:
	nFullStringID = LanguageManager::GetFullStringID(0x174, 0x0);
// LINE 157:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x52BC];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x52C0], eax;
	__asm        cmp    dword ptr [ebp-0x52C0], 0;
	__asm        jne    _T750;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x52BC];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x52C0], eax;
	__asm        jmp    _T702;
_T702:
	__asm        lea    eax, [ebp-0x52BC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x52BC];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T726;
_T726:
	__asm        jmp    _T72b;
_T72b:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T74b;
_T74b:
	__asm        jmp    _T77e;
_T750:
	__asm        jmp    _T755;
_T755:
	__asm        lea    eax, [ebp-0x52BC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x52BC];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T779;
_T779:
	__asm        jmp    _T77e;
// LINE 158:
_T77e:
	sprintf(szUnformattedVersionInformation[0], sMessage.c_str_ptr->basic_string<char>::c_str(lPhysicalMemory), lPhysicalMemory);
// LINE 159:
	strcat(szFormattedVersionInformation[0], szUnformattedVersionInformation[0]);
// LINE 162:
	lCPUVersion = Version::GetCPUVersion();
// LINE 163:
	nFullStringID = LanguageManager::GetFullStringID((lCPUVersion + 0x168), 0x0);
// LINE 164:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x62C0];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x62C4], eax;
	__asm        cmp    dword ptr [ebp-0x62C4], 0;
	__asm        jne    _T884;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x62C0];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x62C4], eax;
	__asm        jmp    _T836;
_T836:
	__asm        lea    eax, [ebp-0x62C0];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x62C0];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T85a;
_T85a:
	__asm        jmp    _T85f;
_T85f:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T87f;
_T87f:
	__asm        jmp    _T8b2;
_T884:
	__asm        jmp    _T889;
_T889:
	__asm        lea    eax, [ebp-0x62C0];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x62C0];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T8ad;
_T8ad:
	__asm        jmp    _T8b2;
// LINE 165:
_T8b2:
	strcat(szFormattedVersionInformation[0], sMessage.c_str_ptr->basic_string<char>::c_str());
// LINE 168:
	lCPUSpeed = Version::GetCPUSpeed();
// LINE 169:
	__asm        cmp    lCPUSpeed, 0;
	__asm        je     _Ta04;
// LINE 170:
	nFullStringID = LanguageManager::GetFullStringID(0x173, 0x0);
// LINE 171:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x72C4];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x72C8], eax;
	__asm        cmp    dword ptr [ebp-0x72C8], 0;
	__asm        jne    _T9a1;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x72C4];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x72C8], eax;
	__asm        jmp    _T953;
_T953:
	__asm        lea    eax, [ebp-0x72C4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x72C4];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T977;
_T977:
	__asm        jmp    _T97c;
_T97c:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T99c;
_T99c:
	__asm        jmp    _T9cf;
_T9a1:
	__asm        jmp    _T9a6;
_T9a6:
	__asm        lea    eax, [ebp-0x72C4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x72C4];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T9ca;
_T9ca:
	__asm        jmp    _T9cf;
// LINE 172:
_T9cf:
	sprintf(szUnformattedVersionInformation[0], sMessage.c_str_ptr->basic_string<char>::c_str(lCPUSpeed), lCPUSpeed);
// LINE 173:
	strcat(szFormattedVersionInformation[0], szUnformattedVersionInformation[0]);
// LINE 178:
_Ta04:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x2AC], eax;
	__asm        cmp    dword ptr [ebp-0x2AC], 0;
	__asm        je     _Ta3e;

	__asm        lea    eax, szFormattedVersionInformation[0];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x2AC];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x290], eax;
	__asm        jmp    _Ta48;
_Ta3e:
	__asm        mov    dword ptr [ebp-0x290], 0;
_Ta48:
	__asm        mov    dword ptr [ebp-0x294], 0;
	__asm        jmp    _Ta57;
_Ta57:
	__asm        push   1;
	__asm        lea    eax, [ebp-0x294];
	__asm        push   eax;
	__asm        push   0x7DA;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::CreateMessageBox;
	__asm        lea    ecx, [ebp-0x294];
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    dword ptr [ebp-0x294], 0;
	__asm        je     _Taaf;

	__asm        mov    eax, [ebp-0x294];
	__asm        mov    [ebp-0x29C], eax;
	__asm        mov    eax, [ebp-0x29C];
	__asm        mov    [ebp-0x2A0], eax;
	__asm        mov    eax, [ebp-0x2A0];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_Taaf:
	__asm        jmp    _Tab4;
// LINE 179:
_Tab4:
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    sMessage.c_str_ptr, 0;
	__asm        je     _Taea;

	__asm        mov    eax, sMessage.c_str_ptr;
	__asm        mov    [ebp-0x2A4], eax;
	__asm        mov    eax, [ebp-0x2A4];
	__asm        mov    [ebp-0x2A8], eax;
	__asm        mov    eax, [ebp-0x2A8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_Taea:
	__asm        jmp    _Taef;
_Taef:
	tempVersion<vftable>->Version::~Version();
	__asm        jmp    __RETURN;
__RETURN:
}

// FUNCTION: COPTER_D 0x0043eda6
int32_t CGameApp::CreateMessageBox(long lID, /*packed*/ class basic_string<char>& sMessage, long lType) {
	/*bp-0x4*/   /*packed*/ class MessageBoxWindow *tempMessageBoxWindow;
	/*bp-0x8*/   /*packed*/ struct SparkalColor colorMessageFont;
	/*bp-0xc*/   char * szAnimationFileNameToUse;
	/*bp-0x10*/  /*packed*/ struct SparkalColor colorButtonFontHighlighted;
	/*bp-0x14*/  char * szButtonImageFileNameToUse;
	/*bp-0x18*/  /*packed*/ struct SparkalColor colorButtonFont;
	/*bp-0x1c*/  char * szImageFileNameToUse;

// LINE 190:
	__asm        jmp    _T17;
// LINE 191:
_T17:
	__asm        jmp    _T1c;
// LINE 192:
_T1c:
	__asm        jmp    _T21;
// LINE 194:
_T21:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T44;
_T44:
	__asm        jmp    _T49;
_T49:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T5d;
_T5d:
	__asm        jmp    _T62;
_T62:
	__asm        jmp    _T67;
_T67:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0x9C], eax;
	__asm        jmp    _T3b7;
// LINE 196:
_T7b:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_1;
// LINE 197:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_1;
// LINE 198:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_1;
// LINE 199:
	__asm        mov    byte ptr [ebp-0x20], 0x6B;
	__asm        mov    byte ptr [ebp-0x1F], 0x52;
	__asm        mov    byte ptr [ebp-0x1E], 0x4D;
	__asm        jmp    _Ta4;
_Ta4:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 200:
	__asm        mov    byte ptr [ebp-0x24], 0xDA;
	__asm        mov    byte ptr [ebp-0x23], 0xDA;
	__asm        mov    byte ptr [ebp-0x22], 0xDA;
	__asm        jmp    _Tbb;
_Tbb:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 201:
	__asm        mov    byte ptr [ebp-0x28], 0xF0;
	__asm        mov    byte ptr [ebp-0x27], 0xFA;
	__asm        mov    byte ptr [ebp-0x26], 0xFF;
	__asm        jmp    _Td2;
_Td2:
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 202:
	__asm        jmp    _T3f8;
// LINE 204:
_Tdd:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xBCC], 0;
	__asm        je     _T170;

	__asm        jmp    _Tf5;
_Tf5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xBCC];
	__asm        cmp    dword ptr [eax+0xF2], 0;
	__asm        je     _T170;
// LINE 205:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_2D;
// LINE 206:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_2D;
// LINE 207:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_2D;
// LINE 208:
	__asm        mov    byte ptr [ebp-0x2C], 0x18;
	__asm        mov    byte ptr [ebp-0x2B], 0x21;
	__asm        mov    byte ptr [ebp-0x2A], 0x39;
	__asm        jmp    _T137;
_T137:
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 209:
	__asm        mov    byte ptr [ebp-0x30], 0x4A;
	__asm        mov    byte ptr [ebp-0x2F], 0x95;
	__asm        mov    byte ptr [ebp-0x2E], 0xC0;
	__asm        jmp    _T14e;
_T14e:
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 210:
	__asm        mov    byte ptr [ebp-0x34], 0x70;
	__asm        mov    byte ptr [ebp-0x33], 0xCA;
	__asm        mov    byte ptr [ebp-0x32], 0xEA;
	__asm        jmp    _T165;
_T165:
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 212:
	__asm        jmp    _T1cd;
// LINE 213:
_T170:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_2N;
// LINE 214:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_2N;
// LINE 215:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_2N;
// LINE 216:
	__asm        mov    byte ptr [ebp-0x38], 0x19;
	__asm        mov    byte ptr [ebp-0x37], 0x1F;
	__asm        mov    byte ptr [ebp-0x36], 0x41;
	__asm        jmp    _T199;
_T199:
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 217:
	__asm        mov    byte ptr [ebp-0x3C], 0x30;
	__asm        mov    byte ptr [ebp-0x3B], 0x7A;
	__asm        mov    byte ptr [ebp-0x3A], 0xAA;
	__asm        jmp    _T1b0;
_T1b0:
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 218:
	__asm        mov    byte ptr [ebp-0x40], 0x70;
	__asm        mov    byte ptr [ebp-0x3F], 0xCA;
	__asm        mov    byte ptr [ebp-0x3E], 0xEA;
	__asm        jmp    _T1c7;
_T1c7:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 220:
_T1cd:
	__asm        jmp    _T3f8;
// LINE 222:
_T1d2:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_3;
// LINE 223:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_3;
// LINE 224:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_3;
// LINE 225:
	__asm        mov    byte ptr [ebp-0x44], 0x15;
	__asm        mov    byte ptr [ebp-0x43], 0x18;
	__asm        mov    byte ptr [ebp-0x42], 0x4A;
	__asm        jmp    _T1fb;
_T1fb:
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 226:
	__asm        mov    byte ptr [ebp-0x48], 0x44;
	__asm        mov    byte ptr [ebp-0x47], 0x8A;
	__asm        mov    byte ptr [ebp-0x46], 0xAC;
	__asm        jmp    _T212;
_T212:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 227:
	__asm        mov    byte ptr [ebp-0x4C], 0x94;
	__asm        mov    byte ptr [ebp-0x4B], 0xD6;
	__asm        mov    byte ptr [ebp-0x4A], 0xFF;
	__asm        jmp    _T229;
_T229:
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 228:
	__asm        jmp    _T3f8;
// LINE 230:
_T234:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_4;
// LINE 231:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_4;
// LINE 232:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_4;
// LINE 233:
	__asm        mov    byte ptr [ebp-0x50], 0x15;
	__asm        mov    byte ptr [ebp-0x4F], 0x18;
	__asm        mov    byte ptr [ebp-0x4E], 0x4A;
	__asm        jmp    _T25d;
_T25d:
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 234:
	__asm        mov    byte ptr [ebp-0x54], 0x40;
	__asm        mov    byte ptr [ebp-0x53], 0x89;
	__asm        mov    byte ptr [ebp-0x52], 0xB5;
	__asm        jmp    _T274;
_T274:
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 235:
	__asm        mov    byte ptr [ebp-0x58], 0x70;
	__asm        mov    byte ptr [ebp-0x57], 0xCA;
	__asm        mov    byte ptr [ebp-0x56], 0xEA;
	__asm        jmp    _T28b;
_T28b:
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 236:
	__asm        jmp    _T3f8;
// LINE 238:
_T296:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_5;
// LINE 239:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_5;
// LINE 240:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_5;
// LINE 241:
	__asm        mov    byte ptr [ebp-0x5C], 0x15;
	__asm        mov    byte ptr [ebp-0x5B], 0x18;
	__asm        mov    byte ptr [ebp-0x5A], 0x4A;
	__asm        jmp    _T2bf;
_T2bf:
	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 242:
	__asm        mov    byte ptr [ebp-0x60], 0x40;
	__asm        mov    byte ptr [ebp-0x5F], 0x89;
	__asm        mov    byte ptr [ebp-0x5E], 0xB5;
	__asm        jmp    _T2d6;
_T2d6:
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 243:
	__asm        mov    byte ptr [ebp-0x64], 0x70;
	__asm        mov    byte ptr [ebp-0x63], 0xCA;
	__asm        mov    byte ptr [ebp-0x62], 0xEA;
	__asm        jmp    _T2ed;
_T2ed:
	__asm        mov    eax, [ebp-0x64];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 244:
	__asm        jmp    _T3f8;
// LINE 246:
_T2f8:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_6;
// LINE 247:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_6;
// LINE 248:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_6;
// LINE 249:
	__asm        mov    byte ptr [ebp-0x68], 0x10;
	__asm        mov    byte ptr [ebp-0x67], 0x15;
	__asm        mov    byte ptr [ebp-0x66], 0x1F;
	__asm        jmp    _T321;
_T321:
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 250:
	__asm        mov    byte ptr [ebp-0x6C], 0xA;
	__asm        mov    byte ptr [ebp-0x6B], 0x85;
	__asm        mov    byte ptr [ebp-0x6A], 0xDA;
	__asm        jmp    _T338;
_T338:
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 251:
	__asm        mov    byte ptr [ebp-0x70], 0xD3;
	__asm        mov    byte ptr [ebp-0x6F], 0xDA;
	__asm        mov    byte ptr [ebp-0x6E], 0xFF;
	__asm        jmp    _T34f;
_T34f:
	__asm        mov    eax, [ebp-0x70];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 254:
_T355:
	szImageFileNameToUse = SZ_ABOUT_BOX_IMAGE_FILE_NAME_0;
// LINE 255:
	szButtonImageFileNameToUse = SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_0;
// LINE 256:
	szAnimationFileNameToUse = SZ_ABOUT_BOX_ANIMATION_FILE_NAME_0;
// LINE 257:
	__asm        mov    byte ptr [ebp-0x74], 0x10;
	__asm        mov    byte ptr [ebp-0x73], 0x15;
	__asm        mov    byte ptr [ebp-0x72], 0x1F;
	__asm        jmp    _T37e;
_T37e:
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 258:
	__asm        mov    byte ptr [ebp-0x78], 0xA;
	__asm        mov    byte ptr [ebp-0x77], 0x85;
	__asm        mov    byte ptr [ebp-0x76], 0xDA;
	__asm        jmp    _T395;
_T395:
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 259:
	__asm        mov    byte ptr [ebp-0x7C], 0xD3;
	__asm        mov    byte ptr [ebp-0x7B], 0xDA;
	__asm        mov    byte ptr [ebp-0x7A], 0xFF;
	__asm        jmp    _T3ac;
_T3ac:
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 260:
	__asm        jmp    _T3f8;
_T3b7:
	__asm        sub    dword ptr [ebp-0x9C], 4;
	__asm        cmp    dword ptr [ebp-0x9C], 7;
	__asm        ja     _T355;

	__asm        mov    eax, [ebp-0x9C];
	__asm        jmp    _Switch_3d8[0][eax*4];
	// Switch pointers:
	//   _T2f8
	//   _T7b
	//   _T355
	//   _Tdd
	//   _T1d2
	//   _T234
	//   _T355
	//   _T296
// LINE 264:
_T3f8:
	__asm        push   0xA4;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x80], eax;
	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        je     _T49f;

	__asm        cmp    this, 0;
	__asm        je     _T433;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _T43d;
_T433:
	__asm        mov    dword ptr [ebp-0x8C], 0;
_T43d:
	__asm        jmp    _T442;
_T442:
	__asm        mov    dword ptr [ebp-0x88], 0;
	__asm        mov    dword ptr [ebp-0x84], 0;
	__asm        jmp    _T45b;
_T45b:
	__asm        mov    eax, szAnimationFileNameToUse;
	__asm        push   eax;
	__asm        mov    eax, szButtonImageFileNameToUse;
	__asm        push   eax;
	__asm        mov    eax, szImageFileNameToUse;
	__asm        push   eax;
	__asm        push   1;
	__asm        push   1;
	__asm        mov    eax, [ebp-0x8C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, lID;
	__asm        push   eax;
	__asm        mov    eax, sMessage;
	__asm        push   eax;
	__asm        mov    eax, lType;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x88];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x80];
	__asm        call   MessageBoxWindow::MessageBoxWindow;
	__asm        mov    tempMessageBoxWindow, eax;
	__asm        jmp    _T4a6;
_T49f:
	tempMessageBoxWindow = 0x0;
// LINE 265:
_T4a6:
	__asm        cmp    tempMessageBoxWindow, 0;
	__asm        je     _T504;
// LINE 266:
	__asm        lea    eax, colorMessageFont.Blue;
	__asm        push   eax;
	__asm        mov    eax, tempMessageBoxWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindow;
	__asm        call   dword ptr [eax+0xC4];
// LINE 267:
	__asm        lea    eax, colorButtonFontHighlighted.Blue;
	__asm        push   eax;
	__asm        lea    eax, colorButtonFont.Blue;
	__asm        push   eax;
	__asm        mov    eax, tempMessageBoxWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindow;
	__asm        call   dword ptr [eax+0xC8];
// LINE 268:
	__asm        mov    eax, tempMessageBoxWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindow;
	__asm        call   dword ptr [eax+4];
// LINE 269:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, tempMessageBoxWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 270:
	this-><CGameApp+0xa4:4>++;
// LINE 272:
_T504:
	return tempMessageBoxWindow;
// LINE 273:
}

// FUNCTION: COPTER_D 0x0043f2b9
int32_t CGameApp::CreateMessageBox(long lID, int32_t nStringID, long lType) {
	/*bp-0x8*/   /*packed*/ class basic_string<char> sMessage; // 0x8 bytes
	/*bp-0xc*/   int32_t nFullStringID;

// LINE 282:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _T66;

	__asm        mov    eax, [ebp-0x14];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x14];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T5b;
_T5b:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    sMessage.reference, eax;
	__asm        jmp    _T6d;
_T66:
	sMessage.reference = 0x0;
_T6d:
	sMessage.c_str_ptr = 0x0;
	__asm        jmp    _T79;
// LINE 284:
_T79:
	nFullStringID = LanguageManager::GetFullStringID(nStringID, 0x0);
// LINE 285:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1030], eax;
	__asm        cmp    dword ptr [ebp-0x1030], 0;
	__asm        jne    _T3a7;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1030], eax;
	__asm        jmp    _Te9;
_Te9:
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1044], eax;
	__asm        cmp    dword ptr [ebp-0x1044], 0xFFFFFFFF;
	__asm        jne    _T143;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1040], eax;
	__asm        mov    eax, [ebp-0x1040];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T134;
_T134:
	exit(0x1);
	__asm        jmp    _T143;
_T143:
	__asm        jmp    _T148;
_T148:
	__asm        mov    eax, sMessage.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T179;

	__asm        cmp    dword ptr [ebp-0x1044], 0;
	__asm        je     _T1da;

	__asm        jmp    _T167;
_T167:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    ecx, [ebp-0x1044];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T1da;
_T179:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1038], eax;
	__asm        cmp    dword ptr [ebp-0x1038], 0;
	__asm        je     _T1ba;

	__asm        mov    eax, [ebp-0x1044];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x1038];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x1034], eax;
	__asm        jmp    _T1c4;
_T1ba:
	__asm        mov    dword ptr [ebp-0x1034], 0;
_T1c4:
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        mov    eax, [ebp-0x1034];
	__asm        mov    sMessage.reference, eax;
	__asm        jmp    _T219;
_T1da:
	__asm        cmp    dword ptr [ebp-0x1044], 0;
	__asm        je     _T219;

	__asm        jmp    _T1ec;
_T1ec:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x103C], eax;
	__asm        mov    eax, [ebp-0x1044];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x103C];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T219;
_T219:
	__asm        mov    eax, [ebp-0x1044];
	__asm        mov    ecx, sMessage.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T22a;
_T22a:
	__asm        jmp    _T22f;
_T22f:
	__asm        jmp    _T234;
_T234:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1058], eax;
	__asm        jmp    _T24c;
_T24c:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    ecx, 0xFFFFFFFF;
	__asm        sub    ecx, [ebp-0x1058];
	__asm        cmp    [eax+4], ecx;
	__asm        jb     _T29b;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1054], eax;
	__asm        mov    eax, [ebp-0x1054];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T28c;
_T28c:
	exit(0x1);
	__asm        jmp    _T29b;
_T29b:
	__asm        jmp    _T2a0;
_T2a0:
	__asm        mov    eax, sMessage.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T2cf;

	__asm        jmp    _T2b2;
_T2b2:
	__asm        jmp    _T2b7;
_T2b7:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, sMessage.reference;
	__asm        sub    eax, [ecx+4];
	__asm        cmp    eax, [ebp-0x1058];
	__asm        jae    _T344;
_T2cf:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x104C], eax;
	__asm        cmp    dword ptr [ebp-0x104C], 0;
	__asm        je     _T329;

	__asm        jmp    _T2f1;
_T2f1:
	__asm        jmp    _T2f6;
_T2f6:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, [ebp-0x1058];
	__asm        push   eax;
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x104C];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x1048], eax;
	__asm        jmp    _T333;
_T329:
	__asm        mov    dword ptr [ebp-0x1048], 0;
_T333:
	__asm        lea    ecx, sMessage.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        mov    eax, [ebp-0x1048];
	__asm        mov    sMessage.reference, eax;
_T344:
	__asm        cmp    dword ptr [ebp-0x1058], 0;
	__asm        je     _T38c;

	__asm        jmp    _T356;
_T356:
	__asm        jmp    _T35b;
_T35b:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, sMessage.reference;
	__asm        add    eax, [ecx];
	__asm        mov    [ebp-0x1050], eax;
	__asm        mov    eax, [ebp-0x1058];
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        mov    eax, [ebp-0x1050];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T38c;
_T38c:
	__asm        mov    eax, [ebp-0x1058];
	__asm        mov    ecx, sMessage.reference;
	__asm        add    [ecx+4], eax;
	__asm        jmp    _T39d;
_T39d:
	__asm        jmp    _T3a2;
_T3a2:
	__asm        jmp    _T53b;
_T3a7:
	__asm        jmp    _T3ac;
_T3ac:
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1074], eax;
	__asm        cmp    dword ptr [ebp-0x1074], 0xFFFFFFFF;
	__asm        jne    _T406;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1068], eax;
	__asm        mov    eax, [ebp-0x1068];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T3f7;
_T3f7:
	exit(0x1);
	__asm        jmp    _T406;
_T406:
	__asm        jmp    _T40b;
_T40b:
	__asm        mov    eax, sMessage.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T43c;

	__asm        cmp    dword ptr [ebp-0x1074], 0;
	__asm        je     _T4e1;

	__asm        jmp    _T42a;
_T42a:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    ecx, [ebp-0x1074];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T4e1;
_T43c:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1060], eax;
	__asm        cmp    dword ptr [ebp-0x1060], 0;
	__asm        je     _T47d;

	__asm        mov    eax, [ebp-0x1074];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x1060];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x105C], eax;
	__asm        jmp    _T487;
_T47d:
	__asm        mov    dword ptr [ebp-0x105C], 0;
_T487:
	__asm        mov    eax, sMessage.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sMessage.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T4ce;

	__asm        mov    eax, sMessage.reference;
	__asm        mov    [ebp-0x1070], eax;
	__asm        mov    eax, [ebp-0x1070];
	__asm        mov    [ebp-0x106C], eax;
	__asm        cmp    dword ptr [ebp-0x106C], 0;
	__asm        je     _T4ce;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x106C];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T4ce;
_T4ce:
	__asm        jmp    _T4d3;
_T4d3:
	__asm        mov    eax, [ebp-0x105C];
	__asm        mov    sMessage.reference, eax;
	__asm        jmp    _T520;
_T4e1:
	__asm        cmp    dword ptr [ebp-0x1074], 0;
	__asm        je     _T520;

	__asm        jmp    _T4f3;
_T4f3:
	__asm        mov    eax, sMessage.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1064], eax;
	__asm        mov    eax, [ebp-0x1074];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x102C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1064];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T520;
_T520:
	__asm        mov    eax, [ebp-0x1074];
	__asm        mov    ecx, sMessage.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T531;
_T531:
	__asm        jmp    _T536;
_T536:
	__asm        jmp    _T53b;
// LINE 286:
_T53b:
	__asm        mov    eax, lType;
	__asm        push   eax;
	__asm        lea    eax, sMessage.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, lID;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::CreateMessageBox;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, sMessage.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sMessage.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T5d8;

	__asm        mov    eax, sMessage.reference;
	__asm        mov    [ebp-0x24], eax;
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-0x20], eax;
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        je     _T5d8;

	__asm        mov    eax, [ebp-0x20];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T5b8;

	__asm        mov    eax, [ebp-0x20];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x28], eax;
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    [ebp-0x2C], eax;
	__asm        mov    eax, [ebp-0x2C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    dword ptr [eax], 0;
_T5b8:
	__asm        jmp    _T5bd;
_T5bd:
	__asm        jmp    _T5c2;
_T5c2:
	__asm        mov    eax, [ebp-0x20];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T5d3;
_T5d3:
	__asm        jmp    _T5d8;
_T5d8:
	__asm        jmp    _T5dd;
_T5dd:
	__asm        cmp    sMessage.c_str_ptr, 0;
	__asm        je     _T5ff;

	__asm        mov    eax, sMessage.c_str_ptr;
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T5ff:
	__asm        jmp    _T604;
_T604:
	__asm        mov    eax, [ebp-0x10];
	__asm        jmp    __RETURN;
// LINE 287:
__RETURN:
}

// FUNCTION: COPTER_D 0x0043f8cc
void CGameApp::DestroyMessageBox() {
// LINE 298:
	this-><CGameApp+0xa4:4>--;
// LINE 299:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xA4], 0;
	__asm        jge    _T32;
// LINE 300:
	this-><CGameApp+0xa4:4> = 0x0;
// LINE 301:
_T32:
	return;
}

// FUNCTION: COPTER_D 0x0043f908
int32_t CGameApp::CreateCheatCodeEntryMessageBox() {
	/*bp-0x4*/   /*packed*/ struct SparkalColor colorMessageFont;
	/*bp-0x8*/   /*packed*/ struct SparkalColor colorButtonFontHighlighted;
	/*bp-0xc*/   /*packed*/ class MessageBoxWindowEdit *tempMessageBoxWindowEdit;
	/*bp-0x10*/  /*packed*/ struct SparkalColor colorButtonFont;


	__asm        mov    dword ptr [ebp-0x34], 0;
// LINE 308:
	__asm        jmp    _T18;
// LINE 309:
_T18:
	__asm        jmp    _T1d;
// LINE 310:
_T1d:
	__asm        jmp    _T22;
// LINE 313:
_T22:
	__asm        mov    byte ptr [ebp-0x14], 0x10;
	__asm        mov    byte ptr [ebp-0x13], 0x15;
	__asm        mov    byte ptr [ebp-0x12], 0x1F;
	__asm        jmp    _T33;
_T33:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    reinterpret_cast<uint32_t>(colorMessageFont.Blue), eax;
// LINE 314:
	__asm        mov    byte ptr [ebp-0x18], 0xA;
	__asm        mov    byte ptr [ebp-0x17], 0x85;
	__asm        mov    byte ptr [ebp-0x16], 0xDA;
	__asm        jmp    _T4a;
_T4a:
	__asm        mov    eax, [ebp-0x18];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFont.Blue), eax;
// LINE 315:
	__asm        mov    byte ptr [ebp-0x1C], 0xD3;
	__asm        mov    byte ptr [ebp-0x1B], 0xDA;
	__asm        mov    byte ptr [ebp-0x1A], 0xFF;
	__asm        jmp    _T61;
_T61:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    reinterpret_cast<uint32_t>(colorButtonFontHighlighted.Blue), eax;
// LINE 322:
	__asm        push   0xA8;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x20], eax;
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        je     _T170;

	__asm        cmp    this, 0;
	__asm        je     _T99;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    _Ta0;
_T99:
	__asm        mov    dword ptr [ebp-0x38], 0;
_Ta0:
	__asm        or     dword ptr [ebp-0x34], 1;
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x40], eax;
	__asm        cmp    dword ptr [ebp-0x40], 0;
	__asm        je     _Tf4;

	__asm        mov    eax, [ebp-0x40];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x40];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _Te9;
_Te9:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _Tfb;
_Tf4:
	__asm        mov    dword ptr [ebp-0x24], 0;
_Tfb:
	__asm        mov    dword ptr [ebp-0x28], 0;
	__asm        jmp    _T107;
_T107:
	__asm        lea    eax, [ebp-0x28];
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    _T112;
_T112:
	__asm        mov    dword ptr [ebp-0x30], 0;
	__asm        mov    dword ptr [ebp-0x2C], 0;
	__asm        jmp    _T125;
_T125:
	__asm        mov    eax, SZ_ABOUT_BOX_ANIMATION_FILE_NAME_0;
	__asm        push   eax;
	__asm        mov    eax, SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_0;
	__asm        push   eax;
	__asm        mov    eax, SZ_ABOUT_BOX_IMAGE_FILE_NAME_0;
	__asm        push   eax;
	__asm        mov    eax, SZ_CHEAT_BOX_TEXT_IMAGE_FILE_NAME;
	__asm        push   eax;
	__asm        push   1;
	__asm        push   1;
	__asm        mov    eax, [ebp-0x38];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x7DF;
	__asm        mov    eax, [ebp-0x3C];
	__asm        push   eax;
	__asm        push   0x25;
	__asm        push   0x10001;
	__asm        lea    eax, [ebp-0x30];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x20];
	__asm        call   MessageBoxWindowEdit::MessageBoxWindowEdit;
	__asm        mov    tempMessageBoxWindowEdit, eax;
	__asm        jmp    _T177;
_T170:
	tempMessageBoxWindowEdit = 0x0;
_T177:
	__asm        test   byte ptr [ebp-0x34], 1;
	__asm        je     _T239;

	__asm        and    dword ptr [ebp-0x34], 0xFFFFFFFE;
	__asm        mov    eax, [ebp-0x24];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x24];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T208;

	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x4C], eax;
	__asm        cmp    dword ptr [ebp-0x4C], 0;
	__asm        je     _T208;

	__asm        mov    eax, [ebp-0x4C];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T1e8;

	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x54], eax;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    dword ptr [eax], 0;
_T1e8:
	__asm        jmp    _T1ed;
_T1ed:
	__asm        jmp    _T1f2;
_T1f2:
	__asm        mov    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T203;
_T203:
	__asm        jmp    _T208;
_T208:
	__asm        jmp    _T20d;
_T20d:
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T22f;

	__asm        mov    eax, [ebp-0x28];
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, [ebp-0x48];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T22f:
	__asm        jmp    _T234;
_T234:
	__asm        jmp    _T239;
// LINE 323:
_T239:
	__asm        cmp    tempMessageBoxWindowEdit, 0;
	__asm        je     _T29b;
// LINE 324:
	__asm        lea    eax, colorMessageFont.Blue;
	__asm        push   eax;
	__asm        mov    eax, tempMessageBoxWindowEdit;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindowEdit;
	__asm        call   dword ptr [eax+0xC4];
// LINE 325:
	__asm        lea    eax, colorButtonFontHighlighted.Blue;
	__asm        push   eax;
	__asm        lea    eax, colorButtonFont.Blue;
	__asm        push   eax;
	__asm        mov    eax, tempMessageBoxWindowEdit;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindowEdit;
	__asm        call   dword ptr [eax+0xC8];
// LINE 326:
	__asm        mov    eax, tempMessageBoxWindowEdit;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindowEdit;
	__asm        call   dword ptr [eax+4];
// LINE 327:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, tempMessageBoxWindowEdit;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempMessageBoxWindowEdit;
	__asm        call   dword ptr [eax+0x40];
// LINE 328:
	this-><CGameApp+0xa4:4>++;
// LINE 329:
	return 0x1;
// LINE 331:
_T29b:
	return 0x0;
// LINE 332:
}

// FUNCTION: COPTER_D 0x0043fbaf
void CGameApp::DestroyCheatCodeEntryMessageBox() {
// LINE 340:
	this->CGameApp::DestroyMessageBox();
// LINE 341:
	return;
}

// FUNCTION: COPTER_D 0x0043fbcd
int32_t CGameApp::DoCheatCode(/*packed*/ class basic_string<char>& sCheatCodeString) {
	/*bp-0x4*/   uint32_t nTextPosition;
	/*bp-0x8*/   char * szCheatOff;
	/*bp-0xc*/   char * szCheatSoundFileName;
	/*bp-0x10*/  char * szCheatOn;
	/*bp-0x14*/  int32_t nReturnValue;


	__asm        mov    dword ptr [ebp-0x14C], 0;
// LINE 353:
	nReturnValue = 0x0;
// LINE 354:
	szCheatSoundFileName = 0x0;
// LINE 356:
	szCheatOn = 0x598830;
// LINE 357:
	szCheatOff = 0x59883c;
// LINE 360:
	__asm        jmp    _T3d;
_T3d:
	__asm        jmp    _T42;
_T42:
	__asm        push   0x59884C;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x59884C;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find_str;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _Tb3;
// LINE 362:
	__asm        cmp    G_CheatCodes[0], 0;
	__asm        jne    _T84;

	G_CheatCodes[0] = 0x1;
	__asm        jmp    _T8e;
_T84:
	G_CheatCodes[0] = 0x0;
// LINE 363:
_T8e:
	__asm        cmp    G_CheatCodes[0], 0;
	__asm        je     _Ta6;
// LINE 364:
	szCheatSoundFileName = szCheatOn;
// LINE 365:
	__asm        jmp    _Tac;
// LINE 366:
_Ta6:
	szCheatSoundFileName = szCheatOff;
// LINE 367:
_Tac:
	nReturnValue = 0x1;
// LINE 369:
_Tb3:
	__asm        jmp    _Tb8;
_Tb8:
	__asm        jmp    _Tbd;
_Tbd:
	__asm        push   0x598860;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x598860;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find_str;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T12e;
// LINE 370:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        jne    _Tff;

	G_CheatCodes[1] = 0x1;
	__asm        jmp    _T109;
_Tff:
	G_CheatCodes[1] = 0x0;
// LINE 371:
_T109:
	__asm        cmp    G_CheatCodes[1], 0;
	__asm        je     _T121;
// LINE 372:
	szCheatSoundFileName = szCheatOn;
// LINE 373:
	__asm        jmp    _T127;
// LINE 374:
_T121:
	szCheatSoundFileName = szCheatOff;
// LINE 375:
_T127:
	nReturnValue = 0x1;
// LINE 377:
_T12e:
	__asm        jmp    _T133;
_T133:
	__asm        jmp    _T138;
_T138:
	__asm        push   0x59886C;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x59886C;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find_str;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T1cb;
// LINE 378:
	__asm        cmp    G_CheatCodes[2], 0;
	__asm        jne    _T17a;

	G_CheatCodes[2] = 0x1;
	__asm        jmp    _T184;
_T17a:
	G_CheatCodes[2] = 0x0;
// LINE 379:
_T184:
	__asm        cmp    G_CheatCodes[2], 0;
	__asm        je     _T1be;
// LINE 380:
	__asm        mov    eax, G_uheli;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [ecx+eax*2];
	__asm        mov    eax, S_helitype_data[0].fuel_capacity[eax*8];
	__asm        mov    ecx, G_uheli;
	__asm        mov    [ecx+0x320], eax;
// LINE 381:
	szCheatSoundFileName = szCheatOn;
// LINE 383:
	__asm        jmp    _T1c4;
// LINE 384:
_T1be:
	szCheatSoundFileName = szCheatOff;
// LINE 385:
_T1c4:
	nReturnValue = 0x1;
// LINE 387:
_T1cb:
	__asm        jmp    _T1d0;
_T1d0:
	__asm        jmp    _T1d5;
_T1d5:
	__asm        push   0x598884;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x598884;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find_str;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T246;
// LINE 388:
	__asm        cmp    G_CheatCodes[4], 0;
	__asm        jne    _T217;

	G_CheatCodes[4] = 0x1;
	__asm        jmp    _T221;
_T217:
	G_CheatCodes[4] = 0x0;
// LINE 389:
_T221:
	__asm        cmp    G_CheatCodes[4], 0;
	__asm        je     _T239;
// LINE 390:
	szCheatSoundFileName = szCheatOn;
// LINE 391:
	__asm        jmp    _T23f;
// LINE 392:
_T239:
	szCheatSoundFileName = szCheatOff;
// LINE 393:
_T23f:
	nReturnValue = 0x1;
// LINE 395:
_T246:
	__asm        jmp    _T24b;
_T24b:
	__asm        jmp    _T250;
_T250:
	__asm        push   0x5988A8;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x5988A8;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find_str;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T2bc;
// LINE 397:
	__asm        cmp    G_camera_mode, 3;
	__asm        jne    _T2b7;
// LINE 398:
// Block start:
	/*bp-0x18*/  /*packed*/ struct Point2d *position2d;
	position2d = S3HeliGetFreePad();
// LINE 399:
	S3PersonUserAppear(position2d->x, position2d->y, 0x50000, 0x50000);
// LINE 400:
	szCheatSoundFileName = szCheatOn;
// LINE 401:
	nReturnValue = 0x1;
// LINE 404:
// Block end:
_T2b7:
	__asm        jmp    _T515;
_T2bc:
	__asm        jmp    _T2c1;
_T2c1:
	__asm        jmp    _T2c6;
_T2c6:
	__asm        push   0x5988C4;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0x5988C4;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find_str;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     _T32f;
// LINE 405:
	__asm        cmp    G_camera_mode, 3;
	__asm        jne    _T32a;
// LINE 406:
	S3PersonUserAppear(G_uheli->currpos.x, G_uheli->currpos.y, 0x50000, 0x50000);
// LINE 407:
	szCheatSoundFileName = szCheatOn;
// LINE 408:
	nReturnValue = 0x1;
// LINE 411:
_T32a:
	__asm        jmp    _T515;
_T32f:
	__asm        jmp    _T334;
_T334:
	__asm        push   0x5988DC;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x16C], eax;
	__asm        mov    dword ptr [ebp-0x158], 0;
	__asm        jmp    _T356;
_T356:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T373;

	__asm        cmp    dword ptr [ebp-0x16C], 0;
	__asm        jne    _T382;
_T373:
	__asm        mov    dword ptr [ebp-0x168], 0xFFFFFFFF;
	__asm        jmp    _T4dc;
_T382:
	__asm        jmp    __WHILE_387;
__WHILE_387:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, [ebp-0x158];
	__asm        cmp    eax, [ebp-0x16C];
	__asm        jb     _T4cd;
_FOR_3b1:
	__asm        mov    dword ptr [ebp-0x15C], 0;
	__asm        jmp    _FOR_COND_3b1;
_FOR_NEXT_3b1:
	__asm        inc    dword ptr [ebp-0x15C];
_FOR_COND_3b1:
	__asm        mov    eax, [ebp-0x16C];
	__asm        cmp    [ebp-0x15C], eax;
	__asm        jae    _T438;

	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::data;
	__asm        mov    ecx, [ebp-0x16C];
	__asm        dec    ecx;
	__asm        sub    ecx, [ebp-0x15C];
	__asm        add    eax, ecx;
	__asm        add    eax, [ebp-0x158];
	__asm        mov    [ebp-0x160], eax;
	__asm        mov    eax, [ebp-0x16C];
	__asm        add    eax, 0x5988DC;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x15C];
	__asm        movsx  eax, byte ptr [eax];
	__asm        mov    ecx, [ebp-0x160];
	__asm        movsx  ecx, byte ptr [ecx];
	__asm        cmp    eax, ecx;
	__asm        je     _T417;

	__asm        jmp    _T41c;
_T417:
	__asm        jmp    _T433;
_T41c:
	__asm        jmp    _T42e;

	__asm        cmp    dword ptr [ebp-0x164], 0;
	__asm        je     _T433;
_T42e:
	__asm        jmp    _T438;
_T433:
	__asm        jmp    _FOR_NEXT_3b1;
_T438:
	__asm        mov    eax, [ebp-0x16C];
	__asm        cmp    [ebp-0x15C], eax;
	__asm        jne    _T45b;

	__asm        mov    eax, [ebp-0x158];
	__asm        mov    [ebp-0x168], eax;
	__asm        jmp    _T4dc;
_T45b:
	__asm        mov    eax, [ebp-0x16C];
	__asm        sub    eax, [ebp-0x15C];
	__asm        add    eax, [ebp-0x158];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x16C];
	__asm        add    eax, 0x5988DC;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x15C];
	__asm        mov    al, [eax];
	__asm        push   eax;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find;
	__asm        mov    [ebp-0x154], eax;
	__asm        cmp    dword ptr [ebp-0x154], 0xFFFFFFFF;
	__asm        jne    _T4ad;

	__asm        mov    dword ptr [ebp-0x168], 0xFFFFFFFF;
	__asm        jmp    _T4dc;
_T4ad:
	__asm        mov    eax, [ebp-0x154];
	__asm        mov    ecx, [ebp-0x16C];
	__asm        sub    ecx, [ebp-0x15C];
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        mov    [ebp-0x158], eax;
	__asm        jmp    __WHILE_387;
_T4cd:
	__asm        mov    dword ptr [ebp-0x168], 0xFFFFFFFF;
	__asm        jmp    _T4dc;
_T4dc:
	__asm        jmp    _T4e1;
_T4e1:
	__asm        cmp    dword ptr [ebp-0x168], 0xFFFFFFFF;
	__asm        je     _T515;
// LINE 412:
	__asm        cmp    gCurrentCityType, 2;
	__asm        jne    _T515;
// LINE 413:
	SetUserPoints(0x3e9);
// LINE 414:
	szCheatSoundFileName = szCheatOn;
// LINE 415:
	nReturnValue = 0x1;
// LINE 418:
_T515:
	__asm        jmp    _T51a;
_T51a:
	__asm        push   0x5988F4;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x188], eax;
	__asm        mov    dword ptr [ebp-0x174], 0;
	__asm        jmp    _T53c;
_T53c:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T559;

	__asm        cmp    dword ptr [ebp-0x188], 0;
	__asm        jne    _T568;
_T559:
	__asm        mov    dword ptr [ebp-0x184], 0xFFFFFFFF;
	__asm        jmp    _T6c2;
_T568:
	__asm        jmp    __WHILE_56d;
__WHILE_56d:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, [ebp-0x174];
	__asm        cmp    eax, [ebp-0x188];
	__asm        jb     _T6b3;
_FOR_597:
	__asm        mov    dword ptr [ebp-0x178], 0;
	__asm        jmp    _FOR_COND_597;
_FOR_NEXT_597:
	__asm        inc    dword ptr [ebp-0x178];
_FOR_COND_597:
	__asm        mov    eax, [ebp-0x178];
	__asm        cmp    [ebp-0x188], eax;
	__asm        jbe    _T61e;

	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::data;
	__asm        mov    ecx, [ebp-0x188];
	__asm        dec    ecx;
	__asm        sub    ecx, [ebp-0x178];
	__asm        add    eax, ecx;
	__asm        add    eax, [ebp-0x174];
	__asm        mov    [ebp-0x17C], eax;
	__asm        mov    eax, [ebp-0x188];
	__asm        add    eax, 0x5988F4;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x178];
	__asm        movsx  eax, byte ptr [eax];
	__asm        mov    ecx, [ebp-0x17C];
	__asm        movsx  ecx, byte ptr [ecx];
	__asm        cmp    eax, ecx;
	__asm        je     _T5fd;

	__asm        jmp    _T602;
_T5fd:
	__asm        jmp    _T619;
_T602:
	__asm        jmp    _T614;

	__asm        cmp    dword ptr [ebp-0x180], 0;
	__asm        je     _T619;
_T614:
	__asm        jmp    _T61e;
_T619:
	__asm        jmp    _FOR_NEXT_597;
_T61e:
	__asm        mov    eax, [ebp-0x178];
	__asm        cmp    [ebp-0x188], eax;
	__asm        jne    _T641;

	__asm        mov    eax, [ebp-0x174];
	__asm        mov    [ebp-0x184], eax;
	__asm        jmp    _T6c2;
_T641:
	__asm        mov    eax, [ebp-0x188];
	__asm        sub    eax, [ebp-0x178];
	__asm        add    eax, [ebp-0x174];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x188];
	__asm        add    eax, 0x5988F4;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x178];
	__asm        mov    al, [eax];
	__asm        push   eax;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find;
	__asm        mov    [ebp-0x170], eax;
	__asm        cmp    dword ptr [ebp-0x170], 0xFFFFFFFF;
	__asm        jne    _T693;

	__asm        mov    dword ptr [ebp-0x184], 0xFFFFFFFF;
	__asm        jmp    _T6c2;
_T693:
	__asm        mov    eax, [ebp-0x170];
	__asm        mov    ecx, [ebp-0x188];
	__asm        sub    ecx, [ebp-0x178];
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        mov    [ebp-0x174], eax;
	__asm        jmp    __WHILE_56d;
_T6b3:
	__asm        mov    dword ptr [ebp-0x184], 0xFFFFFFFF;
	__asm        jmp    _T6c2;
_T6c2:
	__asm        jmp    _T6c7;
_T6c7:
	__asm        cmp    dword ptr [ebp-0x184], 0xFFFFFFFF;
	__asm        je     _T71f;
// LINE 419:
	__asm        cmp    G_CheatCodes[5], 0;
	__asm        jne    _T6f0;

	G_CheatCodes[5] = 0x1;
	__asm        jmp    _T6fa;
_T6f0:
	G_CheatCodes[5] = 0x0;
// LINE 420:
_T6fa:
	__asm        cmp    G_CheatCodes[5], 0;
	__asm        je     _T712;
// LINE 421:
	szCheatSoundFileName = szCheatOn;
// LINE 422:
	__asm        jmp    _T718;
// LINE 423:
_T712:
	szCheatSoundFileName = szCheatOff;
// LINE 424:
_T718:
	nReturnValue = 0x1;
// LINE 426:
_T71f:
	__asm        jmp    _T724;
_T724:
	__asm        push   0x598904;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1A4], eax;
	__asm        mov    dword ptr [ebp-0x190], 0;
	__asm        jmp    _T746;
_T746:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T763;

	__asm        cmp    dword ptr [ebp-0x1A4], 0;
	__asm        jne    _T772;
_T763:
	__asm        mov    dword ptr [ebp-0x1A0], 0xFFFFFFFF;
	__asm        jmp    _T8cc;
_T772:
	__asm        jmp    __WHILE_777;
__WHILE_777:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, [ebp-0x190];
	__asm        cmp    eax, [ebp-0x1A4];
	__asm        jb     _T8bd;
_FOR_7a1:
	__asm        mov    dword ptr [ebp-0x194], 0;
	__asm        jmp    _FOR_COND_7a1;
_FOR_NEXT_7a1:
	__asm        inc    dword ptr [ebp-0x194];
_FOR_COND_7a1:
	__asm        mov    eax, [ebp-0x1A4];
	__asm        cmp    [ebp-0x194], eax;
	__asm        jae    _T828;

	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::data;
	__asm        mov    ecx, [ebp-0x1A4];
	__asm        dec    ecx;
	__asm        sub    ecx, [ebp-0x194];
	__asm        add    eax, ecx;
	__asm        add    eax, [ebp-0x190];
	__asm        mov    [ebp-0x198], eax;
	__asm        mov    eax, [ebp-0x1A4];
	__asm        add    eax, 0x598904;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x194];
	__asm        movsx  eax, byte ptr [eax];
	__asm        mov    ecx, [ebp-0x198];
	__asm        movsx  ecx, byte ptr [ecx];
	__asm        cmp    eax, ecx;
	__asm        je     _T807;

	__asm        jmp    _T80c;
_T807:
	__asm        jmp    _T823;
_T80c:
	__asm        jmp    _T81e;

	__asm        cmp    dword ptr [ebp-0x19C], 0;
	__asm        je     _T823;
_T81e:
	__asm        jmp    _T828;
_T823:
	__asm        jmp    _FOR_NEXT_7a1;
_T828:
	__asm        mov    eax, [ebp-0x1A4];
	__asm        cmp    [ebp-0x194], eax;
	__asm        jne    _T84b;

	__asm        mov    eax, [ebp-0x190];
	__asm        mov    [ebp-0x1A0], eax;
	__asm        jmp    _T8cc;
_T84b:
	__asm        mov    eax, [ebp-0x1A4];
	__asm        sub    eax, [ebp-0x194];
	__asm        add    eax, [ebp-0x190];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1A4];
	__asm        add    eax, 0x598904;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x194];
	__asm        mov    al, [eax];
	__asm        push   eax;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find;
	__asm        mov    [ebp-0x18C], eax;
	__asm        cmp    dword ptr [ebp-0x18C], 0xFFFFFFFF;
	__asm        jne    _T89d;

	__asm        mov    dword ptr [ebp-0x1A0], 0xFFFFFFFF;
	__asm        jmp    _T8cc;
_T89d:
	__asm        mov    eax, [ebp-0x18C];
	__asm        mov    ecx, [ebp-0x1A4];
	__asm        sub    ecx, [ebp-0x194];
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        mov    [ebp-0x190], eax;
	__asm        jmp    __WHILE_777;
_T8bd:
	__asm        mov    dword ptr [ebp-0x1A0], 0xFFFFFFFF;
	__asm        jmp    _T8cc;
_T8cc:
	__asm        mov    eax, [ebp-0x1A0];
	__asm        mov    nTextPosition, eax;
	__asm        jmp    _T8da;
_T8da:
	__asm        cmp    nTextPosition, 0xFFFFFFFF;
	__asm        je     _T9cf;
// LINE 431:
// Block start:
	/*bp-0x1c*/  int32_t nNewCareerLevel;
	/*bp-0x20*/  int32_t nCharsToCopy;
	/*bp-0x24*/  char szCareerLevel[3];
	__asm        cmp    gCurrentCityType, 2;
	__asm        jne    _T9cf;
// LINE 432:
	__asm        push   0x598918;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        add    nTextPosition, eax;
// LINE 433:
	__asm        jmp    _T906;
_T906:
	nCharsToCopy = (sCheatCodeString.reference-><basic_string_ref<char>+0x04:4> - nTextPosition);
// LINE 434:
	__asm        cmp    nCharsToCopy, 0;
	__asm        jl     _T9cf;
// LINE 435:
	__asm        cmp    nCharsToCopy, 2;
	__asm        jle    _T930;
// LINE 436:
	nCharsToCopy = 0x2;
// LINE 437:
_T930:
	__asm        jmp    _T935;
_T935:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        dec    eax;
	__asm        cmp    eax, nTextPosition;
	__asm        jbe    _T99e;
// LINE 438:
	__asm        jmp    _T94d;
_T94d:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T975;

	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1C4], eax;
	__asm        jmp    _T984;

	__asm        jmp    _T984;
_T975:
	__asm        mov    dword ptr [ebp-0x1C4], 0;
	__asm        jmp    _T984;
_T984:
	__asm        mov    eax, nCharsToCopy;
	__asm        push   eax;
	__asm        mov    eax, nTextPosition;
	__asm        add    eax, [ebp-0x1C4];
	__asm        push   eax;
	__asm        lea    eax, szCareerLevel[0];
	__asm        push   eax;
	__asm        call   strncpy;
	__asm        add    esp, 0xC;
// LINE 439:
_T99e:
	nNewCareerLevel = atoi(szCareerLevel[0]);
// LINE 440:
	__asm        cmp    nNewCareerLevel, 1;
	__asm        jge    _T9c1;

	__asm        cmp    nNewCareerLevel, 0x1F;
	__asm        jg     _T9cf;
// LINE 443:
_T9c1:
	G_CheatCodes[3] = nNewCareerLevel;
// LINE 444:
	szCheatSoundFileName = szCheatOn;
// LINE 449:
// Block end:
_T9cf:
	__asm        jmp    _T9d4;
_T9d4:
	__asm        push   0x59892C;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1C0], eax;
	__asm        mov    dword ptr [ebp-0x1AC], 0;
	__asm        jmp    _T9f6;
_T9f6:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _Ta13;

	__asm        cmp    dword ptr [ebp-0x1C0], 0;
	__asm        jne    _Ta22;
_Ta13:
	__asm        mov    dword ptr [ebp-0x1BC], 0xFFFFFFFF;
	__asm        jmp    _Tb7c;
_Ta22:
	__asm        jmp    __WHILE_a27;
__WHILE_a27:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        sub    eax, [ebp-0x1AC];
	__asm        cmp    eax, [ebp-0x1C0];
	__asm        jb     _Tb6d;
_FOR_a51:
	__asm        mov    dword ptr [ebp-0x1B0], 0;
	__asm        jmp    _FOR_COND_a51;
_FOR_NEXT_a51:
	__asm        inc    dword ptr [ebp-0x1B0];
_FOR_COND_a51:
	__asm        mov    eax, [ebp-0x1C0];
	__asm        cmp    [ebp-0x1B0], eax;
	__asm        jae    _Tad8;

	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::data;
	__asm        mov    ecx, [ebp-0x1C0];
	__asm        dec    ecx;
	__asm        sub    ecx, [ebp-0x1B0];
	__asm        add    eax, ecx;
	__asm        add    eax, [ebp-0x1AC];
	__asm        mov    [ebp-0x1B4], eax;
	__asm        mov    eax, [ebp-0x1C0];
	__asm        add    eax, 0x59892C;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x1B0];
	__asm        movsx  eax, byte ptr [eax];
	__asm        mov    ecx, [ebp-0x1B4];
	__asm        movsx  ecx, byte ptr [ecx];
	__asm        cmp    eax, ecx;
	__asm        je     _Tab7;

	__asm        jmp    _Tabc;
_Tab7:
	__asm        jmp    _Tad3;
_Tabc:
	__asm        jmp    _Tace;

	__asm        cmp    dword ptr [ebp-0x1B8], 0;
	__asm        je     _Tad3;
_Tace:
	__asm        jmp    _Tad8;
_Tad3:
	__asm        jmp    _FOR_NEXT_a51;
_Tad8:
	__asm        mov    eax, [ebp-0x1C0];
	__asm        cmp    [ebp-0x1B0], eax;
	__asm        jne    _Tafb;

	__asm        mov    eax, [ebp-0x1AC];
	__asm        mov    [ebp-0x1BC], eax;
	__asm        jmp    _Tb7c;
_Tafb:
	__asm        mov    eax, [ebp-0x1C0];
	__asm        sub    eax, [ebp-0x1B0];
	__asm        add    eax, [ebp-0x1AC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1C0];
	__asm        add    eax, 0x59892C;
	__asm        dec    eax;
	__asm        sub    eax, [ebp-0x1B0];
	__asm        mov    al, [eax];
	__asm        push   eax;
	__asm        mov    ecx, sCheatCodeString;
	__asm        call   basic_string<char>::find;
	__asm        mov    [ebp-0x1A8], eax;
	__asm        cmp    dword ptr [ebp-0x1A8], 0xFFFFFFFF;
	__asm        jne    _Tb4d;

	__asm        mov    dword ptr [ebp-0x1BC], 0xFFFFFFFF;
	__asm        jmp    _Tb7c;
_Tb4d:
	__asm        mov    eax, [ebp-0x1A8];
	__asm        mov    ecx, [ebp-0x1C0];
	__asm        sub    ecx, [ebp-0x1B0];
	__asm        dec    ecx;
	__asm        sub    eax, ecx;
	__asm        mov    [ebp-0x1AC], eax;
	__asm        jmp    __WHILE_a27;
_Tb6d:
	__asm        mov    dword ptr [ebp-0x1BC], 0xFFFFFFFF;
	__asm        jmp    _Tb7c;
_Tb7c:
	__asm        mov    eax, [ebp-0x1BC];
	__asm        mov    nTextPosition, eax;
	__asm        jmp    _Tb8a;
_Tb8a:
	__asm        cmp    nTextPosition, 0xFFFFFFFF;
	__asm        je     _Tc80;
// LINE 453:
// Block start:
	/*bp-0x28*/  char szBucks[3];
	/*bp-0x2c*/  const long lMaxBucks;
	/*bp-0x30*/  int32_t nCharsToCopy;
	/*bp-0x34*/  int32_t nNewBucks;
	lMaxBucks = 0xc350;
// LINE 455:
	__asm        push   0x598950;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        add    nTextPosition, eax;
// LINE 456:
	__asm        jmp    _Tbb0;
_Tbb0:
	nCharsToCopy = (sCheatCodeString.reference-><basic_string_ref<char>+0x04:4> - nTextPosition);
// LINE 457:
	__asm        cmp    nCharsToCopy, 0;
	__asm        jl     _Tc80;
// LINE 458:
	__asm        cmp    nCharsToCopy, 5;
	__asm        jle    _Tbda;
// LINE 459:
	nCharsToCopy = 0x5;
// LINE 460:
_Tbda:
	__asm        jmp    _Tbdf;
_Tbdf:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        dec    eax;
	__asm        cmp    eax, nTextPosition;
	__asm        jbe    _Tc48;
// LINE 461:
	__asm        jmp    _Tbf7;
_Tbf7:
	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _Tc1f;

	__asm        mov    eax, sCheatCodeString;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1C8], eax;
	__asm        jmp    _Tc2e;

	__asm        jmp    _Tc2e;
_Tc1f:
	__asm        mov    dword ptr [ebp-0x1C8], 0;
	__asm        jmp    _Tc2e;
_Tc2e:
	__asm        mov    eax, nCharsToCopy;
	__asm        push   eax;
	__asm        mov    eax, nTextPosition;
	__asm        add    eax, [ebp-0x1C8];
	__asm        push   eax;
	__asm        lea    eax, szBucks[0];
	__asm        push   eax;
	__asm        call   strncpy;
	__asm        add    esp, 0xC;
// LINE 462:
_Tc48:
	nNewBucks = atoi(szBucks[0]);
// LINE 463:
	__asm        cmp    nNewBucks, 0;
	__asm        jg     _Tc6e;

	__asm        cmp    nNewBucks, 0xC350;
	__asm        jge    _Tc80;
// LINE 467:
_Tc6e:
	ChangeUserMoney(nNewBucks);
// LINE 468:
	szCheatSoundFileName = szCheatOn;
// LINE 482:
// Block end:
_Tc80:
	__asm        cmp    szCheatSoundFileName, 0;
	__asm        je     _Tf4f;
// LINE 484:
// Block start:
	/*bp-0x138*/ char szFullPath[260]; // 0x104 bytes
	/*bp-0x13c*/ /*packed*/ class DigitalSound *tempCheatCodeSound;
	GetPathForFile(0x2, 0x0, szCheatSoundFileName, szFullPath[0]);
// LINE 485:
	__asm        push   0x7A;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x140], eax;
	__asm        cmp    dword ptr [ebp-0x140], 0;
	__asm        je     _Tdf2;

	__asm        or     dword ptr [ebp-0x14C], 1;
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1E4], eax;
	__asm        cmp    dword ptr [ebp-0x1E4], 0;
	__asm        je     _Tdae;

	__asm        lea    eax, szFullPath[0];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x1E4];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _Tcff;
_Tcff:
	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x1E4];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x1E4];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _Td7f;

	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x1E4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1E8], eax;
	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1EC], eax;
	__asm        mov    eax, [ebp-0x1E8];
	__asm        push   eax;
	__asm        lea    eax, szFullPath[0];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1EC];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _Td7a;
_Td7a:
	__asm        jmp    _Td8b;
_Td7f:
	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    dword ptr [eax], 0;
_Td8b:
	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _Td9d;
_Td9d:
	__asm        mov    eax, [ebp-0x1E4];
	__asm        mov    [ebp-0x144], eax;
	__asm        jmp    _Tdb8;
_Tdae:
	__asm        mov    dword ptr [ebp-0x144], 0;
_Tdb8:
	__asm        mov    dword ptr [ebp-0x148], 0;
	__asm        jmp    _Tdc7;
_Tdc7:
	__asm        lea    eax, [ebp-0x148];
	__asm        mov    [ebp-0x150], eax;
	__asm        push   0;
	__asm        mov    eax, [ebp-0x150];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x140];
	__asm        call   DigitalSound::DigitalSound;
	__asm        mov    tempCheatCodeSound, eax;
	__asm        jmp    _Tdfc;
_Tdf2:
	tempCheatCodeSound = 0x0;
_Tdfc:
	__asm        test   byte ptr [ebp-0x14C], 1;
	__asm        je     _Tf06;

	__asm        and    dword ptr [ebp-0x14C], 0xFFFFFFFE;
	__asm        mov    eax, [ebp-0x144];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x144];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _Tec3;

	__asm        mov    eax, [ebp-0x144];
	__asm        mov    [ebp-0x1D8], eax;
	__asm        mov    eax, [ebp-0x1D8];
	__asm        mov    [ebp-0x1D4], eax;
	__asm        cmp    dword ptr [ebp-0x1D4], 0;
	__asm        je     _Tec3;

	__asm        mov    eax, [ebp-0x1D4];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _Tea0;

	__asm        mov    eax, [ebp-0x1D4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1DC], eax;
	__asm        mov    eax, [ebp-0x1DC];
	__asm        mov    [ebp-0x1E0], eax;
	__asm        mov    eax, [ebp-0x1E0];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x1D4];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x1D4];
	__asm        mov    dword ptr [eax], 0;
_Tea0:
	__asm        jmp    _Tea5;
_Tea5:
	__asm        jmp    _Teaa;
_Teaa:
	__asm        mov    eax, [ebp-0x1D4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _Tebe;
_Tebe:
	__asm        jmp    _Tec3;
_Tec3:
	__asm        jmp    _Tec8;
_Tec8:
	__asm        cmp    dword ptr [ebp-0x148], 0;
	__asm        je     _Tefc;

	__asm        mov    eax, [ebp-0x148];
	__asm        mov    [ebp-0x1CC], eax;
	__asm        mov    eax, [ebp-0x1CC];
	__asm        mov    [ebp-0x1D0], eax;
	__asm        mov    eax, [ebp-0x1D0];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_Tefc:
	__asm        jmp    _Tf01;
_Tf01:
	__asm        jmp    _Tf06;
// LINE 486:
_Tf06:
	__asm        mov    eax, tempCheatCodeSound;
	__asm        push   eax;
	__asm        push   0x43E250;
	__asm        mov    eax, tempCheatCodeSound;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempCheatCodeSound;
	__asm        call   dword ptr [eax+0x14];
// LINE 487:
	__asm        mov    eax, glMasterVolume;
	__asm        push   eax;
	__asm        mov    eax, tempCheatCodeSound;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempCheatCodeSound;
	__asm        call   dword ptr [eax+0x24];
// LINE 488:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, tempCheatCodeSound;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempCheatCodeSound;
	__asm        call   dword ptr [eax+8];
// LINE 491:
// Block end:
_Tf4f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x84];
// LINE 492:
	return nReturnValue;
// LINE 493:
}

// FUNCTION: COPTER_D 0x00440b3f
int32_t CGameApp::CheckCommandLineForCheatCodes() {
	/*bp-0x80*/  char szCommandValue[128]; // 0x80 bytes
	/*bp-0x84*/  int32_t i;

// LINE 508:
	__asm        lea    eax, szCommandValue[0];
	__asm        push   eax;
	__asm        push   0x78;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::IsSwitchPresent;
	__asm        test   eax, eax;
	__asm        je     _T284;
// LINE 509:
_FOR_3a:
	for (i = 0x0; (i < 0x80); i++) {
// LINE 510:
		__asm        mov    eax, i;
		__asm        movsx  eax, byte ptr [ebp+eax-0x80];
		__asm        cmp    eax, 0x5F;
		__asm        jne    _T6f;
// LINE 511:
		__asm        mov    eax, i;
		__asm        mov    byte ptr [ebp+eax-0x80], 0x20;
// LINE 512:
_T6f:
	}
// LINE 513:
_T74:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xAC], eax;
	__asm        cmp    dword ptr [ebp-0xAC], 0;
	__asm        je     _T157;

	__asm        lea    eax, szCommandValue[0];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0xAC];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _Tab;
_Tab:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xAC];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xAC];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T128;

	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0xAC];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xB4], eax;
	__asm        mov    eax, [ebp-0xB0];
	__asm        push   eax;
	__asm        lea    eax, szCommandValue[0];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xB4];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T123;
_T123:
	__asm        jmp    _T134;
_T128:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    dword ptr [eax], 0;
_T134:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T146;
_T146:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _T161;
_T157:
	__asm        mov    dword ptr [ebp-0x8C], 0;
_T161:
	__asm        mov    dword ptr [ebp-0x90], 0;
	__asm        jmp    _T170;
_T170:
	__asm        lea    eax, [ebp-0x90];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::DoCheatCode;
	__asm        mov    [ebp-0x88], eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x8C];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T23b;

	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    [ebp-0xA0], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    [ebp-0x9C], eax;
	__asm        cmp    dword ptr [ebp-0x9C], 0;
	__asm        je     _T23b;

	__asm        mov    eax, [ebp-0x9C];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T218;

	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    [ebp-0xA8], eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    dword ptr [eax], 0;
_T218:
	__asm        jmp    _T21d;
_T21d:
	__asm        jmp    _T222;
_T222:
	__asm        mov    eax, [ebp-0x9C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T236;
_T236:
	__asm        jmp    _T23b;
_T23b:
	__asm        jmp    _T240;
_T240:
	__asm        cmp    dword ptr [ebp-0x90], 0;
	__asm        je     _T274;

	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    eax, [ebp-0x98];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T274:
	__asm        jmp    _T279;
_T279:
	__asm        mov    eax, [ebp-0x88];
	__asm        jmp    __RETURN;
// LINE 515:
_T284:
	return 0x0;
// LINE 516:
__RETURN:
}

// FUNCTION: COPTER_D 0x00440dcf
void CGameApp::CreateDebugBuffer() {
	/*bp-0x40*/  char szTypeFaceName[64]; // 0x40 bytes
	/*bp-0x44*/  /*packed*/ struct SparkalColor colorDebugText;

// LINE 525:
	__asm        jmp    _T11;
// LINE 527:
_T11:
	__asm        push   0x134;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x48], eax;
	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        je     _T47;

	__asm        push   0;
	__asm        push   0x30;
	__asm        push   0x280;
	__asm        mov    ecx, [ebp-0x48];
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x54], eax;
	__asm        jmp    _T51;
_T47:
	this-><CGameApp+0x54:4> = 0x0;
// LINE 528:
_T51:
	__asm        push   0;
	__asm        push   0xFF;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x44];
// LINE 529:
	__asm        push   0xFF;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+8];
// LINE 530:
	colorDebugText.Red = 0xff;
// LINE 531:
	colorDebugText.Green = 0x0;
// LINE 532:
	__asm        mov    colorDebugText.Blue, 0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    [ebp-0x54], eax;
// LINE 533:
	__asm        mov    eax, reinterpret_cast<uint32_t>(colorDebugText.Blue);
	__asm        mov    ecx, [ebp-0x54];
	__asm        mov    [ecx+0x38], eax;
	__asm        jmp    _Ta4;
// LINE 534:
_Ta4:
LanguageManager::GetTypefaceForLanguage(0x0, 0x0, szTypeFaceName[0]);
// LINE 535:
	__asm        push   0x1C;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x4C], eax;
	__asm        cmp    dword ptr [ebp-0x4C], 0;
	__asm        je     _Te7;

	__asm        push   1;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0xC;
	__asm        lea    eax, szTypeFaceName[0];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x4C];
	__asm        call   MFont::MFont;
	__asm        mov    [ebp-0x50], eax;
	__asm        jmp    _Tee;
_Te7:
	__asm        mov    dword ptr [ebp-0x50], 0;
_Tee:
	__asm        mov    eax, [ebp-0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x54];
	__asm        call   CBackBuffer::SetFont;
// LINE 536:
	return;
}

// FUNCTION: COPTER_D 0x00440ed6
void CGameApp::DestroyDebugBuffer() {
// LINE 544:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        je     _T5a;
// LINE 545:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T50;

	__asm        mov    ecx, [ebp-4];
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T4b;
_T4b:
	__asm        jmp    _T50;
// LINE 546:
_T50:
	this-><CGameApp+0x54:4> = 0x0;
// LINE 548:
_T5a:
	return;
}

// FUNCTION: COPTER_D 0x00440f3a
void CGameApp::CreatePaletteBuffer() {
// LINE 555:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x42BC], 0;
	__asm        jne    _T59;
// LINE 556:
	__asm        push   0x138;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T4c;

	__asm        mov    ecx, [ebp-4];
	__asm        call   PaletteBuffer::PaletteBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x42BC], eax;
	__asm        jmp    _T59;
_T4c:
	this-><CGameApp+0x42bc:4> = 0x0;
// LINE 558:
_T59:
	return;
}

// FUNCTION: COPTER_D 0x00440f9d
void CGameApp::TogglePaletteBufferDisplay() {
// LINE 566:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x430C], 0;
	__asm        jne    _T46;
// LINE 567:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x42BC], 0;
	__asm        jne    _T34;
// LINE 568:
	this->CGameApp::CreatePaletteBuffer();
// LINE 569:
_T34:
	this-><CGameApp+0x430c:4> = 0x1;
// LINE 571:
	__asm        jmp    _T53;
// LINE 572:
_T46:
	this-><CGameApp+0x430c:4> = 0x0;
// LINE 574:
_T53:
	return;
}

// FUNCTION: COPTER_D 0x00440ffa
void CGameApp::ToggleDebugWindowDisplay() {
// LINE 582:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4310], 0;
	__asm        jne    _T46;
// LINE 583:
	__asm        cmp    gDebugWindow, 0;
	__asm        je     _T34;
// LINE 584:
	gDebugWindow->CDebugWindow::ShowWindow();
// LINE 585:
_T34:
	this-><CGameApp+0x4310:4> = 0x1;
// LINE 587:
	__asm        jmp    _T6b;
// LINE 588:
_T46:
	__asm        cmp    gDebugWindow, 0;
	__asm        je     _T5e;
// LINE 589:
	gDebugWindow->CDebugWindow::HideWindow();
// LINE 590:
_T5e:
	this-><CGameApp+0x4310:4> = 0x0;
// LINE 592:
_T6b:
	return;
}

// FUNCTION: COPTER_D 0x0044106f
void CGameApp::CreatePlayMenu() {
	/*bp-0x4*/   /*packed*/ class UserMenuWindow *myUserMenuWindow;
	/*bp-0x58*/  /*packed*/ struct UserMenuWindowDescription tempUMWD; // 0x54 bytes

// LINE 602:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xA8], eax;
	__asm        cmp    dword ptr [ebp-0xA8], 0;
	__asm        je     _T7a;

	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xA8];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T6c;
_T6c:
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    tempUMWD.sImageFileName.reference, eax;
	__asm        jmp    _T81;
_T7a:
	tempUMWD.sImageFileName.reference = 0x0;
_T81:
	tempUMWD.sImageFileName.c_str_ptr = 0x0;
	__asm        jmp    _T8d;
_T8d:
	__asm        jmp    _T92;
_T92:
	__asm        jmp    _T97;
_T97:
	__asm        jmp    _T9c;
_T9c:
	__asm        jmp    _Ta1;
_Ta1:
	__asm        jmp    _Ta6;
_Ta6:
	__asm        jmp    _Tab;
_Tab:
	__asm        jmp    _Tb0;
_Tb0:
	__asm        jmp    _Tb5;
_Tb5:
	__asm        jmp    _Tba;
_Tba:
	__asm        mov    eax, SZ_PLAY_MENU_IMAGE_FILE_NAME;
	__asm        mov    [ebp-0xA4], eax;
// LINE 604:
	__asm        jmp    _Tca;
_Tca:
	__asm        mov    eax, [ebp-0xA4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xA4];
	__asm        push   eax;
	__asm        lea    ecx, tempUMWD.sImageFileName.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _Tee;
// LINE 605:
_Tee:
	tempUMWD.nTransparentIndex = GraphicWindow::colorConstants.nPaletteIndexTransparent;
// LINE 606:
	__asm        jmp    _Tfb;
_Tfb:
	__asm        mov    dword ptr [ebp-0x68], 0x32;
	__asm        mov    dword ptr [ebp-0x64], 0xA;
	__asm        mov    dword ptr [ebp-0x60], 0x33;
	__asm        mov    dword ptr [ebp-0x5C], 0xB;
	__asm        jmp    _T11c;
_T11c:
	__asm        lea    eax, [ebp-0x68];
	__asm        lea    ecx, tempUMWD.rectPosition.left;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 607:
	__asm        cmp    gCurrentCityType, 1;
	__asm        jne    _T151;

	tempUMWD.lMenuStringResourceIndex = 0x3c;
	__asm        jmp    _T158;
_T151:
	tempUMWD.lMenuStringResourceIndex = 0x3d;
// LINE 608:
_T158:
	__asm        cmp    gCurrentCityType, 1;
	__asm        jne    _T171;

	tempUMWD.lMenuStringResourceCount = 0x8;
	__asm        jmp    _T178;
_T171:
	tempUMWD.lMenuStringResourceCount = 0x7;
// LINE 609:
_T178:
	__asm        cmp    gCurrentCityType, 1;
	__asm        jne    _T191;

	tempUMWD.lSelectionBase = 0x0;
	__asm        jmp    _T198;
_T191:
	tempUMWD.lSelectionBase = 0x1;
// LINE 610:
_T198:
	__asm        mov    byte ptr [ebp-0x6C], 0x80;
	__asm        mov    byte ptr [ebp-0x6B], 0x85;
	__asm        mov    byte ptr [ebp-0x6A], 0x4A;
	__asm        jmp    _T1a9;
_T1a9:
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    reinterpret_cast<uint32_t>(tempUMWD.colorFont.Blue), eax;
// LINE 611:
	__asm        mov    byte ptr [ebp-0x70], 0xEA;
	__asm        mov    byte ptr [ebp-0x6F], 0xEF;
	__asm        mov    byte ptr [ebp-0x6E], 0x9A;
	__asm        jmp    _T1c0;
_T1c0:
	__asm        mov    eax, [ebp-0x70];
	__asm        mov    reinterpret_cast<uint32_t>(tempUMWD.colorFontHighlighted.Blue), eax;
// LINE 614:
	__asm        cmp    gCurrentCityType, 1;
	__asm        jne    _T1f6;

	__asm        jmp    _T1d8;
_T1d8:
	__asm        mov    dword ptr [ebp-0x7C], 0x66;
	__asm        mov    dword ptr [ebp-0x78], 0x40;
	__asm        jmp    _T1eb;
_T1eb:
	__asm        lea    eax, [ebp-0x7C];
	__asm        mov    [ebp-0x74], eax;
	__asm        jmp    _T21a;
_T1f6:
	__asm        jmp    _T1fb;
_T1fb:
	__asm        mov    dword ptr [ebp-0x84], 0x66;
	__asm        mov    dword ptr [ebp-0x80], 0x68;
	__asm        jmp    _T211;
_T211:
	__asm        lea    eax, [ebp-0x84];
	__asm        mov    [ebp-0x74], eax;
_T21a:
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    ecx, [eax];
	__asm        mov    eax, [eax+4];
	__asm        lea    edx, tempUMWD.ptPositionFirstItem.x;
	__asm        mov    [edx], ecx;
	__asm        mov    [edx+4], eax;
// LINE 615:
	tempUMWD.nSizeItemFont = 0x1a;
// LINE 616:
	tempUMWD.nLineHeight = 0x28;
// LINE 617:
	tempUMWD.lTitleStringResourceIndex = 0xffffffff;
// LINE 618:
	tempUMWD.bTitleCentered = 0x1;
// LINE 619:
	__asm        jmp    _T257;
_T257:
	__asm        mov    dword ptr [ebp-0x8C], 0;
	__asm        mov    dword ptr [ebp-0x88], 0;
	__asm        jmp    _T270;
_T270:
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    ecx, [ebp-0x88];
	__asm        lea    edx, tempUMWD.ptTitlePosition.x;
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
// LINE 620:
	tempUMWD.nSizeTitleFont = 0x24;
// LINE 623:
	__asm        push   0x15A;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x90], eax;
	__asm        cmp    dword ptr [ebp-0x90], 0;
	__asm        je     _T305;

	__asm        cmp    this, 0;
	__asm        je     _T2cc;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x98], eax;
	__asm        jmp    _T2d6;
_T2cc:
	__asm        mov    dword ptr [ebp-0x98], 0;
_T2d6:
	__asm        push   1;
	__asm        mov    eax, [ebp-0x98];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x7D3;
	__asm        lea    eax, tempUMWD.sImageFileName.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x90];
	__asm        call   CopterPlayMenu::CopterPlayMenu;
	__asm        mov    myUserMenuWindow, eax;
	__asm        jmp    _T30c;
_T305:
	myUserMenuWindow = 0x0;
// LINE 624:
_T30c:
	__asm        mov    eax, myUserMenuWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myUserMenuWindow;
	__asm        call   dword ptr [eax+4];
// LINE 625:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, myUserMenuWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myUserMenuWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 626:
	__asm        jmp    _T331;
_T331:
	__asm        lea    ecx, tempUMWD.sImageFileName.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    tempUMWD.sImageFileName.c_str_ptr, 0;
	__asm        je     _T367;

	__asm        mov    eax, tempUMWD.sImageFileName.c_str_ptr;
	__asm        mov    [ebp-0x9C], eax;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0xA0], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T367:
	__asm        jmp    _T36c;
_T36c:
	return;
}

// FUNCTION: COPTER_D 0x004413e5
void CGameApp::CreateUserInputWindow() {
	/*bp-0x4*/   int32_t nCurrentGameMode;
	/*bp-0x8*/   /*packed*/ class UserInputWindow *myUserInputWindow;

// LINE 634:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x28], eax;
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T23;
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T36;
_T36:
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    eax, [eax+8];
	__asm        mov    nCurrentGameMode, eax;
// LINE 636:
	__asm        cmp    nCurrentGameMode, 6;
	__asm        jne    _T5c;
// LINE 637:
	this-><CGameApp+0xa4:4>++;
// LINE 639:
_T5c:
	__asm        push   0xB0;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Te1;

	__asm        cmp    this, 0;
	__asm        je     _T8e;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T95;
_T8e:
	__asm        mov    dword ptr [ebp-0x20], 0;
_T95:
	__asm        jmp    _T9a;
_T9a:
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        mov    dword ptr [ebp-0x18], 0;
	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        mov    dword ptr [ebp-0x10], 1;
	__asm        jmp    _Tbb;
_Tbb:
	__asm        push   1;
	__asm        mov    eax, [ebp-0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x7D4;
	__asm        lea    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   UserInputWindow::UserInputWindow;
	__asm        mov    myUserInputWindow, eax;
	__asm        jmp    _Te8;
_Te1:
	myUserInputWindow = 0x0;
// LINE 640:
_Te8:
	__asm        mov    eax, myUserInputWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myUserInputWindow;
	__asm        call   dword ptr [eax+4];
// LINE 641:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, myUserInputWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myUserInputWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 642:
	__asm        mov    eax, this;
	__asm        add    eax, 0x1E8;
	__asm        push   eax;
	__asm        mov    eax, myUserInputWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myUserInputWindow;
	__asm        call   dword ptr [eax+0xCC];
// LINE 643:
	return;
}

// FUNCTION: COPTER_D 0x0044150b
void CGameApp::DestroyUserInputWindow(/*packed*/ class UserInputWindow *windowToDestroy, int32_t bUseData) {
	/*bp-0x4*/   int32_t nCurrentGameMode;

// LINE 650:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0xC], eax;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T23;
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T36;
_T36:
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, [ebp-8];
	__asm        mov    eax, [eax+8];
	__asm        mov    nCurrentGameMode, eax;
// LINE 652:
	__asm        cmp    nCurrentGameMode, 6;
	__asm        jne    _T5c;
// LINE 653:
	this-><CGameApp+0xa4:4>--;
// LINE 656:
_T5c:
	__asm        cmp    bUseData, 0;
	__asm        je     _Ta5;

	__asm        jmp    _T6b;
_T6b:
	__asm        mov    eax, windowToDestroy;
	__asm        cmp    dword ptr [eax+0xA8], 0;
	__asm        je     _Ta5;
// LINE 657:
	__asm        mov    eax, windowToDestroy;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, windowToDestroy;
	__asm        call   dword ptr [eax+0xD0];
// LINE 658:
	(this + 0xa0)->GameModePlayData::RemoveUserConfigurableCommands();
// LINE 659:
	(this + 0xa0)->GameModePlayData::ReadUserConfigurableCommands();
// LINE 661:
_Ta5:
	__asm        mov    eax, windowToDestroy;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, windowToDestroy;
	__asm        call   dword ptr [eax+0x6C];
// LINE 662:
	return;
}

// FUNCTION: COPTER_D 0x004415c7
void CGameApp::CreateRenderSettingsWindow() {
	/*bp-0x4*/   int32_t nCurrentGameMode;
	/*bp-0x8*/   /*packed*/ class RenderSettingsWindow *myRenderSettingsWindow;

// LINE 670:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x28], eax;
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T23;
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T36;
_T36:
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    eax, [eax+8];
	__asm        mov    nCurrentGameMode, eax;
// LINE 672:
	__asm        cmp    nCurrentGameMode, 6;
	__asm        jne    _T5c;
// LINE 673:
	this-><CGameApp+0xa4:4>++;
// LINE 675:
_T5c:
	__asm        push   0xB8;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Te1;

	__asm        cmp    this, 0;
	__asm        je     _T8e;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T95;
_T8e:
	__asm        mov    dword ptr [ebp-0x20], 0;
_T95:
	__asm        jmp    _T9a;
_T9a:
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        mov    dword ptr [ebp-0x18], 0;
	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        mov    dword ptr [ebp-0x10], 1;
	__asm        jmp    _Tbb;
_Tbb:
	__asm        push   1;
	__asm        mov    eax, [ebp-0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x7D5;
	__asm        lea    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0xC];
	__asm        call   RenderSettingsWindow::RenderSettingsWindow;
	__asm        mov    myRenderSettingsWindow, eax;
	__asm        jmp    _Te8;
_Te1:
	myRenderSettingsWindow = 0x0;
// LINE 676:
_Te8:
	__asm        mov    eax, myRenderSettingsWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myRenderSettingsWindow;
	__asm        call   dword ptr [eax+4];
// LINE 677:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, myRenderSettingsWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myRenderSettingsWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 682:
	myRenderSettingsWindow->RenderSettingsWindow::SetCurrentSettings(this-><CGameApp+0x4328:4>, this-><CGameApp+0x432c:4>, this-><CGameApp+0x4330:4>, this-><CGameApp+0x4308:4>, ConvertRenderBackPlaneValueToGUI(GetRenderBackPlaneValue()));
// LINE 683:
	return;
}

// FUNCTION: COPTER_D 0x00441715
void CGameApp::DestroyRenderSettingsWindow(/*packed*/ class RenderSettingsWindow *windowToDestroy, int32_t bUseData) {
	/*bp-0x4*/   long lFogCloseness;
	/*bp-0x8*/   long bShowBuildingTextures;
	/*bp-0xc*/   long bShowSkyAndClouds;
	/*bp-0x10*/  long bShowGroundTextures;
	/*bp-0x14*/  int32_t nCurrentGameMode;
	/*bp-0x18*/  long lQuadPixelType;

// LINE 691:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T23;
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T36;
_T36:
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    eax, [eax+8];
	__asm        mov    nCurrentGameMode, eax;
// LINE 698:
	__asm        cmp    nCurrentGameMode, 6;
	__asm        jne    _T5c;
// LINE 699:
	this-><CGameApp+0xa4:4>--;
// LINE 701:
_T5c:
	__asm        cmp    bUseData, 0;
	__asm        je     _Td2;
// LINE 706:
	windowToDestroy->RenderSettingsWindow::GetCurrentSettings(bShowBuildingTextures, bShowGroundTextures, bShowSkyAndClouds, lQuadPixelType, lFogCloseness);
// LINE 709:
	G_texobjs = bShowBuildingTextures;
	this-><CGameApp+0x4328:4> = G_texobjs;
// LINE 710:
	G_texterr = bShowGroundTextures;
	this-><CGameApp+0x432c:4> = G_texterr;
// LINE 711:
	this-><CGameApp+0x4330:4> = bShowSkyAndClouds;
// LINE 712:
	this-><CGameApp+0x4308:4> = lQuadPixelType;
// LINE 717:
	S3SetBackPlaneBasedOnValue(lFogCloseness);
// LINE 720:
_Td2:
	__asm        mov    eax, windowToDestroy;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, windowToDestroy;
	__asm        call   dword ptr [eax+0x6C];
// LINE 721:
	return;
}

// FUNCTION: COPTER_D 0x004417fe
void CGameApp::CreateSoundSettingsWindow() {
	/*bp-0x10*/  /*packed*/ struct SoundPreferences tempSoundPreferences; // 0x10 bytes
	/*bp-0x14*/  char * chPrefData;
	/*bp-0x18*/  int32_t nCurrentGameMode;
	/*bp-0x34*/  /*packed*/ struct RadioPreferences tempRadioPreferences; // 0x1c bytes
	/*bp-0x38*/  /*packed*/ class SoundSettingsWindow *mySoundSettingsWindow;

// LINE 732:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    [ebp-0x54], eax;
	__asm        jmp    _T23;
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x54], eax;
	__asm        jmp    _T36;
_T36:
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    eax, [eax+8];
	__asm        mov    nCurrentGameMode, eax;
// LINE 734:
	__asm        cmp    nCurrentGameMode, 6;
	__asm        jne    _T5c;
// LINE 735:
	this-><CGameApp+0xa4:4>++;
// LINE 737:
_T5c:
	__asm        push   0x88;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x3C], eax;
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        je     _Te1;

	__asm        cmp    this, 0;
	__asm        je     _T8e;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x50], eax;
	__asm        jmp    _T95;
_T8e:
	__asm        mov    dword ptr [ebp-0x50], 0;
_T95:
	__asm        jmp    _T9a;
_T9a:
	__asm        mov    dword ptr [ebp-0x4C], 0;
	__asm        mov    dword ptr [ebp-0x48], 0;
	__asm        mov    dword ptr [ebp-0x44], 1;
	__asm        mov    dword ptr [ebp-0x40], 1;
	__asm        jmp    _Tbb;
_Tbb:
	__asm        push   1;
	__asm        mov    eax, [ebp-0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x7D6;
	__asm        lea    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x3C];
	__asm        call   SoundSettingsWindow::SoundSettingsWindow;
	__asm        mov    mySoundSettingsWindow, eax;
	__asm        jmp    _Te8;
_Te1:
	mySoundSettingsWindow = 0x0;
// LINE 738:
_Te8:
	__asm        mov    eax, mySoundSettingsWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, mySoundSettingsWindow;
	__asm        call   dword ptr [eax+4];
// LINE 739:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, mySoundSettingsWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, mySoundSettingsWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 742:
	__asm        push   0x4FFFFFF;
	__asm        mov    eax, gPreferenceManager;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, gPreferenceManager;
	__asm        call   dword ptr [eax+0x1C];
	__asm        mov    chPrefData, eax;
// LINE 743:
	__asm        cmp    chPrefData, 0;
	__asm        je     _T166;

	__asm        push   0x4FFFFFF;
	__asm        mov    eax, gPreferenceManager;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, gPreferenceManager;
	__asm        call   dword ptr [eax+0x24];
	__asm        cmp    eax, 0x10;
	__asm        jne    _T166;
// LINE 744:
	__asm        mov    eax, chPrefData;
	__asm        lea    ecx, tempSoundPreferences.lMasterVolume;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 746:
	__asm        jmp    _T17f;
// LINE 750:
_T166:
	tempSoundPreferences.lVehicleVolume = 0x2710;
	tempSoundPreferences.lSoundEffectsVolume = tempSoundPreferences.lVehicleVolume;
	tempSoundPreferences.lDispatchVolume = tempSoundPreferences.lSoundEffectsVolume;
	tempSoundPreferences.lMasterVolume = tempSoundPreferences.lDispatchVolume;
// LINE 752:
_T17f:
	mySoundSettingsWindow->SoundSettingsWindow::SetCurrentVolumeSettings(tempSoundPreferences.lMasterVolume);
// LINE 755:
	0x604480->Radio::GetPreferences(tempRadioPreferences.lVolume);
// LINE 760:
	mySoundSettingsWindow->SoundSettingsWindow::SetCurrentRadioSettings(tempRadioPreferences.lVolume, 0x604480->Radio::GetStationCount());
// LINE 761:
	return;
}

// FUNCTION: COPTER_D 0x004419b8
void CGameApp::DestroySoundSettingsWindow(/*packed*/ class SoundSettingsWindow *windowToDestroy, int32_t bUseData) {
	/*bp-0x10*/  /*packed*/ struct SoundPreferences tempSoundPreferences; // 0x10 bytes
	/*bp-0x14*/  int32_t nCurrentGameMode;
	/*bp-0x30*/  /*packed*/ struct RadioPreferences tempRadioPreferences; // 0x1c bytes

// LINE 770:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x38], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T23;
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T36;
_T36:
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    eax, [eax+8];
	__asm        mov    nCurrentGameMode, eax;
// LINE 772:
	__asm        cmp    nCurrentGameMode, 6;
	__asm        jne    _T5c;
// LINE 773:
	this-><CGameApp+0xa4:4>--;
// LINE 775:
_T5c:
	__asm        cmp    bUseData, 0;
	__asm        je     _Tba;
// LINE 777:
	windowToDestroy->SoundSettingsWindow::GetCurrentVolumeSettings(tempSoundPreferences.lMasterVolume);
// LINE 778:
	__asm        lea    eax, tempSoundPreferences.lMasterVolume;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x30];
// LINE 781:
	windowToDestroy->SoundSettingsWindow::GetCurrentRadioSettings(tempRadioPreferences.lVolume);
// LINE 786:
	0x604480->Radio::SetPreferences(tempRadioPreferences.lVolume);
// LINE 794:
	__asm        cmp    tempRadioPreferences.bPreferToBeOn, 0;
	__asm        je     _Tb2;
// LINE 795:
	this->CGameApp::EnableSoundTrack();
// LINE 796:
	__asm        jmp    _Tba;
// LINE 797:
_Tb2:
	this->CGameApp::DisableSoundTrack();
// LINE 799:
_Tba:
	__asm        mov    eax, windowToDestroy;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, windowToDestroy;
	__asm        call   dword ptr [eax+0x6C];
// LINE 800:
	return;
}

// FUNCTION: COPTER_D 0x00441a89
void CGameApp::CreateCitySettingsWindow() {
	/*bp-0x4*/   /*packed*/ class CitySettingsWindow *myCitySettingsWindow;

// LINE 808:
	this-><CGameApp+0xa4:4>++;
// LINE 810:
	__asm        push   0x94;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T9a;

	__asm        cmp    this, 0;
	__asm        je     _T47;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T4e;
_T47:
	__asm        mov    dword ptr [ebp-0x1C], 0;
_T4e:
	__asm        jmp    _T53;
_T53:
	__asm        mov    dword ptr [ebp-0x18], 0;
	__asm        mov    dword ptr [ebp-0x14], 0;
	__asm        mov    dword ptr [ebp-0x10], 1;
	__asm        mov    dword ptr [ebp-0xC], 1;
	__asm        jmp    _T74;
_T74:
	__asm        push   1;
	__asm        mov    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x7D8;
	__asm        lea    eax, [ebp-0x18];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-8];
	__asm        call   CitySettingsWindow::CitySettingsWindow;
	__asm        mov    myCitySettingsWindow, eax;
	__asm        jmp    _Ta1;
_T9a:
	myCitySettingsWindow = 0x0;
// LINE 811:
_Ta1:
	__asm        mov    eax, myCitySettingsWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myCitySettingsWindow;
	__asm        call   dword ptr [eax+4];
// LINE 812:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, myCitySettingsWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, myCitySettingsWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 813:
	myCitySettingsWindow->CitySettingsWindow::SetCurrentCitySettings(GetCurrentCitySettings());
// LINE 814:
	return;
}

// FUNCTION: COPTER_D 0x00441b5f
void CGameApp::DestroyCitySettingsWindow(/*packed*/ class CitySettingsWindow *windowToDestroy, int32_t bUseData) {
// LINE 825:
	this-><CGameApp+0xa4:4>--;
// LINE 826:
	__asm        cmp    bUseData, 0;
	__asm        je     _T4a;
// LINE 827:
	windowToDestroy->CitySettingsWindow::GetCurrentCitySettings(GetCurrentCitySettings());
// LINE 828:
	__asm        push   0x24;
	__asm        call   GetCurrentCitySettings;
	__asm        push   eax;
	__asm        push   0x5EEEEEE;
	__asm        mov    eax, gPreferenceManager;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, gPreferenceManager;
	__asm        call   dword ptr [eax+0x2C];
// LINE 830:
_T4a:
	__asm        mov    eax, windowToDestroy;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, windowToDestroy;
	__asm        call   dword ptr [eax+0x6C];
// LINE 831:
	return;
}

// FUNCTION: COPTER_D 0x00441bc0
void CGameApp::CreateControlDisplayWindow() {
	/*bp-0x4*/   /*packed*/ class ControlDisplayWindow *tempControlDisplayWindow;

// LINE 838:
	this-><CGameApp+0xa4:4>++;
// LINE 840:
	__asm        push   0x80;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T9a;

	__asm        cmp    this, 0;
	__asm        je     _T47;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T4e;
_T47:
	__asm        mov    dword ptr [ebp-0x1C], 0;
_T4e:
	__asm        jmp    _T53;
_T53:
	__asm        mov    dword ptr [ebp-0x18], 0;
	__asm        mov    dword ptr [ebp-0x14], 0;
	__asm        mov    dword ptr [ebp-0x10], 1;
	__asm        mov    dword ptr [ebp-0xC], 1;
	__asm        jmp    _T74;
_T74:
	__asm        push   1;
	__asm        mov    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x2711;
	__asm        lea    eax, [ebp-0x18];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-8];
	__asm        call   ControlDisplayWindow::ControlDisplayWindow;
	__asm        mov    tempControlDisplayWindow, eax;
	__asm        jmp    _Ta1;
_T9a:
	tempControlDisplayWindow = 0x0;
// LINE 841:
_Ta1:
	__asm        mov    eax, tempControlDisplayWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempControlDisplayWindow;
	__asm        call   dword ptr [eax+4];
// LINE 842:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, tempControlDisplayWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempControlDisplayWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 843:
	__asm        mov    eax, this;
	__asm        add    eax, 0x1E8;
	__asm        push   eax;
	__asm        mov    eax, tempControlDisplayWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempControlDisplayWindow;
	__asm        call   dword ptr [eax+0xC4];
// LINE 844:
	return;
}

// FUNCTION: COPTER_D 0x00441c9f
void CGameApp::DestroyControlDisplayWindow() {
// LINE 851:
	this-><CGameApp+0xa4:4>--;
// LINE 852:
	return;
}

// FUNCTION: COPTER_D 0x00441cbe
void CGameApp::CreateCheckupWindow() {
	/*bp-0x4*/   /*packed*/ class CheckupWindow *tempCheckupWindow;

// LINE 859:
	this-><CGameApp+0xa4:4>++;
// LINE 861:
	__asm        push   0x94;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-8], eax;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T9a;

	__asm        cmp    this, 0;
	__asm        je     _T47;

	__asm        mov    eax, this;
	__asm        add    eax, 0x14;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T4e;
_T47:
	__asm        mov    dword ptr [ebp-0x1C], 0;
_T4e:
	__asm        jmp    _T53;
_T53:
	__asm        mov    dword ptr [ebp-0x18], 0;
	__asm        mov    dword ptr [ebp-0x14], 0;
	__asm        mov    dword ptr [ebp-0x10], 1;
	__asm        mov    dword ptr [ebp-0xC], 1;
	__asm        jmp    _T74;
_T74:
	__asm        push   1;
	__asm        mov    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        push   0x7E1;
	__asm        lea    eax, [ebp-0x18];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-8];
	__asm        call   CheckupWindow::CheckupWindow;
	__asm        mov    tempCheckupWindow, eax;
	__asm        jmp    _Ta1;
_T9a:
	tempCheckupWindow = 0x0;
// LINE 862:
_Ta1:
	__asm        mov    eax, tempCheckupWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempCheckupWindow;
	__asm        call   dword ptr [eax+4];
// LINE 863:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x38];
	__asm        push   eax;
	__asm        mov    eax, tempCheckupWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempCheckupWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 864:
	return;
}

// FUNCTION: COPTER_D 0x00441d86
void CGameApp::DestroyCheckupWindow(/*packed*/ class CheckupWindow *windowToDestroy, int32_t bUseData) {
	/*bp-0xc*/   long lSettings[3]; // 0xc bytes

// LINE 873:
	this-><CGameApp+0xa4:4>--;
// LINE 874:
	__asm        cmp    bUseData, 0;
	__asm        je     _T85;
// LINE 875:
	windowToDestroy->CheckupWindow::GetCurrentSettings(lSettings[0]);
// LINE 878:
	ChangeUserMoney(-lSettings[0]);
// LINE 879:
	S3HeliPurchaseRepairs(G_uheli, lSettings[0]);
// LINE 881:
	ChangeUserMoney(-lSettings[1]);
// LINE 882:
	S3HeliPurchaseFuel(G_uheli, lSettings[1]);
// LINE 884:
	ChangeUserMoney(-lSettings[2]);
// LINE 885:
	S3HeliPurchaseTeargasCanisters(lSettings[2]);
// LINE 888:
_T85:
	__asm        mov    eax, windowToDestroy;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, windowToDestroy;
	__asm        call   dword ptr [eax+0x6C];
// LINE 889:
	return;
}



// Contribution: 3:00001680-00001970 Module: 53, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x00598680
char * SZ_PLAY_MENU_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00598684
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_0 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00598688
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_1 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x0059868c
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_2N = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00598690
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_2D = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00598694
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_3 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00598698
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_4 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x0059869c
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_5 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986a0
char * SZ_ABOUT_BOX_IMAGE_FILE_NAME_6 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986a4
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_0 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986a8
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_1 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986ac
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_2N = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986b0
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_2D = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986b4
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_3 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986b8
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_4 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986bc
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_5 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986c0
char * SZ_ABOUT_BOX_BUTTON_IMAGE_FILE_NAME_6 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986c4
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_0 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986c8
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_1 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986cc
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_2N = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986d0
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_2D = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986d4
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_3 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986d8
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_4 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986dc
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_5 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986e0
char * SZ_ABOUT_BOX_ANIMATION_FILE_NAME_6 = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005986e4
char * SZ_CHEAT_BOX_TEXT_IMAGE_FILE_NAME = { 0 /* todo */ };

