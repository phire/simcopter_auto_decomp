// Module: ddbuffer.obj
// Source: C:\Copter\source\sparkal\ddbuffer.cpp
// autogenerated by simcopter_tool from PDB file

// Type: void;

// Type: /*packed*/ class CBackBuffer (forward reference);
// VTABLE: COPTER_D 0x00590808
class CBackBuffer : public IBackBuffer
{ // packed(0x134 bytes) TI: 0x2843
public:
	void CBackBuffer(long, long, const /*packed*/ struct SparkalColor*);
	void CBackBuffer(char *);
	void CBackBuffer();
	virtual void InitializeMemberVariables(); // vtable+0x28
	void ~CBackBuffer();
	unsigned long Load();
	virtual unsigned long Lock() /* override */;
	virtual unsigned long Unlock() /* override */;
	// calltype: NearC
	static int32_t GetPaletteFromImage(char *, /*packed*/ struct SparkalColor*);
	virtual unsigned long Swap(/*packed*/ class CSparkalWindow*, long, long) /* override */;
	virtual unsigned long SwapRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalPoint&, const /*packed*/ struct SparkalRect&); // vtable+0x2c
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalRect&, const /*packed*/ struct SparkalRect&); // vtable+0x30
	virtual unsigned long Duplicate(/*packed*/ class CBackBuffer*, int32_t); // vtable+0x34
	virtual unsigned long ComposeNoClip(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalPoint&, const /*packed*/ struct SparkalRect&); // vtable+0x38
	virtual unsigned long ComposeNoClip(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0x3c
	void UpdatePalette(long, long, const /*packed*/ struct SparkalColor*);
	virtual void SetTransparentColor(int32_t, long) /* override */;
	unsigned long GetTransparentColor(long&);
	unsigned long SetFont(/*packed*/ class MFont*);
	void SetFontColor(/*packed*/ struct SparkalColor&);
	void SetFontIndex(int32_t);
	void SetColor(/*packed*/ struct SparkalColor&);
	void SetColorIndex(int32_t);
	virtual unsigned long DrawLine(long, long, long, long, long); // vtable+0x40
	virtual unsigned long FillRect(long, const /*packed*/ struct SparkalRect*); // vtable+0x44
	virtual unsigned long DrawBufferText(char *, long, unsigned long, const /*packed*/ class MRect&, /*packed*/ class MFont*); // vtable+0x48
	virtual unsigned long DrawBufferText(char *, unsigned long, long *, long *, long *, long *, /*packed*/ class MFont*); // vtable+0x4c
	virtual unsigned long DrawLineUnclipped(long, long, long, long, long); // vtable+0x50
	virtual unsigned long DrawLineClipped(long, long, long, long, long); // vtable+0x54
	virtual unsigned long DrawRectangleOutline(const /*packed*/ struct SparkalRect&, long); // vtable+0x58
	virtual unsigned long DrawRectangleOutlineUnclipped(const /*packed*/ struct SparkalRect&, long); // vtable+0x5c
	long IsLost();
	long Restore();
	/*+0x18*/  char * szFilePath;
	/*+0x1c*/  /*packed*/ struct tagRECT rectDirectDrawBuffer; // 0x10 bytes
protected:
	/*+0x2c*/  int32_t bSurfacePrimary;
	/*+0x30*/  int32_t bSurfaceTransparent;
	/*+0x34*/  /*packed*/ class MFont *mFont;
	/*+0x38*/  /*packed*/ struct SparkalColor colorFontCurrent;
	/*+0x3c*/  /*packed*/ struct SparkalColor colorCurrent;
	/*+0x40*/  int32_t nColorIndexFontCurrent;
	/*+0x44*/  int32_t nColorIndexCurrent;
	/*+0x48*/  int32_t nColorIndexTransparent;
	/*+0x4c*/  /*packed*/ struct IDirectDrawSurface *mpFrontSurface;
	/*+0x50*/  /*packed*/ struct IDirectDrawSurface *mpBackSurface;
	/*+0x54*/  /*packed*/ struct IDirectDrawPalette *mpPalette;
	/*+0x58*/  /*packed*/ struct _DDSURFACEDESC mDDdesc; // 0x6c bytes
	/*+0xc4*/  /*packed*/ struct _DDBLTFX mDDBltFx; // 0x64 bytes
	/*+0x128*/ void * __ptr32 hPen;
	/*+0x12c*/ int32_t nPenThickness;
	/*+0x130*/ /*packed*/ struct SparkalColor colorPenCurrent;
	virtual /*packed*/ struct IDirectDrawSurface* GetDDSurface(); // vtable+0x60
};

// Type: char *;

// Type: int32_t;

// Type: /*packed*/ struct tagBITMAPINFOHEADER;
struct tagBITMAPINFOHEADER{ // packed(0x28 bytes) TI: 0x26dd
	/*+0x0*/   unsigned long biSize;
	/*+0x4*/   long biWidth;
	/*+0x8*/   long biHeight;
	/*+0xc*/   unsigned short biPlanes; // 0x2 bytes
	/*+0xe*/   unsigned short biBitCount; // 0x2 bytes
	/*+0x10*/  unsigned long biCompression;
	/*+0x14*/  unsigned long biSizeImage;
	/*+0x18*/  long biXPelsPerMeter;
	/*+0x1c*/  long biYPelsPerMeter;
	/*+0x20*/  unsigned long biClrUsed;
	/*+0x24*/  unsigned long biClrImportant;
};

// Type: long;

// Type: /*packed*/ struct tagBITMAPFILEHEADER;
struct tagBITMAPFILEHEADER{ // packed(0xe bytes) TI: 0x2742
	/*+0x0*/   unsigned short bfType; // 0x2 bytes
	/*+0x2*/   unsigned long bfSize;
	/*+0x6*/   unsigned short bfReserved1; // 0x2 bytes
	/*+0x8*/   unsigned short bfReserved2; // 0x2 bytes
	/*+0xa*/   unsigned long bfOffBits;
};

// Type: /*packed*/ class PFile (forward reference);
// VTABLE: COPTER_D 0x00590468
class PFile{ // packed(0x110 bytes) TI: 0x453c
	enum /* __unnamed */ {
		FileNull = -1,
	};
	enum SeekTypes {
		N_SEEK_FROM_FILE_START = 0,
		N_SEEK_FROM_FILE_CURRENT = 1,
		N_SEEK_FROM_FILE_END = 2,
	};
	enum AccessTypes {
		ReadOnly = 0,
		ReadWrite = 2,
		WriteOnly = 1,
		Create = 768,
		CreateExcl = 1280,
		Append = 8,
		Binary = 32768,
		Compat = 0,
		DenyNone = 64,
		DenyRead = 48,
		DenyWrite = 32,
		DenyRdWr = 16,
		NoInherit = 128,
	};
	enum PermissionTypes {
		PermRead = 256,
		PermWrite = 128,
		PermRdWr = 384,
	};
	enum seek_dir {
		beg = 0,
		cur = 1,
		end = 2,
	};
public:
	void PFile(char *);
	void PFile(const /*packed*/ class PFile&);
	void PFile(int32_t);
	void PFile();
	virtual void ~PFile(); // vtable+0x0
	int32_t Open(char *, unsigned short, unsigned short, int32_t);
	int32_t Close();
	int32_t GetHandle();
	long Position();
	void Length(long);
	long Length();
	long Seek(long, int32_t);
	long SeekToBegin();
	long SeekToEnd();
	int32_t IsOpen();
	int32_t Read(void * __ptr32, int32_t);
	int32_t Write(void * __ptr32, int32_t);
	void Flush();
	// calltype: NearC
	static void Remove(char *);
	// calltype: NearC
	static void Rename(char *, char *);
	// calltype: NearC
	static unsigned long Checksum(char *);
	long SetPath(char *);
	long FileCreate(char *, int32_t);
	long FileExists(char *);
	/*+0x4*/   char szFilePath[260]; // 0x104 bytes
	/*+0x108*/ int32_t Handle;
private:
	/*+0x10c*/ int32_t ShouldClose;
};

// Type: /*packed*/ struct SparkalColor (forward reference);
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: /*packed*/ struct tagRGBQUAD (forward reference);
struct tagRGBQUAD{ // packed(0x4 bytes) TI: 0x1ba1
	/*+0x0*/   unsigned char rgbBlue; // 0x1 bytes
	/*+0x1*/   unsigned char rgbGreen; // 0x1 bytes
	/*+0x2*/   unsigned char rgbRed; // 0x1 bytes
	/*+0x3*/   unsigned char rgbReserved; // 0x1 bytes
};

// Type: unsigned char *;

// Type: unsigned long;

// Type: long *;

// Type: /*packed*/ class MFont (forward reference);
// VTABLE: COPTER_D 0x00591640
class MFont{ // packed(0x1c bytes) TI: 0x1a6c
public:
	/*+0x4*/   /*packed*/ class basic_string<char> sName; // 0x8 bytes
	/*+0xc*/   unsigned long lHeight;
	/*+0x10*/  unsigned long lWidth;
	/*+0x14*/  unsigned long lAttributes;
	void MFont(char *, unsigned long, unsigned long, unsigned long, int32_t);
	void MFont(const /*packed*/ class MFont&);
	void MFont();
	void ~MFont();
	/*packed*/ class MFont& operator=(const /*packed*/ class MFont&);
	// calltype: NearC
	static int32_t IsFontAvailable(char *, unsigned long, unsigned long, unsigned long);
	// calltype: NearC
	static int32_t LoadFont(char *);
	// calltype: NearC
	static int32_t UnloadFont(char *);
	void SetFontCharacteristics(long, long, long);
	int32_t GetTextDimensions(char *, long&, long&);
	virtual int32_t CreateFontA(); // vtable+0x0
	virtual void DestroyFont(); // vtable+0x4
	void * __ptr32 operator void *();
protected:
	/*+0x18*/  void * __ptr32 hFont;
};

// Type: /*packed*/ struct tagRECT;
struct tagRECT{ // packed(0x10 bytes) TI: 0x13c4
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
};

// Type: /*packed*/ struct IDirectDrawSurface (forward reference);
struct IDirectDrawSurface{ // packed(0x4 bytes) TI: 0x2764
	/*+0x0*/   /*packed*/ struct IDirectDrawSurfaceVtbl *lpVtbl;
};

// Type: void * __ptr32;

// Type: uint32_t;

// Type: /*packed*/ class MRect (forward reference);
class MRect : public SparkalRect
{ // packed(0x10 bytes) TI: 0x1067
public:
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalSize);
	void MRect(/*packed*/ struct SparkalRect*);
	void MRect(/*packed*/ class MRect*);
	void MRect(const /*packed*/ struct SparkalRect&);
	void MRect(long, long, long, long);
	void MRect();
	long Width();
	long Height();
	/*packed*/ class MSize Size();
	const /*packed*/ class MPoint& TopLeft();
	/*packed*/ class MPoint& TopLeft();
	const /*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint CenterPoint();
	/*packed*/ struct SparkalRect* operator struct SparkalRect *();
	/*packed*/ class MRect* operator class MRect *();
	int32_t IsRectEmpty();
	int32_t IsRectNull();
	int32_t PtInRect(/*packed*/ struct SparkalPoint);
	int32_t PtInRect(long, long);
	int32_t DoesRectOverlap(/*packed*/ struct SparkalRect*);
	void SetRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void SetRect(long, long, long, long);
	void SetRectEmpty();
	void CopyRect(/*packed*/ class MRect*);
	int32_t EqualRect(/*packed*/ class MRect*);
	void InflateRect(long, long, long, long);
	void InflateRect(/*packed*/ class MRect*);
	void InflateRect(/*packed*/ struct SparkalSize);
	void InflateRect(long, long);
	void DeflateRect(long, long, long, long);
	void DeflateRect(/*packed*/ class MRect*);
	void DeflateRect(/*packed*/ struct SparkalSize);
	void DeflateRect(long, long);
	void MoveRect(/*packed*/ struct SparkalPoint);
	void MoveRect(long, long);
	void OffsetRect(/*packed*/ struct SparkalPoint);
	void OffsetRect(/*packed*/ struct SparkalSize);
	void OffsetRect(long, long);
	void NormalizeRect();
	int32_t IntersectRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t UnionRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t SubtractRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t operator==(const /*packed*/ struct SparkalRect&);
	int32_t operator!=(const /*packed*/ struct SparkalRect&);
	void operator+=(/*packed*/ class MRect*);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ class MRect*);
	void operator-=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator&=(const /*packed*/ struct SparkalRect&);
	void operator|=(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(/*packed*/ class MRect*);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator-(/*packed*/ class MRect*);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator&(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator|(const /*packed*/ struct SparkalRect&);
};

// Type: /*packed*/ struct tagPOINT;
struct tagPOINT{ // packed(0x8 bytes) TI: 0x1131
	/*+0x0*/   long x;
	/*+0x4*/   long y;
};

// Type: /*unpacked*/ class CSparkalWindow (forward reference);
// CSparkalWindow Class implementation not found

// Type: /*packed*/ struct _DDBLTFX;
struct _DDBLTFX{ // packed(0x64 bytes) TI: 0x12e7
	/*+0x0*/   unsigned long dwSize;
	/*+0x4*/   unsigned long dwDDFX;
	/*+0x8*/   unsigned long dwROP;
	/*+0xc*/   unsigned long dwDDROP;
	/*+0x10*/  unsigned long dwRotationAngle;
	/*+0x14*/  unsigned long dwZBufferOpCode;
	/*+0x18*/  unsigned long dwZBufferLow;
	/*+0x1c*/  unsigned long dwZBufferHigh;
	/*+0x20*/  unsigned long dwZBufferBaseDest;
	/*+0x24*/  unsigned long dwZDestConstBitDepth;
	/*+0x28*/  unsigned long dwZDestConst;
	/*+0x28*/  /*packed*/ struct IDirectDrawSurface *lpDDSZBufferDest;
	/*+0x2c*/  unsigned long dwZSrcConstBitDepth;
	/*+0x30*/  unsigned long dwZSrcConst;
	/*+0x30*/  /*packed*/ struct IDirectDrawSurface *lpDDSZBufferSrc;
	/*+0x34*/  unsigned long dwAlphaEdgeBlendBitDepth;
	/*+0x38*/  unsigned long dwAlphaEdgeBlend;
	/*+0x3c*/  unsigned long dwReserved;
	/*+0x40*/  unsigned long dwAlphaDestConstBitDepth;
	/*+0x44*/  unsigned long dwAlphaDestConst;
	/*+0x44*/  /*packed*/ struct IDirectDrawSurface *lpDDSAlphaDest;
	/*+0x48*/  unsigned long dwAlphaSrcConstBitDepth;
	/*+0x4c*/  unsigned long dwAlphaSrcConst;
	/*+0x4c*/  /*packed*/ struct IDirectDrawSurface *lpDDSAlphaSrc;
	/*+0x50*/  unsigned long dwFillColor;
	/*+0x50*/  /*packed*/ struct IDirectDrawSurface *lpDDSPattern;
	/*+0x54*/  /*packed*/ struct _DDCOLORKEY ddckDestColorkey; // 0x8 bytes
	/*+0x5c*/  /*packed*/ struct _DDCOLORKEY ddckSrcColorkey; // 0x8 bytes
};

// Type: /*packed*/ class IFlatImage (forward reference);
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(/*packed*/ class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, /*packed*/ struct SparkalRect, /*packed*/ struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	/*+0x4*/   unsigned long mLockCount;
	/*+0x8*/   long mWidth;
	/*+0xc*/   long mHeight;
	/*+0x10*/  void * __ptr32 mpBits;
	/*+0x14*/  long mStride;
};

// Type: /*packed*/ class MRect;
class MRect : public SparkalRect
{ // packed(0x10 bytes) TI: 0x1067
public:
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalSize);
	void MRect(/*packed*/ struct SparkalRect*);
	void MRect(/*packed*/ class MRect*);
	void MRect(const /*packed*/ struct SparkalRect&);
	void MRect(long, long, long, long);
	void MRect();
	long Width();
	long Height();
	/*packed*/ class MSize Size();
	const /*packed*/ class MPoint& TopLeft();
	/*packed*/ class MPoint& TopLeft();
	const /*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint CenterPoint();
	/*packed*/ struct SparkalRect* operator struct SparkalRect *();
	/*packed*/ class MRect* operator class MRect *();
	int32_t IsRectEmpty();
	int32_t IsRectNull();
	int32_t PtInRect(/*packed*/ struct SparkalPoint);
	int32_t PtInRect(long, long);
	int32_t DoesRectOverlap(/*packed*/ struct SparkalRect*);
	void SetRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void SetRect(long, long, long, long);
	void SetRectEmpty();
	void CopyRect(/*packed*/ class MRect*);
	int32_t EqualRect(/*packed*/ class MRect*);
	void InflateRect(long, long, long, long);
	void InflateRect(/*packed*/ class MRect*);
	void InflateRect(/*packed*/ struct SparkalSize);
	void InflateRect(long, long);
	void DeflateRect(long, long, long, long);
	void DeflateRect(/*packed*/ class MRect*);
	void DeflateRect(/*packed*/ struct SparkalSize);
	void DeflateRect(long, long);
	void MoveRect(/*packed*/ struct SparkalPoint);
	void MoveRect(long, long);
	void OffsetRect(/*packed*/ struct SparkalPoint);
	void OffsetRect(/*packed*/ struct SparkalSize);
	void OffsetRect(long, long);
	void NormalizeRect();
	int32_t IntersectRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t UnionRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t SubtractRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t operator==(const /*packed*/ struct SparkalRect&);
	int32_t operator!=(const /*packed*/ struct SparkalRect&);
	void operator+=(/*packed*/ class MRect*);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ class MRect*);
	void operator-=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator&=(const /*packed*/ struct SparkalRect&);
	void operator|=(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(/*packed*/ class MRect*);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator-(/*packed*/ class MRect*);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator&(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator|(const /*packed*/ struct SparkalRect&);
};

// Type: /*packed*/ struct SparkalPoint (forward reference);
struct SparkalPoint{ // packed(0x8 bytes) TI: 0x1a54
	/*+0x0*/   long x;
	/*+0x4*/   long y;
	void SparkalPoint(long, long);
	void SparkalPoint();
};

// Type: /*packed*/ struct SparkalRect (forward reference);
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: /*packed*/ struct _DDCOLORKEY;
struct _DDCOLORKEY{ // packed(0x8 bytes) TI: 0x1871
	/*+0x0*/   unsigned long dwColorSpaceLowValue;
	/*+0x4*/   unsigned long dwColorSpaceHighValue;
};

// Type: /*packed*/ struct tagPALETTEENTRY (forward reference);
struct tagPALETTEENTRY{ // packed(0x4 bytes) TI: 0x1be6
	/*+0x0*/   unsigned char peRed; // 0x1 bytes
	/*+0x1*/   unsigned char peGreen; // 0x1 bytes
	/*+0x2*/   unsigned char peBlue; // 0x1 bytes
	/*+0x3*/   unsigned char peFlags; // 0x1 bytes
};

// Type: /*packed*/ struct tagRECT (forward reference);
struct tagRECT{ // packed(0x10 bytes) TI: 0x13c4
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
};

// Type: /*packed*/ class IBackBuffer (forward reference);
// VTABLE: COPTER_D 0x005907e0
class IBackBuffer : public IFlatImage
{ // packed(0x18 bytes) TI: 0x283f
public:
	virtual unsigned long Swap(/*packed*/ class CSparkalWindow*, long, long); // vtable+0x1c
	virtual unsigned long SwapRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long); // vtable+0x20
	virtual unsigned long StretchRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long, long, long); // vtable+0x24
};

// Type: /*packed*/ class IBackBuffer;
// VTABLE: COPTER_D 0x005907e0
class IBackBuffer : public IFlatImage
{ // packed(0x18 bytes) TI: 0x283f
public:
	virtual unsigned long Swap(/*packed*/ class CSparkalWindow*, long, long); // vtable+0x1c
	virtual unsigned long SwapRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long); // vtable+0x20
	virtual unsigned long StretchRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long, long, long); // vtable+0x24
};

// Type: /*packed*/ class IFlatImage;
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(/*packed*/ class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, /*packed*/ struct SparkalRect, /*packed*/ struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	/*+0x4*/   unsigned long mLockCount;
	/*+0x8*/   long mWidth;
	/*+0xc*/   long mHeight;
	/*+0x10*/  void * __ptr32 mpBits;
	/*+0x14*/  long mStride;
};



// Contribution: 1:0006d690-0007056d Module: 39, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0046e690
void CBackBuffer::CBackBuffer() {

	__asm        mov    ecx, this;
	__asm        call   IFlatImage::IFlatImage;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5907E0;
	__asm        jmp    _T22;
_T22:
	__asm        jmp    _T27;
_T27:
	__asm        jmp    _T2c;
_T2c:
	__asm        jmp    _T31;
_T31:
	this-><CBackBuffer+0x00> = 0x590808;
// LINE 45:
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::InitializeMemberVariables;
// LINE 46:
	__asm        jmp    _T47;
_T47:
	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0046e6df
void CBackBuffer::CBackBuffer(char * imageFileName) {
	/*bp-0x4*/   /*packed*/ class PFile *fileImage;
	/*bp-0x14*/  /*packed*/ struct tagBITMAPFILEHEADER bfHeader; // 0xe bytes
	/*bp-0x18*/  long ddrval;
	/*bp-0x40*/  /*packed*/ struct tagBITMAPINFOHEADER biHeader; // 0x28 bytes
	/*bp-0x44*/  int32_t nFileNameLength;


	__asm        mov    ecx, this;
	__asm        call   IFlatImage::IFlatImage;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5907E0;
	__asm        jmp    _T22;
_T22:
	__asm        jmp    _T27;
_T27:
	__asm        jmp    _T2c;
_T2c:
	__asm        jmp    _T31;
_T31:
	this-><CBackBuffer+0x00> = 0x590808;
// LINE 68:
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::InitializeMemberVariables;
// LINE 69:
	this->bSurfacePrimary = 0x0;
// LINE 70:
	__asm        cmp    imageFileName, 0;
	__asm        jne    _T6f;

	__asm        push   0x46;
	__asm        push   0x599498;
	__asm        push   0x5994C0;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T74;
_T6f:
	__asm        jmp    _T74;
// LINE 71:
_T74:
	__asm        mov    eax, imageFileName;
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    nFileNameLength, eax;
// LINE 72:
	__asm        mov    eax, nFileNameLength;
	__asm        inc    eax;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x18], eax;
// LINE 73:
	__asm        mov    eax, imageFileName;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   strcpy;
	__asm        add    esp, 8;
// LINE 77:
	__asm        push   0x110;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x48], eax;
	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        je     _T129;

	__asm        mov    eax, [ebp-0x48];
	__asm        mov    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    dword ptr [eax+0x10C], 1;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    dword ptr [eax], 0x590468;
	__asm        mov    _fmode, 0x8000;
	__asm        cmp    imageFileName, 0;
	__asm        je     _T112;

	__asm        mov    eax, imageFileName;
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x48];
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   strcpy;
	__asm        add    esp, 8;
	__asm        jmp    _T119;
_T112:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    byte ptr [eax+4], 0;
_T119:
	__asm        jmp    _T11e;
_T11e:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    fileImage, eax;
	__asm        jmp    _T130;
_T129:
	fileImage = 0x0;
// LINE 78:
_T130:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Open;
// LINE 79:
	__asm        mov    eax, fileImage;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T15d;

	__asm        jmp    _T1b6;

	__asm        jmp    _T15d;
_T15d:
	__asm        jmp    _T16c;

	__asm        cmp    dword ptr [ebp-0x60], 0;
	__asm        jne    _T1b6;
// LINE 80:
_T16c:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC], 0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
// LINE 81:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Close;
// LINE 82:
	__asm        mov    eax, fileImage;
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x4C], eax;
	__asm        cmp    dword ptr [ebp-0x4C], 0;
	__asm        je     _T1b1;

	__asm        push   1;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x4C];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T1b1;
// LINE 83:
_T1b1:
	__asm        jmp    _T31d;
// LINE 86:
_T1b6:
	__asm        push   0xE;
	__asm        lea    eax, bfHeader.bfType;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        jmp    _T1d3;
// LINE 87:
_T1d3:
	__asm        push   0x28;
	__asm        lea    eax, biHeader.biSize;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        jmp    _T1f0;
// LINE 88:
_T1f0:
	this->mWidth = biHeader.biWidth;
// LINE 89:
	this->mHeight = biHeader.biHeight;
// LINE 90:
	this->rectDirectDrawBuffer.left = 0x0;
// LINE 91:
	this->rectDirectDrawBuffer.top = 0x0;
// LINE 92:
	this->rectDirectDrawBuffer.right = this->mWidth;
// LINE 93:
	this->rectDirectDrawBuffer.bottom = this->mHeight;
// LINE 94:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Close;
// LINE 95:
	__asm        mov    eax, fileImage;
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    [ebp-0x54], eax;
	__asm        cmp    dword ptr [ebp-0x54], 0;
	__asm        je     _T25d;

	__asm        push   1;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x54];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T25d;
// LINE 99:
_T25d:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 100:
	this->mDDdesc.dwSize = 0x6c;
// LINE 102:
	this->mDDdesc.dwFlags = 0x6;
// LINE 113:
	this->mDDdesc.ddsCaps.dwCaps = 0x840;
// LINE 118:
	this->mDDdesc.dwBackBufferCount = 0x0;
// LINE 119:
	this->mDDdesc.dwWidth = this->mWidth;
// LINE 120:
	this->mDDdesc.dwHeight = this->mHeight;
// LINE 123:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    ddrval, eax;
// LINE 124:
	__asm        cmp    ddrval, 0;
	__asm        je     _T2fd;
// LINE 125:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x5C], eax;
	__asm        jmp    _T2eb;
_T2eb:
	__asm        push   0x5994D0;
	__asm        lea    ecx, [ebp-0x5C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 126:
	__asm        jmp    _T31d;
// LINE 139:
_T2fd:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0xC];
	__asm        add    IFlatImage::lTotalMemoryUsage, eax;
// LINE 142:
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::Load;
// LINE 145:
	__asm        jmp    _T31d;
_T31d:
	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0046ea06
void CBackBuffer::CBackBuffer(long Width, long Height, const /*packed*/ struct SparkalColor *__formal) {
	/*bp-0x4*/   long ddrval;


	__asm        mov    ecx, this;
	__asm        call   IFlatImage::IFlatImage;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5907E0;
	__asm        jmp    _T22;
_T22:
	__asm        jmp    _T27;
_T27:
	__asm        jmp    _T2c;
_T2c:
	__asm        jmp    _T31;
_T31:
	this-><CBackBuffer+0x00> = 0x590808;
// LINE 161:
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::InitializeMemberVariables;
// LINE 165:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 166:
	this->mDDdesc.dwSize = 0x6c;
// LINE 167:
	this->mDDdesc.dwFlags = 0x6;
// LINE 170:
	this->mDDdesc.ddsCaps.dwCaps = 0x840;
// LINE 175:
	this->mDDdesc.dwBackBufferCount = 0x0;
// LINE 176:
	__asm        mov    eax, Width;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x64], eax;
// LINE 177:
	__asm        mov    eax, Height;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xC], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x60], eax;
// LINE 178:
	this->rectDirectDrawBuffer.left = 0x0;
// LINE 179:
	this->rectDirectDrawBuffer.top = 0x0;
// LINE 180:
	this->rectDirectDrawBuffer.right = this->mWidth;
// LINE 181:
	this->rectDirectDrawBuffer.bottom = this->mHeight;
// LINE 183:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    ddrval, eax;
// LINE 184:
	__asm        cmp    ddrval, 0;
	__asm        je     _T120;
// LINE 185:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T10e;
_T10e:
	__asm        push   0x59950C;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 186:
	__asm        jmp    _T148;
// LINE 191:
_T120:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0xC];
	__asm        add    IFlatImage::lTotalMemoryUsage, eax;
// LINE 204:
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::Lock;
// LINE 205:
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::Unlock;
// LINE 208:
	__asm        jmp    _T148;
_T148:
	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0046eb58
void CBackBuffer::InitializeMemberVariables() {
// LINE 216:
	this->bSurfacePrimary = 0x0;
// LINE 217:
	this->bSurfaceTransparent = 0x0;
// LINE 218:
	this->szFilePath = 0x0;
// LINE 219:
	this->mFont = 0x0;
// LINE 222:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x38], 0;
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x38];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x39], al;
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x39];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x3A], al;
// LINE 225:
	__asm        mov    eax, this;
	__asm        mov    byte ptr [eax+0x3C], 0;
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x3C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x3D], al;
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x3D];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x3E], al;
// LINE 226:
	this->nColorIndexFontCurrent = 0x0;
// LINE 227:
	this->nColorIndexCurrent = 0x0;
// LINE 228:
	this->nColorIndexTransparent = 0x0;
// LINE 231:
	this->mpFrontSurface = 0x0;
// LINE 232:
	this->mpBackSurface = 0x0;
// LINE 233:
	this->mpPalette = 0x0;
// LINE 234:
	this->rectDirectDrawBuffer.left = 0x0;
// LINE 235:
	this->rectDirectDrawBuffer.top = 0x0;
// LINE 236:
	this->rectDirectDrawBuffer.right = 0x0;
// LINE 237:
	this->rectDirectDrawBuffer.bottom = 0x0;
// LINE 238:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 239:
	__asm        push   0x64;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0xC4;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 240:
	this->hPen = 0x0;
// LINE 241:
	this->nPenThickness = 0x0;
// LINE 245:
	__asm        jmp    _T11d;
_T11d:
}

// FUNCTION: COPTER_D 0x0046ec7a
void CBackBuffer::~CBackBuffer() {

	this-><CBackBuffer+0x00> = 0x590808;
// LINE 254:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x34], 0;
	__asm        je     _T63;
// LINE 255:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T59;

	__asm        mov    ecx, [ebp-4];
	__asm        call   MFont::~MFont;
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T54;
_T54:
	__asm        jmp    _T59;
// LINE 256:
_T59:
	this->mFont = 0x0;
// LINE 259:
_T63:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T95;
// LINE 260:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    [ebp-0xC], eax;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 261:
	this->szFilePath = 0x0;
// LINE 271:
_T95:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        je     _Td7;
// LINE 272:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 273:
	this->mpFrontSurface = 0x0;
// LINE 277:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    IFlatImage::lTotalMemoryUsage, eax;
// LINE 281:
_Td7:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x50], 0;
	__asm        je     _T119;
// LINE 282:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 283:
	this->mpBackSurface = 0x0;
// LINE 287:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    IFlatImage::lTotalMemoryUsage, eax;
// LINE 291:
_T119:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _T146;
// LINE 292:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x128];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 293:
	this->hPen = 0x0;
// LINE 297:
_T146:
	__asm        jmp    _T14b;
_T14b:
}

// FUNCTION: COPTER_D 0x0046edca
unsigned long CBackBuffer::Load() {
	/*bp-0x4*/   int32_t nBytesRead;
	/*bp-0x8*/   int32_t nFileLength;
	/*bp-0xc*/   /*packed*/ class PFile *fileImage;
	/*bp-0x10*/  int32_t nPosition;
	/*bp-0x20*/  /*packed*/ struct tagBITMAPFILEHEADER bfHeader; // 0xe bytes
	/*bp-0x24*/  unsigned char * biData;
	/*bp-0x28*/  int32_t i;
	/*bp-0x428*/ /*packed*/ struct tagRGBQUAD biColors[256]; // 0x400 bytes
	/*bp-0x450*/ /*packed*/ struct tagBITMAPINFOHEADER biHeader; // 0x28 bytes

// LINE 316:
	__asm        push   0x110;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x454], eax;
	__asm        cmp    dword ptr [ebp-0x454], 0;
	__asm        je     _Tbf;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    [ebp-0x478], eax;
	__asm        mov    eax, [ebp-0x454];
	__asm        mov    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        mov    eax, [ebp-0x454];
	__asm        mov    dword ptr [eax+0x10C], 1;
	__asm        mov    eax, [ebp-0x454];
	__asm        mov    dword ptr [eax], 0x590468;
	__asm        mov    _fmode, 0x8000;
	__asm        cmp    dword ptr [ebp-0x478], 0;
	__asm        je     _Ta2;

	__asm        mov    eax, [ebp-0x478];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x454];
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   strcpy;
	__asm        add    esp, 8;
	__asm        jmp    _Tac;
_Ta2:
	__asm        mov    eax, [ebp-0x454];
	__asm        mov    byte ptr [eax+4], 0;
_Tac:
	__asm        jmp    _Tb1;
_Tb1:
	__asm        mov    eax, [ebp-0x454];
	__asm        mov    fileImage, eax;
	__asm        jmp    _Tc6;
_Tbf:
	fileImage = 0x0;
// LINE 317:
_Tc6:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Open;
// LINE 318:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Length;
	__asm        mov    nFileLength, eax;
// LINE 319:
	__asm        mov    eax, fileImage;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _Tfe;

	__asm        jmp    _T175;

	__asm        jmp    _Tfe;
_Tfe:
	__asm        jmp    _T110;

	__asm        cmp    dword ptr [ebp-0x468], 0;
	__asm        jne    _T175;
// LINE 320:
_T110:
	this->mWidth = 0x0;
// LINE 321:
	this->mHeight = 0x0;
// LINE 322:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Close;
// LINE 323:
	__asm        mov    eax, fileImage;
	__asm        mov    [ebp-0x45C], eax;
	__asm        mov    eax, [ebp-0x45C];
	__asm        mov    [ebp-0x458], eax;
	__asm        cmp    dword ptr [ebp-0x458], 0;
	__asm        je     _T16b;

	__asm        push   1;
	__asm        mov    eax, [ebp-0x458];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x458];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T16b;
// LINE 324:
_T16b:
	__asm        mov    eax, 0x80000006;
	__asm        jmp    _T3ee;
// LINE 327:
_T175:
	__asm        push   0xE;
	__asm        lea    eax, bfHeader.bfType;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    nBytesRead, eax;
	__asm        jmp    _T195;
// LINE 328:
_T195:
	__asm        push   0x28;
	__asm        lea    eax, biHeader.biSize;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    nBytesRead, eax;
	__asm        jmp    _T1b8;
// LINE 329:
_T1b8:
	__asm        jmp    _T1bd;
_T1bd:
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _tell;
	__asm        add    esp, 4;
	__asm        mov    nPosition, eax;
// LINE 330:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Length;
	__asm        mov    nFileLength, eax;
// LINE 335:
	__asm        cmp    biHeader.biClrUsed, 0;
	__asm        jne    _T1fd;
// LINE 336:
	__asm        mov    eax, 1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(biHeader.biBitCount);
	__asm        shl    eax, cl;
	__asm        mov    biHeader.biClrUsed, eax;
// LINE 338:
_T1fd:
	__asm        mov    eax, biHeader.biClrUsed;
	__asm        shl    eax, 2;
	__asm        mov    [ebp-0x46C], eax;
	__asm        mov    eax, [ebp-0x46C];
	__asm        push   eax;
	__asm        lea    eax, biColors[0].rgbBlue;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    nBytesRead, eax;
	__asm        jmp    _T234;
// LINE 339:
_T234:
	__asm        jmp    _T239;
_T239:
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _tell;
	__asm        add    esp, 4;
	__asm        mov    nPosition, eax;
// LINE 340:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Length;
	__asm        mov    nFileLength, eax;
// LINE 344:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax];
// LINE 346:
	biData = this->mpBits;
// LINE 347:
	__asm        mov    eax, biHeader.biWidth;
	__asm        add    eax, 3;
	__asm        and    eax, 0xFFFFFFFC;
	__asm        mov    biHeader.biWidth, eax;
// LINE 348:
	__asm        mov    eax, biHeader.biHeight;
	__asm        dec    eax;
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0x14];
	__asm        add    biData, eax;
// LINE 350:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Length;
	__asm        mov    nFileLength, eax;
// LINE 351:
	__asm        jmp    _T2ab;
_T2ab:
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _tell;
	__asm        add    esp, 4;
	__asm        mov    nPosition, eax;
// LINE 352:
	__asm        mov    i, 0;
	__asm        jmp    _T2cf;
_T2cc:
	i++;
_T2cf:
	__asm        mov    eax, biHeader.biHeight;
	__asm        dec    eax;
	__asm        cmp    eax, i;
	__asm        jle    _T34a;

	__asm        mov    eax, biHeader.biWidth;
	__asm        mov    [ebp-0x470], eax;
// LINE 353:
	__asm        mov    eax, [ebp-0x470];
	__asm        push   eax;
	__asm        mov    eax, biData;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    nBytesRead, eax;
	__asm        jmp    _T310;
// LINE 354:
_T310:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Length;
	__asm        mov    nFileLength, eax;
// LINE 355:
	__asm        jmp    _T320;
_T320:
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _tell;
	__asm        add    esp, 4;
	__asm        mov    nPosition, eax;
// LINE 356:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x14];
	__asm        neg    eax;
	__asm        sub    biData, eax;
// LINE 357:
	__asm        jmp    _T2cc;
_T34a:
	__asm        mov    eax, biHeader.biWidth;
	__asm        mov    [ebp-0x474], eax;
// LINE 361:
	__asm        mov    eax, [ebp-0x474];
	__asm        push   eax;
	__asm        mov    eax, biData;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    nBytesRead, eax;
	__asm        jmp    _T37b;
// LINE 362:
_T37b:
	__asm        jmp    _T380;
_T380:
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _tell;
	__asm        add    esp, 4;
	__asm        mov    nPosition, eax;
// LINE 363:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Close;
// LINE 364:
	__asm        mov    eax, fileImage;
	__asm        mov    [ebp-0x464], eax;
	__asm        mov    eax, [ebp-0x464];
	__asm        mov    [ebp-0x460], eax;
	__asm        cmp    dword ptr [ebp-0x460], 0;
	__asm        je     _T3d6;

	__asm        push   1;
	__asm        mov    eax, [ebp-0x460];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x460];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T3d6;
// LINE 366:
_T3d6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 367:
	__asm        xor    eax, eax;
	__asm        jmp    _T3ee;
// LINE 369:
_T3ee:
}

// FUNCTION: COPTER_D 0x0046f1bd
unsigned long CBackBuffer::DrawBufferText(char * pText, unsigned long Style, long * pRectLeft, long * pRectTop, long * pRectRight, long * pRectBottom, /*packed*/ class MFont *mfontToUse) {
	/*bp-0x4*/   void * __ptr32 hFontOriginal;
	/*bp-0x8*/   uint32_t nFormat;
	/*bp-0xc*/   long ddrval;
	/*bp-0x10*/  void * __ptr32 hdcSurface;
	/*bp-0x14*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;
	/*bp-0x24*/  /*packed*/ struct tagRECT rectText; // 0x10 bytes

// LINE 389:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 390:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T2e;
// LINE 391:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T23f;
// LINE 393:
_T2e:
	rectText.left = pRectLeft[0];
// LINE 394:
	rectText.top = pRectTop[0];
// LINE 395:
	__asm        cmp    pRectRight, 0;
	__asm        je     _T55;
// LINE 396:
	rectText.right = pRectRight[0];
// LINE 397:
	__asm        jmp    _T5e;
// LINE 398:
_T55:
	rectText.right = this->mWidth;
// LINE 399:
_T5e:
	__asm        cmp    pRectBottom, 0;
	__asm        je     _T75;
// LINE 400:
	rectText.bottom = pRectBottom[0];
// LINE 401:
	__asm        jmp    _T7e;
// LINE 402:
_T75:
	rectText.bottom = this->mHeight;
// LINE 404:
_T7e:
	__asm        lea    eax, hdcSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x44];
	__asm        mov    ddrval, eax;
// LINE 405:
	__asm        cmp    ddrval, 0;
	__asm        je     _Tc2;
// LINE 406:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _Ta6;
_Ta6:
	__asm        push   0x599548;
	__asm        lea    ecx, [ebp-0x28];
	__asm        call   DirectDrawError::DisplayError;
// LINE 407:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T23f;
// LINE 410:
	__asm        jmp    _T238;
// LINE 411:
_Tc2:
	nFormat = 0x10;
// LINE 412:
	__asm        test   reinterpret_cast<uint8_t>(Style), 1;
	__asm        je     _Tdc;
// LINE 413:
	__asm        or     nFormat, 1;
// LINE 414:
	__asm        jmp    _Tef;
_Tdc:
	__asm        test   reinterpret_cast<uint8_t>(Style), 8;
	__asm        je     _Tef;
// LINE 415:
	__asm        or     nFormat, 2;
// LINE 416:
	__asm        jmp    _Tef;
// LINE 418:
_Tef:
	__asm        test   reinterpret_cast<uint8_t>(Style), 2;
	__asm        je     _Tfd;
// LINE 419:
	__asm        or     nFormat, 4;
// LINE 420:
_Tfd:
	__asm        test   reinterpret_cast<uint8_t>(Style), 4;
	__asm        je     _T118;
// LINE 421:
	__asm        push   2;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3574];
// LINE 422:
	__asm        jmp    _T124;
// LINE 423:
_T118:
	__asm        push   1;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3574];
// LINE 424:
_T124:
	__asm        test   reinterpret_cast<uint8_t>(Style), 0x10;
	__asm        je     _T135;
// LINE 425:
	__asm        or     nFormat, 0x400;
// LINE 427:
_T135:
	__asm        cmp    mfontToUse, 0;
	__asm        je     _T15d;
// LINE 428:
	__asm        jmp    _T144;
_T144:
	__asm        mov    eax, mfontToUse;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    hFontOriginal, eax;
// LINE 429:
	__asm        jmp    _T186;
_T15d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x34], 0;
	__asm        je     _T186;
// LINE 430:
	__asm        jmp    _T16f;
_T16f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    hFontOriginal, eax;
// LINE 432:
_T186:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x39];
	__asm        shl    ecx, 8;
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x3A];
	__asm        or     ecx, edx;
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x38];
	__asm        shl    edx, 0x10;
	__asm        or     ecx, edx;
	__asm        push   ecx;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3594];
// LINE 434:
	__asm        mov    eax, nFormat;
	__asm        push   eax;
	__asm        lea    eax, rectText.left;
	__asm        push   eax;
	__asm        mov    eax, pText;
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        mov    eax, pText;
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C389C];
// LINE 436:
	__asm        test   reinterpret_cast<uint8_t>(Style), 0x10;
	__asm        je     _T200;
// LINE 437:
	pRectLeft[0] = rectText.left;
// LINE 438:
	pRectTop[0] = rectText.top;
// LINE 439:
	pRectRight[0] = rectText.right;
// LINE 440:
	pRectBottom[0] = rectText.bottom;
// LINE 443:
_T200:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x34], 0;
	__asm        jne    _T217;

	__asm        cmp    mfontToUse, 0;
	__asm        je     _T228;
// LINE 444:
_T217:
	__asm        mov    eax, hFontOriginal;
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    hFontOriginal, eax;
// LINE 445:
_T228:
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x68];
// LINE 448:
_T238:
	__asm        xor    eax, eax;
	__asm        jmp    _T23f;
// LINE 449:
_T23f:
}

// FUNCTION: COPTER_D 0x0046f403
unsigned long CBackBuffer::DrawBufferText(char * pText, long nTextLength, unsigned long Style, const /*packed*/ class MRect& rectText, /*packed*/ class MFont *mfontToUse) {
	/*bp-0x4*/   void * __ptr32 hFontOriginal;
	/*bp-0x8*/   uint32_t nFormat;
	/*bp-0xc*/   long ddrval;
	/*bp-0x10*/  void * __ptr32 hdcSurface;
	/*bp-0x14*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 468:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 469:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T2e;
// LINE 470:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T1bc;
// LINE 472:
_T2e:
	__asm        lea    eax, hdcSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x44];
	__asm        mov    ddrval, eax;
// LINE 473:
	__asm        cmp    ddrval, 0;
	__asm        je     _T72;
// LINE 474:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T56;
_T56:
	__asm        push   0x599580;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   DirectDrawError::DisplayError;
// LINE 475:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T1bc;
// LINE 478:
	__asm        jmp    _T1b5;
// LINE 479:
_T72:
	nFormat = 0x10;
// LINE 480:
	__asm        test   reinterpret_cast<uint8_t>(Style), 1;
	__asm        je     _T8c;
// LINE 481:
	__asm        or     nFormat, 1;
// LINE 482:
	__asm        jmp    _T9f;
_T8c:
	__asm        test   reinterpret_cast<uint8_t>(Style), 8;
	__asm        je     _T9f;
// LINE 483:
	__asm        or     nFormat, 2;
// LINE 484:
	__asm        jmp    _T9f;
// LINE 486:
_T9f:
	__asm        test   reinterpret_cast<uint8_t>(Style), 2;
	__asm        je     _Tad;
// LINE 487:
	__asm        or     nFormat, 4;
// LINE 488:
_Tad:
	__asm        test   reinterpret_cast<uint8_t>(Style), 4;
	__asm        je     _Tc8;
// LINE 489:
	__asm        push   2;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3574];
// LINE 490:
	__asm        jmp    _Td4;
// LINE 491:
_Tc8:
	__asm        push   1;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3574];
// LINE 492:
_Td4:
	__asm        test   reinterpret_cast<uint8_t>(Style), 0x10;
	__asm        je     _Te5;
// LINE 493:
	__asm        or     nFormat, 0x400;
// LINE 495:
_Te5:
	__asm        cmp    mfontToUse, 0;
	__asm        je     _T10d;
// LINE 496:
	__asm        jmp    _Tf4;
_Tf4:
	__asm        mov    eax, mfontToUse;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    hFontOriginal, eax;
// LINE 497:
	__asm        jmp    _T136;
_T10d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x34], 0;
	__asm        je     _T136;
// LINE 498:
	__asm        jmp    _T11f;
_T11f:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    hFontOriginal, eax;
// LINE 500:
_T136:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x39];
	__asm        shl    ecx, 8;
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x3A];
	__asm        or     ecx, edx;
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x38];
	__asm        shl    edx, 0x10;
	__asm        or     ecx, edx;
	__asm        push   ecx;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3594];
// LINE 501:
	__asm        mov    eax, nFormat;
	__asm        push   eax;
	__asm        mov    eax, rectText;
	__asm        push   eax;
	__asm        mov    eax, nTextLength;
	__asm        push   eax;
	__asm        mov    eax, pText;
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C389C];
// LINE 503:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x34], 0;
	__asm        jne    _T194;

	__asm        cmp    mfontToUse, 0;
	__asm        je     _T1a5;
// LINE 504:
_T194:
	__asm        mov    eax, hFontOriginal;
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    hFontOriginal, eax;
// LINE 505:
_T1a5:
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x68];
// LINE 508:
_T1b5:
	__asm        xor    eax, eax;
	__asm        jmp    _T1bc;
// LINE 509:
_T1bc:
}

// FUNCTION: COPTER_D 0x0046f5c6
unsigned long CBackBuffer::DrawLine(long nStartX, long nStartY, long nEndX, long nEndY, long nThickness) {
	/*bp-0x4*/   unsigned long crPen;
	/*bp-0xc*/   /*packed*/ struct tagPOINT ptPositionOld; // 0x8 bytes
	/*bp-0x10*/  long ddrval;
	/*bp-0x14*/  void * __ptr32 hdcSurface;
	/*bp-0x18*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;
	/*bp-0x1c*/  void * __ptr32 hPenOld;

// LINE 546:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 547:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T2e;
// LINE 548:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T1ee;
// LINE 555:
_T2e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _Ta1;

	__asm        mov    eax, this;
	__asm        mov    ecx, nThickness;
	__asm        cmp    [eax+0x12C], ecx;
	__asm        jne    _Ta1;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x132];
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x3E];
	__asm        cmp    ecx, edx;
	__asm        jne    _Ta1;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x3D];
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x131];
	__asm        cmp    ecx, edx;
	__asm        jne    _Ta1;

	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x3C];
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x130];
	__asm        cmp    ecx, edx;
	__asm        je     _T146;
// LINE 557:
_Ta1:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _Tc1;
// LINE 558:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x128];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 559:
_Tc1:
	this->nPenThickness = nThickness;
// LINE 560:
	reinterpret_cast<uint32_t>(this->colorPenCurrent.Blue) = reinterpret_cast<uint32_t>(this->colorCurrent.Blue);
// LINE 561:
	__asm        mov    eax, this;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax+0x3D];
	__asm        shl    ecx, 8;
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x3E];
	__asm        or     ecx, edx;
	__asm        mov    eax, this;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+0x3C];
	__asm        shl    edx, 0x10;
	__asm        or     ecx, edx;
	__asm        mov    crPen, ecx;
// LINE 562:
	__asm        mov    eax, crPen;
	__asm        push   eax;
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C35A0];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x128], eax;
// LINE 563:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        jne    _T146;
// LINE 564:
	__asm        push   0x5995B8;
	__asm        push   0x5995F0;
	__asm        call   DebugOutput;
	__asm        add    esp, 8;
// LINE 565:
	__asm        mov    eax, 0x80000000;
	__asm        jmp    _T1ee;
// LINE 570:
_T146:
	__asm        lea    eax, hdcSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x44];
	__asm        mov    ddrval, eax;
// LINE 571:
	__asm        cmp    ddrval, 0;
	__asm        je     _T18a;
// LINE 572:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T16e;
_T16e:
	__asm        push   0x5995F4;
	__asm        lea    ecx, [ebp-0x20];
	__asm        call   DirectDrawError::DisplayError;
// LINE 573:
	__asm        mov    eax, 0x80000000;
	__asm        jmp    _T1ee;
// LINE 575:
	__asm        jmp    _T1e7;
// LINE 576:
_T18a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x128];
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    hPenOld, eax;
// LINE 577:
	__asm        lea    eax, ptPositionOld.x;
	__asm        push   eax;
	__asm        mov    eax, nStartY;
	__asm        push   eax;
	__asm        mov    eax, nStartX;
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35A8];
// LINE 578:
	__asm        mov    eax, nEndY;
	__asm        push   eax;
	__asm        mov    eax, nEndX;
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3598];
// LINE 579:
	__asm        mov    eax, hPenOld;
	__asm        push   eax;
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
// LINE 580:
	__asm        mov    eax, hdcSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x68];
// LINE 584:
_T1e7:
	__asm        xor    eax, eax;
	__asm        jmp    _T1ee;
// LINE 585:
_T1ee:
}

// FUNCTION: COPTER_D 0x0046f7bb
unsigned long CBackBuffer::Swap(/*unpacked*/ class CSparkalWindow *pDest, long DestLeft, long DestTop) {
	/*bp-0x4*/   long ddrval;

// LINE 602:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        jne    _T23;
// LINE 603:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T66;
// LINE 605:
_T23:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x2C];
	__asm        mov    ddrval, eax;
// LINE 606:
	__asm        cmp    ddrval, 0;
	__asm        je     _T5e;
// LINE 607:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T51;
_T51:
	__asm        push   0x59962C;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 609:
_T5e:
	__asm        mov    eax, ddrval;
	__asm        jmp    _T66;
// LINE 611:
_T66:
}

// FUNCTION: COPTER_D 0x0046f828
unsigned long CBackBuffer::SwapRect(/*unpacked*/ class CSparkalWindow *pDest, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom, long DestLeft, long DestTop) {
	/*bp-0x10*/  /*packed*/ struct tagRECT srcRect; // 0x10 bytes
	/*bp-0x74*/  /*packed*/ struct _DDBLTFX ddbltfx; // 0x64 bytes
	/*bp-0x84*/  /*packed*/ struct tagRECT destRect; // 0x10 bytes
	/*bp-0x88*/  /*packed*/ struct IDirectDrawSurface *pDestSurface;
	/*bp-0x8c*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 634:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 635:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T40;
// LINE 636:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T119;
// LINE 638:
_T40:
	__asm        mov    eax, pDest;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T51;
_T51:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    ecx, [ebp-0x90];
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pDestSurface, eax;
// LINE 640:
	srcRect.left = SrcLeft;
// LINE 641:
	srcRect.top = SrcTop;
// LINE 642:
	srcRect.right = SrcRight;
// LINE 643:
	srcRect.bottom = SrcBottom;
// LINE 645:
	destRect.left = DestLeft;
// LINE 646:
	destRect.top = DestTop;
// LINE 649:
	__asm        mov    eax, SrcRight;
	__asm        sub    eax, SrcLeft;
	__asm        add    eax, DestLeft;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        cmp    eax, ecx;
	__asm        jl     _Tb7;

	__asm        mov    eax, ecx;
_Tb7:
	__asm        mov    destRect.right, eax;
// LINE 650:
	__asm        mov    eax, SrcBottom;
	__asm        sub    eax, SrcTop;
	__asm        add    eax, DestTop;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xC];
	__asm        cmp    eax, ecx;
	__asm        jl     _Td6;

	__asm        mov    eax, ecx;
_Td6:
	__asm        mov    destRect.bottom, eax;
// LINE 652:
	ddbltfx.dwSize = 0x64;
// LINE 653:
	ddbltfx.dwROP = 0xcc0020;
// LINE 656:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1020000;
	__asm        lea    eax, srcRect.left;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        lea    eax, destRect.left;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        jmp    _T119;
// LINE 658:
_T119:
}

// FUNCTION: COPTER_D 0x0046f948
unsigned long CBackBuffer::Compose(/*packed*/ class IFlatImage *pDestImage, long DestLeft, long DestTop, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom) {
	/*bp-0x10*/  /*packed*/ struct tagRECT srcRect; // 0x10 bytes
	/*bp-0x74*/  /*packed*/ struct _DDBLTFX ddbltfx; // 0x64 bytes
	/*bp-0x84*/  /*packed*/ struct tagRECT destRect; // 0x10 bytes
	/*bp-0x88*/  unsigned long ddBltFlags;
	/*bp-0x8c*/  /*packed*/ struct IDirectDrawSurface *pDestSurface;
	/*bp-0x90*/  int32_t nOverhangDistance;
	/*bp-0x94*/  long ddrval;
	/*bp-0x98*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 682:
	__asm        jmp    _T17;
_T17:
	__asm        mov    eax, pDestImage;
	__asm        mov    ecx, DestLeft;
	__asm        cmp    [eax+8], ecx;
	__asm        jg     _T2d;
// LINE 683:
	__asm        xor    eax, eax;
	__asm        jmp    _T262;
// LINE 684:
_T2d:
	__asm        jmp    _T32;
_T32:
	__asm        mov    eax, pDestImage;
	__asm        mov    ecx, DestTop;
	__asm        cmp    [eax+0xC], ecx;
	__asm        jg     _T48;
// LINE 685:
	__asm        xor    eax, eax;
	__asm        jmp    _T262;
// LINE 686:
_T48:
	__asm        mov    eax, SrcRight;
	__asm        sub    eax, SrcLeft;
	__asm        add    eax, DestLeft;
	__asm        jns    _T5e;
// LINE 687:
	__asm        xor    eax, eax;
	__asm        jmp    _T262;
// LINE 688:
_T5e:
	__asm        mov    eax, SrcBottom;
	__asm        sub    eax, SrcTop;
	__asm        add    eax, DestTop;
	__asm        jns    _T74;
// LINE 689:
	__asm        xor    eax, eax;
	__asm        jmp    _T262;
// LINE 691:
_T74:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 692:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _Ta2;
// LINE 693:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T262;
// LINE 697:
_Ta2:
	__asm        mov    eax, pDestImage;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pDestImage;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pDestSurface, eax;
// LINE 699:
	srcRect.left = SrcLeft;
// LINE 700:
	srcRect.top = SrcTop;
// LINE 701:
	srcRect.right = SrcRight;
// LINE 702:
	srcRect.bottom = SrcBottom;
// LINE 704:
	destRect.left = DestLeft;
// LINE 705:
	destRect.top = DestTop;
// LINE 706:
	__asm        mov    eax, SrcRight;
	__asm        sub    eax, SrcLeft;
	__asm        add    eax, DestLeft;
	__asm        mov    destRect.right, eax;
// LINE 707:
	__asm        mov    eax, SrcBottom;
	__asm        sub    eax, SrcTop;
	__asm        add    eax, DestTop;
	__asm        mov    destRect.bottom, eax;
// LINE 710:
	__asm        jmp    _Tf7;
_Tf7:
	__asm        mov    eax, destRect.right;
	__asm        mov    ecx, pDestImage;
	__asm        sub    eax, [ecx+8];
	__asm        mov    nOverhangDistance, eax;
	__asm        cmp    nOverhangDistance, 0;
	__asm        jle    _T12d;
// LINE 711:
	__asm        xor    eax, eax;
	__asm        sub    eax, nOverhangDistance;
	__asm        neg    eax;
	__asm        sub    destRect.right, eax;
// LINE 712:
	__asm        xor    eax, eax;
	__asm        sub    eax, nOverhangDistance;
	__asm        neg    eax;
	__asm        sub    srcRect.right, eax;
// LINE 714:
_T12d:
	__asm        xor    eax, eax;
	__asm        sub    eax, destRect.left;
	__asm        mov    nOverhangDistance, eax;
	__asm        cmp    nOverhangDistance, 0;
	__asm        jle    _T15d;
// LINE 715:
	destRect.left += nOverhangDistance;
// LINE 716:
	srcRect.left += nOverhangDistance;
// LINE 718:
_T15d:
	__asm        jmp    _T162;
_T162:
	__asm        mov    eax, destRect.bottom;
	__asm        mov    ecx, pDestImage;
	__asm        sub    eax, [ecx+0xC];
	__asm        mov    nOverhangDistance, eax;
	__asm        cmp    nOverhangDistance, 0;
	__asm        jle    _T198;
// LINE 719:
	__asm        xor    eax, eax;
	__asm        sub    eax, nOverhangDistance;
	__asm        neg    eax;
	__asm        sub    destRect.bottom, eax;
// LINE 720:
	__asm        xor    eax, eax;
	__asm        sub    eax, nOverhangDistance;
	__asm        neg    eax;
	__asm        sub    srcRect.bottom, eax;
// LINE 722:
_T198:
	__asm        xor    eax, eax;
	__asm        sub    eax, destRect.top;
	__asm        mov    nOverhangDistance, eax;
	__asm        cmp    nOverhangDistance, 0;
	__asm        jle    _T1c2;
// LINE 723:
	destRect.top += nOverhangDistance;
// LINE 724:
	srcRect.top += nOverhangDistance;
// LINE 728:
_T1c2:
	ddbltfx.dwSize = 0x64;
// LINE 729:
	ddbltfx.dwROP = 0xcc0020;
// LINE 730:
	ddBltFlags = 0x1020000;
// LINE 732:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x30], 0;
	__asm        je     _T1f4;
// LINE 733:
	__asm        or     ddBltFlags, 0x8000;
// LINE 736:
_T1f4:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        mov    eax, ddBltFlags;
	__asm        push   eax;
	__asm        lea    eax, srcRect.left;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        lea    eax, destRect.left;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    ddrval, eax;
// LINE 737:
	__asm        cmp    ddrval, 0;
	__asm        je     _T257;
// LINE 738:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x9C], eax;
	__asm        jmp    _T247;
_T247:
	__asm        push   0x599678;
	__asm        lea    ecx, [ebp-0x9C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 740:
_T257:
	__asm        mov    eax, ddrval;
	__asm        jmp    _T262;
// LINE 787:
_T262:
}

// FUNCTION: COPTER_D 0x0046fbb1
unsigned long CBackBuffer::ComposeNoClip(/*packed*/ class IFlatImage *pDestImage, long DestLeft, long DestTop, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom) {
	/*bp-0x10*/  /*packed*/ class MRect sourceRect; // 0x10 bytes
	/*bp-0x74*/  /*packed*/ struct _DDBLTFX ddbltfx; // 0x64 bytes
	/*bp-0x84*/  /*packed*/ class MRect destRect; // 0x10 bytes
	/*bp-0x88*/  unsigned long ddBltFlags;
	/*bp-0x8c*/  /*packed*/ struct IDirectDrawSurface *pDestSurface;
	/*bp-0x90*/  long ddrval;
	/*bp-0x94*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 802:
	__asm        jmp    _T17;
_T17:
	__asm        mov    eax, DestLeft;
	__asm        mov    destRect.left, eax;
	__asm        mov    eax, DestTop;
	__asm        mov    destRect.top, eax;
	__asm        mov    eax, SrcRight;
	__asm        sub    eax, SrcLeft;
	__asm        add    eax, DestLeft;
	__asm        mov    destRect.right, eax;
	__asm        mov    eax, SrcBottom;
	__asm        sub    eax, SrcTop;
	__asm        add    eax, DestTop;
	__asm        mov    destRect.bottom, eax;
	__asm        jmp    _T43;
// LINE 803:
_T43:
	__asm        jmp    _T48;
_T48:
	__asm        mov    eax, SrcLeft;
	__asm        mov    sourceRect.left, eax;
	__asm        mov    eax, SrcTop;
	__asm        mov    sourceRect.top, eax;
	__asm        mov    eax, SrcRight;
	__asm        mov    sourceRect.right, eax;
	__asm        mov    eax, SrcBottom;
	__asm        mov    sourceRect.bottom, eax;
	__asm        jmp    _T65;
// LINE 805:
_T65:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 806:
	__asm        mov    eax, pDestImage;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pDestImage;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pDestSurface, eax;
// LINE 809:
	ddbltfx.dwSize = 0x64;
// LINE 810:
	ddbltfx.dwROP = 0xcc0020;
// LINE 811:
	ddBltFlags = 0x1020000;
// LINE 813:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x30], 0;
	__asm        je     _Tbf;
// LINE 814:
	__asm        or     ddBltFlags, 0x8000;
// LINE 817:
_Tbf:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        mov    eax, ddBltFlags;
	__asm        push   eax;
	__asm        lea    eax, sourceRect.left;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        lea    eax, destRect.left;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    ddrval, eax;
// LINE 818:
	__asm        cmp    ddrval, 0;
	__asm        je     _T122;
// LINE 819:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x98], eax;
	__asm        jmp    _T112;
_T112:
	__asm        push   0x5996B4;
	__asm        lea    ecx, [ebp-0x98];
	__asm        call   DirectDrawError::DisplayError;
// LINE 823:
_T122:
	__asm        mov    eax, 1;
	__asm        jmp    _T12c;
// LINE 825:
_T12c:
}

// FUNCTION: COPTER_D 0x0046fce4
unsigned long CBackBuffer::ComposeNoClip(/*packed*/ class IFlatImage *pDestImage, const /*packed*/ struct SparkalPoint& ptDestination, const /*packed*/ struct SparkalRect& rectSource) {
// LINE 836:
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, ptDestination;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, ptDestination;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, pDestImage;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x3C];
	__asm        jmp    _T48;
// LINE 837:
_T48:
}

// FUNCTION: COPTER_D 0x0046fd33
unsigned long CBackBuffer::Compose(/*packed*/ class IFlatImage *pDestImage, const /*packed*/ struct SparkalPoint& ptDestination, const /*packed*/ struct SparkalRect& rectSource) {
// LINE 848:
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectSource;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, ptDestination;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, ptDestination;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, pDestImage;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC];
	__asm        jmp    _T48;
// LINE 849:
_T48:
}

// FUNCTION: COPTER_D 0x0046fd82
unsigned long CBackBuffer::StretchCompose(/*packed*/ class IFlatImage *pDestImage, const /*packed*/ struct SparkalRect& destRect, const /*packed*/ struct SparkalRect& srcRect) {
	/*bp-0x64*/  /*packed*/ struct _DDBLTFX ddbltfx; // 0x64 bytes
	/*bp-0x68*/  unsigned long ddBltFlags;
	/*bp-0x6c*/  /*packed*/ struct IDirectDrawSurface *pDestSurface;
	/*bp-0x70*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 872:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 873:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T2e;
// LINE 874:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T8a;
// LINE 878:
_T2e:
	__asm        mov    eax, pDestImage;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pDestImage;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pDestSurface, eax;
// LINE 880:
	ddbltfx.dwSize = 0x64;
// LINE 881:
	ddbltfx.dwROP = 0xcc0020;
// LINE 883:
	ddBltFlags = 0x1020000;
// LINE 885:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x30], 0;
	__asm        je     _T65;
// LINE 886:
	__asm        or     ddBltFlags, 0x8000;
// LINE 890:
_T65:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        mov    eax, ddBltFlags;
	__asm        push   eax;
	__asm        mov    eax, srcRect;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, destRect;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        jmp    _T8a;
// LINE 892:
_T8a:
}

// FUNCTION: COPTER_D 0x0046fe13
unsigned long CBackBuffer::StretchCompose(/*packed*/ class IFlatImage *pDestImage, long DestLeft, long DestTop, long DestRight, long DestBottom, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom) {
	/*bp-0x10*/  /*packed*/ struct SparkalRect srcRect; // 0x10 bytes
	/*bp-0x20*/  /*packed*/ struct SparkalRect destRect; // 0x10 bytes

// LINE 904:
	__asm        jmp    _T11;
_T11:
	__asm        jmp    _T16;
// LINE 906:
_T16:
	srcRect.left = SrcLeft;
// LINE 907:
	srcRect.top = SrcTop;
// LINE 908:
	srcRect.right = SrcRight;
// LINE 909:
	srcRect.bottom = SrcBottom;
// LINE 911:
	destRect.left = DestLeft;
// LINE 912:
	destRect.top = DestTop;
// LINE 913:
	destRect.right = DestRight;
// LINE 914:
	destRect.bottom = DestBottom;
// LINE 916:
	__asm        lea    eax, srcRect.left;
	__asm        push   eax;
	__asm        lea    eax, destRect.left;
	__asm        push   eax;
	__asm        mov    eax, pDestImage;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x30];
	__asm        jmp    _T62;
// LINE 917:
_T62:
}

// FUNCTION: COPTER_D 0x0046fe7c
unsigned long CBackBuffer::Duplicate(/*packed*/ class CBackBuffer *pDestImage, int32_t bAllowTransparent) {
	/*bp-0x10*/  /*packed*/ struct tagRECT srcRect; // 0x10 bytes
	/*bp-0x74*/  /*packed*/ struct _DDBLTFX ddbltfx; // 0x64 bytes
	/*bp-0x84*/  /*packed*/ struct tagRECT destRect; // 0x10 bytes
	/*bp-0x88*/  unsigned long ddBltFlags;
	/*bp-0x8c*/  /*packed*/ struct IDirectDrawSurface *pDestSurface;
	/*bp-0x90*/  long ddrval;
	/*bp-0x94*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 939:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 940:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T40;
// LINE 941:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T149;
// LINE 945:
_T40:
	__asm        mov    eax, pDestImage;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pDestImage;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pDestSurface, eax;
// LINE 947:
	__asm        mov    destRect.left, 0;
	__asm        mov    eax, destRect.left;
	__asm        mov    srcRect.left, eax;
// LINE 948:
	__asm        mov    destRect.top, 0;
	__asm        mov    eax, destRect.top;
	__asm        mov    srcRect.top, eax;
// LINE 949:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    destRect.right, eax;
	__asm        jmp    _T82;
_T82:
	srcRect.right = destRect.right;
// LINE 950:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    destRect.bottom, eax;
	__asm        jmp    _T99;
_T99:
	srcRect.bottom = destRect.bottom;
// LINE 952:
	ddbltfx.dwSize = 0x64;
// LINE 953:
	ddbltfx.dwROP = 0xcc0020;
// LINE 955:
	ddBltFlags = 0x1020000;
// LINE 957:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x30], 0;
	__asm        je     _Tdb;

	__asm        cmp    bAllowTransparent, 0;
	__asm        je     _Tdb;
// LINE 958:
	__asm        or     ddBltFlags, 0x8000;
// LINE 961:
_Tdb:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        mov    eax, ddBltFlags;
	__asm        push   eax;
	__asm        lea    eax, srcRect.left;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        lea    eax, destRect.left;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        push   eax;
	__asm        mov    eax, pDestSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    ddrval, eax;
// LINE 962:
	__asm        cmp    ddrval, 0;
	__asm        je     _T13e;
// LINE 963:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x98], eax;
	__asm        jmp    _T12e;
_T12e:
	__asm        push   0x5996F0;
	__asm        lea    ecx, [ebp-0x98];
	__asm        call   DirectDrawError::DisplayError;
// LINE 965:
_T13e:
	__asm        mov    eax, ddrval;
	__asm        jmp    _T149;
// LINE 967:
_T149:
}

// FUNCTION: COPTER_D 0x0046ffcc
unsigned long CBackBuffer::StretchRect(/*unpacked*/ class CSparkalWindow *pDest, long __formal, long __formal, long __formal, long __formal, long __formal, long __formal, long __formal, long __formal) {
// LINE 981:
	__asm        xor    eax, eax;
	__asm        jmp    _T13;
// LINE 982:
_T13:
}

// FUNCTION: COPTER_D 0x0046ffe6
void CBackBuffer::SetTransparentColor(int32_t bEnable, long nPaletteIndex) {
	/*bp-0x8*/   /*packed*/ struct _DDCOLORKEY DDColorKey; // 0x8 bytes
	/*bp-0xc*/   /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 992:
	__asm        cmp    bEnable, 0;
	__asm        je     _T2e;
// LINE 993:
	this->bSurfaceTransparent = 0x1;
// LINE 994:
	this->nColorIndexTransparent = nPaletteIndex;
// LINE 996:
	__asm        jmp    _T38;
// LINE 997:
_T2e:
	this->bSurfaceTransparent = 0x0;
// LINE 1004:
_T38:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 1005:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T55;
// LINE 1006:
	__asm        jmp    _T82;
// LINE 1008:
_T55:
	__asm        cmp    bEnable, 0;
	__asm        je     _T7d;
// LINE 1009:
	DDColorKey.dwColorSpaceLowValue = nPaletteIndex;
// LINE 1010:
	DDColorKey.dwColorSpaceHighValue = nPaletteIndex;
// LINE 1011:
	__asm        lea    eax, DDColorKey.dwColorSpaceLowValue;
	__asm        push   eax;
	__asm        push   8;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x74];
// LINE 1014:
_T7d:
	__asm        jmp    _T82;
_T82:
}

// FUNCTION: COPTER_D 0x0047006f
unsigned long CBackBuffer::Lock() {
	/*bp-0x4*/   long ddrval;
	/*bp-0x8*/   /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 1036:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jbe    _T30;
// LINE 1037:
	this->mLockCount++;
// LINE 1039:
	IFlatImage::lTotalLockCount++;
// LINE 1041:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        jmp    _Td5;
// LINE 1045:
_T30:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 1046:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T4f;
// LINE 1047:
	__asm        xor    eax, eax;
	__asm        jmp    _Td5;
// LINE 1050:
_T4f:
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x64];
	__asm        mov    ddrval, eax;
	__asm        cmp    ddrval, 0x8876021C;
	__asm        jne    _T7d;

	__asm        jmp    _T4f;
// LINE 1051:
_T7d:
	__asm        cmp    ddrval, 0;
	__asm        je     _Ta6;
// LINE 1052:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T92;
_T92:
	__asm        push   0x59972C;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 1053:
	__asm        xor    eax, eax;
	__asm        jmp    _Td5;
// LINE 1055:
_Ta6:
	this->mpBits = this->mDDdesc.lpSurface;
// LINE 1056:
	this->mStride = this->mDDdesc.lPitch;
// LINE 1058:
	this->mLockCount++;
// LINE 1060:
	IFlatImage::lTotalLockCount++;
// LINE 1062:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        jmp    _Td5;
// LINE 1064:
_Td5:
}

// FUNCTION: COPTER_D 0x00470149
unsigned long CBackBuffer::Unlock() {
	/*bp-0x4*/   long ddrval;
	/*bp-0x8*/   /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 1089:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 1;
	__asm        jbe    _T30;
// LINE 1090:
	this->mLockCount--;
// LINE 1092:
	IFlatImage::lTotalLockCount--;
// LINE 1094:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        jmp    _Td3;
// LINE 1098:
_T30:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        jne    _T44;
// LINE 1099:
	__asm        xor    eax, eax;
	__asm        jmp    _Td3;
// LINE 1101:
_T44:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 1102:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T63;
// LINE 1103:
	__asm        xor    eax, eax;
	__asm        jmp    _Td3;
// LINE 1104:
_T63:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x80];
	__asm        mov    ddrval, eax;
// LINE 1105:
	__asm        cmp    ddrval, 0;
	__asm        je     _Ta5;
// LINE 1106:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T91;
_T91:
	__asm        push   0x599758;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 1107:
	__asm        xor    eax, eax;
	__asm        jmp    _Td3;
// LINE 1109:
_Ta5:
	this->mLockCount--;
// LINE 1111:
	IFlatImage::lTotalLockCount--;
// LINE 1114:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _Tc8;
// LINE 1115:
	this->mpBits = 0x0;
// LINE 1117:
_Tc8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        jmp    _Td3;
// LINE 1119:
_Td3:
}

// FUNCTION: COPTER_D 0x00470221
void CBackBuffer::UpdatePalette(long start, long count, const /*packed*/ struct SparkalColor *pColor) {
	/*bp-0x400*/ /*packed*/ struct tagPALETTEENTRY palColors[256]; // 0x400 bytes
	/*bp-0x404*/ int32_t i;

// LINE 1132:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        je     _Tc4;
// LINE 1133:
	__asm        mov    eax, start;
	__asm        mov    i, eax;
	__asm        jmp    _T36;
_T30:
	i++;
_T36:
	__asm        mov    eax, count;
	__asm        add    eax, start;
	__asm        cmp    eax, i;
	__asm        jle    _T97;
// LINE 1134:
	__asm        mov    eax, pColor;
	__asm        mov    al, [eax+2];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x400], al;
// LINE 1135:
	__asm        mov    eax, pColor;
	__asm        mov    al, [eax+1];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x3FF], al;
// LINE 1136:
	__asm        mov    eax, pColor;
	__asm        mov    al, [eax];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x3FE], al;
// LINE 1137:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3FD], 5;
// LINE 1138:
	pColor += 0x4;
// LINE 1139:
	__asm        jmp    _T30;
// LINE 1141:
_T97:
	__asm        mov    eax, start;
	__asm        lea    eax, [ebp+eax*4-0x400];
	__asm        push   eax;
	__asm        mov    eax, count;
	__asm        push   eax;
	__asm        mov    eax, start;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
// LINE 1145:
_Tc4:
	__asm        jmp    _Tc9;
_Tc9:
}

// FUNCTION: COPTER_D 0x004702f1
unsigned long CBackBuffer::FillRect(long nPaletteIndex, const /*packed*/ struct SparkalRect *rectFill) {
	/*bp-0x4*/   /*packed*/ struct tagRECT *rectToUse;
	/*bp-0x8*/   long ddrval;
	/*bp-0x18*/  /*packed*/ struct tagRECT rectFillTemp; // 0x10 bytes
	/*bp-0x1c*/  /*packed*/ struct IDirectDrawSurface *pOurSurface;

// LINE 1176:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x60];
	__asm        mov    pOurSurface, eax;
// LINE 1177:
	__asm        cmp    pOurSurface, 0;
	__asm        jne    _T2e;
// LINE 1178:
	__asm        mov    eax, 0x65;
	__asm        jmp    _T148;
// LINE 1180:
_T2e:
	this->mDDdesc.dwSize = 0x6c;
// LINE 1181:
	this->mDDBltFx.dwSize = 0x64;
// LINE 1182:
	this->mDDBltFx.dwFillColor = nPaletteIndex;
// LINE 1184:
	__asm        cmp    rectFill, 0;
	__asm        je     _Tf1;
// LINE 1185:
	rectFillTemp.left = rectFill->left;
// LINE 1186:
	rectFillTemp.top = rectFill->top;
// LINE 1187:
	rectFillTemp.right = rectFill->right;
// LINE 1188:
	rectFillTemp.bottom = rectFill->bottom;
// LINE 1189:
	rectToUse = rectFillTemp.left;
// LINE 1190:
	__asm        mov    eax, rectToUse;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jge    _T99;
// LINE 1191:
	rectToUse->left = 0x0;
// LINE 1192:
_T99:
	__asm        mov    eax, rectToUse;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jge    _Tb0;
// LINE 1193:
	rectToUse->top = 0x0;
// LINE 1194:
_Tb0:
	__asm        mov    eax, this;
	__asm        mov    ecx, rectToUse;
	__asm        mov    ecx, [ecx+8];
	__asm        cmp    [eax+0x24], ecx;
	__asm        jge    _Tce;
// LINE 1195:
	rectToUse->right = this->rectDirectDrawBuffer.right;
// LINE 1196:
_Tce:
	__asm        mov    eax, this;
	__asm        mov    ecx, rectToUse;
	__asm        mov    ecx, [ecx+0xC];
	__asm        cmp    [eax+0x28], ecx;
	__asm        jge    _Tec;
// LINE 1197:
	rectToUse->bottom = this->rectDirectDrawBuffer.bottom;
// LINE 1199:
_Tec:
	__asm        jmp    _Tfa;
// LINE 1200:
_Tf1:
	__asm        mov    eax, this;
	__asm        add    eax, 0x1C;
	__asm        mov    rectToUse, eax;
// LINE 1206:
_Tfa:
	__asm        mov    eax, this;
	__asm        add    eax, 0xC4;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, rectToUse;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        push   eax;
	__asm        mov    eax, pOurSurface;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    ddrval, eax;
// LINE 1207:
	__asm        cmp    ddrval, 0;
	__asm        je     _T141;
// LINE 1208:
	__asm        mov    eax, ddrval;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T134;
_T134:
	__asm        push   0x599788;
	__asm        lea    ecx, [ebp-0x20];
	__asm        call   DirectDrawError::DisplayError;
// LINE 1211:
_T141:
	__asm        xor    eax, eax;
	__asm        jmp    _T148;
// LINE 1212:
_T148:
}

// FUNCTION: COPTER_D 0x00470440
unsigned long CBackBuffer::SetFont(/*packed*/ class MFont *mNewFont) {
// LINE 1225:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x34], 0;
	__asm        je     _T50;
// LINE 1226:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T50;

	__asm        mov    ecx, [ebp-4];
	__asm        call   MFont::~MFont;
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T4b;
_T4b:
	__asm        jmp    _T50;
// LINE 1227:
_T50:
	this->mFont = mNewFont;
// LINE 1228:
	__asm        xor    eax, eax;
	__asm        jmp    _T60;
// LINE 1229:
_T60:
}

// FUNCTION: COPTER_D 0x004704a7
/*packed*/ struct IDirectDrawSurface* CBackBuffer::GetDDSurface() {
// LINE 1244:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x2C], 0;
	__asm        je     _T24;
// LINE 1245:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        jmp    _T2f;
// LINE 1246:
_T24:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        jmp    _T2f;
// LINE 1247:
_T2f:
}

// FUNCTION: COPTER_D 0x004704db
int32_t CBackBuffer::GetPaletteFromImage(char * imageFileName, /*packed*/ struct SparkalColor *pColors) {
	/*bp-0x4*/   /*packed*/ class PFile *fileImage;
	/*bp-0x14*/  /*packed*/ struct tagBITMAPFILEHEADER bfHeader; // 0xe bytes
	/*bp-0x3c*/  /*packed*/ struct tagBITMAPINFOHEADER biHeader; // 0x28 bytes

// LINE 1263:
	__asm        push   0x110;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x40], eax;
	__asm        cmp    dword ptr [ebp-0x40], 0;
	__asm        je     _T89;

	__asm        mov    eax, [ebp-0x40];
	__asm        mov    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    dword ptr [eax+0x10C], 1;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    dword ptr [eax], 0x590468;
	__asm        mov    _fmode, 0x8000;
	__asm        cmp    imageFileName, 0;
	__asm        je     _T72;

	__asm        mov    eax, imageFileName;
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   strcpy;
	__asm        add    esp, 8;
	__asm        jmp    _T79;
_T72:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    byte ptr [eax+4], 0;
_T79:
	__asm        jmp    _T7e;
_T7e:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    fileImage, eax;
	__asm        jmp    _T90;
_T89:
	fileImage = 0x0;
// LINE 1264:
_T90:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Open;
// LINE 1265:
	__asm        mov    eax, fileImage;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _Tbd;

	__asm        jmp    _T105;

	__asm        jmp    _Tbd;
_Tbd:
	__asm        jmp    _Tcc;

	__asm        cmp    dword ptr [ebp-0x5C], 0;
	__asm        jne    _T105;
// LINE 1266:
_Tcc:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Close;
// LINE 1267:
	__asm        mov    eax, fileImage;
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x44], eax;
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        je     _Tfb;

	__asm        push   1;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x44];
	__asm        call   dword ptr [eax];
	__asm        jmp    _Tfb;
// LINE 1268:
_Tfb:
	__asm        mov    eax, 0x80000000;
	__asm        jmp    _T204;
// LINE 1271:
_T105:
	__asm        push   0xE;
	__asm        lea    eax, bfHeader.bfType;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        jmp    _T122;
// LINE 1272:
_T122:
	__asm        push   0x28;
	__asm        lea    eax, biHeader.biSize;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        jmp    _T13f;
// LINE 1278:
_T13f:
	__asm        cmp    biHeader.biClrUsed, 0;
	__asm        jne    _T156;
// LINE 1279:
	__asm        mov    eax, 1;
	__asm        mov    cl, reinterpret_cast<uint8_t>(biHeader.biBitCount);
	__asm        shl    eax, cl;
	__asm        mov    biHeader.biClrUsed, eax;
// LINE 1280:
_T156:
	__asm        cmp    biHeader.biClrUsed, 0x100;
	__asm        ja     _T16d;

	__asm        cmp    biHeader.biClrUsed, 0;
	__asm        ja     _T1a6;
// LINE 1281:
_T16d:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Close;
// LINE 1282:
	__asm        mov    eax, fileImage;
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x4C], eax;
	__asm        cmp    dword ptr [ebp-0x4C], 0;
	__asm        je     _T19c;

	__asm        push   1;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x4C];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T19c;
// LINE 1283:
_T19c:
	__asm        mov    eax, 0x80000000;
	__asm        jmp    _T204;
// LINE 1285:
_T1a6:
	__asm        mov    eax, biHeader.biClrUsed;
	__asm        shl    eax, 2;
	__asm        mov    [ebp-0x60], eax;
	__asm        mov    eax, [ebp-0x60];
	__asm        push   eax;
	__asm        mov    eax, pColors;
	__asm        push   eax;
	__asm        mov    eax, fileImage;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        jmp    _T1ce;
// LINE 1286:
_T1ce:
	__asm        mov    ecx, fileImage;
	__asm        call   PFile::Close;
// LINE 1287:
	__asm        mov    eax, fileImage;
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    [ebp-0x54], eax;
	__asm        cmp    dword ptr [ebp-0x54], 0;
	__asm        je     _T1fd;

	__asm        push   1;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x54];
	__asm        call   dword ptr [eax];
	__asm        jmp    _T1fd;
// LINE 1288:
_T1fd:
	__asm        xor    eax, eax;
	__asm        jmp    _T204;
// LINE 1290:
_T204:
}

// FUNCTION: COPTER_D 0x004706e4
unsigned long CBackBuffer::DrawRectangleOutline(const /*packed*/ struct SparkalRect& rectOutline, long nThickness) {
// LINE 1301:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x54];
// LINE 1305:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x54];
// LINE 1309:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x54];
// LINE 1313:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x54];
	__asm        jmp    _Tb9;
// LINE 1314:
_Tb9:
}

// FUNCTION: COPTER_D 0x004707a4
unsigned long CBackBuffer::DrawRectangleOutlineUnclipped(const /*packed*/ struct SparkalRect& rectOutline, long nThickness) {
// LINE 1325:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x50];
// LINE 1329:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x50];
// LINE 1333:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x50];
// LINE 1337:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, rectOutline;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x50];
	__asm        jmp    _Tb9;
// LINE 1338:
_Tb9:
}

// FUNCTION: COPTER_D 0x00470864
unsigned long CBackBuffer::DrawLineUnclipped(long nStartX, long nStartY, long nEndX, long nEndY, long nThickness) {
	/*bp-0x4*/   char * address;
	/*bp-0x8*/   int32_t bufferHeight;
	/*bp-0xc*/   int32_t length;
	/*bp-0x10*/  int32_t temp;
	/*bp-0x14*/  int32_t i;
	/*bp-0x18*/  int32_t j;
	/*bp-0x1c*/  int32_t bufferWidth;

// LINE 1456:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax];
// LINE 1463:
	__asm        jmp    _T1b;
_T1b:
	bufferWidth = this->mWidth;
// LINE 1464:
	__asm        jmp    _T29;
_T29:
	bufferHeight = this->mHeight;
// LINE 1467:
	__asm        mov    eax, nStartY;
	__asm        cmp    nEndY, eax;
	__asm        jne    _Tbf;
// LINE 1469:
	__asm        mov    eax, nStartX;
	__asm        cmp    nEndX, eax;
	__asm        jg     _T5c;
// LINE 1471:
	__asm        mov    eax, nStartX;
	__asm        mov    temp, eax;
	__asm        mov    eax, nEndX;
	__asm        mov    nStartX, eax;
	__asm        mov    eax, temp;
	__asm        mov    nEndX, eax;
// LINE 1474:
_T5c:
	__asm        mov    eax, nEndX;
	__asm        sub    eax, nStartX;
	__asm        inc    eax;
	__asm        mov    length, eax;
// LINE 1476:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, nStartY;
	__asm        add    eax, nStartX;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    address, eax;
// LINE 1477:
	i = nThickness;
// LINE 1478:
_T82:
	__asm        mov    eax, i;
	__asm        mov    [ebp-0x50], eax;
	__asm        dec    i;
	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        je     _Tba;
// LINE 1480:
	__asm        mov    eax, length;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1481:
	address += this->mStride;
// LINE 1482:
	__asm        jmp    _T82;
// LINE 1486:
_Tba:
	__asm        jmp    _T3a5;
_Tbf:
	__asm        mov    eax, nStartX;
	__asm        cmp    nEndX, eax;
	__asm        jne    _T146;
// LINE 1488:
	__asm        mov    eax, nStartY;
	__asm        cmp    nEndY, eax;
	__asm        jg     _Te9;
// LINE 1490:
	__asm        mov    eax, nStartY;
	__asm        mov    temp, eax;
	__asm        mov    eax, nEndY;
	__asm        mov    nStartY, eax;
	__asm        mov    eax, temp;
	__asm        mov    nEndY, eax;
// LINE 1492:
_Te9:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, nStartY;
	__asm        add    eax, nStartX;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    address, eax;
// LINE 1493:
	__asm        mov    eax, nEndY;
	__asm        sub    eax, nStartY;
	__asm        inc    eax;
	__asm        mov    i, eax;
// LINE 1494:
_T109:
	__asm        mov    eax, i;
	__asm        mov    [ebp-0x54], eax;
	__asm        dec    i;
	__asm        cmp    dword ptr [ebp-0x54], 0;
	__asm        je     _T141;
// LINE 1496:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1497:
	address += this->mStride;
// LINE 1498:
	__asm        jmp    _T109;
// LINE 1501:
_T141:
	__asm        jmp    _T3a5;
// LINE 1508:
// Block start:
	/*bp-0x20*/  int32_t d;
	/*bp-0x24*/  int32_t xinc1;
	/*bp-0x28*/  int32_t xinc2;
	/*bp-0x2c*/  int32_t x;
	/*bp-0x30*/  int32_t y;
	/*bp-0x34*/  int32_t numpixels;
	/*bp-0x38*/  int32_t deltax;
	/*bp-0x3c*/  int32_t deltay;
	/*bp-0x40*/  int32_t yinc1;
	/*bp-0x44*/  int32_t dinc1;
	/*bp-0x48*/  int32_t yinc2;
	/*bp-0x4c*/  int32_t dinc2;
_T146:
	__asm        mov    eax, nEndX;
	__asm        sub    eax, nStartX;
	__asm        push   eax;
	__asm        call   abs;
	__asm        add    esp, 4;
	__asm        mov    deltax, eax;
// LINE 1509:
	__asm        mov    eax, nEndY;
	__asm        sub    eax, nStartY;
	__asm        push   eax;
	__asm        call   abs;
	__asm        add    esp, 4;
	__asm        mov    deltay, eax;
// LINE 1511:
	__asm        mov    eax, deltax;
	__asm        cmp    deltay, eax;
	__asm        jg     _T1ae;
// LINE 1513:
	__asm        mov    eax, deltax;
	__asm        inc    eax;
	__asm        mov    numpixels, eax;
// LINE 1514:
	__asm        mov    eax, deltay;
	__asm        add    eax, eax;
	__asm        sub    eax, deltax;
	__asm        mov    d, eax;
// LINE 1515:
	__asm        mov    eax, deltay;
	__asm        add    eax, eax;
	__asm        mov    dinc1, eax;
// LINE 1516:
	__asm        mov    eax, deltay;
	__asm        sub    eax, deltax;
	__asm        add    eax, eax;
	__asm        mov    dinc2, eax;
// LINE 1517:
	xinc1 = 0x1;
// LINE 1518:
	yinc1 = 0x0;
// LINE 1520:
	__asm        jmp    _T1e1;
// LINE 1522:
_T1ae:
	__asm        mov    eax, deltay;
	__asm        inc    eax;
	__asm        mov    numpixels, eax;
// LINE 1523:
	__asm        mov    eax, deltax;
	__asm        add    eax, eax;
	__asm        sub    eax, deltay;
	__asm        mov    d, eax;
// LINE 1524:
	__asm        mov    eax, deltax;
	__asm        add    eax, eax;
	__asm        mov    dinc1, eax;
// LINE 1525:
	__asm        mov    eax, deltax;
	__asm        sub    eax, deltay;
	__asm        add    eax, eax;
	__asm        mov    dinc2, eax;
// LINE 1526:
	xinc1 = 0x0;
// LINE 1527:
	yinc1 = 0x1;
// LINE 1531:
_T1e1:
	__asm        mov    eax, nStartX;
	__asm        cmp    nEndX, eax;
	__asm        jge    _T201;
// LINE 1533:
	__asm        mov    eax, xinc1;
	__asm        neg    eax;
	__asm        mov    xinc1, eax;
// LINE 1534:
	xinc2 = 0xffffffff;
// LINE 1536:
	__asm        jmp    _T208;
// LINE 1537:
_T201:
	xinc2 = 0x1;
// LINE 1539:
_T208:
	__asm        mov    eax, nStartY;
	__asm        cmp    nEndY, eax;
	__asm        jge    _T228;
// LINE 1541:
	__asm        mov    eax, yinc1;
	__asm        neg    eax;
	__asm        mov    yinc1, eax;
// LINE 1542:
	yinc2 = 0xffffffff;
// LINE 1544:
	__asm        jmp    _T22f;
// LINE 1545:
_T228:
	yinc2 = 0x1;
// LINE 1548:
_T22f:
	x = nStartX;
// LINE 1549:
	y = nStartY;
// LINE 1553:
	__asm        cmp    nThickness, 1;
	__asm        jne    _T2b9;
// LINE 1555:
	__asm        mov    i, 1;
	__asm        jmp    _T254;
_T251:
	i++;
_T254:
	__asm        mov    eax, i;
	__asm        cmp    numpixels, eax;
	__asm        jl     _T2b4;
// LINE 1557:
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x44];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        imul   ecx, y;
	__asm        mov    edx, this;
	__asm        add    ecx, [edx+0x10];
	__asm        mov    edx, x;
	__asm        mov    [ecx+edx], al;
// LINE 1559:
	__asm        cmp    d, 0;
	__asm        jge    _T29d;
// LINE 1561:
	d += dinc1;
// LINE 1562:
	x += xinc1;
// LINE 1563:
	y += yinc1;
// LINE 1565:
	__asm        jmp    _T2af;
// LINE 1567:
_T29d:
	d += dinc2;
// LINE 1568:
	x += xinc2;
// LINE 1569:
	y += yinc2;
// LINE 1571:
_T2af:
	__asm        jmp    _T251;
// LINE 1573:
_T2b4:
	__asm        jmp    _T3a5;
// LINE 1575:
_T2b9:
	__asm        mov    i, 1;
	__asm        jmp    _T2c8;
_T2c5:
	i++;
_T2c8:
	__asm        mov    eax, i;
	__asm        cmp    numpixels, eax;
	__asm        jl     _T3a5;
// LINE 1581:
	__asm        cmp    xinc2, 0xFFFFFFFF;
	__asm        jne    _T2fd;
// LINE 1582:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, y;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        add    eax, x;
	__asm        sub    eax, nThickness;
	__asm        inc    eax;
	__asm        mov    address, eax;
// LINE 1583:
	__asm        jmp    _T313;
// LINE 1584:
_T2fd:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, y;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        add    eax, x;
	__asm        mov    address, eax;
// LINE 1586:
_T313:
	j = nThickness;
// LINE 1587:
_T319:
	__asm        mov    eax, j;
	__asm        mov    [ebp-0x58], eax;
	__asm        dec    j;
	__asm        cmp    dword ptr [ebp-0x58], 0;
	__asm        je     _T36d;
// LINE 1589:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1590:
	__asm        cmp    yinc2, 0xFFFFFFFF;
	__asm        jne    _T35f;
// LINE 1591:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x14];
	__asm        neg    eax;
	__asm        sub    address, eax;
// LINE 1592:
	__asm        jmp    _T368;
// LINE 1593:
_T35f:
	address += this->mStride;
// LINE 1594:
_T368:
	__asm        jmp    _T319;
// LINE 1596:
_T36d:
	__asm        cmp    d, 0;
	__asm        jge    _T38e;
// LINE 1598:
	d += dinc1;
// LINE 1599:
	x += xinc1;
// LINE 1600:
	y += yinc1;
// LINE 1602:
	__asm        jmp    _T3a0;
// LINE 1604:
_T38e:
	d += dinc2;
// LINE 1605:
	x += xinc2;
// LINE 1606:
	y += yinc2;
// LINE 1608:
_T3a0:
	__asm        jmp    _T2c5;
// LINE 1612:
// Block end:
_T3a5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 1613:
	__asm        xor    eax, eax;
	__asm        jmp    _T3b7;
// LINE 1614:
_T3b7:
}

// FUNCTION: COPTER_D 0x00470c22
unsigned long CBackBuffer::DrawLineClipped(long nStartX, long nStartY, long nEndX, long nEndY, long nThickness) {
	/*bp-0x4*/   char * address;
	/*bp-0x8*/   int32_t bufferHeight;
	/*bp-0xc*/   int32_t length;
	/*bp-0x10*/  int32_t temp;
	/*bp-0x14*/  int32_t i;
	/*bp-0x18*/  int32_t j;
	/*bp-0x1c*/  int32_t bufferWidth;

// LINE 1626:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax];
// LINE 1633:
	__asm        jmp    _T27;
_T27:
	bufferWidth = this->mWidth;
// LINE 1634:
	__asm        jmp    _T38;
_T38:
	bufferHeight = this->mHeight;
// LINE 1637:
	__asm        mov    dword ptr [ebp-0x7C], 0;
	__asm        mov    dword ptr [ebp-0x80], 0;
	__asm        mov    dword ptr [ebp-0x94], 0;
	__asm        cmp    nStartX, 0;
	__asm        jge    _T6d;

	__asm        add    dword ptr [ebp-0x94], 4;
_T6d:
	__asm        mov    eax, bufferWidth;
	__asm        dec    eax;
	__asm        cmp    eax, nStartX;
	__asm        jge    _T81;

	__asm        add    dword ptr [ebp-0x94], 8;
_T81:
	__asm        cmp    nStartY, 0;
	__asm        jge    _T91;

	__asm        inc    dword ptr [ebp-0x94];
_T91:
	__asm        mov    eax, bufferHeight;
	__asm        dec    eax;
	__asm        cmp    eax, nStartY;
	__asm        jge    _Ta5;

	__asm        add    dword ptr [ebp-0x94], 2;
_Ta5:
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _Tb6;
_Tb6:
	__asm        mov    dword ptr [ebp-0x98], 0;
	__asm        cmp    nEndX, 0;
	__asm        jge    _Td1;

	__asm        add    dword ptr [ebp-0x98], 4;
_Td1:
	__asm        mov    eax, bufferWidth;
	__asm        dec    eax;
	__asm        cmp    eax, nEndX;
	__asm        jge    _Te5;

	__asm        add    dword ptr [ebp-0x98], 8;
_Te5:
	__asm        cmp    nEndY, 0;
	__asm        jge    _Tf5;

	__asm        inc    dword ptr [ebp-0x98];
_Tf5:
	__asm        mov    eax, bufferHeight;
	__asm        dec    eax;
	__asm        cmp    eax, nEndY;
	__asm        jge    _T109;

	__asm        add    dword ptr [ebp-0x98], 2;
_T109:
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T11a;
_T11a:
	__asm        mov    eax, [ebp-0x90];
	__asm        or     eax, [ebp-0x88];
	__asm        jne    _T13f;

	__asm        mov    dword ptr [ebp-0x7C], 1;
	__asm        mov    dword ptr [ebp-0x80], 1;
	__asm        jmp    _T36c;
_T13f:
	__asm        mov    eax, [ebp-0x90];
	__asm        test   [ebp-0x88], eax;
	__asm        je     _T15d;

	__asm        mov    dword ptr [ebp-0x80], 1;
	__asm        jmp    _T36c;
_T15d:
	__asm        cmp    dword ptr [ebp-0x88], 0;
	__asm        je     _T178;

	__asm        mov    eax, [ebp-0x88];
	__asm        mov    [ebp-0x78], eax;
	__asm        jmp    _T181;
_T178:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0x78], eax;
_T181:
	__asm        test   byte ptr [ebp-0x78], 1;
	__asm        je     _T1bc;

	__asm        mov    eax, nEndX;
	__asm        sub    eax, nStartX;
	__asm        xor    ecx, ecx;
	__asm        sub    ecx, nStartY;
	__asm        imul   eax, ecx;
	__asm        mov    ecx, nEndY;
	__asm        sub    ecx, nStartY;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, nStartX;
	__asm        add    ecx, eax;
	__asm        mov    [ebp-0x84], ecx;
	__asm        mov    dword ptr [ebp-0x8C], 0;
	__asm        jmp    _T26c;
_T1bc:
	__asm        test   byte ptr [ebp-0x78], 2;
	__asm        je     _T1f9;

	__asm        mov    eax, bufferHeight;
	__asm        dec    eax;
	__asm        sub    eax, nStartY;
	__asm        mov    ecx, nEndX;
	__asm        sub    ecx, nStartX;
	__asm        imul   eax, ecx;
	__asm        mov    ecx, nEndY;
	__asm        sub    ecx, nStartY;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, nStartX;
	__asm        add    ecx, eax;
	__asm        mov    [ebp-0x84], ecx;
	__asm        mov    eax, bufferHeight;
	__asm        dec    eax;
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _T26c;
_T1f9:
	__asm        test   byte ptr [ebp-0x78], 8;
	__asm        je     _T236;

	__asm        mov    eax, bufferWidth;
	__asm        dec    eax;
	__asm        sub    eax, nStartX;
	__asm        mov    ecx, nEndY;
	__asm        sub    ecx, nStartY;
	__asm        imul   eax, ecx;
	__asm        mov    ecx, nEndX;
	__asm        sub    ecx, nStartX;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, nStartY;
	__asm        add    ecx, eax;
	__asm        mov    [ebp-0x8C], ecx;
	__asm        mov    eax, bufferWidth;
	__asm        dec    eax;
	__asm        mov    [ebp-0x84], eax;
	__asm        jmp    _T26c;
_T236:
	__asm        test   byte ptr [ebp-0x78], 4;
	__asm        je     _T26c;

	__asm        mov    eax, nEndY;
	__asm        sub    eax, nStartY;
	__asm        xor    ecx, ecx;
	__asm        sub    ecx, nStartX;
	__asm        imul   eax, ecx;
	__asm        mov    ecx, nEndX;
	__asm        sub    ecx, nStartX;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    ecx, nStartY;
	__asm        add    ecx, eax;
	__asm        mov    [ebp-0x8C], ecx;
	__asm        mov    dword ptr [ebp-0x84], 0;
_T26c:
	__asm        mov    eax, [ebp-0x88];
	__asm        cmp    [ebp-0x78], eax;
	__asm        jne    _T2f6;

	__asm        mov    eax, [ebp-0x84];
	__asm        mov    nStartX, eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    nStartY, eax;
	__asm        mov    dword ptr [ebp-0x9C], 0;
	__asm        cmp    nStartX, 0;
	__asm        jge    _T2a8;

	__asm        add    dword ptr [ebp-0x9C], 4;
_T2a8:
	__asm        mov    eax, bufferWidth;
	__asm        dec    eax;
	__asm        cmp    eax, nStartX;
	__asm        jge    _T2bc;

	__asm        add    dword ptr [ebp-0x9C], 8;
_T2bc:
	__asm        cmp    nStartY, 0;
	__asm        jge    _T2cc;

	__asm        inc    dword ptr [ebp-0x9C];
_T2cc:
	__asm        mov    eax, bufferHeight;
	__asm        dec    eax;
	__asm        cmp    eax, nStartY;
	__asm        jge    _T2e0;

	__asm        add    dword ptr [ebp-0x9C], 2;
_T2e0:
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _T2f1;
_T2f1:
	__asm        jmp    _T36c;
_T2f6:
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    nEndX, eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    nEndY, eax;
	__asm        mov    dword ptr [ebp-0xA0], 0;
	__asm        cmp    nEndX, 0;
	__asm        jge    _T323;

	__asm        add    dword ptr [ebp-0xA0], 4;
_T323:
	__asm        mov    eax, bufferWidth;
	__asm        dec    eax;
	__asm        cmp    eax, nEndX;
	__asm        jge    _T337;

	__asm        add    dword ptr [ebp-0xA0], 8;
_T337:
	__asm        cmp    nEndY, 0;
	__asm        jge    _T347;

	__asm        inc    dword ptr [ebp-0xA0];
_T347:
	__asm        mov    eax, bufferHeight;
	__asm        dec    eax;
	__asm        cmp    eax, nEndY;
	__asm        jge    _T35b;

	__asm        add    dword ptr [ebp-0xA0], 2;
_T35b:
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T36c;
_T36c:
	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        je     _T11a;

	__asm        jmp    _T37b;
_T37b:
	__asm        cmp    dword ptr [ebp-0x7C], 1;
	__asm        jne    _T926;
// LINE 1640:
	__asm        mov    eax, nStartY;
	__asm        cmp    nEndY, eax;
	__asm        jne    _T41e;
// LINE 1642:
	__asm        mov    eax, nStartX;
	__asm        cmp    nEndX, eax;
	__asm        jg     _T3af;
// LINE 1644:
	__asm        mov    eax, nStartX;
	__asm        mov    temp, eax;
	__asm        mov    eax, nEndX;
	__asm        mov    nStartX, eax;
	__asm        mov    eax, temp;
	__asm        mov    nEndX, eax;
// LINE 1647:
_T3af:
	__asm        mov    eax, nEndX;
	__asm        sub    eax, nStartX;
	__asm        inc    eax;
	__asm        mov    length, eax;
// LINE 1649:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, nStartY;
	__asm        add    eax, nStartX;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    address, eax;
// LINE 1650:
	i = nThickness;
// LINE 1651:
_T3db:
	__asm        mov    eax, i;
	__asm        mov    [ebp-0x68], eax;
	__asm        dec    i;
	__asm        cmp    dword ptr [ebp-0x68], 0;
	__asm        je     _T419;
// LINE 1653:
	__asm        mov    eax, length;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1654:
	address += this->mStride;
// LINE 1655:
	__asm        jmp    _T3db;
// LINE 1659:
_T419:
	__asm        jmp    _T921;
_T41e:
	__asm        mov    eax, nStartX;
	__asm        cmp    nEndX, eax;
	__asm        jne    _T4b1;
// LINE 1661:
	__asm        mov    eax, nStartY;
	__asm        cmp    nEndY, eax;
	__asm        jg     _T448;
// LINE 1663:
	__asm        mov    eax, nStartY;
	__asm        mov    temp, eax;
	__asm        mov    eax, nEndY;
	__asm        mov    nStartY, eax;
	__asm        mov    eax, temp;
	__asm        mov    nEndY, eax;
// LINE 1665:
_T448:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, nStartY;
	__asm        add    eax, nStartX;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    address, eax;
// LINE 1666:
	__asm        mov    eax, nEndY;
	__asm        sub    eax, nStartY;
	__asm        inc    eax;
	__asm        mov    i, eax;
// LINE 1667:
_T46e:
	__asm        mov    eax, i;
	__asm        mov    [ebp-0x6C], eax;
	__asm        dec    i;
	__asm        cmp    dword ptr [ebp-0x6C], 0;
	__asm        je     _T4ac;
// LINE 1669:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1670:
	address += this->mStride;
// LINE 1671:
	__asm        jmp    _T46e;
// LINE 1674:
_T4ac:
	__asm        jmp    _T921;
// LINE 1681:
// Block start:
	/*bp-0x20*/  int32_t d;
	/*bp-0x24*/  int32_t xinc1;
	/*bp-0x28*/  int32_t xinc2;
	/*bp-0x2c*/  int32_t x;
	/*bp-0x30*/  int32_t y;
	/*bp-0x34*/  int32_t numpixels;
	/*bp-0x38*/  int32_t deltax;
	/*bp-0x3c*/  int32_t deltay;
	/*bp-0x40*/  int32_t yinc1;
	/*bp-0x44*/  int32_t dinc1;
	/*bp-0x48*/  int32_t yinc2;
	/*bp-0x4c*/  int32_t dinc2;
_T4b1:
	__asm        mov    eax, nEndX;
	__asm        sub    eax, nStartX;
	__asm        push   eax;
	__asm        call   abs;
	__asm        add    esp, 4;
	__asm        mov    deltax, eax;
// LINE 1682:
	__asm        mov    eax, nEndY;
	__asm        sub    eax, nStartY;
	__asm        push   eax;
	__asm        call   abs;
	__asm        add    esp, 4;
	__asm        mov    deltay, eax;
// LINE 1684:
	__asm        mov    eax, deltax;
	__asm        cmp    deltay, eax;
	__asm        jg     _T519;
// LINE 1686:
	__asm        mov    eax, deltax;
	__asm        inc    eax;
	__asm        mov    numpixels, eax;
// LINE 1687:
	__asm        mov    eax, deltay;
	__asm        add    eax, eax;
	__asm        sub    eax, deltax;
	__asm        mov    d, eax;
// LINE 1688:
	__asm        mov    eax, deltay;
	__asm        add    eax, eax;
	__asm        mov    dinc1, eax;
// LINE 1689:
	__asm        mov    eax, deltay;
	__asm        sub    eax, deltax;
	__asm        add    eax, eax;
	__asm        mov    dinc2, eax;
// LINE 1690:
	xinc1 = 0x1;
// LINE 1691:
	yinc1 = 0x0;
// LINE 1693:
	__asm        jmp    _T54c;
// LINE 1695:
_T519:
	__asm        mov    eax, deltay;
	__asm        inc    eax;
	__asm        mov    numpixels, eax;
// LINE 1696:
	__asm        mov    eax, deltax;
	__asm        add    eax, eax;
	__asm        sub    eax, deltay;
	__asm        mov    d, eax;
// LINE 1697:
	__asm        mov    eax, deltax;
	__asm        add    eax, eax;
	__asm        mov    dinc1, eax;
// LINE 1698:
	__asm        mov    eax, deltax;
	__asm        sub    eax, deltay;
	__asm        add    eax, eax;
	__asm        mov    dinc2, eax;
// LINE 1699:
	xinc1 = 0x0;
// LINE 1700:
	yinc1 = 0x1;
// LINE 1704:
_T54c:
	__asm        mov    eax, nStartX;
	__asm        cmp    nEndX, eax;
	__asm        jge    _T56c;
// LINE 1706:
	__asm        mov    eax, xinc1;
	__asm        neg    eax;
	__asm        mov    xinc1, eax;
// LINE 1707:
	xinc2 = 0xffffffff;
// LINE 1709:
	__asm        jmp    _T573;
// LINE 1710:
_T56c:
	xinc2 = 0x1;
// LINE 1712:
_T573:
	__asm        mov    eax, nStartY;
	__asm        cmp    nEndY, eax;
	__asm        jge    _T593;
// LINE 1714:
	__asm        mov    eax, yinc1;
	__asm        neg    eax;
	__asm        mov    yinc1, eax;
// LINE 1715:
	yinc2 = 0xffffffff;
// LINE 1717:
	__asm        jmp    _T59a;
// LINE 1718:
_T593:
	yinc2 = 0x1;
// LINE 1721:
_T59a:
	x = nStartX;
// LINE 1722:
	y = nStartY;
// LINE 1726:
	__asm        cmp    nThickness, 1;
	__asm        jne    _T62d;
// LINE 1728:
	__asm        mov    i, 1;
	__asm        jmp    _T5bf;
_T5bc:
	i++;
_T5bf:
	__asm        mov    eax, i;
	__asm        cmp    numpixels, eax;
	__asm        jl     _T628;
// LINE 1730:
	__asm        mov    eax, this;
	__asm        mov    al, [eax+0x44];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        imul   ecx, y;
	__asm        mov    edx, this;
	__asm        add    ecx, [edx+0x10];
	__asm        mov    edx, x;
	__asm        mov    [ecx+edx], al;
// LINE 1732:
	__asm        cmp    d, 0;
	__asm        jge    _T611;
// LINE 1734:
	d += dinc1;
// LINE 1735:
	x += xinc1;
// LINE 1736:
	y += yinc1;
// LINE 1738:
	__asm        jmp    _T623;
// LINE 1740:
_T611:
	d += dinc2;
// LINE 1741:
	x += xinc2;
// LINE 1742:
	y += yinc2;
// LINE 1744:
_T623:
	__asm        jmp    _T5bc;
// LINE 1746:
_T628:
	__asm        jmp    _T921;
// LINE 1761:
// Block start:
	/*bp-0x50*/  int32_t minSafeX;
	/*bp-0x54*/  int32_t maxSafeY;
	/*bp-0x58*/  int32_t maxSafeX;
	/*bp-0x5c*/  int32_t minSafeY;
_T62d:
	__asm        mov    eax, nThickness;
	__asm        dec    eax;
	__asm        mov    minSafeX, eax;
// LINE 1762:
	__asm        mov    eax, nThickness;
	__asm        dec    eax;
	__asm        mov    minSafeY, eax;
// LINE 1763:
	__asm        mov    eax, bufferWidth;
	__asm        sub    eax, nThickness;
	__asm        mov    maxSafeX, eax;
// LINE 1764:
	__asm        mov    eax, bufferHeight;
	__asm        sub    eax, nThickness;
	__asm        mov    maxSafeY, eax;
// LINE 1768:
_T64d:
	__asm        cmp    numpixels, 0;
	__asm        je     _T770;

	__asm        mov    eax, x;
	__asm        cmp    minSafeX, eax;
	__asm        jg     _T770;

	__asm        mov    eax, x;
	__asm        cmp    maxSafeX, eax;
	__asm        jl     _T770;

	__asm        mov    eax, y;
	__asm        cmp    minSafeY, eax;
	__asm        jg     _T770;

	__asm        mov    eax, y;
	__asm        cmp    maxSafeY, eax;
	__asm        jl     _T770;
// LINE 1771:
	__asm        cmp    xinc2, 0xFFFFFFFF;
	__asm        jne    _T6b6;
// LINE 1772:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, y;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        add    eax, x;
	__asm        sub    eax, nThickness;
	__asm        inc    eax;
	__asm        mov    address, eax;
// LINE 1773:
	__asm        jmp    _T6d2;
// LINE 1774:
_T6b6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, y;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        add    eax, x;
	__asm        mov    address, eax;
// LINE 1776:
_T6d2:
	j = nThickness;
// LINE 1777:
_T6d8:
	__asm        mov    eax, j;
	__asm        mov    [ebp-0x70], eax;
	__asm        dec    j;
	__asm        cmp    dword ptr [ebp-0x70], 0;
	__asm        je     _T735;
// LINE 1779:
	__asm        mov    eax, nThickness;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1780:
	__asm        cmp    yinc2, 0xFFFFFFFF;
	__asm        jne    _T724;
// LINE 1781:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x14];
	__asm        neg    eax;
	__asm        sub    address, eax;
// LINE 1782:
	__asm        jmp    _T730;
// LINE 1783:
_T724:
	address += this->mStride;
// LINE 1784:
_T730:
	__asm        jmp    _T6d8;
// LINE 1786:
_T735:
	__asm        cmp    d, 0;
	__asm        jge    _T756;
// LINE 1788:
	d += dinc1;
// LINE 1789:
	x += xinc1;
// LINE 1790:
	y += yinc1;
// LINE 1792:
	__asm        jmp    _T768;
// LINE 1794:
_T756:
	d += dinc2;
// LINE 1795:
	x += xinc2;
// LINE 1796:
	y += yinc2;
// LINE 1799:
_T768:
	numpixels--;
// LINE 1800:
	__asm        jmp    _T64d;
// LINE 1804:
_T770:
	__asm        cmp    numpixels, 0;
	__asm        je     _T921;
// LINE 1807:
// Block start:
	/*bp-0x60*/  char * bufferEnd;
	__asm        cmp    xinc2, 0xFFFFFFFF;
	__asm        jne    _T7b5;
// LINE 1809:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, y;
	__asm        mov    ecx, x;
	__asm        sub    ecx, nThickness;
	__asm        inc    ecx;
	__asm        test   ecx, ecx;
	__asm        jg     _T7a2;

	__asm        xor    ecx, ecx;
_T7a2:
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    address, eax;
// LINE 1810:
	__asm        jmp    _T7e1;
// LINE 1812:
_T7b5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, y;
	__asm        mov    ecx, bufferWidth;
	__asm        dec    ecx;
	__asm        mov    edx, x;
	__asm        cmp    ecx, edx;
	__asm        jl     _T7d3;

	__asm        mov    ecx, edx;
_T7d3:
	__asm        add    eax, ecx;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    address, eax;
// LINE 1814:
_T7e1:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x14];
	__asm        imul   eax, bufferHeight;
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x10];
	__asm        mov    bufferEnd, eax;
// LINE 1816:
	j = nThickness;
// LINE 1818:
_T800:
	__asm        mov    eax, j;
	__asm        mov    [ebp-0x74], eax;
	__asm        dec    j;
	__asm        cmp    dword ptr [ebp-0x74], 0;
	__asm        je     _T8e6;
// LINE 1822:
	__asm        mov    eax, this;
	__asm        mov    ecx, address;
	__asm        cmp    [eax+0x10], ecx;
	__asm        ja     _T8b6;

	__asm        mov    eax, bufferEnd;
	__asm        cmp    address, eax;
	__asm        jae    _T8b6;
// LINE 1825:
// Block start:
	/*bp-0x64*/  int32_t nPixels;
	__asm        cmp    xinc2, 0xFFFFFFFF;
	__asm        jne    _T879;
// LINE 1827:
	__asm        mov    eax, nThickness;
	__asm        dec    eax;
	__asm        cmp    eax, x;
	__asm        jg     _T853;

	__asm        mov    eax, nThickness;
	__asm        mov    nPixels, eax;
	__asm        jmp    _T85a;
_T853:
	__asm        mov    eax, x;
	__asm        inc    eax;
	__asm        mov    nPixels, eax;
// LINE 1828:
_T85a:
	__asm        mov    eax, nPixels;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1830:
	__asm        jmp    _T8b6;
// LINE 1832:
_T879:
	__asm        mov    eax, bufferWidth;
	__asm        sub    eax, nThickness;
	__asm        cmp    eax, x;
	__asm        jge    _T896;

	__asm        mov    eax, bufferWidth;
	__asm        sub    eax, x;
	__asm        mov    nPixels, eax;
	__asm        jmp    _T89c;
_T896:
	nPixels = nThickness;
// LINE 1833:
_T89c:
	__asm        mov    eax, nPixels;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, address;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 1837:
// Block end:
_T8b6:
	__asm        cmp    yinc2, 0xFFFFFFFF;
	__asm        jne    _T8d5;
// LINE 1838:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x14];
	__asm        neg    eax;
	__asm        sub    address, eax;
// LINE 1839:
	__asm        jmp    _T8e1;
// LINE 1840:
_T8d5:
	address += this->mStride;
// LINE 1841:
_T8e1:
	__asm        jmp    _T800;
// LINE 1843:
_T8e6:
	__asm        cmp    d, 0;
	__asm        jge    _T907;
// LINE 1845:
	d += dinc1;
// LINE 1846:
	x += xinc1;
// LINE 1847:
	y += yinc1;
// LINE 1849:
	__asm        jmp    _T919;
// LINE 1851:
_T907:
	d += dinc2;
// LINE 1852:
	x += xinc2;
// LINE 1853:
	y += yinc2;
// LINE 1856:
_T919:
	numpixels--;
// LINE 1857:
// Block end:
	__asm        jmp    _T770;
// LINE 1861:
// Block end:
// Block end:
_T921:
	__asm        jmp    _T92d;
// LINE 1864:
_T926:
	i = 0x1;
// LINE 1867:
_T92d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 1868:
	__asm        xor    eax, eax;
	__asm        jmp    _T945;
// LINE 1869:
_T945:
}



// Contribution: 1:00070570-00070587 Module: 39, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:00070590-000705d0 Module: 39, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 2:000017e0-00001807 Module: 39, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for IBackBuffer @ 0x005907e0
//   00: _purecall @ 0x0056cfa0
//   01: _purecall @ 0x0056cfa0
//   02: IFlatImage::SetTransparentColor @ 0x00471570
//   03: IFlatImage::Compose @ 0x0048f3b1
//   04: IFlatImage::StretchCompose @ 0x0048f174
//   05: IFlatImage::StretchCompose @ 0x0048f32e
//   06: IFlatImage::FillRect @ 0x0048f56b
//   07: IBackBuffer::Swap @ 0x00471590
//   08: _purecall @ 0x0056cfa0
//   09: _purecall @ 0x0056cfa0
//   10 entries



// Contribution: 2:00001808-0000186b Module: 39, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for CBackBuffer @ 0x00590808
//   00: CBackBuffer::Lock @ 0x0047006f
//   01: CBackBuffer::Unlock @ 0x00470149
//   02: CBackBuffer::SetTransparentColor @ 0x0046ffe6
//   03: CBackBuffer::Compose @ 0x0046f948
//   04: CBackBuffer::StretchCompose @ 0x0046fe13
//   05: IFlatImage::StretchCompose @ 0x0048f32e
//   06: IFlatImage::FillRect @ 0x0048f56b
//   07: CBackBuffer::Swap @ 0x0046f7bb
//   08: CBackBuffer::SwapRect @ 0x0046f828
//   09: CBackBuffer::StretchRect @ 0x0046ffcc
//   10: CBackBuffer::InitializeMemberVariables @ 0x0046eb58
//   11: CBackBuffer::Compose @ 0x0046fd33
//   12: CBackBuffer::StretchCompose @ 0x0046fd82
//   13: CBackBuffer::Duplicate @ 0x0046fe7c
//   14: CBackBuffer::ComposeNoClip @ 0x0046fce4
//   15: CBackBuffer::ComposeNoClip @ 0x0046fbb1
//   16: CBackBuffer::DrawLine @ 0x0046f5c6
//   17: CBackBuffer::FillRect @ 0x004702f1
//   18: CBackBuffer::DrawBufferText @ 0x0046f403
//   19: CBackBuffer::DrawBufferText @ 0x0046f1bd
//   20: CBackBuffer::DrawLineUnclipped @ 0x00470864
//   21: CBackBuffer::DrawLineClipped @ 0x00470c22
//   22: CBackBuffer::DrawRectangleOutline @ 0x004706e4
//   23: CBackBuffer::DrawRectangleOutlineUnclipped @ 0x004707a4
//   24: CBackBuffer::GetDDSurface @ 0x004704a7
//   25 entries



// Contribution: 3:00002498-000027b5 Module: 39, 4 byte alignment, initialized_data, read, write, 
