// Module: palhelp.obj
// Source: C:\Copter\source\sparkal\palhelp.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class SparkalPalette (forward reference);
// VTABLE: COPTER_D 0x005910f8
class SparkalPalette{ // packed(0x10 bytes) TI: 0x47c7
public:
	/*+0x4*/   /*packed*/ struct SparkalColor *pColors;
	/*+0x8*/   long lColors;
	/*+0xc*/   int32_t bOwnColors;
	void SparkalPalette(/*packed*/ struct SparkalColor*, int32_t, unsigned long);
	void SparkalPalette();
	virtual void ~SparkalPalette(); // vtable+0x0
	virtual void GetRGBValue(int32_t, /*packed*/ struct SparkalColor&); // vtable+0x4
	virtual void GetNearestIndex(/*packed*/ struct SparkalColor&, int32_t&); // vtable+0x8
	virtual void FadeToWhite(long); // vtable+0xc
	virtual void FadeToBlack(long); // vtable+0x10
	virtual void FadeToPalette(/*packed*/ struct SparkalColor, long, long); // vtable+0x14
	// calltype: NearC
	static void FadeToPalette(/*packed*/ struct SparkalColor, /*packed*/ struct SparkalColor*, long, long);
	void FadeToRGB(/*packed*/ struct SparkalColor&, long);
	// calltype: NearC
	static void SetSystemPaletteEntriesToRGB(/*packed*/ struct SparkalColor&);
	virtual void ImplementNewPalette(/*packed*/ struct SparkalColor*); // vtable+0x18
};

// Type: /*packed*/ struct SparkalColor (forward reference);
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: int32_t;

// Type: unsigned long;

// Type: void;

// Type: long;

// Type: /*packed*/ class MTimer;
class MTimer{ // packed(0x10 bytes) TI: 0x1968
	enum TimerResolution {
		nTimerResolutionMicroseconds = 0,
		nTimerResolutionMilliseconds = 1,
		nTimerResolutionSeconds = 2,
	};
public:
	void MTimer(enum MTimer::TimerResolution);
	void ~MTimer();
	void SetResolution(enum MTimer::TimerResolution);
	enum MTimer::TimerResolution GetResolution();
	void Start();
	void Stop();
	void Reset();
	void Restart();
	unsigned long GetElapsedTime();
	int32_t IsTimerRunning();
	unsigned long GetTickCount();
protected:
	/*+0x0*/   enum MTimer::TimerResolution nTimerResolution;
	/*+0x4*/   unsigned long lStartTime;
	/*+0x8*/   unsigned long lTotalElapsedTime;
	unsigned long GetWindowsTimerFrequency();
	/*+0xc*/   unsigned long lFrequency;
};

// Type: /*packed*/ struct tagPALETTEENTRY (forward reference);
struct tagPALETTEENTRY{ // packed(0x4 bytes) TI: 0x1be6
	/*+0x0*/   unsigned char peRed; // 0x1 bytes
	/*+0x1*/   unsigned char peGreen; // 0x1 bytes
	/*+0x2*/   unsigned char peBlue; // 0x1 bytes
	/*+0x3*/   unsigned char peFlags; // 0x1 bytes
};

// Type: /*packed*/ struct SparkalColor;
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: /*packed*/ struct SparkalPalette::FadeToPalette::TempPalette (forward reference);
struct SparkalPalette::FadeToPalette::TempPalette{ // packed(0x400 bytes) TI: 0x47cb
	/*+0x0*/   /*packed*/ struct tagPALETTEENTRY palEntries[256]; // 0x400 bytes
};

// Type: /*packed*/ class CopterSparkalPalette (forward reference);
// VTABLE: COPTER_D 0x00591118
class CopterSparkalPalette : public SparkalPalette
{ // packed(0x10 bytes) TI: 0x47ce
public:
	void CopterSparkalPalette(/*packed*/ struct SparkalColor*, int32_t);
	void CopterSparkalPalette();
	int32_t GetNextDarkerColorIndex(int32_t);
	int32_t GetNextLighterColorIndex(int32_t);
	virtual void ~CopterSparkalPalette() /* override */; // synthetic
};

// Type: void * __ptr32;

// Type: /*packed*/ struct ClearWindowsSystemPalette::__unnamed;
struct ClearWindowsSystemPalette::__unnamed{ // packed(0x404 bytes) TI: 0x2314
	/*+0x0*/   unsigned short Version; // 0x2 bytes
	/*+0x2*/   unsigned short NumberOfEntries; // 0x2 bytes
	/*+0x4*/   /*packed*/ struct tagPALETTEENTRY aEntries[256]; // 0x400 bytes
};

// Type: uint32_t;

// Type: /*packed*/ class SparkalPalette;
// VTABLE: COPTER_D 0x005910f8
class SparkalPalette{ // packed(0x10 bytes) TI: 0x47c7
public:
	/*+0x4*/   /*packed*/ struct SparkalColor *pColors;
	/*+0x8*/   long lColors;
	/*+0xc*/   int32_t bOwnColors;
	void SparkalPalette(/*packed*/ struct SparkalColor*, int32_t, unsigned long);
	void SparkalPalette();
	virtual void ~SparkalPalette(); // vtable+0x0
	virtual void GetRGBValue(int32_t, /*packed*/ struct SparkalColor&); // vtable+0x4
	virtual void GetNearestIndex(/*packed*/ struct SparkalColor&, int32_t&); // vtable+0x8
	virtual void FadeToWhite(long); // vtable+0xc
	virtual void FadeToBlack(long); // vtable+0x10
	virtual void FadeToPalette(/*packed*/ struct SparkalColor, long, long); // vtable+0x14
	// calltype: NearC
	static void FadeToPalette(/*packed*/ struct SparkalColor, /*packed*/ struct SparkalColor*, long, long);
	void FadeToRGB(/*packed*/ struct SparkalColor&, long);
	// calltype: NearC
	static void SetSystemPaletteEntriesToRGB(/*packed*/ struct SparkalColor&);
	virtual void ImplementNewPalette(/*packed*/ struct SparkalColor*); // vtable+0x18
};



// Contribution: 1:000953b0-00096b4b Module: 18, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004963b0
void SparkalPalette::SparkalPalette(/*packed*/ struct SparkalColor *pNewColors, int32_t bNewOwnColors, unsigned long lNewColors) {

	this->pColors = pNewColors;
	this->lColors = lNewColors;
	this->bOwnColors = bNewOwnColors;
	this-><vftable> = 0x5910f8;
// LINE 31:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004963ef
void SparkalPalette::SparkalPalette() {

	this->pColors = 0x0;
	this->lColors = 0x0;
	this->bOwnColors = 0x0;
	this-><vftable> = 0x5910f8;
// LINE 41:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0049642f
void SparkalPalette::~SparkalPalette() {

	this-><vftable> = 0x5910f8;
// LINE 48:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        je     _T4a;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T4a;
// LINE 49:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-4], eax;
	__asm        mov    eax, [ebp-4];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 50:
_T4a:
	return;
}

// FUNCTION: COPTER_D 0x00496483
void SparkalPalette::GetNearestIndex(/*packed*/ struct SparkalColor& colorValue, int32_t& nIndex) {
	/*bp-0x4*/   unsigned long lClosestDistance;
	/*bp-0x8*/   unsigned long lCurrentDistance;
	/*bp-0xc*/   int32_t i;
	/*bp-0x10*/  int32_t nCurrentBestMatch;

// LINE 67:
	lClosestDistance = 0xffffffff;
// LINE 70:
_FOR_25:
	nCurrentBestMatch = 0x0;
	i = nCurrentBestMatch;
	__asm        jmp    _FOR_COND_25;
_FOR_NEXT_25:
	for (; (this->lColors > i); i++) {
		// LINE 77:
			__asm        mov    eax, colorValue;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+2];
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    edx, i;
			__asm        xor    ebx, ebx;
			__asm        mov    bl, [eax+edx*4+2];
			__asm        sub    ecx, ebx;
			__asm        mov    [ebp-0x18], ecx;
			__asm        mov    eax, colorValue;
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+2];
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ebx, i;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+ebx*4+2];
			__asm        sub    edx, ecx;
			__asm        mov    eax, [ebp-0x18];
			__asm        imul   eax, edx;
			__asm        lea    eax, [eax+eax*2];
			__asm        mov    [ebp-0x1C], eax;
			__asm        mov    ecx, colorValue;
			__asm        xor    edx, edx;
			__asm        mov    dl, [ecx];
			__asm        mov    ecx, this;
			__asm        mov    ecx, [ecx+4];
			__asm        mov    ebx, i;
			__asm        xor    eax, eax;
			__asm        mov    al, [ecx+ebx*4];
			__asm        sub    edx, eax;
			__asm        mov    [ebp-0x20], edx;
			__asm        mov    eax, colorValue;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax];
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ebx, i;
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+ebx*4];
			__asm        sub    ecx, edx;
			__asm        mov    eax, [ebp-0x20];
			__asm        imul   eax, ecx;
			__asm        mov    ecx, [ebp-0x1C];
			__asm        lea    eax, [ecx+eax*2];
			__asm        mov    [ebp-0x24], eax;
			__asm        mov    ecx, colorValue;
			__asm        xor    edx, edx;
			__asm        mov    dl, [ecx+1];
			__asm        mov    ecx, this;
			__asm        mov    ecx, [ecx+4];
			__asm        mov    ebx, i;
			__asm        xor    eax, eax;
			__asm        mov    al, [ecx+ebx*4+1];
			__asm        sub    edx, eax;
			__asm        mov    [ebp-0x28], edx;
			__asm        mov    eax, colorValue;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax+1];
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ebx, i;
			__asm        xor    edx, edx;
			__asm        mov    dl, [eax+ebx*4+1];
			__asm        sub    ecx, edx;
			__asm        mov    eax, [ebp-0x28];
			__asm        imul   eax, ecx;
			__asm        mov    ecx, [ebp-0x24];
			__asm        lea    eax, [ecx+eax*4];
			__asm        mov    lCurrentDistance, eax;
		// LINE 78:
			__asm        mov    eax, lClosestDistance;
			__asm        cmp    lCurrentDistance, eax;
			__asm        jae    _T114;
		// LINE 79:
			lCurrentDistance = lClosestDistance;
		// LINE 80:
			nCurrentBestMatch = i;
		// LINE 82:
		_T114:
	}
// LINE 83:
_T119:
	nIndex. = nCurrentBestMatch;
// LINE 84:
	return;
}

// FUNCTION: COPTER_D 0x004965b0
void SparkalPalette::FadeToWhite(long lFadeTime) {
	/*bp-0x4*/   int32_t nDivisor;
	/*bp-0x8*/   int32_t nMultiplier;
	/*bp-0xc*/   int32_t nOriginalPriority;
	/*bp-0x10*/  int32_t i;
	/*bp-0x14*/  int32_t j;
	/*bp-0x414*/ /*packed*/ struct tagPALETTEENTRY palEntries[256]; // 0x400 bytes
	/*bp-0x424*/ /*packed*/ class MTimer timerFade; // 0x10 bytes
	/*bp-0x428*/ const unsigned long lDelayTime;

// LINE 95:
	__asm        mov    eax, lFadeTime;
	__asm        cdq;
	__asm        and    edx, 0x3F;
	__asm        add    eax, edx;
	__asm        sar    eax, 6;
	__asm        mov    lDelayTime, eax;
// LINE 96:
	__asm        mov    timerFade.nTimerResolution, 1;
	__asm        mov    timerFade.lStartTime, 0;
	__asm        mov    timerFade.lTotalElapsedTime, 0;
	__asm        mov    timerFade.lFrequency, 0;
	__asm        cmp    timerFade.nTimerResolution, 0;
	__asm        jne    _T83;

	__asm        lea    eax, [ebp-0x440];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3668];
	__asm        mov    eax, [ebp-0x440];
	__asm        mov    [ebp-0x438], eax;
	__asm        mov    eax, [ebp-0x438];
	__asm        mov    timerFade.lFrequency, eax;
	__asm        jmp    _T83;
_T83:
	__asm        jmp    _T88;
// LINE 113:
_T88:
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E0];
	__asm        mov    nOriginalPriority, eax;
// LINE 114:
	__asm        push   2;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 116:
	__asm        cmp    lpPalette, 0;
	__asm        jne    _FOR_ca;
// LINE 117:
	__asm        jmp    _Tb9;
_Tb9:
	return;
// LINE 118:
_FOR_ca:
	for (i = 0xa; (i < 0xf6); i++) {
		// LINE 119:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4+2];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x414], al;
		// LINE 120:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4+1];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x413], al;
		// LINE 121:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x412], al;
		// LINE 122:
			__asm        mov    eax, i;
			__asm        mov    byte ptr [ebp+eax*4-0x411], 5;
	}
// LINE 124:
_T137:
	nMultiplier = 0x3f;
// LINE 125:
	nDivisor = 0x40;
// LINE 126:
_FOR_151:
	for (i = 0x0; (i < 0x40); i++) {
		// LINE 127:
			timerFade.lTotalElapsedTime = 0x0;
			timerFade.lStartTime = 0x0;
			__asm        jmp    _T177;
		_T177:
			__asm        jmp    _T17c;
		_T17c:
			__asm        cmp    timerFade.lStartTime, 0;
			__asm        je     _T18e;

			__asm        jmp    _T20c;
		_T18e:
			__asm        cmp    timerFade.nTimerResolution, 1;
			__asm        jne    _T1b1;

			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;

			__asm        jmp    _T207;
		_T1b1:
			__asm        cmp    timerFade.nTimerResolution, 0;
			__asm        jne    _T1ed;

			__asm        lea    eax, [ebp-0x434];
			__asm        push   eax;
			__asm        call   dword ptr ds:[0x6C365C];
			__asm        mov    eax, [ebp-0x434];
			__asm        mov    [ebp-0x42C], eax;
			__asm        mov    eax, [ebp-0x42C];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;

			__asm        jmp    _T207;
		_T1ed:
			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    ecx, 0x3E8;
			__asm        sub    edx, edx;
			__asm        div    ecx;
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;
		_T207:
			__asm        jmp    _T20c;
		_T20c:
			__asm        jmp    _T211;
		// LINE 128:
		_T211:
			__asm        mov    eax, i;
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        and    eax, 0xF;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        jne    _FOR_23d;
		// LINE 129:
			__asm        sar    nDivisor, 1;
		// LINE 130:
			__asm        mov    eax, nDivisor;
			__asm        dec    eax;
			__asm        mov    nMultiplier, eax;
		// LINE 132:
		_FOR_23d:
			for (j = 0xa; (j < 0xf6); j++) {
				// LINE 134:
					__asm        mov    ecx, 0xFF;
					__asm        mov    eax, 0xFF;
					__asm        mov    edx, j;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ebp+edx*4-0x414];
					__asm        sub    eax, ebx;
					__asm        imul   eax, nMultiplier;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        sub    ecx, eax;
					__asm        mov    eax, j;
					__asm        mov    [ebp+eax*4-0x414], cl;
				// LINE 135:
					__asm        mov    ecx, 0xFF;
					__asm        mov    eax, 0xFF;
					__asm        mov    edx, j;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ebp+edx*4-0x413];
					__asm        sub    eax, ebx;
					__asm        imul   eax, nMultiplier;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        sub    ecx, eax;
					__asm        mov    eax, j;
					__asm        mov    [ebp+eax*4-0x413], cl;
				// LINE 136:
					__asm        mov    ecx, 0xFF;
					__asm        mov    eax, 0xFF;
					__asm        mov    edx, j;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ebp+edx*4-0x412];
					__asm        sub    eax, ebx;
					__asm        imul   eax, nMultiplier;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        sub    ecx, eax;
					__asm        mov    eax, j;
					__asm        mov    [ebp+eax*4-0x412], cl;
			}
		// LINE 139:
		_T2d6:
			__asm        push   0;
			__asm        push   1;
			__asm        mov    eax, lpDD;
			__asm        push   eax;
			__asm        mov    eax, lpDD;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x58];
		// LINE 140:
			__asm        lea    eax, palEntries[10].peRed;
			__asm        push   eax;
			__asm        push   0xEC;
			__asm        push   0xA;
			__asm        push   0;
			__asm        mov    eax, lpPalette;
			__asm        push   eax;
			__asm        mov    eax, lpPalette;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x18];
		// LINE 144:
		_LOOP_30a:
			for (;;) {
				// LINE 144:
				_LOOP_30a:
					__asm        mov    eax, timerFade.lTotalElapsedTime;
					__asm        mov    [ebp-0x448], eax;
					__asm        jmp    _T31b;
				_T31b:
					__asm        cmp    timerFade.lStartTime, 0;
					__asm        je     _T3bf;

					__asm        cmp    timerFade.nTimerResolution, 1;
					__asm        jne    _T34b;

					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    [ebp-0x458], eax;
					__asm        jmp    _T3a1;

					__asm        jmp    _T3a1;
				_T34b:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T387;

					__asm        lea    eax, [ebp-0x454];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C365C];
					__asm        mov    eax, [ebp-0x454];
					__asm        mov    [ebp-0x44C], eax;
					__asm        mov    eax, [ebp-0x44C];
					__asm        mov    [ebp-0x458], eax;
					__asm        jmp    _T3a1;

					__asm        jmp    _T3a1;
				_T387:
					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    ecx, 0x3E8;
					__asm        sub    edx, edx;
					__asm        div    ecx;
					__asm        mov    [ebp-0x458], eax;
					__asm        jmp    _T3a1;
				_T3a1:
					__asm        mov    eax, [ebp-0x458];
					__asm        sub    eax, timerFade.lStartTime;
					__asm        mov    [ebp-0x444], eax;
					__asm        mov    eax, [ebp-0x444];
					__asm        add    [ebp-0x448], eax;
				_T3bf:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T40f;

					__asm        cmp    timerFade.lFrequency, 0;
					__asm        je     _T40f;

					__asm        mov    eax, timerFade.lFrequency;
					__asm        push   eax;
					__asm        push   0xF4240;
					__asm        mov    eax, [ebp-0x448];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C372C];
					__asm        mov    [ebp-0x448], eax;
					__asm        mov    eax, lDelayTime;
					__asm        cmp    [ebp-0x448], eax;
					__asm        jae    _T43d;

					__asm        jmp    _T438;
				_T40f:
					__asm        mov    eax, lDelayTime;
					__asm        cmp    [ebp-0x448], eax;
					__asm        jae    _T43d;

					__asm        jmp    _T438;

					__asm        mov    eax, lDelayTime;
					__asm        cmp    [ebp-0x45C], eax;
					__asm        jae    _T43d;
				_T438:
			}
		// LINE 145:
		_T43d:
	}
// LINE 147:
_T442:
	__asm        mov    eax, nOriginalPriority;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 171:
	__asm        jmp    _T458;
_T458:
	return;
}

// FUNCTION: COPTER_D 0x00496a14
void SparkalPalette::FadeToBlack(long lFadeTime) {
	/*bp-0x4*/   int32_t nDivisor;
	/*bp-0x8*/   int32_t nMultiplier;
	/*bp-0xc*/   int32_t nOriginalPriority;
	/*bp-0x10*/  int32_t i;
	/*bp-0x14*/  int32_t j;
	/*bp-0x414*/ /*packed*/ struct tagPALETTEENTRY palEntries[256]; // 0x400 bytes
	/*bp-0x424*/ /*packed*/ class MTimer timerFade; // 0x10 bytes
	/*bp-0x428*/ const unsigned long lDelayTime;

// LINE 182:
	__asm        mov    eax, lFadeTime;
	__asm        cdq;
	__asm        and    edx, 0x3F;
	__asm        add    eax, edx;
	__asm        sar    eax, 6;
	__asm        mov    lDelayTime, eax;
// LINE 183:
	__asm        mov    timerFade.nTimerResolution, 1;
	__asm        mov    timerFade.lStartTime, 0;
	__asm        mov    timerFade.lTotalElapsedTime, 0;
	__asm        mov    timerFade.lFrequency, 0;
	__asm        cmp    timerFade.nTimerResolution, 0;
	__asm        jne    _T83;

	__asm        lea    eax, [ebp-0x440];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3668];
	__asm        mov    eax, [ebp-0x440];
	__asm        mov    [ebp-0x438], eax;
	__asm        mov    eax, [ebp-0x438];
	__asm        mov    timerFade.lFrequency, eax;
	__asm        jmp    _T83;
_T83:
	__asm        jmp    _T88;
// LINE 200:
_T88:
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E0];
	__asm        mov    nOriginalPriority, eax;
// LINE 201:
	__asm        push   2;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 203:
	__asm        cmp    lpPalette, 0;
	__asm        jne    _FOR_ca;
// LINE 204:
	__asm        jmp    _Tb9;
_Tb9:
	return;
// LINE 206:
_FOR_ca:
	for (i = 0xa; (i < 0xf6); i++) {
		// LINE 207:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4+2];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x414], al;
		// LINE 208:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4+1];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x413], al;
		// LINE 209:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x412], al;
		// LINE 210:
			__asm        mov    eax, i;
			__asm        mov    byte ptr [ebp+eax*4-0x411], 5;
	}
// LINE 213:
_T137:
	nMultiplier = 0x3f;
// LINE 214:
	nDivisor = 0x40;
// LINE 215:
_FOR_151:
	for (i = 0x0; (i < 0x40); i++) {
		// LINE 216:
			timerFade.lTotalElapsedTime = 0x0;
			timerFade.lStartTime = 0x0;
			__asm        jmp    _T177;
		_T177:
			__asm        jmp    _T17c;
		_T17c:
			__asm        cmp    timerFade.lStartTime, 0;
			__asm        je     _T18e;

			__asm        jmp    _T20c;
		_T18e:
			__asm        cmp    timerFade.nTimerResolution, 1;
			__asm        jne    _T1b1;

			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;

			__asm        jmp    _T207;
		_T1b1:
			__asm        cmp    timerFade.nTimerResolution, 0;
			__asm        jne    _T1ed;

			__asm        lea    eax, [ebp-0x434];
			__asm        push   eax;
			__asm        call   dword ptr ds:[0x6C365C];
			__asm        mov    eax, [ebp-0x434];
			__asm        mov    [ebp-0x42C], eax;
			__asm        mov    eax, [ebp-0x42C];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;

			__asm        jmp    _T207;
		_T1ed:
			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    ecx, 0x3E8;
			__asm        sub    edx, edx;
			__asm        div    ecx;
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;
		_T207:
			__asm        jmp    _T20c;
		_T20c:
			__asm        jmp    _T211;
		// LINE 217:
		_T211:
			__asm        mov    eax, i;
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        and    eax, 0xF;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        jne    _FOR_23d;
		// LINE 218:
			__asm        sar    nDivisor, 1;
		// LINE 219:
			__asm        mov    eax, nDivisor;
			__asm        dec    eax;
			__asm        mov    nMultiplier, eax;
		// LINE 221:
		_FOR_23d:
			for (j = 0xa; (j < 0xf6); j++) {
				// LINE 223:
					__asm        mov    eax, j;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [ebp+eax*4-0x414];
					__asm        imul   ecx, nMultiplier;
					__asm        mov    eax, ecx;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        mov    ecx, j;
					__asm        mov    [ebp+ecx*4-0x414], al;
				// LINE 224:
					__asm        mov    eax, j;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [ebp+eax*4-0x413];
					__asm        imul   ecx, nMultiplier;
					__asm        mov    eax, ecx;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        mov    ecx, j;
					__asm        mov    [ebp+ecx*4-0x413], al;
				// LINE 225:
					__asm        mov    eax, j;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [ebp+eax*4-0x412];
					__asm        imul   ecx, nMultiplier;
					__asm        mov    eax, ecx;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        mov    ecx, j;
					__asm        mov    [ebp+ecx*4-0x412], al;
			}
		// LINE 228:
		_T2b2:
			__asm        push   0;
			__asm        push   1;
			__asm        mov    eax, lpDD;
			__asm        push   eax;
			__asm        mov    eax, lpDD;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x58];
		// LINE 229:
			__asm        lea    eax, palEntries[10].peRed;
			__asm        push   eax;
			__asm        push   0xEC;
			__asm        push   0xA;
			__asm        push   0;
			__asm        mov    eax, lpPalette;
			__asm        push   eax;
			__asm        mov    eax, lpPalette;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x18];
		// LINE 233:
		_LOOP_2e6:
			for (;;) {
				// LINE 233:
				_LOOP_2e6:
					__asm        mov    eax, timerFade.lTotalElapsedTime;
					__asm        mov    [ebp-0x448], eax;
					__asm        jmp    _T2f7;
				_T2f7:
					__asm        cmp    timerFade.lStartTime, 0;
					__asm        je     _T39b;

					__asm        cmp    timerFade.nTimerResolution, 1;
					__asm        jne    _T327;

					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    [ebp-0x458], eax;
					__asm        jmp    _T37d;

					__asm        jmp    _T37d;
				_T327:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T363;

					__asm        lea    eax, [ebp-0x454];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C365C];
					__asm        mov    eax, [ebp-0x454];
					__asm        mov    [ebp-0x44C], eax;
					__asm        mov    eax, [ebp-0x44C];
					__asm        mov    [ebp-0x458], eax;
					__asm        jmp    _T37d;

					__asm        jmp    _T37d;
				_T363:
					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    ecx, 0x3E8;
					__asm        sub    edx, edx;
					__asm        div    ecx;
					__asm        mov    [ebp-0x458], eax;
					__asm        jmp    _T37d;
				_T37d:
					__asm        mov    eax, [ebp-0x458];
					__asm        sub    eax, timerFade.lStartTime;
					__asm        mov    [ebp-0x444], eax;
					__asm        mov    eax, [ebp-0x444];
					__asm        add    [ebp-0x448], eax;
				_T39b:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T3eb;

					__asm        cmp    timerFade.lFrequency, 0;
					__asm        je     _T3eb;

					__asm        mov    eax, timerFade.lFrequency;
					__asm        push   eax;
					__asm        push   0xF4240;
					__asm        mov    eax, [ebp-0x448];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C372C];
					__asm        mov    [ebp-0x448], eax;
					__asm        mov    eax, [ebp-0x448];
					__asm        cmp    lDelayTime, eax;
					__asm        jbe    _T419;

					__asm        jmp    _T414;
				_T3eb:
					__asm        mov    eax, [ebp-0x448];
					__asm        cmp    lDelayTime, eax;
					__asm        jbe    _T419;

					__asm        jmp    _T414;

					__asm        mov    eax, [ebp-0x45C];
					__asm        cmp    lDelayTime, eax;
					__asm        jbe    _T419;
				_T414:
			}
		// LINE 234:
		_T419:
	}
// LINE 236:
_T41e:
	__asm        mov    eax, nOriginalPriority;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 260:
	__asm        jmp    _T434;
_T434:
	return;
}

// FUNCTION: COPTER_D 0x00496e54
void SparkalPalette::FadeToRGB(/*packed*/ struct SparkalColor& colorToFadeTo, long lFadeTime) {
	/*bp-0x4*/   int32_t nDivisor;
	/*bp-0x8*/   int32_t nMultiplier;
	/*bp-0xc*/   int32_t nOriginalPriority;
	/*bp-0x10*/  int32_t i;
	/*bp-0x14*/  int32_t j;
	/*bp-0x18*/  int32_t nDifference;
	/*bp-0x418*/ /*packed*/ struct tagPALETTEENTRY palEntries[256]; // 0x400 bytes
	/*bp-0x428*/ /*packed*/ class MTimer timerFade; // 0x10 bytes
	/*bp-0x42c*/ const unsigned long lDelayTime;

// LINE 272:
	__asm        mov    eax, lFadeTime;
	__asm        cdq;
	__asm        and    edx, 0x3F;
	__asm        add    eax, edx;
	__asm        sar    eax, 6;
	__asm        mov    lDelayTime, eax;
// LINE 273:
	__asm        mov    timerFade.nTimerResolution, 1;
	__asm        mov    timerFade.lStartTime, 0;
	__asm        mov    timerFade.lTotalElapsedTime, 0;
	__asm        mov    timerFade.lFrequency, 0;
	__asm        cmp    timerFade.nTimerResolution, 0;
	__asm        jne    _T83;

	__asm        lea    eax, [ebp-0x444];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3668];
	__asm        mov    eax, [ebp-0x444];
	__asm        mov    [ebp-0x43C], eax;
	__asm        mov    eax, [ebp-0x43C];
	__asm        mov    timerFade.lFrequency, eax;
	__asm        jmp    _T83;
_T83:
	__asm        jmp    _T88;
// LINE 290:
_T88:
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E0];
	__asm        mov    nOriginalPriority, eax;
// LINE 291:
	__asm        push   2;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 293:
	__asm        cmp    lpPalette, 0;
	__asm        jne    _FOR_ca;
// LINE 294:
	__asm        jmp    _Tb9;
_Tb9:
	return;
// LINE 295:
_FOR_ca:
	for (i = 0xa; (i < 0xf6); i++) {
		// LINE 296:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4+2];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x418], al;
		// LINE 297:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4+1];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x417], al;
		// LINE 298:
			__asm        mov    eax, this;
			__asm        mov    eax, [eax+4];
			__asm        mov    ecx, i;
			__asm        mov    al, [eax+ecx*4];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x416], al;
		// LINE 299:
			__asm        mov    eax, i;
			__asm        mov    byte ptr [ebp+eax*4-0x415], 5;
	}
// LINE 302:
_T137:
	nMultiplier = 0x3f;
// LINE 303:
	nDivisor = 0x40;
// LINE 304:
_FOR_151:
	for (i = 0x0; (i < 0x40); i++) {
		// LINE 305:
			timerFade.lTotalElapsedTime = 0x0;
			timerFade.lStartTime = 0x0;
			__asm        jmp    _T177;
		_T177:
			__asm        jmp    _T17c;
		_T17c:
			__asm        cmp    timerFade.lStartTime, 0;
			__asm        je     _T18e;

			__asm        jmp    _T20c;
		_T18e:
			__asm        cmp    timerFade.nTimerResolution, 1;
			__asm        jne    _T1b1;

			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;

			__asm        jmp    _T207;
		_T1b1:
			__asm        cmp    timerFade.nTimerResolution, 0;
			__asm        jne    _T1ed;

			__asm        lea    eax, [ebp-0x438];
			__asm        push   eax;
			__asm        call   dword ptr ds:[0x6C365C];
			__asm        mov    eax, [ebp-0x438];
			__asm        mov    [ebp-0x430], eax;
			__asm        mov    eax, [ebp-0x430];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;

			__asm        jmp    _T207;
		_T1ed:
			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    ecx, 0x3E8;
			__asm        sub    edx, edx;
			__asm        div    ecx;
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T207;
		_T207:
			__asm        jmp    _T20c;
		_T20c:
			__asm        jmp    _T211;
		// LINE 306:
		_T211:
			__asm        mov    eax, i;
			__asm        cdq;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        and    eax, 0xF;
			__asm        xor    eax, edx;
			__asm        sub    eax, edx;
			__asm        jne    _FOR_23d;
		// LINE 307:
			__asm        sar    nDivisor, 1;
		// LINE 308:
			__asm        mov    eax, nDivisor;
			__asm        dec    eax;
			__asm        mov    nMultiplier, eax;
		// LINE 310:
		_FOR_23d:
			for (j = 0xa; (j < 0xf6); j++) {
				// LINE 311:
					__asm        mov    eax, colorToFadeTo;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [eax+2];
					__asm        mov    eax, j;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ebp+eax*4-0x418];
					__asm        sub    ecx, edx;
					__asm        mov    nDifference, ecx;
				// LINE 312:
					__asm        mov    eax, j;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [ebp+eax*4-0x418];
					__asm        mov    eax, nMultiplier;
					__asm        imul   eax, nDifference;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        add    ecx, eax;
					__asm        mov    eax, j;
					__asm        mov    [ebp+eax*4-0x418], cl;
				// LINE 314:
					__asm        mov    eax, colorToFadeTo;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [eax+1];
					__asm        mov    eax, j;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ebp+eax*4-0x417];
					__asm        sub    ecx, edx;
					__asm        mov    nDifference, ecx;
				// LINE 315:
					__asm        mov    eax, j;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [ebp+eax*4-0x417];
					__asm        mov    eax, nMultiplier;
					__asm        imul   eax, nDifference;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        add    ecx, eax;
					__asm        mov    eax, j;
					__asm        mov    [ebp+eax*4-0x417], cl;
				// LINE 317:
					__asm        mov    eax, colorToFadeTo;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [eax];
					__asm        mov    eax, j;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ebp+eax*4-0x416];
					__asm        sub    ecx, edx;
					__asm        mov    nDifference, ecx;
				// LINE 318:
					__asm        mov    eax, j;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [ebp+eax*4-0x416];
					__asm        mov    eax, nMultiplier;
					__asm        imul   eax, nDifference;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        add    ecx, eax;
					__asm        mov    eax, j;
					__asm        mov    [ebp+eax*4-0x416], cl;
			}
		// LINE 321:
		_T305:
			__asm        push   0;
			__asm        push   1;
			__asm        mov    eax, lpDD;
			__asm        push   eax;
			__asm        mov    eax, lpDD;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x58];
		// LINE 322:
			__asm        lea    eax, palEntries[10].peRed;
			__asm        push   eax;
			__asm        push   0xEC;
			__asm        push   0xA;
			__asm        push   0;
			__asm        mov    eax, lpPalette;
			__asm        push   eax;
			__asm        mov    eax, lpPalette;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x18];
		// LINE 326:
		_LOOP_339:
			for (;;) {
				// LINE 326:
				_LOOP_339:
					__asm        mov    eax, timerFade.lTotalElapsedTime;
					__asm        mov    [ebp-0x44C], eax;
					__asm        jmp    _T34a;
				_T34a:
					__asm        cmp    timerFade.lStartTime, 0;
					__asm        je     _T3ee;

					__asm        cmp    timerFade.nTimerResolution, 1;
					__asm        jne    _T37a;

					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    [ebp-0x45C], eax;
					__asm        jmp    _T3d0;

					__asm        jmp    _T3d0;
				_T37a:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T3b6;

					__asm        lea    eax, [ebp-0x458];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C365C];
					__asm        mov    eax, [ebp-0x458];
					__asm        mov    [ebp-0x450], eax;
					__asm        mov    eax, [ebp-0x450];
					__asm        mov    [ebp-0x45C], eax;
					__asm        jmp    _T3d0;

					__asm        jmp    _T3d0;
				_T3b6:
					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    ecx, 0x3E8;
					__asm        sub    edx, edx;
					__asm        div    ecx;
					__asm        mov    [ebp-0x45C], eax;
					__asm        jmp    _T3d0;
				_T3d0:
					__asm        mov    eax, [ebp-0x45C];
					__asm        sub    eax, timerFade.lStartTime;
					__asm        mov    [ebp-0x448], eax;
					__asm        mov    eax, [ebp-0x448];
					__asm        add    [ebp-0x44C], eax;
				_T3ee:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T43e;

					__asm        cmp    timerFade.lFrequency, 0;
					__asm        je     _T43e;

					__asm        mov    eax, timerFade.lFrequency;
					__asm        push   eax;
					__asm        push   0xF4240;
					__asm        mov    eax, [ebp-0x44C];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C372C];
					__asm        mov    [ebp-0x44C], eax;
					__asm        mov    eax, [ebp-0x44C];
					__asm        cmp    lDelayTime, eax;
					__asm        jbe    _T46c;

					__asm        jmp    _T467;
				_T43e:
					__asm        mov    eax, [ebp-0x44C];
					__asm        cmp    lDelayTime, eax;
					__asm        jbe    _T46c;

					__asm        jmp    _T467;

					__asm        mov    eax, lDelayTime;
					__asm        cmp    [ebp-0x460], eax;
					__asm        jae    _T46c;
				_T467:
			}
		// LINE 327:
		_T46c:
	}
// LINE 329:
_T471:
	__asm        mov    eax, nOriginalPriority;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 353:
	__asm        jmp    _T487;
_T487:
	return;
}

// FUNCTION: COPTER_D 0x004972e7
void SparkalPalette::FadeToPalette(/*packed*/ struct SparkalColor colorStart, long lFadeTime, long lSteps) {
// LINE 361:
	SparkalPalette::FadeToPalette(reinterpret_cast<uint32_t>(colorStart.Blue), this->pColors, lFadeTime, lSteps);
// LINE 362:
	return;
}

// FUNCTION: COPTER_D 0x0049731a
void SparkalPalette::FadeToPalette(/*packed*/ struct SparkalColor colorStart, /*packed*/ struct SparkalColor *paletteDestination, long lFadeTime, long lSteps) {
	/*bp-0x4*/   int32_t nDivisor;
	/*bp-0x8*/   int32_t nMultiplier;
	/*bp-0xc*/   int32_t nOriginalPriority;
	/*bp-0x10*/  const int32_t nLastStepIndex;
	typedef /*packed*/ struct SparkalPalette::FadeToPalette::TempPalette SparkalPalette::FadeToPalette::TempPalette;
	/*bp-0x14*/  int32_t i;
	/*bp-0x18*/  int32_t j;
	/*bp-0x1c*/  /*packed*/ struct SparkalPalette::FadeToPalette::TempPalette *paletteArray;
	/*bp-0x20*/  int32_t nDifference;
	/*bp-0x30*/  /*packed*/ class MTimer timerFade; // 0x10 bytes
	/*bp-0x34*/  const unsigned long lDelayTime;

// LINE 379:
	__asm        mov    eax, lFadeTime;
	__asm        cdq;
	__asm        idiv   lSteps;
	__asm        mov    lDelayTime, eax;
// LINE 381:
	__asm        mov    timerFade.nTimerResolution, 1;
	__asm        mov    timerFade.lStartTime, 0;
	__asm        mov    timerFade.lTotalElapsedTime, 0;
	__asm        mov    timerFade.lFrequency, 0;
	__asm        cmp    timerFade.nTimerResolution, 0;
	__asm        jne    _T54;

	__asm        lea    eax, [ebp-0x54];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3668];
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    [ebp-0x4C], eax;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    timerFade.lFrequency, eax;
	__asm        jmp    _T54;
_T54:
	__asm        jmp    _T59;
// LINE 384:
_T59:
	__asm        cmp    lSteps, 0xC8;
	__asm        jle    _T6d;
// LINE 385:
	lSteps = 0xc8;
// LINE 391:
_T6d:
	paletteArray = operator new((lSteps << 0xa));
// LINE 392:
	__asm        mov    eax, lSteps;
	__asm        dec    eax;
	__asm        mov    nLastStepIndex, eax;
// LINE 396:
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E0];
	__asm        mov    nOriginalPriority, eax;
// LINE 397:
	__asm        push   2;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 399:
	__asm        cmp    lpPalette, 0;
	__asm        jne    _FOR_c8;
// LINE 400:
	__asm        jmp    _Tb7;
_Tb7:
	return;
// LINE 401:
_FOR_c8:
	for (i = 0x0; (i < lSteps); i++) {
		// LINE 402:
		_FOR_e3:
			for (j = 0xa; (j < 0xf5); j++) {
				// LINE 403:
					__asm        mov    eax, j;
					__asm        mov    ecx, i;
					__asm        shl    ecx, 0xA;
					__asm        lea    eax, [ecx+eax*4];
					__asm        mov    ecx, paletteArray;
					__asm        mov    byte ptr [eax+ecx+3], 5;
					__asm        jmp    _FOR_NEXT_e3;
			}
		// LINE 404:
		_T10c:
	}
// LINE 406:
_FOR_11d:
	for (j = 0xa; (j < 0xf6); j++) {
		// LINE 407:
			__asm        mov    al, colorStart.Red;
			__asm        mov    ecx, j;
			__asm        mov    edx, paletteArray;
			__asm        mov    [edx+ecx*4], al;
		// LINE 408:
			__asm        mov    al, colorStart.Green;
			__asm        mov    ecx, j;
			__asm        mov    edx, paletteArray;
			__asm        mov    [edx+ecx*4+1], al;
		// LINE 409:
			__asm        mov    al, colorStart.Blue;
			__asm        mov    ecx, j;
			__asm        mov    edx, paletteArray;
			__asm        mov    [edx+ecx*4+2], al;
		// LINE 410:
			__asm        mov    eax, j;
			__asm        mov    ecx, paletteDestination;
			__asm        mov    al, [ecx+eax*4+2];
			__asm        mov    ecx, j;
			__asm        mov    edx, nLastStepIndex;
			__asm        shl    edx, 0xA;
			__asm        lea    ecx, [edx+ecx*4];
			__asm        mov    edx, paletteArray;
			__asm        mov    [ecx+edx], al;
		// LINE 411:
			__asm        mov    eax, j;
			__asm        mov    ecx, paletteDestination;
			__asm        mov    al, [ecx+eax*4+1];
			__asm        mov    ecx, j;
			__asm        mov    edx, nLastStepIndex;
			__asm        shl    edx, 0xA;
			__asm        lea    ecx, [edx+ecx*4];
			__asm        mov    edx, paletteArray;
			__asm        mov    [ecx+edx+1], al;
		// LINE 412:
			__asm        mov    eax, j;
			__asm        mov    ecx, paletteDestination;
			__asm        mov    al, [ecx+eax*4];
			__asm        mov    ecx, j;
			__asm        mov    edx, nLastStepIndex;
			__asm        shl    edx, 0xA;
			__asm        lea    ecx, [edx+ecx*4];
			__asm        mov    edx, paletteArray;
			__asm        mov    [ecx+edx+2], al;
	}
// LINE 417:
_T1ad:
	nMultiplier = 0x3f;
// LINE 418:
	nDivisor = 0x40;
// LINE 419:
_FOR_1c7:
	for (i = 0x1; (i < nLastStepIndex); i++) {
		// LINE 420:
			timerFade.lTotalElapsedTime = 0x0;
			timerFade.lStartTime = 0x0;
			__asm        jmp    _T1e9;
		_T1e9:
			__asm        jmp    _T1ee;
		_T1ee:
			__asm        cmp    timerFade.lStartTime, 0;
			__asm        je     _T1fd;

			__asm        jmp    _T260;
		_T1fd:
			__asm        cmp    timerFade.nTimerResolution, 1;
			__asm        jne    _T21a;

			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T25b;

			__asm        jmp    _T25b;
		_T21a:
			__asm        cmp    timerFade.nTimerResolution, 0;
			__asm        jne    _T244;

			__asm        lea    eax, [ebp-0x48];
			__asm        push   eax;
			__asm        call   dword ptr ds:[0x6C365C];
			__asm        mov    eax, [ebp-0x48];
			__asm        mov    [ebp-0x40], eax;
			__asm        mov    eax, [ebp-0x40];
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T25b;

			__asm        jmp    _T25b;
		_T244:
			__asm        call   dword ptr ds:[0x6C3908];
			__asm        mov    ecx, 0x3E8;
			__asm        sub    edx, edx;
			__asm        div    ecx;
			__asm        mov    timerFade.lStartTime, eax;
			__asm        jmp    _T25b;
		_T25b:
			__asm        jmp    _T260;
		_T260:
			__asm        jmp    _T265;
		// LINE 421:
		_T265:
			__asm        mov    ecx, lSteps;
			__asm        sar    ecx, 2;
			__asm        mov    eax, i;
			__asm        cdq;
			__asm        idiv   ecx;
			__asm        test   edx, edx;
			__asm        jne    _FOR_290;
		// LINE 422:
			__asm        sar    nDivisor, 1;
		// LINE 423:
			__asm        mov    eax, nDivisor;
			__asm        dec    eax;
			__asm        mov    nMultiplier, eax;
		// LINE 425:
		_FOR_290:
			for (j = 0xa; (j < 0xf6); j++) {
				// LINE 426:
					__asm        mov    eax, j;
					__asm        mov    ecx, paletteDestination;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ecx+eax*4+2];
					__asm        mov    eax, i;
					__asm        dec    eax;
					__asm        shl    eax, 0xA;
					__asm        mov    ecx, j;
					__asm        lea    eax, [eax+ecx*4];
					__asm        mov    ecx, paletteArray;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [eax+ecx];
					__asm        sub    edx, ebx;
					__asm        mov    nDifference, edx;
				// LINE 427:
					__asm        mov    eax, j;
					__asm        mov    ecx, paletteDestination;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ecx+eax*4+2];
					__asm        mov    eax, nMultiplier;
					__asm        imul   eax, nDifference;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        sub    ebx, eax;
					__asm        mov    eax, j;
					__asm        mov    ecx, i;
					__asm        shl    ecx, 0xA;
					__asm        lea    eax, [ecx+eax*4];
					__asm        mov    ecx, paletteArray;
					__asm        mov    [eax+ecx], bl;
				// LINE 429:
					__asm        mov    eax, j;
					__asm        mov    ecx, paletteDestination;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ecx+eax*4+1];
					__asm        mov    eax, i;
					__asm        dec    eax;
					__asm        shl    eax, 0xA;
					__asm        mov    ecx, j;
					__asm        lea    eax, [eax+ecx*4];
					__asm        mov    ecx, paletteArray;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [eax+ecx+1];
					__asm        sub    edx, ebx;
					__asm        mov    nDifference, edx;
				// LINE 430:
					__asm        mov    eax, j;
					__asm        mov    ecx, paletteDestination;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ecx+eax*4+1];
					__asm        mov    eax, nMultiplier;
					__asm        imul   eax, nDifference;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        sub    ebx, eax;
					__asm        mov    eax, j;
					__asm        mov    ecx, i;
					__asm        shl    ecx, 0xA;
					__asm        lea    eax, [ecx+eax*4];
					__asm        mov    ecx, paletteArray;
					__asm        mov    [eax+ecx+1], bl;
				// LINE 432:
					__asm        mov    eax, j;
					__asm        mov    ecx, paletteDestination;
					__asm        xor    edx, edx;
					__asm        mov    dl, [ecx+eax*4];
					__asm        mov    eax, i;
					__asm        dec    eax;
					__asm        shl    eax, 0xA;
					__asm        mov    ecx, j;
					__asm        lea    eax, [eax+ecx*4];
					__asm        mov    ecx, paletteArray;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [eax+ecx+2];
					__asm        sub    edx, ebx;
					__asm        mov    nDifference, edx;
				// LINE 433:
					__asm        mov    eax, j;
					__asm        mov    ecx, paletteDestination;
					__asm        xor    ebx, ebx;
					__asm        mov    bl, [ecx+eax*4];
					__asm        mov    eax, nMultiplier;
					__asm        imul   eax, nDifference;
					__asm        cdq;
					__asm        idiv   nDivisor;
					__asm        sub    ebx, eax;
					__asm        mov    eax, j;
					__asm        mov    ecx, i;
					__asm        shl    ecx, 0xA;
					__asm        lea    eax, [ecx+eax*4];
					__asm        mov    ecx, paletteArray;
					__asm        mov    [eax+ecx+2], bl;
			}
		// LINE 436:
		_T39a:
			__asm        push   0;
			__asm        push   1;
			__asm        mov    eax, lpDD;
			__asm        push   eax;
			__asm        mov    eax, lpDD;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x58];
		// LINE 437:
			__asm        mov    eax, i;
			__asm        shl    eax, 0xA;
			__asm        add    eax, paletteArray;
			__asm        add    eax, 0x28;
			__asm        push   eax;
			__asm        push   0xEC;
			__asm        push   0xA;
			__asm        push   0;
			__asm        mov    eax, lpPalette;
			__asm        push   eax;
			__asm        mov    eax, lpPalette;
			__asm        mov    eax, [eax];
			__asm        call   dword ptr [eax+0x18];
		// LINE 441:
		_LOOP_3d4:
			for (;;) {
				// LINE 441:
				_LOOP_3d4:
					__asm        mov    eax, timerFade.lTotalElapsedTime;
					__asm        mov    [ebp-0x5C], eax;
					__asm        jmp    _T3df;
				_T3df:
					__asm        cmp    timerFade.lStartTime, 0;
					__asm        je     _T456;

					__asm        cmp    timerFade.nTimerResolution, 1;
					__asm        jne    _T406;

					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    [ebp-0x6C], eax;
					__asm        jmp    _T447;

					__asm        jmp    _T447;
				_T406:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T430;

					__asm        lea    eax, [ebp-0x68];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C365C];
					__asm        mov    eax, [ebp-0x68];
					__asm        mov    [ebp-0x60], eax;
					__asm        mov    eax, [ebp-0x60];
					__asm        mov    [ebp-0x6C], eax;
					__asm        jmp    _T447;

					__asm        jmp    _T447;
				_T430:
					__asm        call   dword ptr ds:[0x6C3908];
					__asm        mov    ecx, 0x3E8;
					__asm        sub    edx, edx;
					__asm        div    ecx;
					__asm        mov    [ebp-0x6C], eax;
					__asm        jmp    _T447;
				_T447:
					__asm        mov    eax, [ebp-0x6C];
					__asm        sub    eax, timerFade.lStartTime;
					__asm        mov    [ebp-0x58], eax;
					__asm        mov    eax, [ebp-0x58];
					__asm        add    [ebp-0x5C], eax;
				_T456:
					__asm        cmp    timerFade.nTimerResolution, 0;
					__asm        jne    _T491;

					__asm        cmp    timerFade.lFrequency, 0;
					__asm        je     _T491;

					__asm        mov    eax, timerFade.lFrequency;
					__asm        push   eax;
					__asm        push   0xF4240;
					__asm        mov    eax, [ebp-0x5C];
					__asm        push   eax;
					__asm        call   dword ptr ds:[0x6C372C];
					__asm        mov    [ebp-0x5C], eax;
					__asm        mov    eax, lDelayTime;
					__asm        cmp    [ebp-0x5C], eax;
					__asm        jae    _T4b3;

					__asm        jmp    _T4ae;
				_T491:
					__asm        mov    eax, lDelayTime;
					__asm        cmp    [ebp-0x5C], eax;
					__asm        jae    _T4b3;

					__asm        jmp    _T4ae;

					__asm        mov    eax, lDelayTime;
					__asm        cmp    [ebp-0x70], eax;
					__asm        jae    _T4b3;
				_T4ae:
			}
		// LINE 442:
		_T4b3:
	}
// LINE 444:
_T4b8:
	__asm        push   0;
	__asm        push   1;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x58];
// LINE 445:
	__asm        mov    eax, nLastStepIndex;
	__asm        shl    eax, 0xA;
	__asm        add    eax, paletteArray;
	__asm        add    eax, 0x28;
	__asm        push   eax;
	__asm        push   0xEC;
	__asm        push   0xA;
	__asm        push   0;
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
// LINE 450:
	__asm        mov    eax, nOriginalPriority;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F4];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35F8];
// LINE 452:
	__asm        mov    eax, paletteArray;
	__asm        mov    [ebp-0x38], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 456:
	__asm        jmp    _T520;
_T520:
	return;
}

// FUNCTION: COPTER_D 0x00497844
void SparkalPalette::SetSystemPaletteEntriesToRGB(/*packed*/ struct SparkalColor& colorToSet) {
	/*bp-0x4*/   int32_t i;
	/*bp-0x404*/ /*packed*/ struct tagPALETTEENTRY palEntries[256]; // 0x400 bytes

// LINE 467:
_FOR_18:
	for (i = 0xa; (i < 0xf6); i++) {
		// LINE 468:
			__asm        mov    eax, colorToSet;
			__asm        mov    al, [eax+2];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x404], al;
		// LINE 469:
			__asm        mov    eax, colorToSet;
			__asm        mov    al, [eax+1];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x403], al;
		// LINE 470:
			__asm        mov    eax, colorToSet;
			__asm        mov    al, [eax];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x402], al;
		// LINE 471:
			__asm        mov    eax, i;
			__asm        mov    byte ptr [ebp+eax*4-0x401], 5;
	}
// LINE 475:
_T67:
	__asm        push   0;
	__asm        push   1;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x58];
// LINE 476:
	__asm        lea    eax, palEntries[10].peRed;
	__asm        push   eax;
	__asm        push   0xEC;
	__asm        push   0xA;
	__asm        push   0;
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
// LINE 483:
	return;
}

// FUNCTION: COPTER_D 0x004978e9
void SparkalPalette::ImplementNewPalette(/*packed*/ struct SparkalColor *pNewColors) {
	/*bp-0x4*/   int32_t i;
	/*bp-0x404*/ /*packed*/ struct tagPALETTEENTRY palEntries[256]; // 0x400 bytes
	/*bp-0x408*/ long hResult;

// LINE 503:
_FOR_1e:
	for (i = 0xa; (i < 0xf6); i++) {
		// LINE 504:
			__asm        mov    eax, i;
			__asm        mov    ecx, pNewColors;
			__asm        mov    al, [ecx+eax*4+2];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x404], al;
		// LINE 505:
			__asm        mov    eax, i;
			__asm        mov    ecx, pNewColors;
			__asm        mov    al, [ecx+eax*4+1];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x403], al;
		// LINE 506:
			__asm        mov    eax, i;
			__asm        mov    ecx, pNewColors;
			__asm        mov    al, [ecx+eax*4];
			__asm        mov    ecx, i;
			__asm        mov    [ebp+ecx*4-0x402], al;
		// LINE 507:
			__asm        mov    eax, i;
			__asm        mov    byte ptr [ebp+eax*4-0x401], 5;
	}
// LINE 510:
_T79:
	__asm        cmp    lpPalette, 0;
	__asm        je     _Tda;
// LINE 511:
	__asm        lea    eax, palEntries[10].peRed;
	__asm        push   eax;
	__asm        push   0xEC;
	__asm        push   0xA;
	__asm        push   0;
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 512:
	__asm        cmp    hResult, 0;
	__asm        je     _Tda;
// LINE 513:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x40C], eax;
	__asm        jmp    _Tca;
_Tca:
	__asm        push   0x59A1C8;
	__asm        lea    ecx, [ebp-0x40C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 519:
_Tda:
	return;
}

// SYNTHETIC: COPTER_D 0x004979cf
void CopterSparkalPalette::CopterSparkalPalette() {

	this->SparkalPalette::SparkalPalette();
	this-><CopterSparkalPalette+0x00> = 0x591118;
// LINE 535:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004979f9
void CopterSparkalPalette::CopterSparkalPalette(/*packed*/ struct SparkalColor *pNewColors, int32_t bNewOwnColors) {

	this->SparkalPalette::SparkalPalette(pNewColors, bNewOwnColors, 0x100);
	this-><CopterSparkalPalette+0x00> = 0x591118;
// LINE 544:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00497a32
void ClearWindowsSystemPalette() {
	/*bp-0x4*/   int32_t Counter;
	/*bp-0x408*/ /*packed*/ struct ClearWindowsSystemPalette::__unnamed Palette; // 0x404 bytes
	/*bp-0x40c*/ void * __ptr32 BlackPalette;
	/*bp-0x410*/ void * __ptr32 OldPalette;
	/*bp-0x414*/ void * __ptr32 ScreenDC;

// LINE 570:
	__asm        mov    Palette.Version, 0x300;
	__asm        mov    Palette.NumberOfEntries, 0x100;
	__asm        lea    edi, Palette.aEntries[0].peRed;
	__asm        xor    eax, eax;
	__asm        mov    ecx, 0x100;
	__asm        rep stosd;
// LINE 573:
_FOR_39:
	for (Counter = 0x0; (Counter < 0x100); Counter++) {
		// LINE 574:
			__asm        mov    eax, Counter;
			__asm        mov    byte ptr [ebp+eax*4-0x404], 0;
		// LINE 575:
			__asm        mov    eax, Counter;
			__asm        mov    byte ptr [ebp+eax*4-0x403], 0;
		// LINE 576:
			__asm        mov    eax, Counter;
			__asm        mov    byte ptr [ebp+eax*4-0x402], 0;
		// LINE 577:
			__asm        mov    eax, Counter;
			__asm        mov    byte ptr [ebp+eax*4-0x401], 5;
	}
// LINE 582:
_T7a:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    ScreenDC, eax;
// LINE 583:
	__asm        cmp    ScreenDC, 0;
	__asm        je     _T110;
// LINE 584:
	__asm        lea    eax, Palette.Version;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C357C];
	__asm        mov    BlackPalette, eax;
// LINE 585:
	__asm        cmp    BlackPalette, 0;
	__asm        je     _T101;
// LINE 586:
	__asm        push   0;
	__asm        mov    eax, BlackPalette;
	__asm        push   eax;
	__asm        mov    eax, ScreenDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3570];
	__asm        mov    OldPalette, eax;
// LINE 587:
	__asm        mov    eax, ScreenDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3578];
// LINE 588:
	__asm        push   0;
	__asm        mov    eax, OldPalette;
	__asm        push   eax;
	__asm        mov    eax, ScreenDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3570];
// LINE 589:
	__asm        mov    eax, BlackPalette;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 591:
_T101:
	__asm        mov    eax, ScreenDC;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 594:
_T110:
	return;
}



// Contribution: 1:00096b50-00096b78 Module: 18, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:00096b80-00096bb8 Module: 18, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00497b80
// SparkalPalette::`scalar deleting destructor'



// Contribution: 1:00096bc0-00096bfd Module: 18, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00497bc0
// CopterSparkalPalette::`scalar deleting destructor'



// Contribution: 2:000020f8-00002113 Module: 18, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for SparkalPalette @ 0x005910f8
//   00: SparkalPalette::`scalar deleting destructor' @ 0x00497b80
//   01: SparkalPalette::GetRGBValue @ 0x00497b50
//   02: SparkalPalette::GetNearestIndex @ 0x00496483
//   03: SparkalPalette::FadeToWhite @ 0x004965b0
//   04: SparkalPalette::FadeToBlack @ 0x00496a14
//   05: SparkalPalette::FadeToPalette @ 0x004972e7
//   06: SparkalPalette::ImplementNewPalette @ 0x004978e9
//   7 entries



// Contribution: 2:00002118-00002133 Module: 18, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for CopterSparkalPalette @ 0x00591118
//   00: CopterSparkalPalette::`scalar deleting destructor' @ 0x00497bc0
//   01: SparkalPalette::GetRGBValue @ 0x00497b50
//   02: SparkalPalette::GetNearestIndex @ 0x00496483
//   03: SparkalPalette::FadeToWhite @ 0x004965b0
//   04: SparkalPalette::FadeToBlack @ 0x00496a14
//   05: SparkalPalette::FadeToPalette @ 0x004972e7
//   06: SparkalPalette::ImplementNewPalette @ 0x004978e9
//   7 entries



// Contribution: 3:000031c8-00003207 Module: 18, 4 byte alignment, initialized_data, read, write, 
