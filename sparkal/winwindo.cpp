// Module: Winwindo.obj
// Source: C:\Copter\source\sparkal\Winwindo.cpp
// autogenerated by simcopter_tool from PDB file

// Type: char;

// Type: int32_t;

// Type: void;

// Type: /*packed*/ class CSparkalWindow (forward reference);
// VTABLE: COPTER_D 0x00590ef8
class CSparkalWindow{ // packed(0x68 bytes) TI: 0x20d9
public:
	void CSparkalWindow(unsigned long, unsigned long, unsigned long, const /*packed*/ struct SparkalColor*, char *);
	void CSparkalWindow();
	virtual void ~CSparkalWindow(); // vtable+0x0
	void * __ptr32 GetPlatformData();
	long GetWidth();
	long GetHeight();
	virtual unsigned long GetClientSize(long *, long *); // vtable+0x4
	/*unpacked*/ class ScreenBuffer* GetBackBuffer();
	/*unpacked*/ class ScreenBuffer* SetBackBuffer(/*unpacked*/ class ScreenBuffer*);
	/*unpacked*/ class ICommander* GetCommander();
	/*unpacked*/ class ICommander* SetCommander(/*unpacked*/ class ICommander*);
	virtual unsigned long Draw(); // vtable+0x8
	virtual unsigned long SetCursor(unsigned long); // vtable+0xc
	virtual unsigned long SetCursorFromIndex(int32_t); // vtable+0x10
	virtual unsigned long LoadGameCursors(); // vtable+0x14
	virtual void FreeGameCursors(); // vtable+0x18
	unsigned long DrawBufferText(const const char*, unsigned long, long, long, long *, long *, long *, long *);
	virtual unsigned long Sleep(); // vtable+0x1c
	virtual unsigned long WakeUp(); // vtable+0x20
	unsigned long ScreenScroll(long, long, long, long, long, long);
	unsigned long RectSlideUp(long, long, long, long);
	virtual unsigned long SwapBuffer(long, long, long, long); // vtable+0x24
	virtual unsigned long SwapBuffer(); // vtable+0x28
	virtual void UpdatePalette(long, long, /*packed*/ struct SparkalColor*); // vtable+0x2c
protected:
	/*+0x4*/   long mHeight;
	/*+0x8*/   long mWidth;
	/*+0xc*/   unsigned long mStyle;
	/*+0x10*/  /*unpacked*/ class ICommander *mpCommander;
	/*+0x14*/  /*unpacked*/ class ScreenBuffer *mpBackBuffer;
	/*+0x18*/  void * __ptr32 mWindow;
	// calltype: NearStd
	virtual long MySparkalWindowProc(void * __ptr32, uint32_t, uint32_t, long); // vtable+0x30
	/*+0x1c*/  void * __ptr32 mPalette;
	/*+0x20*/  void * __ptr32 mhCurrentCursor;
	/*+0x24*/  void * __ptr32 mhCustomCursor;
	/*+0x28*/  void * __ptr32 mCursors[16]; // 0x40 bytes
};

// Type: unsigned long;

// Type: /*packed*/ struct SparkalColor (forward reference);
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: char *;

// Type: /*packed*/ struct tagRECT;
struct tagRECT{ // packed(0x10 bytes) TI: 0x13c4
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
};

// Type: /*packed*/ struct tagWNDCLASSA;
struct tagWNDCLASSA{ // packed(0x28 bytes) TI: 0x26d3
	/*+0x0*/   uint32_t style;
	/*+0x4*/   long (*lpfnWndProc)(void * __ptr32, uint32_t, uint32_t, long);
	/*+0x8*/   int32_t cbClsExtra;
	/*+0xc*/   int32_t cbWndExtra;
	/*+0x10*/  void * __ptr32 hInstance;
	/*+0x14*/  void * __ptr32 hIcon;
	/*+0x18*/  void * __ptr32 hCursor;
	/*+0x1c*/  void * __ptr32 hbrBackground;
	/*+0x20*/  char * lpszMenuName;
	/*+0x24*/  char * lpszClassName;
};

// Type: /*packed*/ struct CSparkalWindow::__ctor::__unnamed;
struct CSparkalWindow::__ctor::__unnamed{ // packed(0x404 bytes) TI: 0x26d4
	/*+0x0*/   unsigned short Version; // 0x2 bytes
	/*+0x2*/   unsigned short NumberOfEntries; // 0x2 bytes
	/*+0x4*/   /*packed*/ struct tagPALETTEENTRY aEntries[256]; // 0x400 bytes
};

// Type: void * __ptr32;

// Type: uint32_t;

// Type: long *;

// Type: long;

// Type: /*packed*/ struct tagSIZE;
struct tagSIZE{ // packed(0x8 bytes) TI: 0x21e7
	/*+0x0*/   long cx;
	/*+0x4*/   long cy;
};

// Type: /*packed*/ struct tagPALETTEENTRY (forward reference);
struct tagPALETTEENTRY{ // packed(0x4 bytes) TI: 0x1be6
	/*+0x0*/   unsigned char peRed; // 0x1 bytes
	/*+0x1*/   unsigned char peGreen; // 0x1 bytes
	/*+0x2*/   unsigned char peBlue; // 0x1 bytes
	/*+0x3*/   unsigned char peFlags; // 0x1 bytes
};

// Type: unsigned char;

// Type: /*packed*/ struct CheckIdentityPalette::__unnamed;
struct CheckIdentityPalette::__unnamed{ // packed(0x428 bytes) TI: 0x26d9
	/*+0x0*/   /*packed*/ struct tagBITMAPINFOHEADER Header; // 0x28 bytes
	/*+0x28*/  /*packed*/ struct tagRGBQUAD Colors[256]; // 0x400 bytes
};

// Type: /*packed*/ struct tagPAINTSTRUCT;
struct tagPAINTSTRUCT{ // packed(0x40 bytes) TI: 0x124b
	/*+0x0*/   void * __ptr32 hdc;
	/*+0x4*/   int32_t fErase;
	/*+0x8*/   /*packed*/ struct tagRECT rcPaint; // 0x10 bytes
	/*+0x18*/  int32_t fRestore;
	/*+0x1c*/  int32_t fIncUpdate;
	/*+0x20*/  unsigned char rgbReserved[32]; // 0x20 bytes
};



// Contribution: 1:0007f690-00080ad0 Module: 30, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00480690
void CSparkalWindow::CSparkalWindow() {
	/*bp-0x4*/   int32_t i;


	this-><vftable> = 0x590ef8;
// LINE 55:
	this->mpCommander = 0x0;
// LINE 56:
	this->mpBackBuffer = 0x0;
// LINE 57:
	this->mWindow = 0x0;
// LINE 58:
	this->mWidth = 0x0;
// LINE 59:
	this->mHeight = 0x0;
// LINE 60:
	this->mStyle = 0x0;
// LINE 61:
	this->mPalette = 0x0;
// LINE 62:
	this->mhCurrentCursor = 0x0;
// LINE 63:
	this->mhCustomCursor = 0x0;
// LINE 65:
	__asm        mov    i, 0;
	__asm        jmp    _T7e;
_T7b:
	i++;
_T7e:
	__asm        cmp    i, 0x10;
	__asm        jge    _T9b;
// LINE 66:
	__asm        mov    eax, i;
	__asm        mov    ecx, this;
	__asm        mov    dword ptr [ecx+eax*4+0x28], 0;
	__asm        jmp    _T7b;
// LINE 67:
_T9b:
	return;
_Ta0:
	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00480738
void CSparkalWindow::CSparkalWindow(unsigned long Width, unsigned long Height, unsigned long Style, const /*packed*/ struct SparkalColor *pColors, char * Caption) {
	/*bp-0x4*/   unsigned long ScreenHeight;
	/*bp-0x2c*/  /*packed*/ struct tagWNDCLASSA ClassInfo; // 0x28 bytes
	/*bp-0x30*/  unsigned long dwWindowsStyle;
	/*bp-0x34*/  unsigned long ScreenWidth;
	/*bp-0x38*/  int32_t i;
	/*bp-0x48*/  /*packed*/ struct tagRECT WindowRect; // 0x10 bytes
	/*bp-0x4c*/  int32_t Top;
	/*bp-0x50*/  int32_t Left;


	this-><vftable> = 0x590ef8;
// LINE 80:
	this->mpCommander = 0x0;
// LINE 81:
	this->mpBackBuffer = 0x0;
// LINE 82:
	this->mWindow = 0x0;
// LINE 83:
	this->mWidth = Width;
// LINE 84:
	this->mHeight = Height;
// LINE 85:
	this->mStyle = Style;
// LINE 86:
	this->mPalette = 0x0;
// LINE 87:
	this->mhCurrentCursor = 0x0;
// LINE 88:
	this->mhCustomCursor = 0x0;
// LINE 90:
	__asm        mov    i, 0;
	__asm        jmp    _T9f;
_T9c:
	i++;
_T9f:
	__asm        cmp    i, 0x10;
	__asm        jge    _Tbf;
// LINE 91:
	__asm        mov    eax, i;
	__asm        mov    ecx, this;
	__asm        mov    dword ptr [ecx+eax*4+0x28], 0;
	__asm        jmp    _T9c;
// LINE 94:
_Tbf:
	__asm        lea    eax, ClassInfo.style;
	__asm        push   eax;
	__asm        push   0x599AB8;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3878];
	__asm        test   eax, eax;
	__asm        jne    _T13a;
// LINE 95:
	ClassInfo.hCursor = 0x0;
// LINE 96:
	ClassInfo.lpszMenuName = 0x599ac0;
// LINE 97:
	ClassInfo.lpszClassName = 0x599ab8;
// LINE 98:
	__asm        push   4;
	__asm        call   dword ptr ds:[0x6C3560];
	__asm        mov    ClassInfo.hbrBackground, eax;
// LINE 99:
	ClassInfo.hInstance = _ghWindowsInstance;
// LINE 100:
	ClassInfo.style = 0x23;
// LINE 101:
	ClassInfo.lpfnWndProc = 0x4815dd;
// LINE 102:
	ClassInfo.cbWndExtra = 0x4;
// LINE 103:
	ClassInfo.cbClsExtra = 0x0;
// LINE 104:
	__asm        push   0x7F00;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C381C];
	__asm        mov    ClassInfo.hIcon, eax;
// LINE 105:
	__asm        lea    eax, ClassInfo.style;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3814];
// LINE 109:
_T13a:
	dwWindowsStyle = 0x0;
// LINE 110:
	__asm        test   reinterpret_cast<uint8_t>(Style), 1;
	__asm        je     _T157;
// LINE 111:
	__asm        or     dwWindowsStyle, 0x40000;
// LINE 112:
	__asm        jmp    _T174;
_T157:
	__asm        test   reinterpret_cast<uint8_t>(Style), 4;
	__asm        je     _T16d;
// LINE 113:
	__asm        or     dwWindowsStyle, 0x800000;
// LINE 114:
	__asm        jmp    _T174;
// LINE 115:
_T16d:
	__asm        or     dwWindowsStyle, 0x80000000;
// LINE 116:
_T174:
	__asm        test   reinterpret_cast<uint8_t>(Style), 2;
	__asm        je     _T185;
// LINE 117:
	__asm        or     dwWindowsStyle, 0xC00000;
// LINE 118:
_T185:
	__asm        test   reinterpret_cast<uint8_t>(Style), 8;
	__asm        je     _T196;
// LINE 119:
	__asm        or     dwWindowsStyle, 0xC80000;
// LINE 120:
_T196:
	__asm        test   reinterpret_cast<uint8_t>(Style), 0x10;
	__asm        je     _T1a7;
// LINE 121:
	__asm        or     dwWindowsStyle, 0x30000;
// LINE 124:
_T1a7:
	__asm        mov    WindowRect.left, 0;
	__asm        mov    WindowRect.top, 0;
	__asm        mov    eax, Width;
	__asm        mov    WindowRect.right, eax;
	__asm        mov    eax, Height;
	__asm        mov    WindowRect.bottom, eax;
// LINE 125:
	__asm        push   0;
	__asm        mov    eax, dwWindowsStyle;
	__asm        push   eax;
	__asm        lea    eax, WindowRect.left;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3890];
// LINE 128:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3810];
	__asm        mov    ScreenWidth, eax;
	__asm        jmp    _T1e1;
// LINE 129:
_T1e1:
	__asm        push   1;
	__asm        call   dword ptr ds:[0x6C3810];
	__asm        mov    ScreenHeight, eax;
	__asm        jmp    _T1f1;
// LINE 131:
_T1f1:
	__asm        cmp    Width, 0;
	__asm        jne    _T206;
// LINE 132:
	Width = ScreenWidth;
// LINE 133:
	__asm        jmp    _T20f;
// LINE 134:
_T206:
	__asm        mov    eax, WindowRect.right;
	__asm        sub    eax, WindowRect.left;
	__asm        mov    Width, eax;
// LINE 135:
_T20f:
	__asm        cmp    Height, 0;
	__asm        jne    _T224;
// LINE 136:
	Height = ScreenHeight;
// LINE 137:
	__asm        jmp    _T22d;
// LINE 138:
_T224:
	__asm        mov    eax, WindowRect.bottom;
	__asm        sub    eax, WindowRect.top;
	__asm        mov    Height, eax;
// LINE 141:
_T22d:
	__asm        mov    eax, Width;
	__asm        cmp    ScreenWidth, eax;
	__asm        jae    _T23f;
// LINE 142:
	Width = ScreenWidth;
// LINE 143:
_T23f:
	__asm        mov    eax, Height;
	__asm        cmp    ScreenHeight, eax;
	__asm        jae    _T251;
// LINE 144:
	Height = ScreenHeight;
// LINE 147:
_T251:
	__asm        mov    eax, ScreenWidth;
	__asm        shr    eax, 1;
	__asm        mov    ecx, Width;
	__asm        shr    ecx, 1;
	__asm        sub    eax, ecx;
	__asm        mov    Left, eax;
// LINE 148:
	__asm        mov    eax, ScreenHeight;
	__asm        shr    eax, 1;
	__asm        mov    ecx, Height;
	__asm        shr    ecx, 1;
	__asm        sub    eax, ecx;
	__asm        mov    Top, eax;
// LINE 152:
	__asm        push   0;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, Height;
	__asm        push   eax;
	__asm        mov    eax, Width;
	__asm        push   eax;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, dwWindowsStyle;
	__asm        push   eax;
	__asm        mov    eax, Caption;
	__asm        push   eax;
	__asm        push   0x599AB8;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3808];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x18], eax;
// LINE 155:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T5b7;
// LINE 156:
// Block start:
	/*bp-0x54*/  int32_t Counter;
	/*bp-0x58*/  int32_t Start;
	/*bp-0x5c*/  int32_t End;
	/*bp-0x60*/  uint32_t PaletteUse;
	/*bp-0x64*/  int32_t StaticCount;
	/*bp-0x68*/  void * __ptr32 hdc;
	/*bp-0x46c*/ /*packed*/ struct CSparkalWindow::__ctor::__unnamed LogPalette; // 0x404 bytes
	__asm        lea    eax, WindowRect.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C382C];
// LINE 157:
	__asm        mov    eax, WindowRect.right;
	__asm        sub    eax, WindowRect.left;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
// LINE 158:
	__asm        mov    eax, WindowRect.bottom;
	__asm        sub    eax, WindowRect.top;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+4], eax;
// LINE 165:
	__asm        mov    LogPalette.Version, 0x300;
	__asm        mov    LogPalette.NumberOfEntries, 0x100;
	__asm        lea    edi, LogPalette.aEntries[0].peRed;
	__asm        xor    eax, eax;
	__asm        mov    ecx, 0x100;
	__asm        rep stosd;
// LINE 169:
	StaticCount = 0x14;
// LINE 170:
	PaletteUse = 0x1;
// LINE 172:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 173:
	__asm        cmp    hdc, 0;
	__asm        je     _T373;
// LINE 174:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3588];
	__asm        mov    PaletteUse, eax;
// LINE 175:
	__asm        push   0x18;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3590];
	__asm        mov    StaticCount, eax;
// LINE 176:
	__asm        lea    eax, LogPalette.aEntries[0].peRed;
	__asm        push   eax;
	__asm        push   0x100;
	__asm        push   0;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3580];
// LINE 177:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 181:
_T373:
	__asm        mov    eax, StaticCount;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    Start, eax;
// LINE 182:
	__asm        mov    ecx, 0x100;
	__asm        mov    eax, StaticCount;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    End, ecx;
// LINE 184:
	__asm        cmp    PaletteUse, 2;
	__asm        jne    _T3aa;
// LINE 185:
	Start = 0x1;
// LINE 186:
	End = 0xff;
// LINE 192:
_T3aa:
	__asm        mov    Counter, 0;
	__asm        jmp    _T3b9;
_T3b6:
	Counter++;
_T3b9:
	__asm        mov    eax, Start;
	__asm        cmp    Counter, eax;
	__asm        jge    _T3d5;
// LINE 193:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x465], 0;
	__asm        jmp    _T3b6;
// LINE 196:
_T3d5:
	__asm        cmp    pColors, 0;
	__asm        je     _T443;
// LINE 197:
	__asm        jmp    _T3e7;
_T3e4:
	Counter++;
_T3e7:
	__asm        mov    eax, End;
	__asm        cmp    Counter, eax;
	__asm        jge    _T43e;
// LINE 198:
	__asm        mov    eax, Counter;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4];
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x466], al;
// LINE 199:
	__asm        mov    eax, Counter;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+1];
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x467], al;
// LINE 200:
	__asm        mov    eax, Counter;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+2];
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x468], al;
// LINE 201:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x465], 5;
// LINE 202:
	__asm        jmp    _T3e4;
// LINE 204:
_T43e:
	__asm        jmp    _T48e;
// LINE 205:
_T443:
	__asm        jmp    _T44b;
_T448:
	Counter++;
_T44b:
	__asm        mov    eax, End;
	__asm        cmp    Counter, eax;
	__asm        jge    _T48e;
// LINE 206:
	__asm        mov    al, reinterpret_cast<uint8_t>(Counter);
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x466], al;
// LINE 207:
	__asm        mov    al, reinterpret_cast<uint8_t>(Counter);
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x467], al;
// LINE 208:
	__asm        mov    al, reinterpret_cast<uint8_t>(Counter);
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x468], al;
// LINE 209:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x465], 5;
// LINE 210:
	__asm        jmp    _T448;
// LINE 214:
_T48e:
	__asm        jmp    _T496;
_T493:
	Counter++;
_T496:
	__asm        cmp    Counter, 0x100;
	__asm        jge    _T4b3;
// LINE 215:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x465], 0;
	__asm        jmp    _T493;
// LINE 218:
_T4b3:
	__asm        lea    eax, LogPalette.Version;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C357C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1C], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    [ebp-0x470], eax;
// LINE 222:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, [ebp-0x470];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C380C];
	__asm        jmp    _T4f3;
// LINE 224:
_T4f3:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3820];
// LINE 225:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3864];
// LINE 228:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 229:
	__asm        cmp    hdc, 0;
	__asm        je     _T5b7;
// LINE 230:
	__asm        push   1;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3584];
// LINE 231:
	__asm        push   1;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3574];
// LINE 232:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3570];
// LINE 233:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3578];
// LINE 235:
	__asm        lea    eax, LogPalette.aEntries[0].peRed;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   CheckIdentityPalette;
	__asm        add    esp, 0xC;
	__asm        test   eax, eax;
	__asm        jne    _T5a3;
// LINE 236:
	__asm        push   0;
	__asm        push   0x599AC4;
	__asm        push   0x599ACC;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3870];
// LINE 238:
_T5a3:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 241:
// Block end:
_T5b7:
	return;
_T5bc:
	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00480d01
void CSparkalWindow::~CSparkalWindow() {
	/*bp-0x4*/   int32_t i;


	this-><vftable> = 0x590ef8;
// LINE 251:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T4b;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    [ebp-8], eax;
// LINE 254:
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C380C];
	__asm        jmp    _T3e;
// LINE 255:
_T3e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3804];
// LINE 257:
_T4b:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1C], 0;
	__asm        je     _T65;
// LINE 258:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 259:
_T65:
	__asm        mov    i, 0;
	__asm        jmp    _T74;
_T71:
	i++;
_T74:
	__asm        cmp    i, 0x10;
	__asm        jge    _Ta5;
// LINE 260:
	__asm        mov    eax, i;
	__asm        mov    ecx, this;
	__asm        cmp    dword ptr [ecx+eax*4+0x28], 0;
	__asm        je     _Ta0;
// LINE 261:
	__asm        mov    eax, i;
	__asm        mov    ecx, this;
	__asm        mov    eax, [ecx+eax*4+0x28];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 262:
_Ta0:
	__asm        jmp    _T71;
// LINE 267:
_Ta5:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x24], 0;
	__asm        je     _Tbf;
// LINE 268:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 269:
_Tbf:
	return;
_Tc4:
}

// FUNCTION: COPTER_D 0x00480dca
unsigned long CSparkalWindow::GetClientSize(long * pWidth, long * pHeight) {
	/*bp-0x4*/   unsigned long Error;

// LINE 277:
	__asm        cmp    pWidth, 0;
	__asm        je     _T20;

	__asm        cmp    pHeight, 0;
	__asm        jne    _T3c;
_T20:
	__asm        push   0x115;
	__asm        push   0x599AF0;
	__asm        push   0x599B18;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T41;
_T3c:
	__asm        jmp    _T41;
// LINE 279:
_T41:
	Error = 0x0;
// LINE 281:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T81;
// LINE 283:
// Block start:
	/*bp-0x14*/  /*packed*/ struct tagRECT r; // 0x10 bytes
	__asm        lea    eax, r.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C382C];
// LINE 284:
	__asm        mov    eax, r.right;
	__asm        sub    eax, r.left;
	__asm        mov    ecx, pWidth;
	__asm        mov    [ecx], eax;
// LINE 285:
	__asm        mov    eax, r.bottom;
	__asm        sub    eax, r.top;
	__asm        mov    ecx, pHeight;
	__asm        mov    [ecx], eax;
// LINE 287:
// Block end:
	__asm        jmp    _T9b;
// LINE 288:
_T81:
	__asm        mov    eax, pHeight;
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, pHeight;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, pWidth;
	__asm        mov    [ecx], eax;
// LINE 289:
	Error = 0x80000000;
// LINE 292:
_T9b:
	__asm        mov    eax, Error;
	__asm        jmp    _Ta3;
// LINE 293:
_Ta3:
}

// FUNCTION: COPTER_D 0x00480e74
unsigned long CSparkalWindow::SetCursor(unsigned long CursorID) {
	/*bp-0x4*/   unsigned long ReturnCode;
	/*bp-0x8*/   void * __ptr32 hNewCursor;

// LINE 309:
	ReturnCode = 0x0;
// LINE 312:
	__asm        cmp    CursorID, 0;
	__asm        je     _T67;
// LINE 313:
	__asm        mov    eax, CursorID;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3818];
	__asm        mov    hNewCursor, eax;
// LINE 314:
	__asm        cmp    hNewCursor, 0;
	__asm        je     _T59;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x24], 0;
	__asm        je     _T59;
// LINE 315:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 316:
_T59:
	this->mhCustomCursor = hNewCursor;
// LINE 318:
	__asm        jmp    _T77;
// LINE 319:
_T67:
	__asm        push   0x7F00;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3818];
	__asm        mov    hNewCursor, eax;
// LINE 321:
_T77:
	this->mhCurrentCursor = hNewCursor;
// LINE 323:
	__asm        cmp    hNewCursor, 0;
	__asm        je     _Ta8;
// LINE 324:
	__asm        mov    eax, hNewCursor;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C388C];
	__asm        test   eax, eax;
	__asm        jne    _Ta3;
// LINE 325:
	ReturnCode = 0x80000000;
// LINE 327:
_Ta3:
	__asm        jmp    _Taf;
// LINE 328:
_Ta8:
	ReturnCode = 0x80000007;
// LINE 329:
_Taf:
	__asm        mov    eax, ReturnCode;
	__asm        jmp    _Tb7;
// LINE 330:
_Tb7:
}

// FUNCTION: COPTER_D 0x00480f32
unsigned long CSparkalWindow::SetCursorFromIndex(int32_t nIndex) {
	/*bp-0x4*/   unsigned long ReturnCode;

// LINE 338:
	ReturnCode = 0x0;
// LINE 340:
	__asm        mov    eax, nIndex;
	__asm        mov    ecx, this;
	__asm        mov    eax, [ecx+eax*4+0x28];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x20], eax;
// LINE 341:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C388C];
	__asm        test   eax, eax;
	__asm        jne    _T3f;
// LINE 342:
	ReturnCode = 0x80000007;
// LINE 344:
_T3f:
	__asm        mov    eax, ReturnCode;
	__asm        jmp    _T47;
// LINE 345:
_T47:
}

// FUNCTION: COPTER_D 0x00480f80
unsigned long CSparkalWindow::LoadGameCursors() {
// LINE 353:
	__asm        mov    eax, 0x80000007;
	__asm        jmp    _T16;
// LINE 354:
_T16:
}

// FUNCTION: COPTER_D 0x00480f9b
void CSparkalWindow::FreeGameCursors() {
// LINE 362:
	return;
_T11:
}

// FUNCTION: COPTER_D 0x00480fb1
unsigned long CSparkalWindow::DrawBufferText(const const char *pText, unsigned long Style, long Left, long Top, long * pRectLeft, long * pRectTop, long * pRectRight, long * pRectBottom) {
	/*bp-0x10*/  /*packed*/ struct tagRECT TextRect; // 0x10 bytes
	/*bp-0x18*/  /*packed*/ struct tagSIZE TextSize; // 0x8 bytes
	/*bp-0x1c*/  long ClientWidth;
	/*bp-0x20*/  uint32_t Length;
	/*bp-0x24*/  long ClientHeight;
	/*bp-0x28*/  void * __ptr32 DeviceContext;

// LINE 373:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        jne    _T35;

	__asm        push   0x175;
	__asm        push   0x599B2C;
	__asm        push   0x599B54;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T3a;
_T35:
	__asm        jmp    _T3a;
// LINE 376:
_T3a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    DeviceContext, eax;
// LINE 380:
	__asm        mov    eax, pText;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3608];
	__asm        mov    Length, eax;
// LINE 383:
	__asm        lea    eax, TextSize.cx;
	__asm        push   eax;
	__asm        mov    eax, Length;
	__asm        push   eax;
	__asm        mov    eax, pText;
	__asm        push   eax;
	__asm        mov    eax, DeviceContext;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35A4];
// LINE 389:
	__asm        test   reinterpret_cast<uint8_t>(Style), 1;
	__asm        je     _T90;
// LINE 390:
	__asm        mov    ecx, Left;
	__asm        mov    eax, TextSize.cx;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        sub    ecx, 2;
	__asm        mov    TextRect.left, ecx;
// LINE 391:
	__asm        jmp    _T99;
// LINE 392:
_T90:
	__asm        mov    eax, Left;
	__asm        sub    eax, 2;
	__asm        mov    TextRect.left, eax;
// LINE 394:
_T99:
	__asm        test   reinterpret_cast<uint8_t>(Style), 2;
	__asm        je     _Tbc;
// LINE 395:
	__asm        mov    ecx, Top;
	__asm        mov    eax, TextSize.cy;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        sub    ecx, 2;
	__asm        mov    TextRect.top, ecx;
// LINE 396:
	__asm        jmp    _Tc5;
// LINE 397:
_Tbc:
	__asm        mov    eax, Top;
	__asm        sub    eax, 2;
	__asm        mov    TextRect.top, eax;
// LINE 399:
_Tc5:
	__asm        mov    eax, TextSize.cx;
	__asm        add    eax, TextRect.left;
	__asm        add    eax, 2;
	__asm        mov    TextRect.right, eax;
// LINE 400:
	__asm        mov    eax, TextRect.top;
	__asm        add    eax, TextSize.cy;
	__asm        add    eax, 2;
	__asm        mov    TextRect.bottom, eax;
// LINE 404:
	__asm        lea    eax, ClientHeight;
	__asm        push   eax;
	__asm        lea    eax, ClientWidth;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 407:
	__asm        mov    eax, ClientWidth;
	__asm        cmp    TextRect.right, eax;
	__asm        jl     _T10f;
// LINE 409:
	__asm        mov    eax, ClientWidth;
	__asm        dec    eax;
	__asm        mov    TextRect.right, eax;
// LINE 410:
	__asm        mov    eax, TextRect.right;
	__asm        sub    eax, TextSize.cx;
	__asm        sub    eax, 4;
	__asm        mov    TextRect.left, eax;
// LINE 412:
_T10f:
	__asm        cmp    TextRect.left, 0;
	__asm        jge    _T129;
// LINE 414:
	__asm        mov    eax, TextSize.cx;
	__asm        add    eax, 4;
	__asm        mov    TextRect.right, eax;
// LINE 415:
	TextRect.left = 0x0;
// LINE 417:
_T129:
	__asm        cmp    TextRect.top, 0;
	__asm        jge    _T143;
// LINE 419:
	__asm        mov    eax, TextSize.cy;
	__asm        add    eax, 4;
	__asm        mov    TextRect.bottom, eax;
// LINE 420:
	TextRect.top = 0x0;
// LINE 422:
_T143:
	__asm        mov    eax, ClientHeight;
	__asm        cmp    TextRect.bottom, eax;
	__asm        jl     _T162;
// LINE 424:
	__asm        mov    eax, ClientHeight;
	__asm        dec    eax;
	__asm        mov    TextRect.bottom, eax;
// LINE 425:
	__asm        mov    eax, TextRect.bottom;
	__asm        sub    eax, TextSize.cy;
	__asm        sub    eax, 4;
	__asm        mov    TextRect.top, eax;
// LINE 430:
_T162:
	__asm        test   reinterpret_cast<uint8_t>(Style), 4;
	__asm        je     _T183;
// LINE 431:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3560];
	__asm        push   eax;
	__asm        lea    eax, TextRect.left;
	__asm        push   eax;
	__asm        mov    eax, DeviceContext;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3888];
// LINE 436:
_T183:
	__asm        mov    eax, Length;
	__asm        push   eax;
	__asm        mov    eax, pText;
	__asm        push   eax;
	__asm        mov    eax, TextRect.top;
	__asm        add    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, TextRect.left;
	__asm        add    eax, 2;
	__asm        push   eax;
	__asm        mov    eax, DeviceContext;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3558];
// LINE 439:
	__asm        mov    eax, DeviceContext;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 443:
	__asm        cmp    pRectLeft, 0;
	__asm        je     _T1fc;

	__asm        cmp    pRectTop, 0;
	__asm        je     _T1fc;

	__asm        cmp    pRectRight, 0;
	__asm        je     _T1fc;

	__asm        cmp    pRectBottom, 0;
	__asm        je     _T1fc;
// LINE 445:
	pRectLeft[0] = TextRect.left;
// LINE 446:
	pRectRight[0] = TextRect.right;
// LINE 447:
	pRectTop[0] = TextRect.top;
// LINE 448:
	pRectBottom[0] = TextRect.bottom;
// LINE 451:
_T1fc:
	__asm        xor    eax, eax;
	__asm        jmp    _T203;
// LINE 452:
_T203:
}

// FUNCTION: COPTER_D 0x004811bb
unsigned long CSparkalWindow::ScreenScroll(long Left, long Top, long Right, long Bottom, long ScrollRightAmount, long ScrollDownAmount) {
	/*bp-0x4*/   void * __ptr32 hdc;

// LINE 463:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        jne    _T35;

	__asm        push   0x1CF;
	__asm        push   0x599B5C;
	__asm        push   0x599B84;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T3a;
_T35:
	__asm        jmp    _T3a;
// LINE 465:
_T3a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 466:
	__asm        cmp    hdc, 0;
	__asm        je     _T9c;
// LINE 469:
	__asm        push   0xCC0020;
	__asm        mov    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        mov    eax, Bottom;
	__asm        sub    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Right;
	__asm        sub    eax, Left;
	__asm        push   eax;
	__asm        mov    eax, ScrollDownAmount;
	__asm        add    eax, Top;
	__asm        push   eax;
	__asm        mov    eax, Left;
	__asm        add    eax, ScrollRightAmount;
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35B4];
// LINE 470:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 473:
_T9c:
	__asm        xor    eax, eax;
	__asm        jmp    _Ta3;
// LINE 474:
_Ta3:
}

// FUNCTION: COPTER_D 0x00481265
void CSparkalWindow::UpdatePalette(long start, long count, /*packed*/ struct SparkalColor *pColor) {
	/*bp-0x400*/ /*packed*/ struct tagPALETTEENTRY palColors[256]; // 0x400 bytes
	/*bp-0x404*/ int32_t i;

// LINE 486:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1C], 0;
	__asm        je     _Tba;
// LINE 487:
	__asm        mov    eax, start;
	__asm        mov    i, eax;
	__asm        jmp    _T36;
_T30:
	i++;
_T36:
	__asm        mov    eax, count;
	__asm        add    eax, start;
	__asm        cmp    eax, i;
	__asm        jle    _T97;
// LINE 488:
	__asm        mov    eax, pColor;
	__asm        mov    al, [eax+2];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x400], al;
// LINE 489:
	__asm        mov    eax, pColor;
	__asm        mov    al, [eax+1];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x3FF], al;
// LINE 490:
	__asm        mov    eax, pColor;
	__asm        mov    al, [eax];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x3FE], al;
// LINE 491:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3FD], 5;
// LINE 492:
	pColor += 0x4;
// LINE 493:
	__asm        jmp    _T30;
// LINE 494:
_T97:
	__asm        mov    eax, start;
	__asm        lea    eax, [ebp+eax*4-0x400];
	__asm        push   eax;
	__asm        mov    eax, count;
	__asm        push   eax;
	__asm        mov    eax, start;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35AC];
// LINE 496:
_Tba:
	return;
_Tbf:
}

// FUNCTION: COPTER_D 0x0048132b
int32_t CheckIdentityPalette(void * __ptr32 hdc, void * __ptr32 hPalette, /*packed*/ struct tagPALETTEENTRY *pColors) {
	/*bp-0x100*/ unsigned char Bits[256]; // 0x100 bytes
	/*bp-0x104*/ void * __ptr32 MemDC;
	/*bp-0x108*/ int32_t IsID;
	/*bp-0x10c*/ int32_t i;
	/*bp-0x110*/ int32_t nReturnValue;

// LINE 506:
	IsID = 0x0;
// LINE 512:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35C8];
	__asm        mov    MemDC, eax;
// LINE 513:
	__asm        cmp    MemDC, 0;
	__asm        je     _T2a2;
// LINE 514:
// Block start:
	/*bp-0x114*/ void * __ptr32 MemBitmap;
	__asm        push   1;
	__asm        push   0x100;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35BC];
	__asm        mov    MemBitmap, eax;
// LINE 515:
	__asm        cmp    MemBitmap, 0;
	__asm        je     _T295;
// LINE 516:
// Block start:
	/*bp-0x118*/ void * __ptr32 Mono;
	/*bp-0x540*/ /*packed*/ struct CheckIdentityPalette::__unnamed Info; // 0x428 bytes
	__asm        mov    eax, MemBitmap;
	__asm        push   eax;
	__asm        mov    eax, MemDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
	__asm        mov    Mono, eax;
// LINE 517:
	__asm        push   0;
	__asm        mov    eax, hPalette;
	__asm        push   eax;
	__asm        mov    eax, MemDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3570];
// LINE 525:
	Info.Header.biSize = 0x28;
// LINE 526:
	Info.Header.biWidth = 0x100;
// LINE 527:
	Info.Header.biHeight = 0x1;
// LINE 528:
	Info.Header.biPlanes = 0x1;
// LINE 529:
	Info.Header.biBitCount = 0x8;
// LINE 530:
	Info.Header.biCompression = 0x0;
// LINE 531:
	Info.Header.biSizeImage = 0x0;
// LINE 532:
	Info.Header.biXPelsPerMeter = 0x0;
// LINE 533:
	Info.Header.biYPelsPerMeter = 0x0;
// LINE 534:
	Info.Header.biClrUsed = 0x0;
// LINE 535:
	Info.Header.biClrImportant = 0x0;
// LINE 537:
	__asm        mov    i, 0;
	__asm        jmp    _T105;
_Tff:
	i++;
_T105:
	__asm        cmp    i, 0x100;
	__asm        jge    _T175;
// LINE 538:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x516], al;
// LINE 539:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+1];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x517], al;
// LINE 540:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+2];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x518], al;
// LINE 541:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x515], 0;
// LINE 542:
	__asm        jmp    _Tff;
// LINE 545:
_T175:
	__asm        mov    i, 0;
	__asm        jmp    _T18a;
_T184:
	i++;
_T18a:
	__asm        cmp    i, 0x100;
	__asm        jge    _T1b2;
// LINE 546:
	__asm        mov    al, reinterpret_cast<uint8_t>(i);
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx-0x100], al;
	__asm        jmp    _T184;
// LINE 549:
_T1b2:
	__asm        push   0xCC0020;
	__asm        push   0;
	__asm        lea    eax, Info.Header.biSize;
	__asm        push   eax;
	__asm        lea    eax, Bits[0];
	__asm        push   eax;
	__asm        push   1;
	__asm        push   0x100;
	__asm        push   0;
	__asm        push   0;
	__asm        push   1;
	__asm        push   0x100;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, MemDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35B8];
	__asm        mov    nReturnValue, eax;
// LINE 551:
	__asm        cmp    nReturnValue, 0xFFFFFFFF;
	__asm        je     _T274;
// LINE 553:
	IsID = 0x1;
// LINE 554:
	__asm        lea    eax, Bits[0];
	__asm        push   eax;
	__asm        push   0x100;
	__asm        mov    eax, MemBitmap;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35C0];
// LINE 555:
	__asm        mov    i, 0;
	__asm        jmp    _T235;
_T22f:
	i++;
_T235:
	__asm        cmp    i, 0x100;
	__asm        jge    _T274;
// LINE 556:
	__asm        mov    eax, i;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [ebp+eax-0x100];
	__asm        cmp    ecx, i;
	__asm        je     _T26f;
// LINE 557:
	IsID = 0x0;
// LINE 558:
	__asm        jmp    _T274;
// LINE 560:
_T26f:
	__asm        jmp    _T22f;
// LINE 563:
_T274:
	__asm        mov    eax, Mono;
	__asm        push   eax;
	__asm        mov    eax, MemDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C359C];
// LINE 564:
	__asm        mov    eax, MemBitmap;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C358C];
// LINE 567:
// Block end:
_T295:
	__asm        mov    eax, MemDC;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35B0];
// LINE 570:
// Block end:
_T2a2:
	__asm        mov    eax, IsID;
	__asm        jmp    _T2ad;
// LINE 571:
_T2ad:
}

// FUNCTION: COPTER_D 0x004815dd
long SparkalWindowProc(void * __ptr32 Window, uint32_t Message, uint32_t wParam, long lParam) {
	/*bp-0x4*/   /*packed*/ class CSparkalWindow *pWindow;

// LINE 585:
	__asm        jmp    _T0e;
_T0e:
	__asm        push   0;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3868];
	__asm        mov    pWindow, eax;
// LINE 586:
	__asm        cmp    pWindow, 0;
	__asm        je     _T48;
// LINE 587:
	__asm        mov    eax, lParam;
	__asm        push   eax;
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, Message;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        mov    eax, pWindow;
	__asm        push   eax;
	__asm        mov    eax, pWindow;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x30];
	__asm        jmp    _T63;
// LINE 588:
_T48:
	__asm        mov    eax, lParam;
	__asm        push   eax;
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, Message;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3860];
	__asm        jmp    _T63;
// LINE 589:
_T63:
}

// FUNCTION: COPTER_D 0x00481647
long CSparkalWindow::MySparkalWindowProc(void * __ptr32 Window, uint32_t Message, uint32_t wParam, long lParam) {
// LINE 603:
	__asm        mov    eax, Message;
	__asm        mov    [ebp-0x70], eax;
	__asm        jmp    _T3a7;
// LINE 608:
// Block start:
	/*bp-0x40*/  /*packed*/ struct tagPAINTSTRUCT Paint; // 0x40 bytes
	/*bp-0x44*/  void * __ptr32 hdc;
_T14:
	__asm        mov    eax, Window;
	__asm        cmp    wParam, eax;
	__asm        jne    _T25;
// LINE 609:
	__asm        jmp    _T468;
// LINE 612:
_T25:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1C], 0;
	__asm        je     _T8d;
// LINE 614:
// Block start:
	/*bp-0x48*/  void * __ptr32 hdc;
	/*bp-0x4c*/  int32_t bRedraw;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 616:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3570];
// LINE 617:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3578];
	__asm        mov    bRedraw, eax;
// LINE 618:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 619:
	__asm        cmp    bRedraw, 0;
	__asm        je     _T85;
// LINE 620:
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3824];
// LINE 621:
_T85:
	__asm        mov    eax, bRedraw;
	__asm        jmp    _T483;
// LINE 623:
// Block end:
_T8d:
	__asm        jmp    _T468;
// LINE 626:
_T92:
	__asm        cmp    wParam, 0;
	__asm        je     _Tba;
// LINE 627:
	__asm        jmp    _Ta1;
_Ta1:
	__asm        mov    eax, _gSparkalApp;
	__asm        mov    [ebp-0x54], eax;
	__asm        mov    eax, [ebp-0x54];
	__asm        or     dword ptr [eax+0xC], 2;
	__asm        jmp    _Tb5;
// LINE 628:
_Tb5:
	__asm        jmp    _Td3;
// LINE 629:
_Tba:
	__asm        jmp    _Tbf;
_Tbf:
	__asm        mov    eax, _gSparkalApp;
	__asm        mov    [ebp-0x60], eax;
	__asm        mov    eax, [ebp-0x60];
	__asm        and    dword ptr [eax+0xC], 0xFFFFFFFD;
	__asm        jmp    _Td3;
// LINE 631:
_Td3:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1C], 0;
	__asm        je     _T125;
// LINE 632:
// Block start:
	/*bp-0x50*/  void * __ptr32 hdc;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 633:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35CC];
// LINE 634:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3570];
// LINE 635:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3578];
// LINE 636:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 638:
// Block end:
_T125:
	__asm        jmp    _T468;
// LINE 642:
	__asm        jmp    _T12f;
_T12f:
	__asm        mov    eax, _gSparkalApp;
	__asm        mov    [ebp-0x64], eax;
	__asm        mov    eax, [ebp-0x64];
	__asm        and    dword ptr [eax+0xC], 0xFFFFFFFE;
	__asm        jmp    _T143;
// LINE 643:
_T143:
	this->mWindow = 0x0;
// LINE 644:
	__asm        jmp    _T468;
// LINE 649:
_T152:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T193;
// LINE 650:
	__asm        test   wParam, 0xFFFF;
	__asm        je     _T182;
// LINE 651:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x18];
// LINE 652:
	__asm        jmp    _T193;
// LINE 653:
_T182:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x1C];
// LINE 655:
_T193:
	__asm        jmp    _T468;
// LINE 658:
_T198:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T1c3;
// LINE 659:
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+8];
// LINE 660:
_T1c3:
	__asm        jmp    _T468;
// LINE 663:
_T1c8:
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38A0];
// LINE 664:
	__asm        jmp    _T1d7;
_T1d7:
	__asm        mov    eax, _gSparkalApp;
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        or     dword ptr [eax+0xC], 4;
	__asm        jmp    _T1eb;
// LINE 665:
_T1eb:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T221;
// LINE 666:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0xC];
// LINE 667:
_T221:
	__asm        jmp    _T468;
// LINE 670:
_T226:
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38A0];
// LINE 671:
	__asm        jmp    _T235;
_T235:
	__asm        mov    eax, _gSparkalApp;
	__asm        mov    [ebp-0x5C], eax;
	__asm        mov    eax, [ebp-0x5C];
	__asm        or     dword ptr [eax+0xC], 8;
	__asm        jmp    _T249;
// LINE 672:
_T249:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T27f;
// LINE 673:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0xC];
// LINE 674:
_T27f:
	__asm        jmp    _T468;
// LINE 677:
_T284:
	__asm        call   dword ptr ds:[0x6C38A8];
// LINE 678:
	__asm        jmp    _T28f;
_T28f:
	__asm        mov    eax, _gSparkalApp;
	__asm        mov    [ebp-0x68], eax;
	__asm        mov    eax, [ebp-0x68];
	__asm        and    dword ptr [eax+0xC], 0xFFFFFFFB;
	__asm        jmp    _T2a3;
// LINE 679:
_T2a3:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T2d9;
// LINE 680:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x10];
// LINE 681:
_T2d9:
	__asm        jmp    _T468;
// LINE 684:
_T2de:
	__asm        call   dword ptr ds:[0x6C38A8];
// LINE 685:
	__asm        jmp    _T2e9;
_T2e9:
	__asm        mov    eax, _gSparkalApp;
	__asm        mov    [ebp-0x6C], eax;
	__asm        mov    eax, [ebp-0x6C];
	__asm        and    dword ptr [eax+0xC], 0xFFFFFFF7;
	__asm        jmp    _T2fd;
// LINE 686:
_T2fd:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T333;
// LINE 687:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x10];
// LINE 688:
_T333:
	__asm        jmp    _T468;
// LINE 691:
_T338:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T36e;
// LINE 692:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x14];
// LINE 693:
_T36e:
	__asm        jmp    _T468;
// LINE 699:
_T373:
	__asm        lea    eax, Paint.hdc;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3838];
	__asm        mov    hdc, eax;
// LINE 700:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+8];
// LINE 701:
	__asm        lea    eax, Paint.hdc;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3830];
// LINE 702:
	__asm        jmp    _T468;
// LINE 703:
// Block end:
	__asm        jmp    _T468;
_T3a7:
	__asm        cmp    dword ptr [ebp-0x70], 6;
	__asm        ja     _T3c6;

	__asm        je     _T152;

	__asm        cmp    dword ptr [ebp-0x70], 2;
	__asm        je     _T12f;

	__asm        jmp    _T468;
_T3c6:
	__asm        cmp    dword ptr [ebp-0x70], 0x1C;
	__asm        ja     _T3ef;

	__asm        je     _T92;

	__asm        cmp    dword ptr [ebp-0x70], 0xF;
	__asm        je     _T373;

	__asm        cmp    dword ptr [ebp-0x70], 0x10;
	__asm        je     _T12f;

	__asm        jmp    _T468;
_T3ef:
	__asm        cmp    dword ptr [ebp-0x70], 0x200;
	__asm        ja     _T414;

	__asm        je     _T338;

	__asm        cmp    dword ptr [ebp-0x70], 0x100;
	__asm        je     _T198;

	__asm        jmp    _T468;
_T414:
	__asm        cmp    dword ptr [ebp-0x70], 0x30F;
	__asm        ja     _T456;

	__asm        je     _T25;

	__asm        sub    dword ptr [ebp-0x70], 0x201;
	__asm        cmp    dword ptr [ebp-0x70], 4;
	__asm        ja     _T468;

	__asm        mov    eax, [ebp-0x70];
	__asm        jmp    _Switch_442[0][eax*4];
// Switch pointers:
//   _T1c8
//   _T284
//   _T468
//   _T226
//   _T2de
_T456:
	__asm        cmp    dword ptr [ebp-0x70], 0x311;
	__asm        je     _T14;

	__asm        jmp    _T468;
// LINE 705:
_T468:
	__asm        mov    eax, lParam;
	__asm        push   eax;
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, Message;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3860];
	__asm        jmp    _T483;
// LINE 706:
_T483:
}



// Contribution: 1:00080ae0-00080b18 Module: 30, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00481ae0
// CSparkalWindow::`scalar deleting destructor'



// Contribution: 2:00001ef8-00001f2b Module: 30, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for CSparkalWindow @ 0x00590ef8
//   00: CSparkalWindow::`scalar deleting destructor' @ 0x00481ae0
//   01: CSparkalWindow::GetClientSize @ 0x00480dca
//   02: CSparkalWindow::Draw @ 0x00432304
//   03: CSparkalWindow::SetCursor @ 0x00480e74
//   04: CSparkalWindow::SetCursorFromIndex @ 0x00480f32
//   05: CSparkalWindow::LoadGameCursors @ 0x00480f80
//   06: CSparkalWindow::FreeGameCursors @ 0x00480f9b
//   07: CSparkalWindow::Sleep @ 0x00468020
//   08: CSparkalWindow::WakeUp @ 0x00468040
//   09: CSparkalWindow::SwapBuffer @ 0x0043238c
//   10: CSparkalWindow::SwapBuffer @ 0x00432325
//   11: CSparkalWindow::UpdatePalette @ 0x00481265
//   12: CSparkalWindow::MySparkalWindowProc @ 0x00481647
//   13 entries



// Contribution: 3:00002ab8-00002b8b Module: 30, 8 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x00599ab8
char gWindowClassName[8] = {83, 112, 97, 114, 107, 97, 108, 0};

