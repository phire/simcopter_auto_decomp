// Module: prntscrn.obj
// Source: C:\Copter\source\sparkal\prntscrn.c
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: struct _dPoint2d (forward reference);
struct _dPoint2d{
	double x;
	double z;
};

// Type: short;

// Type: struct PCXHEAD;
struct PCXHEAD{
	char manufacturer;
	char version;
	char encoding;
	char bits_per_pixel;
	short xmin;
	short ymin;
	short xmax;
	short ymax;
	short hres;
	short vres;
	char palette[48];
	char reserved;
	char colour_planes;
	short bytes_per_line;
	short palette_type;
	char filler[58];
};

// Type: unsigned char;

// Type: struct tagPALETTEENTRY (forward reference);
struct tagPALETTEENTRY{
	unsigned char peRed;
	unsigned char peGreen;
	unsigned char peBlue;
	unsigned char peFlags;
};

// Type: void * __ptr32;

// Type: char *;

// Type: char;

// Type: void;

// Type: struct _iobuf (forward reference);
struct _iobuf{
	char * _ptr;
	int32_t _cnt;
	char * _base;
	int32_t _flag;
	int32_t _file;
	int32_t _charbuf;
	int32_t _bufsiz;
	char * _tmpfname;
};

// Type: unsigned short;



// Contribution: 1:0006a870-0006ac9e Module: 41, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0046b870
void S3PrintScreen() {
	char * chPalette;
	char fname[260];

// LINE 56:
	__asm        mov    eax, G_respal;
	__asm        push   eax;
	__asm        call   VRGetPalFromResource;
	__asm        add    esp, 4;
	__asm        mov    chPalette, eax;
// LINE 57:
	__asm        mov    ax, S_ctr;
	__asm        mov    [ebp-0x10C], ax;
	__asm        inc    S_ctr;
	__asm        movsx  eax, word ptr [ebp-0x10C];
	__asm        push   eax;
	__asm        push   0x599434;
	__asm        lea    eax, fname[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0xC;
// LINE 58:
	__asm        mov    eax, chPalette;
	__asm        push   eax;
	__asm        lea    eax, fname[0];
	__asm        push   eax;
	__asm        call   S3BufferPrint;
	__asm        add    esp, 8;
// LINE 59:
}

// FUNCTION: COPTER_D 0x0046b8db
void S3BufferPrint(char * fname, char * chPalette) {
	struct _iobuf *hFileOut;
	int32_t ydim;
	int32_t pitch;
	int32_t xdim;
	int32_t y;
	char * ptr;

// LINE 74:
	__asm        cmp    G_video_mode, 0x10;
	__asm        jne    _T33;
// LINE 76:
	xdim = swindow.WindowWide;
// LINE 77:
	ydim = swindow.WindowHigh;
// LINE 78:
	pitch = swindow.RenderWide;
// LINE 80:
	__asm        jmp    _T4b;
// LINE 82:
_T33:
	xdim = qwindow.WindowWide;
// LINE 83:
	ydim = qwindow.WindowHigh;
// LINE 84:
	pitch = qwindow.RenderWide;
// LINE 87:
_T4b:
	pcx.manufacturer = 0xa;
// LINE 88:
	pcx.encoding = 0x1;
// LINE 89:
	__asm        mov    pcx.ymin, 0;
	__asm        mov    ax, pcx.ymin;
	__asm        mov    pcx.xmin, ax;
// LINE 90:
	__asm        mov    eax, xdim;
	__asm        dec    eax;
	__asm        mov    pcx.xmax, ax;
// LINE 91:
	__asm        mov    eax, ydim;
	__asm        dec    eax;
	__asm        mov    pcx.ymax, ax;
// LINE 92:
	pcx.palette_type = 0x0;
// LINE 93:
	pcx.bits_per_pixel = 0x8;
// LINE 94:
	pcx.version = 0x5;
// LINE 95:
	pcx.colour_planes = 0x1;
// LINE 96:
	__asm        mov    eax, xdim;
	__asm        mov    pcx.bytes_per_line, ax;
// LINE 99:
	__asm        push   0x599444;
	__asm        mov    eax, fname;
	__asm        push   eax;
	__asm        call   fopen;
	__asm        add    esp, 8;
	__asm        mov    hFileOut, eax;
// LINE 100:
	__asm        cmp    hFileOut, 0;
	__asm        je     _T1e3;
// LINE 101:
	__asm        mov    eax, hFileOut;
	__asm        push   eax;
	__asm        push   1;
	__asm        push   0x80;
	__asm        push   0x603DC8;
	__asm        call   fwrite;
	__asm        add    esp, 0x10;
// LINE 103:
	ptr = buffer1;
// LINE 104:
	__asm        mov    y, 0;
	__asm        jmp    _Tf6;
_Tf3:
	__asm        inc    y;
_Tf6:
	__asm        mov    eax, y;
	__asm        cmp    ydim, eax;
	__asm        jle    _T121;
// LINE 106:
	__asm        mov    eax, xdim;
	__asm        push   eax;
	__asm        mov    eax, ptr;
	__asm        push   eax;
	__asm        mov    eax, hFileOut;
	__asm        push   eax;
	__asm        call   S3WritePCXLine;
	__asm        add    esp, 0xC;
// LINE 107:
	__asm        mov    eax, pitch;
	__asm        add    ptr, eax;
// LINE 108:
	__asm        jmp    _Tf3;
// LINE 109:
_T121:
	__asm        mov    eax, hFileOut;
	__asm        push   eax;
	__asm        push   0xC;
	__asm        call   fputc;
	__asm        add    esp, 8;
// LINE 111:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 112:
	__asm        push   0x603E48;
	__asm        push   0x100;
	__asm        push   0;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3580];
// LINE 113:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 114:
	__asm        mov    y, 0;
	__asm        jmp    _T171;
_T16e:
	__asm        inc    y;
_T171:
	__asm        cmp    y, 0x100;
	__asm        jge    _T1bf;
// LINE 116:
	__asm        mov    eax, y;
	__asm        mov    al, ppe[0].peRed[eax*4];
	__asm        mov    ecx, y;
	__asm        mov    wpal[ecx+ecx*2], al;
// LINE 117:
	__asm        mov    eax, y;
	__asm        mov    al, ppe[0].peGreen[eax*4];
	__asm        mov    ecx, y;
	__asm        mov    wpal[1][ecx+ecx*2], al;
// LINE 118:
	__asm        mov    eax, y;
	__asm        mov    al, ppe[0].peBlue[eax*4];
	__asm        mov    ecx, y;
	__asm        mov    wpal[2][ecx+ecx*2], al;
// LINE 119:
	__asm        jmp    _T16e;
// LINE 120:
_T1bf:
	__asm        mov    eax, hFileOut;
	__asm        push   eax;
	__asm        push   1;
	__asm        push   0x300;
	__asm        push   0x603AC0;
	__asm        call   fwrite;
	__asm        add    esp, 0x10;
// LINE 124:
	__asm        mov    eax, hFileOut;
	__asm        push   eax;
	__asm        call   fclose;
	__asm        add    esp, 4;
// LINE 127:
_T1e3:
}

// FUNCTION: COPTER_D 0x0046bac3
int32_t S3WritePCXLine(struct _iobuf *fp, char * p, unsigned short n) {
	unsigned short j;
	unsigned short i;
	unsigned short t;

// LINE 137:
	__asm        mov    i, 0;
	__asm        mov    j, 0;
	__asm        mov    t, 0;
// LINE 140:
_T1b:
	i = 0x0;
// LINE 141:
_T21:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(i);
	__asm        and    ecx, 0xFFFF;
	__asm        add    eax, ecx;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx+1];
	__asm        mov    ecx, reinterpret_cast<uint32_t>(t);
	__asm        and    ecx, 0xFFFF;
	__asm        mov    edx, reinterpret_cast<uint32_t>(i);
	__asm        and    edx, 0xFFFF;
	__asm        add    ecx, edx;
	__asm        mov    edx, p;
	__asm        movsx  ecx, byte ptr [ecx+edx];
	__asm        cmp    eax, ecx;
	__asm        jne    _T9d;

	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(i);
	__asm        and    ecx, 0xFFFF;
	__asm        add    eax, ecx;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(n);
	__asm        and    ecx, 0xFFFF;
	__asm        cmp    eax, ecx;
	__asm        jge    _T9d;

	__asm        mov    eax, reinterpret_cast<uint32_t>(i);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x3F;
	__asm        jge    _T9d;

	__asm        inc    i;
	__asm        jmp    _T21;
// LINE 142:
_T9d:
	__asm        test   reinterpret_cast<uint32_t>(i), 0xFFFF;
	__asm        jle    _T131;
// LINE 143:
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(i);
	__asm        and    eax, 0xFFFF;
	__asm        or     eax, 0xC0;
	__asm        push   eax;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _Td7;

	__asm        mov    eax, 0xFFFFFFFF;
	__asm        jmp    _T1d7;
// LINE 144:
_Td7:
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx];
	__asm        push   eax;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T106;

	__asm        mov    eax, 0xFFFFFFFF;
	__asm        jmp    _T1d7;
// LINE 145:
_T106:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(i);
	__asm        and    ecx, 0xFFFF;
	__asm        add    eax, ecx;
	__asm        mov    t, ax;
// LINE 146:
	__asm        mov    eax, reinterpret_cast<uint32_t>(j);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 2;
	__asm        mov    j, ax;
// LINE 148:
	__asm        jmp    _T1b1;
// LINE 149:
_T131:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx];
	__asm        and    al, 0xC0;
	__asm        cmp    al, 0xC0;
	__asm        jne    _T172;
// LINE 150:
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        push   0xC1;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T16e;

	__asm        mov    eax, 0xFFFFFFFF;
	__asm        jmp    _T1d7;
// LINE 151:
_T16e:
	__asm        inc    j;
// LINE 153:
_T172:
	__asm        mov    ax, t;
	__asm        mov    [ebp-0x10], ax;
	__asm        inc    t;
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx];
	__asm        push   eax;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T1ad;

	__asm        mov    eax, 0xFFFFFFFF;
	__asm        jmp    _T1d7;
// LINE 154:
_T1ad:
	__asm        inc    j;
// LINE 156:
_T1b1:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(n);
	__asm        and    ecx, 0xFFFF;
	__asm        cmp    eax, ecx;
	__asm        jl     _T1b;
// LINE 157:
	__asm        mov    eax, reinterpret_cast<uint32_t>(n);
	__asm        and    eax, 0xFFFF;
	__asm        jmp    _T1d7;
// LINE 158:
_T1d7:
}



// Contribution: 2:000014f8-00001707 Module: 41, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x005904f8
static const int32_t TurnTable3[4][8] = {{0, 1, 2, 3, 4, 5, 6, 7}, {2, 3, 4, 5, 6, 7, 0, 1}, {6, 7, 0, 1, 2, 3, 4, 5}, {4, 5, 6, 7, 0, 1, 2, 3}};

// GLOBAL: COPTER_D 0x00590578
static const int32_t TurnTable2[4][4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {3, 0, 1, 2}, {2, 3, 0, 1}};

// GLOBAL: COPTER_D 0x005905b8
static const int32_t IndexToType[4] = {1, 2, 4, 8};

// GLOBAL: COPTER_D 0x005905c8
static const int32_t TypeToIndex2[16] = {-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1};

// GLOBAL: COPTER_D 0x00590608
static const int32_t TILUT[4][4] = {{0, 1, 3, 2}, {2, 0, 1, 3}, {3, 2, 0, 1}, {1, 3, 2, 0}};

// GLOBAL: COPTER_D 0x00590648
static const struct _dPoint2d OT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00590688
static const struct _dPoint2d RRT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005906c8
static const struct _dPoint2d LRT[4] = { 0 /* todo */ };



// Contribution: 3:00002430-00002446 Module: 41, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x00599430
static short S_ctr = 0;



// Contribution: 3:0006cac0-0006d247 Module: 41, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00603ac0
static unsigned char wpal[768];

// GLOBAL: COPTER_D 0x00603dc0
static void * __ptr32 hdc;

// GLOBAL: COPTER_D 0x00603dc8
static struct PCXHEAD pcx;

// GLOBAL: COPTER_D 0x00603e48
static struct tagPALETTEENTRY ppe[256];

