// Module: prntscrn.obj
// Source: C:\Copter\source\sparkal\prntscrn.c
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: /*packed*/ struct _dPoint2d (forward reference);
struct _dPoint2d{ // packed(0x10 bytes) TI: 0x2766
	/*+0x0*/   double x; // 0x8 bytes
	/*+0x8*/   double z; // 0x8 bytes
};

// Type: short;

// Type: /*packed*/ struct PCXHEAD;
struct PCXHEAD{ // packed(0x80 bytes) TI: 0x2757
	/*+0x0*/   char manufacturer; // 0x1 bytes
	/*+0x1*/   char version; // 0x1 bytes
	/*+0x2*/   char encoding; // 0x1 bytes
	/*+0x3*/   char bits_per_pixel; // 0x1 bytes
	/*+0x4*/   short xmin; // 0x2 bytes
	/*+0x6*/   short ymin; // 0x2 bytes
	/*+0x8*/   short xmax; // 0x2 bytes
	/*+0xa*/   short ymax; // 0x2 bytes
	/*+0xc*/   short hres; // 0x2 bytes
	/*+0xe*/   short vres; // 0x2 bytes
	/*+0x10*/  char palette[48]; // 0x30 bytes
	/*+0x40*/  char reserved; // 0x1 bytes
	/*+0x41*/  char colour_planes; // 0x1 bytes
	/*+0x42*/  short bytes_per_line; // 0x2 bytes
	/*+0x44*/  short palette_type; // 0x2 bytes
	/*+0x46*/  char filler[58]; // 0x3a bytes
};

// Type: unsigned char;

// Type: /*packed*/ struct tagPALETTEENTRY (forward reference);
struct tagPALETTEENTRY{ // packed(0x4 bytes) TI: 0x1be6
	/*+0x0*/   unsigned char peRed; // 0x1 bytes
	/*+0x1*/   unsigned char peGreen; // 0x1 bytes
	/*+0x2*/   unsigned char peBlue; // 0x1 bytes
	/*+0x3*/   unsigned char peFlags; // 0x1 bytes
};

// Type: void * __ptr32;

// Type: char *;

// Type: char;

// Type: void;

// Type: /*packed*/ struct _iobuf (forward reference);
struct _iobuf{ // packed(0x20 bytes) TI: 0x2278
	/*+0x0*/   char * _ptr;
	/*+0x4*/   int32_t _cnt;
	/*+0x8*/   char * _base;
	/*+0xc*/   int32_t _flag;
	/*+0x10*/  int32_t _file;
	/*+0x14*/  int32_t _charbuf;
	/*+0x18*/  int32_t _bufsiz;
	/*+0x1c*/  char * _tmpfname;
};

// Type: unsigned short;



// Contribution: 1:0006a870-0006ac9e Module: 41, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0046b870
void S3PrintScreen() {
	/*bp-0x104*/ char fname[260]; // 0x104 bytes
	/*bp-0x108*/ char * chPalette;

// LINE 56:
	chPalette = VRGetPalFromResource(G_respal);
// LINE 57:
	__asm        mov    ax, S_ctr;
	__asm        mov    [ebp-0x10C], ax;
	__asm        inc    S_ctr;
	__asm        movsx  eax, word ptr [ebp-0x10C];
	__asm        push   eax;
	__asm        push   0x599434;
	__asm        lea    eax, fname[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0xC;
// LINE 58:
	S3BufferPrint(chPalette, fname[0]);
// LINE 59:
}

// FUNCTION: COPTER_D 0x0046b8db
void S3BufferPrint(char * fname, char * chPalette) {
	/*bp-0x4*/   char * ptr;
	/*bp-0x8*/   int32_t y;
	/*bp-0xc*/   int32_t xdim;
	/*bp-0x10*/  int32_t pitch;
	/*bp-0x14*/  int32_t ydim;
	/*bp-0x18*/  /*packed*/ struct _iobuf *hFileOut;

// LINE 74:
	__asm        cmp    G_video_mode, 0x10;
	__asm        jne    _T33;
// LINE 76:
	xdim = swindow.WindowWide;
// LINE 77:
	ydim = swindow.WindowHigh;
// LINE 78:
	pitch = swindow.RenderWide;
// LINE 80:
	__asm        jmp    _T4b;
// LINE 82:
_T33:
	xdim = qwindow.WindowWide;
// LINE 83:
	ydim = qwindow.WindowHigh;
// LINE 84:
	pitch = qwindow.RenderWide;
// LINE 87:
_T4b:
	pcx.manufacturer = 0xa;
// LINE 88:
	pcx.encoding = 0x1;
// LINE 89:
	__asm        mov    pcx.ymin, 0;
	__asm        mov    ax, pcx.ymin;
	__asm        mov    pcx.xmin, ax;
// LINE 90:
	__asm        mov    eax, xdim;
	__asm        dec    eax;
	__asm        mov    pcx.xmax, ax;
// LINE 91:
	__asm        mov    eax, ydim;
	__asm        dec    eax;
	__asm        mov    pcx.ymax, ax;
// LINE 92:
	pcx.palette_type = 0x0;
// LINE 93:
	pcx.bits_per_pixel = 0x8;
// LINE 94:
	pcx.version = 0x5;
// LINE 95:
	pcx.colour_planes = 0x1;
// LINE 96:
	__asm        mov    eax, xdim;
	__asm        mov    pcx.bytes_per_line, ax;
// LINE 99:
	hFileOut = fopen(0x599444, fname);
// LINE 100:
	__asm        cmp    hFileOut, 0;
	__asm        je     __RETURN;
// LINE 101:
	fwrite(hFileOut, 0x1, 0x80, 0x603dc8);
// LINE 103:
	ptr = buffer1;
// LINE 104:
	y = 0x0;
	__asm        jmp    _Tf6;
_Tf3:
	y++;
_Tf6:
	__asm        mov    eax, y;
	__asm        cmp    ydim, eax;
	__asm        jle    _T121;
// LINE 106:
	S3WritePCXLine(xdim, ptr, hFileOut);
// LINE 107:
	ptr += pitch;
// LINE 108:
	__asm        jmp    _Tf3;
// LINE 109:
_T121:
	fputc(hFileOut, 0xc);
// LINE 111:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 112:
	__asm        push   0x603E48;
	__asm        push   0x100;
	__asm        push   0;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3580];
// LINE 113:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 114:
	y = 0x0;
	__asm        jmp    _T171;
_T16e:
	y++;
_T171:
	__asm        cmp    y, 0x100;
	__asm        jge    _T1bf;
// LINE 116:
	__asm        mov    eax, y;
	__asm        mov    al, ppe[0].peRed[eax*4];
	__asm        mov    ecx, y;
	__asm        mov    wpal[ecx+ecx*2], al;
// LINE 117:
	__asm        mov    eax, y;
	__asm        mov    al, ppe[0].peGreen[eax*4];
	__asm        mov    ecx, y;
	__asm        mov    wpal[1][ecx+ecx*2], al;
// LINE 118:
	__asm        mov    eax, y;
	__asm        mov    al, ppe[0].peBlue[eax*4];
	__asm        mov    ecx, y;
	__asm        mov    wpal[2][ecx+ecx*2], al;
// LINE 119:
	__asm        jmp    _T16e;
// LINE 120:
_T1bf:
	fwrite(hFileOut, 0x1, 0x300, 0x603ac0);
// LINE 124:
	fclose(hFileOut);
// LINE 127:
__RETURN:
}

// FUNCTION: COPTER_D 0x0046bac3
int32_t S3WritePCXLine(/*packed*/ struct _iobuf *fp, char * p, unsigned short n) {
	/*bp-0x4*/   unsigned short t;
	/*bp-0x8*/   unsigned short i;
	/*bp-0xc*/   unsigned short j;

// LINE 137:
	i = 0x0;
	j = 0x0;
	t = 0x0;
// LINE 140:
_T1b:
	i = 0x0;
// LINE 141:
_T21:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(i);
	__asm        and    ecx, 0xFFFF;
	__asm        add    eax, ecx;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx+1];
	__asm        mov    ecx, reinterpret_cast<uint32_t>(t);
	__asm        and    ecx, 0xFFFF;
	__asm        mov    edx, reinterpret_cast<uint32_t>(i);
	__asm        and    edx, 0xFFFF;
	__asm        add    ecx, edx;
	__asm        mov    edx, p;
	__asm        movsx  ecx, byte ptr [ecx+edx];
	__asm        cmp    eax, ecx;
	__asm        jne    _T9d;

	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(i);
	__asm        and    ecx, 0xFFFF;
	__asm        add    eax, ecx;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(n);
	__asm        and    ecx, 0xFFFF;
	__asm        cmp    eax, ecx;
	__asm        jge    _T9d;

	__asm        mov    eax, reinterpret_cast<uint32_t>(i);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 0x3F;
	__asm        jge    _T9d;

	i++;
	__asm        jmp    _T21;
// LINE 142:
_T9d:
	__asm        test   reinterpret_cast<uint32_t>(i), 0xFFFF;
	__asm        jle    _T131;
// LINE 143:
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(i);
	__asm        and    eax, 0xFFFF;
	__asm        or     eax, 0xC0;
	__asm        push   eax;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _Td7;

	return 0xffffffff;
// LINE 144:
_Td7:
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx];
	__asm        push   eax;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T106;

	return 0xffffffff;
// LINE 145:
_T106:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(i);
	__asm        and    ecx, 0xFFFF;
	__asm        add    eax, ecx;
	__asm        mov    t, ax;
// LINE 146:
	__asm        mov    eax, reinterpret_cast<uint32_t>(j);
	__asm        and    eax, 0xFFFF;
	__asm        add    eax, 2;
	__asm        mov    j, ax;
// LINE 148:
	__asm        jmp    _T1b1;
// LINE 149:
_T131:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx];
	__asm        and    al, 0xC0;
	__asm        cmp    al, 0xC0;
	__asm        jne    _T172;
// LINE 150:
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        push   0xC1;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T16e;

	return 0xffffffff;
// LINE 151:
_T16e:
	j++;
// LINE 153:
_T172:
	__asm        mov    ax, t;
	__asm        mov    [ebp-0x10], ax;
	__asm        inc    t;
	__asm        mov    eax, fp;
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, p;
	__asm        movsx  eax, byte ptr [eax+ecx];
	__asm        push   eax;
	__asm        call   fputc;
	__asm        add    esp, 8;
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        jne    _T1ad;

	return 0xffffffff;
// LINE 154:
_T1ad:
	j++;
// LINE 156:
_T1b1:
	__asm        mov    eax, reinterpret_cast<uint32_t>(t);
	__asm        and    eax, 0xFFFF;
	__asm        mov    ecx, reinterpret_cast<uint32_t>(n);
	__asm        and    ecx, 0xFFFF;
	__asm        cmp    eax, ecx;
	__asm        jl     _T1b;
// LINE 157:
	return (reinterpret_cast<uint32_t>(n) & 0xffff);
// LINE 158:
}



// Contribution: 2:000014f8-00001707 Module: 41, 8 byte alignment, initialized_data, read, 
// GLOBAL: COPTER_D 0x005904f8
static const int32_t TurnTable3[4][8] = {{0, 1, 2, 3, 4, 5, 6, 7}, {2, 3, 4, 5, 6, 7, 0, 1}, {6, 7, 0, 1, 2, 3, 4, 5}, {4, 5, 6, 7, 0, 1, 2, 3}};

// GLOBAL: COPTER_D 0x00590578
static const int32_t TurnTable2[4][4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {3, 0, 1, 2}, {2, 3, 0, 1}};

// GLOBAL: COPTER_D 0x005905b8
static const int32_t IndexToType[4] = {1, 2, 4, 8};

// GLOBAL: COPTER_D 0x005905c8
static const int32_t TypeToIndex2[16] = {-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1};

// GLOBAL: COPTER_D 0x00590608
static const int32_t TILUT[4][4] = {{0, 1, 3, 2}, {2, 0, 1, 3}, {3, 2, 0, 1}, {1, 3, 2, 0}};

// GLOBAL: COPTER_D 0x00590648
static const /*packed*/ struct _dPoint2d OT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00590688
static const /*packed*/ struct _dPoint2d RRT[4] = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005906c8
static const /*packed*/ struct _dPoint2d LRT[4] = { 0 /* todo */ };



// Contribution: 3:00002430-00002446 Module: 41, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x00599430
static short S_ctr = 0;



// Contribution: 3:0006cac0-0006d247 Module: 41, 8 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x00603ac0
static unsigned char wpal[768];

// GLOBAL: COPTER_D 0x00603dc0
static void * __ptr32 hdc;

// GLOBAL: COPTER_D 0x00603dc8
static /*packed*/ struct PCXHEAD pcx;

// GLOBAL: COPTER_D 0x00603e48
static /*packed*/ struct tagPALETTEENTRY ppe[256];

