// Module: gamewin.obj
// Source: C:\Copter\source\sparkal\gamewin.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class GameWindow (forward reference);
// VTABLE: COPTER_D 0x00590470
class GameWindow : public CSparkalWindow
{ // packed(0x9c bytes) TI: 0x2460
public:
	void GameWindow(unsigned long, unsigned long, unsigned long, const /*packed*/ struct SparkalColor*, char *);
	virtual void ~GameWindow() /* override */;
	virtual int32_t Initialize(); // vtable+0x34
	virtual unsigned long CreateSparkalWindow(); // vtable+0x38
	virtual unsigned long SwapBuffer() /* override */;
	virtual unsigned long Draw() /* override */;
	virtual unsigned long MakePalette(const /*packed*/ struct SparkalColor*); // vtable+0x3c
	virtual void UpdatePalette(long, long, /*packed*/ struct SparkalColor*) /* override */;
	virtual void ProcessWindowMove(); // vtable+0x40
	virtual void CenterWindow(); // vtable+0x44
	virtual void PlaceWindowRect(/*packed*/ class MRect*); // vtable+0x48
	virtual int32_t PrepareForSwitchToWindowedMode(); // vtable+0x4c
	virtual int32_t CompleteSwitchToWindowedMode(); // vtable+0x50
	virtual int32_t PrepareForSwitchToFullScreenMode(); // vtable+0x54
	virtual int32_t CompleteSwitchToFullScreenMode(); // vtable+0x58
	// calltype: NearStd
	virtual long MySparkalWindowProc(void * __ptr32, uint32_t, uint32_t, long) /* override */;
protected:
	/*+0x68*/  /*packed*/ class MRect rectWindowDesired; // 0x10 bytes
	/*+0x78*/  /*packed*/ class MRect rectWindow; // 0x10 bytes
	/*+0x88*/  /*packed*/ class MRect rectWindowClient; // 0x10 bytes
	/*+0x98*/  char * szCaption;
};

// Type: unsigned long;

// Type: /*packed*/ struct SparkalColor (forward reference);
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: char *;

// Type: /*packed*/ struct tagWNDCLASSA;
struct tagWNDCLASSA{ // packed(0x28 bytes) TI: 0x26d3
	/*+0x0*/   uint32_t style;
	/*+0x4*/   long (*lpfnWndProc)(void * __ptr32, uint32_t, uint32_t, long);
	/*+0x8*/   int32_t cbClsExtra;
	/*+0xc*/   int32_t cbWndExtra;
	/*+0x10*/  void * __ptr32 hInstance;
	/*+0x14*/  void * __ptr32 hIcon;
	/*+0x18*/  void * __ptr32 hCursor;
	/*+0x1c*/  void * __ptr32 hbrBackground;
	/*+0x20*/  char * lpszMenuName;
	/*+0x24*/  char * lpszClassName;
};

// Type: void;

// Type: /*packed*/ struct tagRECT;
struct tagRECT{ // packed(0x10 bytes) TI: 0x13c4
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
};

// Type: int32_t;

// Type: /*packed*/ struct GameWindow::MakePalette::__unnamed;
struct GameWindow::MakePalette::__unnamed{ // packed(0x404 bytes) TI: 0x283b
	/*+0x0*/   unsigned short Version; // 0x2 bytes
	/*+0x2*/   unsigned short NumberOfEntries; // 0x2 bytes
	/*+0x4*/   /*packed*/ struct tagPALETTEENTRY aEntries[256]; // 0x400 bytes
};

// Type: void * __ptr32;

// Type: uint32_t;

// Type: long;

// Type: /*packed*/ class MRect (forward reference);
class MRect : public SparkalRect
{ // packed(0x10 bytes) TI: 0x1067
public:
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalSize);
	void MRect(/*packed*/ struct SparkalRect*);
	void MRect(/*packed*/ class MRect*);
	void MRect(const /*packed*/ struct SparkalRect&);
	void MRect(long, long, long, long);
	void MRect();
	long Width();
	long Height();
	/*packed*/ class MSize Size();
	const /*packed*/ class MPoint& TopLeft();
	/*packed*/ class MPoint& TopLeft();
	const /*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint CenterPoint();
	/*packed*/ struct SparkalRect* operator struct SparkalRect *();
	/*packed*/ class MRect* operator class MRect *();
	int32_t IsRectEmpty();
	int32_t IsRectNull();
	int32_t PtInRect(/*packed*/ struct SparkalPoint);
	int32_t PtInRect(long, long);
	int32_t DoesRectOverlap(/*packed*/ struct SparkalRect*);
	void SetRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void SetRect(long, long, long, long);
	void SetRectEmpty();
	void CopyRect(/*packed*/ class MRect*);
	int32_t EqualRect(/*packed*/ class MRect*);
	void InflateRect(long, long, long, long);
	void InflateRect(/*packed*/ class MRect*);
	void InflateRect(/*packed*/ struct SparkalSize);
	void InflateRect(long, long);
	void DeflateRect(long, long, long, long);
	void DeflateRect(/*packed*/ class MRect*);
	void DeflateRect(/*packed*/ struct SparkalSize);
	void DeflateRect(long, long);
	void MoveRect(/*packed*/ struct SparkalPoint);
	void MoveRect(long, long);
	void OffsetRect(/*packed*/ struct SparkalPoint);
	void OffsetRect(/*packed*/ struct SparkalSize);
	void OffsetRect(long, long);
	void NormalizeRect();
	int32_t IntersectRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t UnionRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t SubtractRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t operator==(const /*packed*/ struct SparkalRect&);
	int32_t operator!=(const /*packed*/ struct SparkalRect&);
	void operator+=(/*packed*/ class MRect*);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ class MRect*);
	void operator-=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator&=(const /*packed*/ struct SparkalRect&);
	void operator|=(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(/*packed*/ class MRect*);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator-(/*packed*/ class MRect*);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator&(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator|(const /*packed*/ struct SparkalRect&);
};

// Type: /*packed*/ struct tagMINMAXINFO (forward reference);
struct tagMINMAXINFO{ // packed(0x28 bytes) TI: 0x2841
	/*+0x0*/   /*packed*/ struct tagPOINT ptReserved; // 0x8 bytes
	/*+0x8*/   /*packed*/ struct tagPOINT ptMaxSize; // 0x8 bytes
	/*+0x10*/  /*packed*/ struct tagPOINT ptMaxPosition; // 0x8 bytes
	/*+0x18*/  /*packed*/ struct tagPOINT ptMinTrackSize; // 0x8 bytes
	/*+0x20*/  /*packed*/ struct tagPOINT ptMaxTrackSize; // 0x8 bytes
};

// Type: /*packed*/ class CSparkalWindow (forward reference);
// VTABLE: COPTER_D 0x00590ef8
class CSparkalWindow{ // packed(0x68 bytes) TI: 0x20d9
public:
	void CSparkalWindow(unsigned long, unsigned long, unsigned long, const /*packed*/ struct SparkalColor*, char *);
	void CSparkalWindow();
	virtual void ~CSparkalWindow(); // vtable+0x0
	void * __ptr32 GetPlatformData();
	long GetWidth();
	long GetHeight();
	virtual unsigned long GetClientSize(long *, long *); // vtable+0x4
	/*unpacked*/ class ScreenBuffer* GetBackBuffer();
	/*unpacked*/ class ScreenBuffer* SetBackBuffer(/*unpacked*/ class ScreenBuffer*);
	/*unpacked*/ class ICommander* GetCommander();
	/*unpacked*/ class ICommander* SetCommander(/*unpacked*/ class ICommander*);
	virtual unsigned long Draw(); // vtable+0x8
	virtual unsigned long SetCursor(unsigned long); // vtable+0xc
	virtual unsigned long SetCursorFromIndex(int32_t); // vtable+0x10
	virtual unsigned long LoadGameCursors(); // vtable+0x14
	virtual void FreeGameCursors(); // vtable+0x18
	unsigned long DrawBufferText(const const char*, unsigned long, long, long, long *, long *, long *, long *);
	virtual unsigned long Sleep(); // vtable+0x1c
	virtual unsigned long WakeUp(); // vtable+0x20
	unsigned long ScreenScroll(long, long, long, long, long, long);
	unsigned long RectSlideUp(long, long, long, long);
	virtual unsigned long SwapBuffer(long, long, long, long); // vtable+0x24
	virtual unsigned long SwapBuffer(); // vtable+0x28
	virtual void UpdatePalette(long, long, /*packed*/ struct SparkalColor*); // vtable+0x2c
protected:
	/*+0x4*/   long mHeight;
	/*+0x8*/   long mWidth;
	/*+0xc*/   unsigned long mStyle;
	/*+0x10*/  /*unpacked*/ class ICommander *mpCommander;
	/*+0x14*/  /*unpacked*/ class ScreenBuffer *mpBackBuffer;
	/*+0x18*/  void * __ptr32 mWindow;
	// calltype: NearStd
	virtual long MySparkalWindowProc(void * __ptr32, uint32_t, uint32_t, long); // vtable+0x30
	/*+0x1c*/  void * __ptr32 mPalette;
	/*+0x20*/  void * __ptr32 mhCurrentCursor;
	/*+0x24*/  void * __ptr32 mhCustomCursor;
	/*+0x28*/  void * __ptr32 mCursors[16]; // 0x40 bytes
};

// Type: /*packed*/ class CSparkalWindow;
// VTABLE: COPTER_D 0x00590ef8
class CSparkalWindow{ // packed(0x68 bytes) TI: 0x20d9
public:
	void CSparkalWindow(unsigned long, unsigned long, unsigned long, const /*packed*/ struct SparkalColor*, char *);
	void CSparkalWindow();
	virtual void ~CSparkalWindow(); // vtable+0x0
	void * __ptr32 GetPlatformData();
	long GetWidth();
	long GetHeight();
	virtual unsigned long GetClientSize(long *, long *); // vtable+0x4
	/*unpacked*/ class ScreenBuffer* GetBackBuffer();
	/*unpacked*/ class ScreenBuffer* SetBackBuffer(/*unpacked*/ class ScreenBuffer*);
	/*unpacked*/ class ICommander* GetCommander();
	/*unpacked*/ class ICommander* SetCommander(/*unpacked*/ class ICommander*);
	virtual unsigned long Draw(); // vtable+0x8
	virtual unsigned long SetCursor(unsigned long); // vtable+0xc
	virtual unsigned long SetCursorFromIndex(int32_t); // vtable+0x10
	virtual unsigned long LoadGameCursors(); // vtable+0x14
	virtual void FreeGameCursors(); // vtable+0x18
	unsigned long DrawBufferText(const const char*, unsigned long, long, long, long *, long *, long *, long *);
	virtual unsigned long Sleep(); // vtable+0x1c
	virtual unsigned long WakeUp(); // vtable+0x20
	unsigned long ScreenScroll(long, long, long, long, long, long);
	unsigned long RectSlideUp(long, long, long, long);
	virtual unsigned long SwapBuffer(long, long, long, long); // vtable+0x24
	virtual unsigned long SwapBuffer(); // vtable+0x28
	virtual void UpdatePalette(long, long, /*packed*/ struct SparkalColor*); // vtable+0x2c
protected:
	/*+0x4*/   long mHeight;
	/*+0x8*/   long mWidth;
	/*+0xc*/   unsigned long mStyle;
	/*+0x10*/  /*unpacked*/ class ICommander *mpCommander;
	/*+0x14*/  /*unpacked*/ class ScreenBuffer *mpBackBuffer;
	/*+0x18*/  void * __ptr32 mWindow;
	// calltype: NearStd
	virtual long MySparkalWindowProc(void * __ptr32, uint32_t, uint32_t, long); // vtable+0x30
	/*+0x1c*/  void * __ptr32 mPalette;
	/*+0x20*/  void * __ptr32 mhCurrentCursor;
	/*+0x24*/  void * __ptr32 mhCustomCursor;
	/*+0x28*/  void * __ptr32 mCursors[16]; // 0x40 bytes
};

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};



// Contribution: 1:00065f70-00067019 Module: 43, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00466f70
void GameWindow::GameWindow(unsigned long Width, unsigned long Height, unsigned long Style, const /*packed*/ struct SparkalColor *pColors, char * Caption) {
	/*bp-0x28*/  /*packed*/ struct tagWNDCLASSA ClassInfo; // 0x28 bytes


	this->CSparkalWindow::CSparkalWindow();
	__asm        jmp    _T19;
_T19:
	__asm        jmp    _T1e;
_T1e:
	__asm        jmp    _T23;
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        jmp    _T2d;
_T2d:
	__asm        jmp    _T32;
_T32:
	this->szCaption = 0x0;
	this-><GameWindow+0x00> = 0x590470;
// LINE 40:
	this->mWidth = Width;
// LINE 41:
	this->mHeight = Height;
// LINE 42:
	this->mStyle = Style;
// LINE 44:
	__asm        cmp    Caption, 0;
	__asm        je     _Ta7;
// LINE 45:
	__asm        mov    eax, Caption;
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        inc    eax;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x98], eax;
// LINE 46:
	strcpy(Caption, this->szCaption);
// LINE 48:
	__asm        jmp    _Td1;
// LINE 49:
_Ta7:
	this->szCaption = operator new(0x4);
// LINE 50:
	strcpy(0x599314, this->szCaption);
// LINE 53:
_Td1:
	__asm        lea    eax, ClassInfo.style;
	__asm        push   eax;
	__asm        push   0x599AB8;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3878];
	__asm        test   eax, eax;
	__asm        jne    _T14c;
// LINE 54:
	ClassInfo.hCursor = 0x0;
// LINE 55:
	ClassInfo.lpszMenuName = 0x599318;
// LINE 56:
	ClassInfo.lpszClassName = 0x599ab8;
// LINE 57:
	__asm        push   4;
	__asm        call   dword ptr ds:[0x6C3560];
	__asm        mov    ClassInfo.hbrBackground, eax;
// LINE 58:
	ClassInfo.hInstance = _ghWindowsInstance;
// LINE 59:
	ClassInfo.style = 0x20;
// LINE 60:
	ClassInfo.lpfnWndProc = 0x4815dd;
// LINE 61:
	ClassInfo.cbWndExtra = 0x4;
// LINE 62:
	ClassInfo.cbClsExtra = 0x0;
// LINE 63:
	__asm        push   0x7F00;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C381C];
	__asm        mov    ClassInfo.hIcon, eax;
// LINE 64:
	__asm        lea    eax, ClassInfo.style;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3814];
// LINE 67:
_T14c:
	this->GameWindow::CreateSparkalWindow();
// LINE 68:
	__asm        mov    eax, pColors;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   GameWindow::MakePalette;
// LINE 70:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004670df
unsigned long GameWindow::CreateSparkalWindow() {
	/*bp-0x10*/  /*packed*/ struct tagRECT rectWindowForAdjust; // 0x10 bytes
	/*bp-0x14*/  unsigned long dwWindowStyle;

// LINE 83:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T23;
// LINE 84:
	return 0x80000000;
// LINE 86:
_T23:
	rectWindowForAdjust.top = 0x0;
// LINE 87:
	rectWindowForAdjust.left = 0x0;
// LINE 88:
	rectWindowForAdjust.right = this->mWidth;
// LINE 89:
	rectWindowForAdjust.bottom = this->mHeight;
// LINE 91:
	dwWindowStyle = 0x0;
// LINE 92:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xC], 1;
	__asm        je     _T63;
// LINE 93:
	__asm        or     dwWindowStyle, 0x40000;
// LINE 94:
	__asm        jmp    _T83;
_T63:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xC], 4;
	__asm        je     _T7c;
// LINE 95:
	__asm        or     dwWindowStyle, 0x800000;
// LINE 96:
	__asm        jmp    _T83;
// LINE 97:
_T7c:
	__asm        or     dwWindowStyle, 0x80000000;
// LINE 98:
_T83:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xC], 2;
	__asm        je     _T97;
// LINE 99:
	__asm        or     dwWindowStyle, 0xC00000;
// LINE 100:
_T97:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xC], 8;
	__asm        je     _Tab;
// LINE 101:
	__asm        or     dwWindowStyle, 0xC80000;
// LINE 102:
_Tab:
	__asm        mov    eax, this;
	__asm        test   byte ptr [eax+0xC], 0x10;
	__asm        je     _Tbf;
// LINE 103:
	__asm        or     dwWindowStyle, 0xB0000;
// LINE 107:
_Tbf:
	__asm        push   0x40000;
	__asm        push   0;
	__asm        mov    eax, dwWindowStyle;
	__asm        push   eax;
	__asm        lea    eax, rectWindowForAdjust.left;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C387C];
// LINE 111:
	this->rectWindow.left = rectWindowForAdjust.left;
// LINE 112:
	this->rectWindow.top = rectWindowForAdjust.top;
// LINE 113:
	this->rectWindow.right = rectWindowForAdjust.right;
// LINE 114:
	this->rectWindow.bottom = rectWindowForAdjust.bottom;
// LINE 115:
	__asm        mov    eax, this;
	__asm        add    eax, 0x78;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x48];
// LINE 116:
	__asm        mov    eax, this;
	__asm        add    eax, 0x78;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x68;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 130:
	__asm        jmp    _T137;
_T137:
	__asm        jmp    _T13c;
_T13c:
	__asm        push   0;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x84];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x7C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x80];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x78];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        push   eax;
	__asm        mov    eax, dwWindowStyle;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        push   eax;
	__asm        push   0x599AB8;
	__asm        push   0x40000;
	__asm        call   dword ptr ds:[0x6C3808];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x18], eax;
// LINE 132:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T1dd;
// LINE 134:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C380C];
// LINE 135:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3820];
// LINE 136:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3864];
// LINE 137:
	return 0x0;
// LINE 139:
_T1dd:
	return 0x80000000;
// LINE 141:
}

// FUNCTION: COPTER_D 0x004672cb
void GameWindow::~GameWindow() {

	this-><GameWindow+0x00> = 0x590470;
// LINE 150:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    [ebp-4], eax;
	__asm        mov    eax, [ebp-4];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 151:
	return;

	this->CSparkalWindow::~CSparkalWindow();
}

// FUNCTION: COPTER_D 0x00467310
int32_t GameWindow::Initialize() {
// LINE 159:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
// LINE 160:
	return 0x1;
// LINE 161:
}

// FUNCTION: COPTER_D 0x00467336
unsigned long GameWindow::Draw() {
// LINE 172:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T4e;
// LINE 173:
__WHILE_19:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
	__asm        test   eax, eax;
	__asm        je     _T37;

	__asm        jmp    __WHILE_19;
// LINE 174:
_T37:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x1C];
// LINE 176:
_T4e:
	return 0x0;
// LINE 177:
}

// FUNCTION: COPTER_D 0x00467390
unsigned long GameWindow::SwapBuffer() {
// LINE 185:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T4e;
// LINE 186:
__WHILE_19:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+4];
	__asm        test   eax, eax;
	__asm        je     _T37;

	__asm        jmp    __WHILE_19;
// LINE 187:
_T37:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x1C];
// LINE 189:
_T4e:
	return 0x0;
// LINE 190:
}

// FUNCTION: COPTER_D 0x004673ea
unsigned long GameWindow::MakePalette(const /*packed*/ struct SparkalColor *pColors) {
	/*bp-0x4*/   int32_t Counter;
	/*bp-0x8*/   int32_t Start;
	/*bp-0xc*/   int32_t End;
	/*bp-0x10*/  uint32_t PaletteUse;
	/*bp-0x14*/  int32_t StaticCount;
	/*bp-0x18*/  void * __ptr32 hdc;
	/*bp-0x41c*/ /*packed*/ struct GameWindow::MakePalette::__unnamed LogPalette; // 0x404 bytes

// LINE 199:
	__asm        cmp    pColors, 0;
	__asm        jne    _T26;
// LINE 200:
	return 0x80000000;
// LINE 201:
_T26:
	return 0x0;
// LINE 208:
	__asm        mov    LogPalette.Version, 0x300;
	__asm        mov    LogPalette.NumberOfEntries, 0x100;
	__asm        lea    edi, LogPalette.aEntries[0].peRed;
	__asm        xor    eax, eax;
	__asm        mov    ecx, 0x100;
	__asm        rep stosd;
// LINE 212:
	StaticCount = 0x14;
// LINE 213:
	PaletteUse = 0x1;
// LINE 215:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 216:
	__asm        cmp    hdc, 0;
	__asm        je     _Tb1;
// LINE 217:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3588];
	__asm        mov    PaletteUse, eax;
// LINE 218:
	__asm        push   0x18;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3590];
	__asm        mov    StaticCount, eax;
// LINE 219:
	__asm        lea    eax, LogPalette.aEntries[0].peRed;
	__asm        push   eax;
	__asm        push   0x100;
	__asm        push   0;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3580];
// LINE 220:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 224:
_Tb1:
	__asm        mov    eax, StaticCount;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        mov    Start, eax;
// LINE 225:
	__asm        mov    ecx, 0x100;
	__asm        mov    eax, StaticCount;
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        sub    ecx, eax;
	__asm        mov    End, ecx;
// LINE 228:
	__asm        cmp    PaletteUse, 2;
	__asm        jne    _FOR_f4;
// LINE 229:
	Start = 0x1;
// LINE 230:
	End = 0xff;
// LINE 234:
_FOR_f4:
	Counter = 0x0;
	__asm        jmp    _FOR_COND_f4;
_FOR_NEXT_f4:
	Counter++;
_FOR_COND_f4:
	__asm        mov    eax, Counter;
	__asm        cmp    Start, eax;
	__asm        jle    _T113;
// LINE 235:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 0;
	__asm        jmp    _FOR_NEXT_f4;
// LINE 238:
_T113:
	__asm        cmp    pColors, 0;
	__asm        je     _FOR_186;
// LINE 239:
_FOR_122:
	__asm        jmp    _FOR_COND_122;
_FOR_NEXT_122:
	Counter++;
_FOR_COND_122:
	__asm        mov    eax, End;
	__asm        cmp    Counter, eax;
	__asm        jge    _T17c;
// LINE 240:
	__asm        mov    eax, Counter;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4];
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x416], al;
// LINE 241:
	__asm        mov    eax, Counter;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+1];
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x417], al;
// LINE 242:
	__asm        mov    eax, Counter;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+2];
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 243:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 5;
// LINE 244:
	__asm        jmp    _FOR_NEXT_122;
// LINE 246:
_T17c:
	__asm        jmp    _FOR_1d1;
// LINE 247:
_FOR_186:
	__asm        jmp    _FOR_COND_186;
_FOR_NEXT_186:
	Counter++;
_FOR_COND_186:
	__asm        mov    eax, End;
	__asm        cmp    Counter, eax;
	__asm        jge    _FOR_1d1;
// LINE 248:
	__asm        mov    al, reinterpret_cast<uint8_t>(Counter);
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x416], al;
// LINE 249:
	__asm        mov    al, reinterpret_cast<uint8_t>(Counter);
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x417], al;
// LINE 250:
	__asm        mov    al, reinterpret_cast<uint8_t>(Counter);
	__asm        mov    ecx, Counter;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 251:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 5;
// LINE 252:
	__asm        jmp    _FOR_NEXT_186;
// LINE 256:
_FOR_1d1:
	__asm        jmp    _FOR_COND_1d1;
_FOR_NEXT_1d1:
	Counter++;
_FOR_COND_1d1:
	__asm        cmp    Counter, 0x100;
	__asm        jge    _T1f1;
// LINE 257:
	__asm        mov    eax, Counter;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 0;
	__asm        jmp    _FOR_NEXT_1d1;
// LINE 260:
_T1f1:
	__asm        lea    eax, LogPalette.Version;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C357C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1C], eax;
// LINE 263:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 264:
	__asm        cmp    hdc, 0;
	__asm        je     _T2a9;
// LINE 265:
	__asm        push   1;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3584];
// LINE 266:
	__asm        push   1;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3574];
// LINE 267:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3570];
// LINE 268:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3578];
// LINE 270:
	__asm        lea    eax, LogPalette.aEntries[0].peRed;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1C];
	__asm        push   eax;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   CheckIdentityPalette;
	__asm        add    esp, 0xC;
	__asm        test   eax, eax;
	__asm        jne    _T295;
// LINE 271:
	__asm        push   0;
	__asm        push   0x59931C;
	__asm        push   0x599324;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3870];
// LINE 273:
_T295:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 276:
_T2a9:
	return 0x0;
// LINE 277:
}

// FUNCTION: COPTER_D 0x004676a1
void GameWindow::UpdatePalette(long start, long count, /*packed*/ struct SparkalColor *pColor) {
// LINE 287:
	__asm        mov    eax, pColor;
	__asm        push   eax;
	__asm        mov    eax, count;
	__asm        push   eax;
	__asm        mov    eax, start;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, [eax+0x14];
	__asm        call   CBackBuffer::UpdatePalette;
// LINE 289:
	return;
}

// FUNCTION: COPTER_D 0x004676d0
void GameWindow::ProcessWindowMove() {
	/*bp-0x10*/  /*packed*/ struct tagRECT rectWindowTemp; // 0x10 bytes

// LINE 305:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B8];
// LINE 306:
	this->rectWindow.left = rectWindowTemp.left;
// LINE 307:
	this->rectWindow.top = rectWindowTemp.top;
// LINE 308:
	this->rectWindow.right = rectWindowTemp.right;
// LINE 309:
	this->rectWindow.bottom = rectWindowTemp.bottom;
// LINE 312:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C382C];
// LINE 313:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C37E0];
// LINE 314:
	__asm        lea    eax, rectWindowTemp.right;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C37E0];
// LINE 315:
	this->rectWindowClient.left = rectWindowTemp.left;
// LINE 316:
	this->rectWindowClient.top = rectWindowTemp.top;
// LINE 317:
	this->rectWindowClient.right = rectWindowTemp.right;
// LINE 318:
	this->rectWindowClient.bottom = rectWindowTemp.bottom;
// LINE 323:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _Td4;
// LINE 324:
	__asm        mov    eax, this;
	__asm        add    eax, 0x88;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x80];
// LINE 326:
_Td4:
	return;
}

// FUNCTION: COPTER_D 0x004677ae
int32_t GameWindow::PrepareForSwitchToWindowedMode() {
// LINE 335:
	return 0x1;
// LINE 340:
}

// FUNCTION: COPTER_D 0x004677c9
int32_t GameWindow::CompleteSwitchToWindowedMode() {
	/*bp-0x4*/   unsigned long dwStyle;
	/*bp-0x14*/  /*packed*/ struct tagRECT rectWindowTempWindows; // 0x10 bytes

// LINE 353:
	__asm        push   0xFFFFFFF0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3868];
	__asm        mov    dwStyle, eax;
// LINE 354:
	__asm        and    dwStyle, 0x7FFFFFFF;
// LINE 355:
	__asm        or     dwStyle, 0x10C60000;
// LINE 356:
	__asm        mov    eax, dwStyle;
	__asm        push   eax;
	__asm        push   0xFFFFFFF0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C380C];
// LINE 358:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, rectWindowTempWindows.left;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38AC];
// LINE 360:
	__asm        push   0xFFFFFFEC;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3868];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B0];
	__asm        cmp    eax, 1;
	__asm        sbb    eax, eax;
	__asm        inc    eax;
	__asm        push   eax;
	__asm        push   0xFFFFFFF0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3868];
	__asm        push   eax;
	__asm        lea    eax, rectWindowTempWindows.left;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C387C];
// LINE 363:
	this->rectWindow.left = rectWindowTempWindows.left;
// LINE 364:
	this->rectWindow.top = rectWindowTempWindows.top;
// LINE 365:
	this->rectWindow.right = rectWindowTempWindows.right;
// LINE 366:
	this->rectWindow.bottom = rectWindowTempWindows.bottom;
// LINE 367:
	__asm        mov    eax, this;
	__asm        add    eax, 0x78;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x48];
// LINE 368:
	__asm        mov    eax, this;
	__asm        add    eax, 0x78;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x68;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 373:
	__asm        jmp    _Tfc;
_Tfc:
	__asm        jmp    _T101;
_T101:
	__asm        push   0x14;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x84];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x7C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x80];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x78];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C37E8];
// LINE 380:
	return 0x1;
// LINE 382:
}

// FUNCTION: COPTER_D 0x00467918
int32_t GameWindow::PrepareForSwitchToFullScreenMode() {
// LINE 392:
	return 0x1;
// LINE 394:
}

// FUNCTION: COPTER_D 0x00467933
int32_t GameWindow::CompleteSwitchToFullScreenMode() {
	/*bp-0x10*/  /*packed*/ struct tagRECT rectWindowTemp; // 0x10 bytes
	/*bp-0x14*/  unsigned long dwStyle;

// LINE 409:
	this->mStyle = 0x0;
// LINE 410:
	dwStyle = 0x90000000;
// LINE 411:
	__asm        mov    eax, dwStyle;
	__asm        push   eax;
	__asm        push   0xFFFFFFF0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C380C];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0x1C], eax;
// LINE 414:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x78], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x7C], 0;
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x80], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x84], eax;
	__asm        jmp    _T73;
// LINE 415:
_T73:
	__asm        mov    eax, this;
	__asm        add    eax, 0x78;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x68;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 416:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38AC];
// LINE 418:
	__asm        push   0xFFFFFFEC;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3868];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B0];
	__asm        cmp    eax, 1;
	__asm        sbb    eax, eax;
	__asm        inc    eax;
	__asm        push   eax;
	__asm        mov    eax, dwStyle;
	__asm        push   eax;
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C387C];
// LINE 424:
	__asm        push   0x14;
	__asm        mov    eax, rectWindowTemp.bottom;
	__asm        sub    eax, rectWindowTemp.top;
	__asm        push   eax;
	__asm        mov    eax, rectWindowTemp.right;
	__asm        sub    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C37E8];
// LINE 431:
	return 0x1;
// LINE 433:
}

// FUNCTION: COPTER_D 0x00467a48
void GameWindow::CenterWindow() {
	/*bp-0x4*/   unsigned long nScreenHeight;
	/*bp-0x8*/   unsigned long nWindowHeight;
	/*bp-0xc*/   unsigned long nScreenWidth;
	/*bp-0x10*/  unsigned long nWindowWidth;

// LINE 443:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3810];
	__asm        mov    nScreenWidth, eax;
	__asm        jmp    _T1c;
// LINE 444:
_T1c:
	__asm        push   1;
	__asm        call   dword ptr ds:[0x6C3810];
	__asm        mov    nScreenHeight, eax;
	__asm        jmp    _T2c;
// LINE 445:
_T2c:
	__asm        jmp    _T31;
_T31:
	nWindowWidth = (this->rectWindow.right - this->rectWindow.left);
// LINE 446:
	__asm        jmp    _T48;
_T48:
	nWindowHeight = (this->rectWindow.bottom - this->rectWindow.top);
// LINE 449:
	this->rectWindow.left = ((nScreenWidth >> 0x1) - (nWindowWidth >> 0x1));
// LINE 450:
	this->rectWindow.top = ((nScreenHeight >> 0x1) - (nWindowHeight >> 0x1));
// LINE 453:
	__asm        push   0;
	__asm        mov    eax, nWindowHeight;
	__asm        push   eax;
	__asm        mov    eax, nWindowWidth;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3828];
// LINE 455:
	return;
}

// FUNCTION: COPTER_D 0x00467af9
void GameWindow::PlaceWindowRect(/*packed*/ class MRect *rectWindowToPlace) {
	/*bp-0x4*/   unsigned long nScreenHeight;
	/*bp-0x8*/   unsigned long nWindowHeight;
	/*bp-0xc*/   unsigned long nScreenWidth;
	/*bp-0x10*/  unsigned long nWindowWidth;

// LINE 471:
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3810];
	__asm        mov    nScreenWidth, eax;
	__asm        jmp    _T1c;
// LINE 472:
_T1c:
	__asm        push   1;
	__asm        call   dword ptr ds:[0x6C3810];
	__asm        mov    nScreenHeight, eax;
	__asm        jmp    _T2c;
// LINE 473:
_T2c:
	__asm        jmp    _T31;
_T31:
	nWindowWidth = (rectWindowToPlace->right - rectWindowToPlace->left);
// LINE 474:
	__asm        jmp    _T44;
_T44:
	nWindowHeight = (rectWindowToPlace->bottom - rectWindowToPlace->top);
// LINE 477:
	rectWindowToPlace->left = ((nScreenWidth >> 0x1) - (nWindowWidth >> 0x1));
// LINE 478:
	rectWindowToPlace->top = ((nScreenHeight >> 0x1) - (nWindowHeight >> 0x1));
// LINE 479:
	rectWindowToPlace->right = (rectWindowToPlace->left + nWindowWidth);
// LINE 480:
	rectWindowToPlace->bottom = (rectWindowToPlace->top + nWindowHeight);
// LINE 482:
	return;
}

// FUNCTION: COPTER_D 0x00467b9c
long GameWindow::MySparkalWindowProc(void * __ptr32 Window, uint32_t Message, uint32_t wParam, long lParam) {
	/*bp-0x4*/   /*packed*/ struct tagMINMAXINFO *lpMinMaxInfo;

// LINE 496:
	__asm        mov    eax, Message;
	__asm        cmp    g_uTWKMessageNum, eax;
	__asm        jne    _T31;
// LINE 497:
	TWKReadAllFiles(0x599348);
// LINE 498:
	TWKUpdate();
// LINE 499:
	return 0x0;
// LINE 502:
_T31:
	__asm        mov    eax, Message;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T345;
// LINE 504:
_T3c:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x4C];
// LINE 505:
	return 0x0;
// LINE 508:
_T54:
	this->mWindow = 0x0;
// LINE 509:
	__asm        jmp    _T459;
// LINE 513:
_T63:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x40];
// LINE 514:
	return 0x0;
// LINE 517:
_T75:
	lpMinMaxInfo = lParam;
// LINE 520:
	lpMinMaxInfo->ptMaxTrackSize.x = (this->rectWindowDesired.right - this->rectWindowDesired.left);
	__asm        jmp    _T92;
_T92:
	lpMinMaxInfo->ptMinTrackSize.x = lpMinMaxInfo->ptMaxTrackSize.x;
	lpMinMaxInfo->ptMaxSize.x = lpMinMaxInfo->ptMinTrackSize.x;
// LINE 523:
	lpMinMaxInfo->ptMaxTrackSize.y = (this->rectWindowDesired.bottom - this->rectWindowDesired.top);
	__asm        jmp    _Tc1;
_Tc1:
	lpMinMaxInfo->ptMinTrackSize.y = lpMinMaxInfo->ptMaxTrackSize.y;
	lpMinMaxInfo->ptMaxSize.y = lpMinMaxInfo->ptMinTrackSize.y;
// LINE 527:
	lpMinMaxInfo->ptMaxPosition.x = this->rectWindowDesired.left;
// LINE 528:
	lpMinMaxInfo->ptMaxPosition.y = this->rectWindowDesired.top;
// LINE 529:
	return 0x0;
// LINE 530:
	__asm        jmp    _T459;
// LINE 533:
_Tfd:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10], 0;
	__asm        je     _T11b;
// LINE 534:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x24];
// LINE 535:
_T11b:
	return 0x0;
// LINE 536:
	__asm        jmp    _T459;
// LINE 539:
_T127:
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x38];
// LINE 540:
	return 0x0;
// LINE 543:
_T143:
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x2C];
// LINE 544:
	return 0x0;
// LINE 547:
_T15f:
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x34];
// LINE 548:
	return 0x0;
// LINE 559:
_T17b:
	__asm        cmp    wParam, 0x73;
	__asm        jne    _T19b;
// LINE 560:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x4C];
// LINE 561:
	__asm        jmp    _T1b0;
// LINE 562:
_T19b:
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x2C];
// LINE 563:
_T1b0:
	return 0x0;
// LINE 566:
_T1b7:
	__asm        cmp    wParam, 0x73;
	__asm        je     _T1d6;
// LINE 567:
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x34];
// LINE 568:
_T1d6:
	return 0x0;
// LINE 571:
_T1dd:
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38A0];
// LINE 572:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x3C];
// LINE 573:
	return 0x0;
// LINE 576:
_T217:
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38A0];
// LINE 577:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x44];
// LINE 578:
	return 0x0;
// LINE 581:
_T251:
	__asm        call   dword ptr ds:[0x6C38A4];
	__asm        cmp    eax, Window;
	__asm        jne    _T266;
// LINE 582:
	__asm        call   dword ptr ds:[0x6C38A8];
// LINE 583:
_T266:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x40];
// LINE 584:
	return 0x0;
// LINE 587:
_T296:
	__asm        call   dword ptr ds:[0x6C38A4];
	__asm        cmp    eax, Window;
	__asm        jne    _T2ab;
// LINE 588:
	__asm        call   dword ptr ds:[0x6C38A8];
// LINE 589:
_T2ab:
	__asm        mov    eax, lParam;
	__asm        shr    eax, 0x10;
	__asm        and    eax, 0xFFFF;
	__asm        movzx  eax, ax;
	__asm        push   eax;
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x10];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x10];
	__asm        call   dword ptr [edx+0x48];
// LINE 590:
	return 0x0;
// LINE 593:
_T2db:
	__asm        mov    eax, lParam;
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 1;
	__asm        jne    _T303;
// LINE 594:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC];
// LINE 595:
	return 0x1;
// LINE 597:
_T303:
	__asm        jmp    _T459;
// LINE 601:
_T308:
	__asm        mov    eax, Window;
	__asm        cmp    wParam, eax;
	__asm        jne    _T31b;
// LINE 602:
	return 0x0;
// LINE 606:
_T31b:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14], 0;
	__asm        je     _T339;
// LINE 607:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x14];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x14];
	__asm        call   dword ptr [edx+0x7C];
// LINE 608:
_T339:
	return 0x0;
// LINE 609:
	__asm        jmp    _T459;
_T345:
	__asm        cmp    dword ptr [ebp-8], 0x10;
	__asm        ja     _T385;

	__asm        je     _T3c;

	__asm        sub    dword ptr [ebp-8], 2;
	__asm        cmp    dword ptr [ebp-8], 5;
	__asm        ja     _T459;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    _Switch_36d[0][eax*4];
// Switch pointers:
//   _T54
//   _T63
//   _T459
//   _T63
//   _T459
//   _Tfd
_T385:
	__asm        cmp    dword ptr [ebp-8], 0x20;
	__asm        ja     _T3a4;

	__asm        je     _T2db;

	__asm        cmp    dword ptr [ebp-8], 0x1C;
	__asm        je     _T31b;

	__asm        jmp    _T459;
_T3a4:
	__asm        cmp    dword ptr [ebp-8], 0x100;
	__asm        ja     _T3c6;

	__asm        je     _T143;

	__asm        cmp    dword ptr [ebp-8], 0x24;
	__asm        je     _T75;

	__asm        jmp    _T459;
_T3c6:
	__asm        cmp    dword ptr [ebp-8], 0x201;
	__asm        ja     _T408;

	__asm        je     _T1dd;

	__asm        sub    dword ptr [ebp-8], 0x101;
	__asm        cmp    dword ptr [ebp-8], 4;
	__asm        ja     _T459;

	__asm        mov    eax, [ebp-8];
	__asm        jmp    _Switch_3f4[0][eax*4];
// Switch pointers:
//   _T15f
//   _T127
//   _T459
//   _T17b
//   _T1b7
_T408:
	__asm        cmp    dword ptr [ebp-8], 0x30F;
	__asm        ja     _T447;

	__asm        je     _T31b;

	__asm        cmp    dword ptr [ebp-8], 0x202;
	__asm        je     _T251;

	__asm        cmp    dword ptr [ebp-8], 0x204;
	__asm        je     _T217;

	__asm        cmp    dword ptr [ebp-8], 0x205;
	__asm        je     _T296;

	__asm        jmp    _T459;
_T447:
	__asm        cmp    dword ptr [ebp-8], 0x311;
	__asm        je     _T308;

	__asm        jmp    _T459;
// LINE 610:
_T459:
	__asm        mov    eax, lParam;
	__asm        push   eax;
	__asm        mov    eax, wParam;
	__asm        push   eax;
	__asm        mov    eax, Message;
	__asm        push   eax;
	__asm        mov    eax, Window;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   CSparkalWindow::MySparkalWindowProc;
	__asm        jmp    __RETURN;
// LINE 611:
__RETURN:
}



// Contribution: 1:00067020-00067037 Module: 43, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:00067040-00067057 Module: 43, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:00067060-00067098 Module: 43, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00468060
// GameWindow::`scalar deleting destructor'



// Contribution: 2:00001470-000014cb Module: 43, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for GameWindow @ 0x00590470
//   00: GameWindow::`scalar deleting destructor' @ 0x00468060
//   01: CSparkalWindow::GetClientSize @ 0x00480dca
//   02: GameWindow::Draw @ 0x00467336
//   03: CSparkalWindow::SetCursor @ 0x00480e74
//   04: CSparkalWindow::SetCursorFromIndex @ 0x00480f32
//   05: CSparkalWindow::LoadGameCursors @ 0x00480f80
//   06: CSparkalWindow::FreeGameCursors @ 0x00480f9b
//   07: CSparkalWindow::Sleep @ 0x00468020
//   08: CSparkalWindow::WakeUp @ 0x00468040
//   09: CSparkalWindow::SwapBuffer @ 0x0043238c
//   10: GameWindow::SwapBuffer @ 0x00467390
//   11: GameWindow::UpdatePalette @ 0x004676a1
//   12: GameWindow::MySparkalWindowProc @ 0x00467b9c
//   13: GameWindow::Initialize @ 0x00467310
//   14: GameWindow::CreateSparkalWindow @ 0x004670df
//   15: GameWindow::MakePalette @ 0x004673ea
//   16: GameWindow::ProcessWindowMove @ 0x004676d0
//   17: GameWindow::CenterWindow @ 0x00467a48
//   18: GameWindow::PlaceWindowRect @ 0x00467af9
//   19: GameWindow::PrepareForSwitchToWindowedMode @ 0x004677ae
//   20: GameWindow::CompleteSwitchToWindowedMode @ 0x004677c9
//   21: GameWindow::PrepareForSwitchToFullScreenMode @ 0x00467918
//   22: GameWindow::CompleteSwitchToFullScreenMode @ 0x00467933
//   23 entries



// Contribution: 3:00002314-00002351 Module: 43, 4 byte alignment, initialized_data, read, write, 
