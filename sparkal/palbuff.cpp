// Module: Palbuff.obj
// Source: C:\Copter\source\sparkal\Palbuff.cpp
// autogenerated by simcopter_tool from PDB file

// Type: char;

// Type: void;

// Type: /*packed*/ class PaletteBuffer (forward reference);
// VTABLE: COPTER_D 0x0058f5e0
class PaletteBuffer : public CBackBuffer
{ // packed(0x138 bytes) TI: 0x2a99
public:
	/*+0x134*/ /*packed*/ struct SparkalColor *paletteColors;
	void PaletteBuffer(/*packed*/ struct SparkalColor*);
	void PaletteBuffer();
	void ~PaletteBuffer();
	int32_t SetPalette();
	int32_t SetPalette(const /*packed*/ struct SparkalColor*);
	void DrawPalette();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long) /* override */;
};

// Type: /*packed*/ struct SparkalColor (forward reference);
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: int32_t;

// Type: long;

// Type: /*packed*/ struct tagPALETTEENTRY (forward reference);
struct tagPALETTEENTRY{ // packed(0x4 bytes) TI: 0x1be6
	/*+0x0*/   unsigned char peRed; // 0x1 bytes
	/*+0x1*/   unsigned char peGreen; // 0x1 bytes
	/*+0x2*/   unsigned char peBlue; // 0x1 bytes
	/*+0x3*/   unsigned char peFlags; // 0x1 bytes
};

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: /*packed*/ class IFlatImage (forward reference);
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(/*packed*/ class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, /*packed*/ struct SparkalRect, /*packed*/ struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	/*+0x4*/   unsigned long mLockCount;
	/*+0x8*/   long mWidth;
	/*+0xc*/   long mHeight;
	/*+0x10*/  void * __ptr32 mpBits;
	/*+0x14*/  long mStride;
};

// Type: unsigned long;

// Type: /*packed*/ class CBackBuffer;
// VTABLE: COPTER_D 0x00590808
class CBackBuffer : public IBackBuffer
{ // packed(0x134 bytes) TI: 0x2843
public:
	void CBackBuffer(long, long, const /*packed*/ struct SparkalColor*);
	void CBackBuffer(char *);
	void CBackBuffer();
	virtual void InitializeMemberVariables(); // vtable+0x28
	void ~CBackBuffer();
	unsigned long Load();
	virtual unsigned long Lock() /* override */;
	virtual unsigned long Unlock() /* override */;
	// calltype: NearC
	static int32_t GetPaletteFromImage(char *, /*packed*/ struct SparkalColor*);
	virtual unsigned long Swap(/*packed*/ class CSparkalWindow*, long, long) /* override */;
	virtual unsigned long SwapRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalPoint&, const /*packed*/ struct SparkalRect&); // vtable+0x2c
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalRect&, const /*packed*/ struct SparkalRect&); // vtable+0x30
	virtual unsigned long Duplicate(/*packed*/ class CBackBuffer*, int32_t); // vtable+0x34
	virtual unsigned long ComposeNoClip(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalPoint&, const /*packed*/ struct SparkalRect&); // vtable+0x38
	virtual unsigned long ComposeNoClip(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0x3c
	void UpdatePalette(long, long, const /*packed*/ struct SparkalColor*);
	virtual void SetTransparentColor(int32_t, long) /* override */;
	unsigned long GetTransparentColor(long&);
	unsigned long SetFont(/*packed*/ class MFont*);
	void SetFontColor(/*packed*/ struct SparkalColor&);
	void SetFontIndex(int32_t);
	void SetColor(/*packed*/ struct SparkalColor&);
	void SetColorIndex(int32_t);
	virtual unsigned long DrawLine(long, long, long, long, long); // vtable+0x40
	virtual unsigned long FillRect(long, const /*packed*/ struct SparkalRect*); // vtable+0x44
	virtual unsigned long DrawBufferText(char *, long, unsigned long, const /*packed*/ class MRect&, /*packed*/ class MFont*); // vtable+0x48
	virtual unsigned long DrawBufferText(char *, unsigned long, long *, long *, long *, long *, /*packed*/ class MFont*); // vtable+0x4c
	virtual unsigned long DrawLineUnclipped(long, long, long, long, long); // vtable+0x50
	virtual unsigned long DrawLineClipped(long, long, long, long, long); // vtable+0x54
	virtual unsigned long DrawRectangleOutline(const /*packed*/ struct SparkalRect&, long); // vtable+0x58
	virtual unsigned long DrawRectangleOutlineUnclipped(const /*packed*/ struct SparkalRect&, long); // vtable+0x5c
	long IsLost();
	long Restore();
	/*+0x18*/  char * szFilePath;
	/*+0x1c*/  /*packed*/ struct tagRECT rectDirectDrawBuffer; // 0x10 bytes
protected:
	/*+0x2c*/  int32_t bSurfacePrimary;
	/*+0x30*/  int32_t bSurfaceTransparent;
	/*+0x34*/  /*packed*/ class MFont *mFont;
	/*+0x38*/  /*packed*/ struct SparkalColor colorFontCurrent;
	/*+0x3c*/  /*packed*/ struct SparkalColor colorCurrent;
	/*+0x40*/  int32_t nColorIndexFontCurrent;
	/*+0x44*/  int32_t nColorIndexCurrent;
	/*+0x48*/  int32_t nColorIndexTransparent;
	/*+0x4c*/  /*packed*/ struct IDirectDrawSurface *mpFrontSurface;
	/*+0x50*/  /*packed*/ struct IDirectDrawSurface *mpBackSurface;
	/*+0x54*/  /*packed*/ struct IDirectDrawPalette *mpPalette;
	/*+0x58*/  /*packed*/ struct _DDSURFACEDESC mDDdesc; // 0x6c bytes
	/*+0xc4*/  /*packed*/ struct _DDBLTFX mDDBltFx; // 0x64 bytes
	/*+0x128*/ void * __ptr32 hPen;
	/*+0x12c*/ int32_t nPenThickness;
	/*+0x130*/ /*packed*/ struct SparkalColor colorPenCurrent;
	virtual /*packed*/ struct IDirectDrawSurface* GetDDSurface(); // vtable+0x60
};

// Type: /*packed*/ class IBackBuffer;
// VTABLE: COPTER_D 0x005907e0
class IBackBuffer : public IFlatImage
{ // packed(0x18 bytes) TI: 0x283f
public:
	virtual unsigned long Swap(/*packed*/ class CSparkalWindow*, long, long); // vtable+0x1c
	virtual unsigned long SwapRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long); // vtable+0x20
	virtual unsigned long StretchRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long, long, long); // vtable+0x24
};

// Type: /*packed*/ class IFlatImage;
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(/*packed*/ class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, /*packed*/ struct SparkalRect, /*packed*/ struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	/*+0x4*/   unsigned long mLockCount;
	/*+0x8*/   long mWidth;
	/*+0xc*/   long mHeight;
	/*+0x10*/  void * __ptr32 mpBits;
	/*+0x14*/  long mStride;
};



// Contribution: 1:00046240-00046788 Module: 50, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00447240
void PaletteBuffer::PaletteBuffer() {
	/*bp-0x40*/  char szTypeFaceName[64]; // 0x40 bytes


	__asm        push   0;
	__asm        push   0x1B8;
	__asm        push   0x258;
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x58F5E0;
// LINE 37:
	__asm        push   0x400;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x44], eax;
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        je     _T80;

	__asm        mov    dword ptr [ebp-0x50], 0x100;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x54], eax;
_T50:
	__asm        dec    dword ptr [ebp-0x50];
	__asm        js     _T6a;

	__asm        mov    ecx, [ebp-0x54];
	__asm        call   SparkalColor::SparkalColor;
	__asm        add    dword ptr [ebp-0x54], 4;
	__asm        jmp    _T50;
_T6a:
	__asm        jmp    near ptr 0x004472AF;

	__asm        mov    eax, [ebp-0x44];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x134], eax;
	__asm        jmp    _T8d;
_T80:
	this->paletteColors = 0x0;
// LINE 38:
_T8d:
	__asm        mov    ecx, this;
	__asm        call   PaletteBuffer::SetPalette;
// LINE 39:
	__asm        lea    eax, szTypeFaceName[0];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        call   LanguageManager::GetTypefaceForLanguage;
	__asm        add    esp, 0xC;
// LINE 40:
	__asm        push   0x1C;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x48], eax;
	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        je     _Td8;

	__asm        push   1;
	__asm        push   0;
	__asm        push   0;
	__asm        push   8;
	__asm        lea    eax, szTypeFaceName[0];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x48];
	__asm        call   MFont::MFont;
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    _Tdf;
_Td8:
	__asm        mov    dword ptr [ebp-0x4C], 0;
_Tdf:
	__asm        mov    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::SetFont;
// LINE 41:
	__asm        mov    ecx, this;
	__asm        call   PaletteBuffer::DrawPalette;
// LINE 42:
	__asm        jmp    near ptr 0x00447338;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00447340
void PaletteBuffer::PaletteBuffer(/*packed*/ struct SparkalColor *newSparkalColors) {
	/*bp-0x40*/  char szTypeFaceName[64]; // 0x40 bytes


	__asm        push   0;
	__asm        push   0x1B8;
	__asm        push   0x258;
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x58F5E0;
// LINE 55:
	__asm        push   0x400;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x44], eax;
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        je     _T80;

	__asm        mov    dword ptr [ebp-0x50], 0x100;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x54], eax;
_T50:
	__asm        dec    dword ptr [ebp-0x50];
	__asm        js     _T6a;

	__asm        mov    ecx, [ebp-0x54];
	__asm        call   SparkalColor::SparkalColor;
	__asm        add    dword ptr [ebp-0x54], 4;
	__asm        jmp    _T50;
_T6a:
	__asm        jmp    near ptr 0x004473AF;

	__asm        mov    eax, [ebp-0x44];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x134], eax;
	__asm        jmp    _T8d;
_T80:
	this->paletteColors = 0x0;
// LINE 56:
_T8d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x134], 0;
	__asm        je     _Ta9;
// LINE 57:
	__asm        mov    eax, newSparkalColors;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   PaletteBuffer::SetPalette;
// LINE 58:
_Ta9:
	__asm        lea    eax, szTypeFaceName[0];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        call   LanguageManager::GetTypefaceForLanguage;
	__asm        add    esp, 0xC;
// LINE 59:
	__asm        push   0x1C;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x48], eax;
	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        je     _Tec;

	__asm        push   1;
	__asm        push   0;
	__asm        push   0;
	__asm        push   8;
	__asm        lea    eax, szTypeFaceName[0];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x48];
	__asm        call   MFont::MFont;
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    _Tf3;
_Tec:
	__asm        mov    dword ptr [ebp-0x4C], 0;
_Tf3:
	__asm        mov    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::SetFont;
// LINE 60:
	__asm        mov    ecx, this;
	__asm        call   PaletteBuffer::DrawPalette;
// LINE 61:
	__asm        jmp    near ptr 0x0044744C;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00447456
void PaletteBuffer::~PaletteBuffer() {

	this-><PaletteBuffer+0x00> = 0x58f5e0;
// LINE 70:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x134], 0;
	__asm        je     _T43;
// LINE 71:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    [ebp-4], eax;
	__asm        mov    eax, [ebp-4];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 72:
_T43:
	__asm        jmp    near ptr 0x0044749E;

	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::~CBackBuffer;
}

// FUNCTION: COPTER_D 0x004474ab
int32_t PaletteBuffer::SetPalette(const /*packed*/ struct SparkalColor *pColors) {
	/*bp-0x4*/   int32_t i;

// LINE 81:
	__asm        mov    i, 0;
	__asm        jmp    _T1b;
_T18:
	__asm        inc    i;
_T1b:
	__asm        cmp    i, 0x100;
	__asm        jge    _T45;
// LINE 82:
	*reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&this->paletteColors->Blue) + ScaleExpr(i, 4)) = *reinterpret_cast<uint32_t*>(reinterpret_cast<char*>(&pColors->Blue) + ScaleExpr(i, 4));
// LINE 83:
	__asm        jmp    _T18;
// LINE 84:
_T45:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x004474FA;
// LINE 85:
}

// FUNCTION: COPTER_D 0x00447501
int32_t PaletteBuffer::SetPalette() {
	/*bp-0x4*/   /*packed*/ struct tagPALETTEENTRY *paletteEntries;
	/*bp-0x8*/   int32_t i;
	/*bp-0xc*/   long hResult;

// LINE 100:
	__asm        push   0x400;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    paletteEntries, eax;
// LINE 101:
	__asm        cmp    paletteEntries, 0;
	__asm        jne    _T2d;
// LINE 102:
	__asm        xor    eax, eax;
	__asm        jmp    _Tdc;
// LINE 103:
_T2d:
	__asm        mov    eax, paletteEntries;
	__asm        push   eax;
	__asm        push   0x100;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x10];
	__asm        mov    hResult, eax;
// LINE 104:
	__asm        mov    i, 0;
	__asm        jmp    _T5c;
_T59:
	__asm        inc    i;
_T5c:
	__asm        cmp    i, 0x100;
	__asm        jge    _Tba;
// LINE 105:
	__asm        mov    eax, i;
	__asm        mov    ecx, paletteEntries;
	__asm        mov    al, [ecx+eax*4];
	__asm        mov    ecx, i;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x134];
	__asm        mov    [edx+ecx*4+2], al;
// LINE 106:
	__asm        mov    eax, i;
	__asm        mov    ecx, paletteEntries;
	__asm        mov    al, [ecx+eax*4+1];
	__asm        mov    ecx, i;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x134];
	__asm        mov    [edx+ecx*4+1], al;
// LINE 107:
	__asm        mov    eax, i;
	__asm        mov    ecx, paletteEntries;
	__asm        mov    al, [ecx+eax*4+2];
	__asm        mov    ecx, i;
	__asm        mov    edx, this;
	__asm        mov    edx, [edx+0x134];
	__asm        mov    [edx+ecx*4], al;
// LINE 108:
	__asm        jmp    _T59;
// LINE 109:
_Tba:
	__asm        mov    eax, paletteEntries;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0x14], eax;
	__asm        mov    eax, [ebp-0x14];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
// LINE 110:
	__asm        mov    eax, 1;
	__asm        jmp    _Tdc;
// LINE 114:
_Tdc:
}

// FUNCTION: COPTER_D 0x004475e2
void PaletteBuffer::DrawPalette() {
	/*bp-0x10*/  /*packed*/ struct SparkalRect rectFill; // 0x10 bytes
	/*bp-0x14*/  int32_t i;
	/*bp-0x114*/ char szDescriptionString[256]; // 0x100 bytes

// LINE 127:
	__asm        jmp    near ptr 0x004475F9;
// LINE 131:
	rectFill.left = 0x0;
// LINE 132:
	rectFill.top = 0x0;
// LINE 133:
	rectFill.right = this->mWidth;
// LINE 134:
	rectFill.bottom = this->mHeight;
// LINE 135:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        push   0xFF;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 138:
	__asm        mov    i, 0;
	__asm        jmp    _T66;
_T63:
	__asm        inc    i;
_T66:
	__asm        cmp    i, 0x100;
	__asm        jge    _T15f;
// LINE 139:
	__asm        mov    ecx, 0x2C;
	__asm        mov    eax, i;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        lea    eax, [eax+eax*4];
	__asm        mov    rectFill.left, eax;
// LINE 140:
	__asm        mov    ecx, 0x2C;
	__asm        mov    eax, i;
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        lea    eax, [edx+edx*4];
	__asm        add    eax, eax;
	__asm        mov    rectFill.top, eax;
// LINE 141:
	__asm        mov    eax, rectFill.left;
	__asm        add    eax, 0xA;
	__asm        mov    rectFill.right, eax;
// LINE 142:
	__asm        mov    eax, rectFill.top;
	__asm        add    eax, 0xA;
	__asm        mov    rectFill.bottom, eax;
// LINE 143:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 145:
	__asm        mov    eax, rectFill.left;
	__asm        add    eax, 0x5A;
	__asm        mov    rectFill.right, eax;
// LINE 146:
	rectFill.left += 0xb;
// LINE 148:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    ecx, i;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx*4];
	__asm        push   edx;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    ecx, i;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx*4+1];
	__asm        push   edx;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    ecx, i;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx*4+2];
	__asm        push   edx;
	__asm        mov    eax, i;
	__asm        push   eax;
	__asm        push   0x598F14;
	__asm        lea    eax, szDescriptionString[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x18;
// LINE 150:
	__asm        push   0;
	__asm        lea    eax, rectFill.bottom;
	__asm        push   eax;
	__asm        lea    eax, rectFill.right;
	__asm        push   eax;
	__asm        lea    eax, rectFill.top;
	__asm        push   eax;
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szDescriptionString[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x4C];
// LINE 151:
	__asm        jmp    _T63;
// LINE 152:
_T15f:
	__asm        jmp    near ptr 0x00447746;
}

// FUNCTION: COPTER_D 0x0044774b
unsigned long PaletteBuffer::Compose(/*packed*/ class IFlatImage *pDestImage, long DestLeft, long DestTop, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom) {
// LINE 162:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, DestTop;
	__asm        push   eax;
	__asm        mov    eax, DestLeft;
	__asm        push   eax;
	__asm        mov    eax, pDestImage;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::Compose;
	__asm        jmp    near ptr 0x00447782;
// LINE 163:
}



// Contribution: 1:00046790-000467a8 Module: 50, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 2:000005e0-00000643 Module: 50, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for PaletteBuffer @ 0x0058f5e0
//   00: CBackBuffer::Lock @ 0x0047006f
//   01: CBackBuffer::Unlock @ 0x00470149
//   02: CBackBuffer::SetTransparentColor @ 0x0046ffe6
//   03: PaletteBuffer::Compose @ 0x0044774b
//   04: CBackBuffer::StretchCompose @ 0x0046fe13
//   05: IFlatImage::StretchCompose @ 0x0048f32e
//   06: IFlatImage::FillRect @ 0x0048f56b
//   07: CBackBuffer::Swap @ 0x0046f7bb
//   08: CBackBuffer::SwapRect @ 0x0046f828
//   09: CBackBuffer::StretchRect @ 0x0046ffcc
//   10: CBackBuffer::InitializeMemberVariables @ 0x0046eb58
//   11: CBackBuffer::Compose @ 0x0046fd33
//   12: CBackBuffer::StretchCompose @ 0x0046fd82
//   13: CBackBuffer::Duplicate @ 0x0046fe7c
//   14: CBackBuffer::ComposeNoClip @ 0x0046fce4
//   15: CBackBuffer::ComposeNoClip @ 0x0046fbb1
//   16: CBackBuffer::DrawLine @ 0x0046f5c6
//   17: CBackBuffer::FillRect @ 0x004702f1
//   18: CBackBuffer::DrawBufferText @ 0x0046f403
//   19: CBackBuffer::DrawBufferText @ 0x0046f1bd
//   20: CBackBuffer::DrawLineUnclipped @ 0x00470864
//   21: CBackBuffer::DrawLineClipped @ 0x00470c22
//   22: CBackBuffer::DrawRectangleOutline @ 0x004706e4
//   23: CBackBuffer::DrawRectangleOutlineUnclipped @ 0x004707a4
//   24: CBackBuffer::GetDDSurface @ 0x004704a7
//   25 entries



// Contribution: 3:00001f14-00001f24 Module: 50, 4 byte alignment, initialized_data, read, write, 
