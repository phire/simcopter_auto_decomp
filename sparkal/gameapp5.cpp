// Module: gameapp5.obj
// Source: C:\Copter\source\sparkal\gameapp5.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*unpacked*/ class CGameApp (forward reference);
// CGameApp Class implementation not found

// Type: int32_t *;

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: /*packed*/ class CBackBuffer (forward reference);
// VTABLE: COPTER_D 0x00590808
class CBackBuffer : public IBackBuffer
{ // packed(0x134 bytes) TI: 0x2843
public:
	void CBackBuffer(long, long, const /*packed*/ struct SparkalColor*);
	void CBackBuffer(char *);
	void CBackBuffer();
	virtual void InitializeMemberVariables(); // vtable+0x28
	void ~CBackBuffer();
	unsigned long Load();
	virtual unsigned long Lock() /* override */;
	virtual unsigned long Unlock() /* override */;
	// calltype: NearC
	static int32_t GetPaletteFromImage(char *, /*packed*/ struct SparkalColor*);
	virtual unsigned long Swap(/*packed*/ class CSparkalWindow*, long, long) /* override */;
	virtual unsigned long SwapRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalPoint&, const /*packed*/ struct SparkalRect&); // vtable+0x2c
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalRect&, const /*packed*/ struct SparkalRect&); // vtable+0x30
	virtual unsigned long Duplicate(/*packed*/ class CBackBuffer*, int32_t); // vtable+0x34
	virtual unsigned long ComposeNoClip(/*packed*/ class IFlatImage*, const /*packed*/ struct SparkalPoint&, const /*packed*/ struct SparkalRect&); // vtable+0x38
	virtual unsigned long ComposeNoClip(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0x3c
	void UpdatePalette(long, long, const /*packed*/ struct SparkalColor*);
	virtual void SetTransparentColor(int32_t, long) /* override */;
	unsigned long GetTransparentColor(long&);
	unsigned long SetFont(/*packed*/ class MFont*);
	void SetFontColor(/*packed*/ struct SparkalColor&);
	void SetFontIndex(int32_t);
	void SetColor(/*packed*/ struct SparkalColor&);
	void SetColorIndex(int32_t);
	virtual unsigned long DrawLine(long, long, long, long, long); // vtable+0x40
	virtual unsigned long FillRect(long, const /*packed*/ struct SparkalRect*); // vtable+0x44
	virtual unsigned long DrawBufferText(char *, long, unsigned long, const /*packed*/ class MRect&, /*packed*/ class MFont*); // vtable+0x48
	virtual unsigned long DrawBufferText(char *, unsigned long, long *, long *, long *, long *, /*packed*/ class MFont*); // vtable+0x4c
	virtual unsigned long DrawLineUnclipped(long, long, long, long, long); // vtable+0x50
	virtual unsigned long DrawLineClipped(long, long, long, long, long); // vtable+0x54
	virtual unsigned long DrawRectangleOutline(const /*packed*/ struct SparkalRect&, long); // vtable+0x58
	virtual unsigned long DrawRectangleOutlineUnclipped(const /*packed*/ struct SparkalRect&, long); // vtable+0x5c
	long IsLost();
	long Restore();
	/*+0x18*/  char * szFilePath;
	/*+0x1c*/  /*packed*/ struct tagRECT rectDirectDrawBuffer; // 0x10 bytes
protected:
	/*+0x2c*/  int32_t bSurfacePrimary;
	/*+0x30*/  int32_t bSurfaceTransparent;
	/*+0x34*/  /*packed*/ class MFont *mFont;
	/*+0x38*/  /*packed*/ struct SparkalColor colorFontCurrent;
	/*+0x3c*/  /*packed*/ struct SparkalColor colorCurrent;
	/*+0x40*/  int32_t nColorIndexFontCurrent;
	/*+0x44*/  int32_t nColorIndexCurrent;
	/*+0x48*/  int32_t nColorIndexTransparent;
	/*+0x4c*/  /*packed*/ struct IDirectDrawSurface *mpFrontSurface;
	/*+0x50*/  /*packed*/ struct IDirectDrawSurface *mpBackSurface;
	/*+0x54*/  /*packed*/ struct IDirectDrawPalette *mpPalette;
	/*+0x58*/  /*packed*/ struct _DDSURFACEDESC mDDdesc; // 0x6c bytes
	/*+0xc4*/  /*packed*/ struct _DDBLTFX mDDBltFx; // 0x64 bytes
	/*+0x128*/ void * __ptr32 hPen;
	/*+0x12c*/ int32_t nPenThickness;
	/*+0x130*/ /*packed*/ struct SparkalColor colorPenCurrent;
	virtual /*packed*/ struct IDirectDrawSurface* GetDDSurface(); // vtable+0x60
};

// Type: char *;

// Type: int32_t;

// Type: long;

// Type: char;

// Type: /*packed*/ struct MISSION_DATA (forward reference);
struct MISSION_DATA{ // packed(0xd4 bytes) TI: 0x31c4
	/*+0x0*/   char mtext[32]; // 0x20 bytes
	/*+0x20*/  long type_ctr;
	/*+0x24*/  long key;
	/*+0x28*/  /*packed*/ struct Point2d maploc; // 0x8 bytes
	/*+0x30*/  /*packed*/ struct Point2d destmaploc; // 0x8 bytes
	/*+0x38*/  /*packed*/ struct Point2d pickuploc; // 0x8 bytes
	/*+0x40*/  int32_t timer;
	/*+0x44*/  long money_bonus;
	/*+0x48*/  long points_bonus;
	/*+0x4c*/  long flags;
	/*+0x50*/  long type;
	/*+0x54*/  long state;
	/*+0x58*/  /*packed*/ struct __unnamed mdata; // 0x7c bytes
};

// Type: /*packed*/ class IBackBuffer;
// VTABLE: COPTER_D 0x005907e0
class IBackBuffer : public IFlatImage
{ // packed(0x18 bytes) TI: 0x283f
public:
	virtual unsigned long Swap(/*packed*/ class CSparkalWindow*, long, long); // vtable+0x1c
	virtual unsigned long SwapRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long); // vtable+0x20
	virtual unsigned long StretchRect(/*packed*/ class CSparkalWindow*, long, long, long, long, long, long, long, long); // vtable+0x24
};

// Type: /*packed*/ class IFlatImage;
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(/*packed*/ class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, /*packed*/ struct SparkalRect, /*packed*/ struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	/*+0x4*/   unsigned long mLockCount;
	/*+0x8*/   long mWidth;
	/*+0xc*/   long mHeight;
	/*+0x10*/  void * __ptr32 mpBits;
	/*+0x14*/  long mStride;
};



// Contribution: 1:00094b40-000953a2 Module: 19, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00495b40
void CGameApp::GetFullRenderingWindowSize(int32_t * nWidth, int32_t * nHeight) {
// LINE 68:
	__asm        cmp    gameResolution, 0;
	__asm        jne    _T30;
// LINE 69:
	nWidth[0] = 0x140;
// LINE 70:
	nHeight[0] = 0xf0;
// LINE 72:
	__asm        jmp    _T97;
_T30:
	__asm        cmp    gameResolution, 1;
	__asm        jne    _T54;
// LINE 73:
	nWidth[0] = 0x280;
// LINE 74:
	nHeight[0] = 0x1e0;
// LINE 76:
	__asm        jmp    _T97;
_T54:
	__asm        cmp    gameResolution, 2;
	__asm        jne    _T78;
// LINE 77:
	nWidth[0] = 0x320;
// LINE 78:
	nHeight[0] = 0x258;
// LINE 80:
	__asm        jmp    _T97;
_T78:
	__asm        cmp    gameResolution, 3;
	__asm        jne    _T97;
// LINE 81:
	nWidth[0] = 0x400;
// LINE 82:
	nHeight[0] = 0x300;
// LINE 84:
_T97:
	return;
}

// FUNCTION: COPTER_D 0x00495be3
int32_t CGameApp::S3PreRender() {
	/*bp-0x10*/  /*packed*/ struct SparkalRect rectFill; // 0x10 bytes

// LINE 93:
	__asm        jmp    _T11;
// LINE 95:
_T11:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x42F8], 0x280;
	__asm        jl     _T171;
// LINE 96:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4308], 0;
	__asm        jne    _T6d;
// LINE 98:
	__asm        push   0x598EC0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 99:
	__asm        call   VRFrustSetNormals;
// LINE 100:
	G_video_mode = 0x20;
// LINE 101:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 102:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 104:
	__asm        jmp    _T16c;
_T6d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4308], 1;
	__asm        jne    _T138;
// LINE 106:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _Te1;
// LINE 107:
	__asm        call   S3ViewerPosDelta;
	__asm        cmp    eax, 0x30000;
	__asm        jge    _Tdc;

	__asm        call   S3ViewerRotDelta;
	__asm        cmp    eax, 0x64;
	__asm        jge    _Tdc;
// LINE 108:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 109:
	__asm        call   VRFrustSetNormals;
// LINE 110:
	G_video_mode = 0x10;
// LINE 111:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 112:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 115:
_Tdc:
	__asm        jmp    _T133;
// LINE 116:
_Te1:
	__asm        call   S3ViewerPosDelta;
	__asm        cmp    eax, 0x30000;
	__asm        jge    _Tff;

	__asm        call   S3ViewerRotDelta;
	__asm        cmp    eax, 0x64;
	__asm        jl     _T133;
// LINE 117:
_Tff:
	__asm        push   0x598EC0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 118:
	__asm        call   VRFrustSetNormals;
// LINE 119:
	G_video_mode = 0x20;
// LINE 120:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 121:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 125:
_T133:
	__asm        jmp    _T16c;
// LINE 127:
_T138:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 128:
	__asm        call   VRFrustSetNormals;
// LINE 129:
	G_video_mode = 0x10;
// LINE 130:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 131:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 134:
_T16c:
	__asm        jmp    _T1a5;
// LINE 135:
_T171:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 136:
	__asm        call   VRFrustSetNormals;
// LINE 137:
	G_video_mode = 0x10;
// LINE 138:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 139:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 143:
_T1a5:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T267;
// LINE 144:
	rectFill.left = qwindow.WindowX;
// LINE 145:
	rectFill.top = qwindow.WindowY;
// LINE 146:
	rectFill.right = (qwindow.WindowWide + qwindow.WindowX);
// LINE 147:
	rectFill.bottom = (qwindow.WindowY + qwindow.WindowHigh);
// LINE 150:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        mov    eax, G_ClearColor;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+0x44];
// LINE 153:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4330], 0;
	__asm        je     _T236;
// LINE 154:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xDC];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xDC];
	__asm        call   dword ptr [edx+0x64];
// LINE 158:
_T236:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx];
// LINE 159:
	__asm        jmp    _T251;
_T251:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    buffer1, eax;
// LINE 161:
	__asm        jmp    _T305;
// LINE 162:
_T267:
	rectFill.left = swindow.WindowX;
// LINE 163:
	rectFill.top = swindow.WindowY;
// LINE 164:
	rectFill.right = (swindow.WindowWide + swindow.WindowX);
// LINE 165:
	rectFill.bottom = (swindow.WindowY + swindow.WindowHigh);
// LINE 169:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        mov    eax, G_ClearColor;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+0x18];
// LINE 172:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4330], 0;
	__asm        je     _T2e2;
// LINE 173:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xDC];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xDC];
	__asm        call   dword ptr [edx+0x64];
// LINE 175:
_T2e2:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx];
// LINE 176:
	__asm        jmp    _T2f7;
_T2f7:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    buffer1, eax;
// LINE 188:
_T305:
	return 0x1;
// LINE 189:
}

// FUNCTION: COPTER_D 0x00495ef7
void CGameApp::S3PostRender() {
// LINE 198:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T94;
// LINE 200:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+4];
// LINE 202:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        push   eax;
	__asm        call   BodyDrawDebugInfo;
	__asm        add    esp, 4;
// LINE 206:
	__asm        mov    eax, qwindow.WindowHigh;
	__asm        push   eax;
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, swindow.WindowHigh;
	__asm        push   eax;
	__asm        mov    eax, swindow.WindowWide;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+0x10];
// LINE 207:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::DrawCrosshairs;
// LINE 209:
	__asm        jmp    _Tc3;
// LINE 210:
_T94:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::DrawCrosshairs;
// LINE 211:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+4];
// LINE 213:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        call   BodyDrawDebugInfo;
	__asm        add    esp, 4;
// LINE 216:
_Tc3:
	return;
}

// FUNCTION: COPTER_D 0x00495fc4
void CGameApp::DrawCrosshairs(/*packed*/ class CBackBuffer *bufferToDrawTo) {
	/*bp-0x4*/   char * pBufferCurrentPosition;
	/*bp-0x8*/   int32_t nSurfaceStride;
	/*bp-0xc*/   int32_t i;
	/*bp-0x10*/  int32_t nMidYPosition;
	/*bp-0x14*/  int32_t nMidXPosition;
	/*bp-0x18*/  char * pBufferStart;

// LINE 235:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _Tf5;

	__asm        cmp    G_camera_mode, 3;
	__asm        je     _Tf5;
// LINE 237:
	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, bufferToDrawTo;
	__asm        call   dword ptr [eax];
// LINE 238:
	__asm        jmp    _T35;
_T35:
	pBufferStart = bufferToDrawTo->mpBits;
// LINE 239:
	__asm        jmp    _T43;
_T43:
	nSurfaceStride = bufferToDrawTo->mStride;
// LINE 241:
	__asm        mov    eax, swindow.WindowWide;
	__asm        sar    eax, 1;
	__asm        mov    nMidXPosition, eax;
// LINE 242:
	__asm        mov    eax, swindow.WindowHigh;
	__asm        sar    eax, 1;
	__asm        mov    nMidYPosition, eax;
// LINE 243:
	__asm        mov    eax, nMidYPosition;
	__asm        sub    eax, 0xD;
	__asm        imul   eax, nSurfaceStride;
	__asm        add    eax, nMidXPosition;
	__asm        add    eax, pBufferStart;
	__asm        mov    pBufferCurrentPosition, eax;
// LINE 244:
	__asm        mov    i, 0;
	__asm        jmp    _T84;
_T81:
	i++;
_T84:
	__asm        cmp    i, 0x1C;
	__asm        jge    _Ta6;
// LINE 245:
	pBufferCurrentPosition[0] = 0x0;
// LINE 246:
	pBufferCurrentPosition[1] = 0x0;
// LINE 247:
	pBufferCurrentPosition += nSurfaceStride;
// LINE 248:
	__asm        jmp    _T81;
// LINE 249:
_Ta6:
	__asm        mov    eax, nMidYPosition;
	__asm        imul   eax, nSurfaceStride;
	__asm        add    eax, nMidXPosition;
	__asm        add    eax, pBufferStart;
	__asm        sub    eax, 0xD;
	__asm        mov    pBufferCurrentPosition, eax;
// LINE 250:
	__asm        mov    i, 0;
	__asm        jmp    _Tc8;
_Tc5:
	i++;
_Tc8:
	__asm        cmp    i, 0x1C;
	__asm        jge    _Tea;
// LINE 251:
	pBufferCurrentPosition[0] = 0x0;
// LINE 252:
	__asm        mov    eax, nSurfaceStride;
	__asm        mov    ecx, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax+ecx], 0;
// LINE 253:
	pBufferCurrentPosition++;
// LINE 254:
	__asm        jmp    _Tc5;
// LINE 255:
_Tea:
	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, bufferToDrawTo;
	__asm        call   dword ptr [eax+4];
// LINE 257:
_Tf5:
	return;
}

// FUNCTION: COPTER_D 0x004960c5
void CGameApp::S3ShowInfo() {
	/*bp-0x4*/   long nTextLeft;
	/*bp-0x104*/ char szBuffer1[256]; // 0x100 bytes
	/*bp-0x108*/ long nTextTop;
	/*bp-0x10c*/ long nTextBottom;

// LINE 267:
	nTextLeft = 0x0;
// LINE 268:
	nTextTop = 0x0;
// LINE 269:
	nTextBottom = 0xc;
// LINE 271:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T42;
// LINE 272:
	return;
// LINE 275:
_T42:
	__asm        push   0;
	__asm        push   0xFF;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x44];
// LINE 283:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x118], eax;
	__asm        mov    eax, [ebp-0x118];
	__asm        mov    [ebp-0x114], eax;
	__asm        jmp    _T83;
_T83:
	__asm        jmp    _T88;
_T88:
	__asm        mov    eax, [ebp-0x114];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x114], eax;
	__asm        jmp    _T9c;
_T9c:
	__asm        jmp    _Ta1;
_Ta1:
	__asm        jmp    _Ta6;
_Ta6:
	__asm        mov    eax, [ebp-0x114];
	__asm        cmp    dword ptr [eax+8], 6;
	__asm        je     _T112;
// LINE 284:
	__asm        mov    eax, this;
	__asm        fld    dword ptr [eax+0x4344];
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        push   0x59A140;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x10;
// LINE 285:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 288:
	__asm        jmp    _T292;
// LINE 305:
// Block start:
	/*bp-0x110*/ /*packed*/ struct MISSION_DATA *md;
_T112:
	__asm        mov    eax, GridProjectEnd;
	__asm        sub    eax, NextProject;
	__asm        push   eax;
	__asm        mov    eax, G_alt;
	__asm        push   eax;
	__asm        mov    eax, G_ViewSize;
	__asm        push   eax;
	__asm        mov    eax, G_odpolys;
	__asm        push   eax;
	__asm        mov    eax, G_gdpolys;
	__asm        push   eax;
	__asm        mov    eax, G_opolys;
	__asm        push   eax;
	__asm        mov    eax, GridNSortFaces;
	__asm        push   eax;
	__asm        mov    eax, G_numcellsrej;
	__asm        push   eax;
	__asm        mov    eax, GridNSortCells;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        fld    dword ptr [eax+0x4344];
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        push   0x59A14C;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x34;
// LINE 306:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 314:
	__asm        mov    eax, IFlatImage::lTotalMemoryUsage;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        call   Sound::GetTotalMemoryUsage;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_max;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_used;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_curr;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        push   0x59A19C;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x1C;
// LINE 315:
	nTextTop += 0xc;
// LINE 316:
	nTextBottom += 0xc;
// LINE 317:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 319:
	__asm        call   S3MissionGetCurr;
	__asm        mov    md, eax;
// LINE 320:
	__asm        cmp    md, 0;
	__asm        je     _T292;
// LINE 321:
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissionDebugString;
	__asm        add    esp, 8;
// LINE 322:
	nTextTop += 0xc;
// LINE 323:
	nTextBottom += 0xc;
// LINE 324:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 379:
// Block end:
_T292:
	__asm        jmp    _T297;
_T297:
	__asm        mov    eax, nTextBottom;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0xC];
// LINE 380:
	return;
}



// Contribution: 3:00003140-000031c4 Module: 19, 4 byte alignment, initialized_data, read, write, 
