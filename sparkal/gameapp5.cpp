// Module: gameapp5.obj
// Source: C:\Copter\source\sparkal\gameapp5.cpp
// autogenerated by simcopter_tool from PDB file

// Type: class CGameApp (forward reference);
// CGameApp Class implementation not found

// Type: int32_t *;

// Type: struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	long left;
	long top;
	long right;
	long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: class CBackBuffer (forward reference);
// VTABLE: COPTER_D 0x00590808
class CBackBuffer : public IBackBuffer
{ // packed(0x134 bytes) TI: 0x2843
public:
	void CBackBuffer(long, long, const struct SparkalColor*);
	void CBackBuffer(char *);
	void CBackBuffer();
	virtual void InitializeMemberVariables(); // vtable+0x28
	void ~CBackBuffer();
	unsigned long Load();
	virtual unsigned long Lock() /* override */;
	virtual unsigned long Unlock() /* override */;
	// calltype: NearC
	static int32_t GetPaletteFromImage(char *, struct SparkalColor*);
	virtual unsigned long Swap(class CSparkalWindow*, long, long) /* override */;
	virtual unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long Compose(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&); // vtable+0x2c
	virtual unsigned long Compose(class IFlatImage*, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(class IFlatImage*, long, long, long, long, long, long, long, long) /* override */;
	virtual unsigned long StretchCompose(class IFlatImage*, const struct SparkalRect&, const struct SparkalRect&); // vtable+0x30
	virtual unsigned long Duplicate(class CBackBuffer*, int32_t); // vtable+0x34
	virtual unsigned long ComposeNoClip(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&); // vtable+0x38
	virtual unsigned long ComposeNoClip(class IFlatImage*, long, long, long, long, long, long); // vtable+0x3c
	void UpdatePalette(long, long, const struct SparkalColor*);
	virtual void SetTransparentColor(int32_t, long) /* override */;
	unsigned long GetTransparentColor(long&);
	unsigned long SetFont(class MFont*);
	void SetFontColor(struct SparkalColor&);
	void SetFontIndex(int32_t);
	void SetColor(struct SparkalColor&);
	void SetColorIndex(int32_t);
	virtual unsigned long DrawLine(long, long, long, long, long); // vtable+0x40
	virtual unsigned long FillRect(long, const struct SparkalRect*); // vtable+0x44
	virtual unsigned long DrawBufferText(char *, long, unsigned long, const class MRect&, class MFont*); // vtable+0x48
	virtual unsigned long DrawBufferText(char *, unsigned long, long *, long *, long *, long *, class MFont*); // vtable+0x4c
	virtual unsigned long DrawLineUnclipped(long, long, long, long, long); // vtable+0x50
	virtual unsigned long DrawLineClipped(long, long, long, long, long); // vtable+0x54
	virtual unsigned long DrawRectangleOutline(const struct SparkalRect&, long); // vtable+0x58
	virtual unsigned long DrawRectangleOutlineUnclipped(const struct SparkalRect&, long); // vtable+0x5c
	long IsLost();
	long Restore();
	char * szFilePath;
	struct tagRECT rectDirectDrawBuffer;
protected:
	int32_t bSurfacePrimary;
	int32_t bSurfaceTransparent;
	class MFont *mFont;
	struct SparkalColor colorFontCurrent;
	struct SparkalColor colorCurrent;
	int32_t nColorIndexFontCurrent;
	int32_t nColorIndexCurrent;
	int32_t nColorIndexTransparent;
	struct IDirectDrawSurface *mpFrontSurface;
	struct IDirectDrawSurface *mpBackSurface;
	struct IDirectDrawPalette *mpPalette;
	struct _DDSURFACEDESC mDDdesc;
	struct _DDBLTFX mDDBltFx;
	void * __ptr32 hPen;
	int32_t nPenThickness;
	struct SparkalColor colorPenCurrent;
	virtual struct IDirectDrawSurface* GetDDSurface(); // vtable+0x60
};

// Type: char *;

// Type: int32_t;

// Type: long;

// Type: char;

// Type: struct MISSION_DATA (forward reference);
struct MISSION_DATA{ // packed(0xd4 bytes) TI: 0x31c4
	char mtext[32];
	long type_ctr;
	long key;
	struct Point2d maploc;
	struct Point2d destmaploc;
	struct Point2d pickuploc;
	int32_t timer;
	long money_bonus;
	long points_bonus;
	long flags;
	long type;
	long state;
	struct __unnamed mdata;
};

// Type: class IBackBuffer;
// VTABLE: COPTER_D 0x005907e0
class IBackBuffer : public IFlatImage
{ // packed(0x18 bytes) TI: 0x283f
public:
	virtual unsigned long Swap(class CSparkalWindow*, long, long); // vtable+0x1c
	virtual unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long); // vtable+0x20
	virtual unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long); // vtable+0x24
};

// Type: class IFlatImage;
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(class IFlatImage*, struct SparkalRect, struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	unsigned long mLockCount;
	long mWidth;
	long mHeight;
	void * __ptr32 mpBits;
	long mStride;
};



// Contribution: 1:00094b40-000953a2 Module: 19, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00495b40
void  CGameApp::GetFullRenderingWindowSize(int32_t * nWidth, int32_t * nHeight) {
// LINE 68:
	__asm        cmp    gameResolution, 0;
	__asm        jne    _T30;
// LINE 69:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x140;
// LINE 70:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0xF0;
// LINE 72:
	__asm        jmp    _T97;
_T30:
	__asm        cmp    gameResolution, 1;
	__asm        jne    _T54;
// LINE 73:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x280;
// LINE 74:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0x1E0;
// LINE 76:
	__asm        jmp    _T97;
_T54:
	__asm        cmp    gameResolution, 2;
	__asm        jne    _T78;
// LINE 77:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x320;
// LINE 78:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0x258;
// LINE 80:
	__asm        jmp    _T97;
_T78:
	__asm        cmp    gameResolution, 3;
	__asm        jne    _T97;
// LINE 81:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x400;
// LINE 82:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0x300;
// LINE 84:
_T97:
	__asm        jmp    near ptr 0x00495BDC;
}

// FUNCTION: COPTER_D 0x00495be3
int  CGameApp::S3PreRender() {
	struct SparkalRect rectFill;

// LINE 93:
	__asm        jmp    near ptr 0x00495BF4;
// LINE 95:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x42F8], 0x280;
	__asm        jl     _T171;
// LINE 96:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4308], 0;
	__asm        jne    _T6d;
// LINE 98:
	__asm        push   0x598EC0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 99:
	__asm        call   VRFrustSetNormals;
// LINE 100:
	G_video_mode = 0x20;
// LINE 101:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 102:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 104:
	__asm        jmp    _T16c;
_T6d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4308], 1;
	__asm        jne    _T138;
// LINE 106:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _Te1;
// LINE 107:
	__asm        call   S3ViewerPosDelta;
	__asm        cmp    eax, 0x30000;
	__asm        jge    _Tdc;

	__asm        call   S3ViewerRotDelta;
	__asm        cmp    eax, 0x64;
	__asm        jge    _Tdc;
// LINE 108:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 109:
	__asm        call   VRFrustSetNormals;
// LINE 110:
	G_video_mode = 0x10;
// LINE 111:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 112:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 115:
_Tdc:
	__asm        jmp    _T133;
// LINE 116:
_Te1:
	__asm        call   S3ViewerPosDelta;
	__asm        cmp    eax, 0x30000;
	__asm        jge    _Tff;

	__asm        call   S3ViewerRotDelta;
	__asm        cmp    eax, 0x64;
	__asm        jl     _T133;
// LINE 117:
_Tff:
	__asm        push   0x598EC0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 118:
	__asm        call   VRFrustSetNormals;
// LINE 119:
	G_video_mode = 0x20;
// LINE 120:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 121:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 125:
_T133:
	__asm        jmp    _T16c;
// LINE 127:
_T138:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 128:
	__asm        call   VRFrustSetNormals;
// LINE 129:
	G_video_mode = 0x10;
// LINE 130:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 131:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 134:
_T16c:
	__asm        jmp    _T1a5;
// LINE 135:
_T171:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 136:
	__asm        call   VRFrustSetNormals;
// LINE 137:
	G_video_mode = 0x10;
// LINE 138:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 139:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 143:
_T1a5:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T267;
// LINE 144:
	rectFill.left = qwindow.WindowX;
// LINE 145:
	rectFill.top = qwindow.WindowY;
// LINE 146:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        add    eax, qwindow.WindowX;
	__asm        mov    rectFill.right, eax;
// LINE 147:
	__asm        mov    eax, qwindow.WindowY;
	__asm        add    eax, qwindow.WindowHigh;
	__asm        mov    rectFill.bottom, eax;
// LINE 150:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        mov    eax, G_ClearColor;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+0x44];
// LINE 153:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4330], 0;
	__asm        je     _T236;
// LINE 154:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xDC];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xDC];
	__asm        call   dword ptr [edx+0x64];
// LINE 158:
_T236:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx];
// LINE 159:
	__asm        jmp    near ptr 0x00495E34;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    buffer1, eax;
// LINE 161:
	__asm        jmp    _T305;
// LINE 162:
_T267:
	rectFill.left = swindow.WindowX;
// LINE 163:
	rectFill.top = swindow.WindowY;
// LINE 164:
	__asm        mov    eax, swindow.WindowWide;
	__asm        add    eax, swindow.WindowX;
	__asm        mov    rectFill.right, eax;
// LINE 165:
	__asm        mov    eax, swindow.WindowY;
	__asm        add    eax, swindow.WindowHigh;
	__asm        mov    rectFill.bottom, eax;
// LINE 169:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        mov    eax, G_ClearColor;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+0x18];
// LINE 172:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4330], 0;
	__asm        je     _T2e2;
// LINE 173:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xDC];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xDC];
	__asm        call   dword ptr [edx+0x64];
// LINE 175:
_T2e2:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx];
// LINE 176:
	__asm        jmp    near ptr 0x00495EDA;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    buffer1, eax;
// LINE 188:
_T305:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x00495EF2;
// LINE 189:
}

// FUNCTION: COPTER_D 0x00495ef7
void  CGameApp::S3PostRender() {
// LINE 198:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T94;
// LINE 200:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+4];
// LINE 202:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        push   eax;
	__asm        call   BodyDrawDebugInfo;
	__asm        add    esp, 4;
// LINE 206:
	__asm        mov    eax, qwindow.WindowHigh;
	__asm        push   eax;
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, swindow.WindowHigh;
	__asm        push   eax;
	__asm        mov    eax, swindow.WindowWide;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+0x10];
// LINE 207:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::DrawCrosshairs;
// LINE 209:
	__asm        jmp    _Tc3;
// LINE 210:
_T94:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::DrawCrosshairs;
// LINE 211:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+4];
// LINE 213:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        call   BodyDrawDebugInfo;
	__asm        add    esp, 4;
// LINE 216:
_Tc3:
	__asm        jmp    near ptr 0x00495FBF;
}

// FUNCTION: COPTER_D 0x00495fc4
void  CGameApp::DrawCrosshairs(class CBackBuffer *bufferToDrawTo) {
	char * pBufferStart;
	int32_t nMidXPosition;
	int32_t nMidYPosition;
	int32_t i;
	int32_t nSurfaceStride;
	char * pBufferCurrentPosition;

// LINE 235:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _Tf5;

	__asm        cmp    G_camera_mode, 3;
	__asm        je     _Tf5;
// LINE 237:
	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, bufferToDrawTo;
	__asm        call   dword ptr [eax];
// LINE 238:
	__asm        jmp    near ptr 0x00495FF9;

	pBufferStart = bufferToDrawTo->mpBits;
// LINE 239:
	__asm        jmp    near ptr 0x00496007;

	nSurfaceStride = bufferToDrawTo->mStride;
// LINE 241:
	__asm        mov    eax, swindow.WindowWide;
	__asm        sar    eax, 1;
	__asm        mov    nMidXPosition, eax;
// LINE 242:
	__asm        mov    eax, swindow.WindowHigh;
	__asm        sar    eax, 1;
	__asm        mov    nMidYPosition, eax;
// LINE 243:
	__asm        mov    eax, nMidYPosition;
	__asm        sub    eax, 0xD;
	__asm        imul   eax, nSurfaceStride;
	__asm        add    eax, nMidXPosition;
	__asm        add    eax, pBufferStart;
	__asm        mov    pBufferCurrentPosition, eax;
// LINE 244:
	__asm        mov    i, 0;
	__asm        jmp    _T84;
_T81:
	__asm        inc    i;
_T84:
	__asm        cmp    i, 0x1C;
	__asm        jge    _Ta6;
// LINE 245:
	__asm        mov    eax, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax], 0;
// LINE 246:
	__asm        mov    eax, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax+1], 0;
// LINE 247:
	__asm        mov    eax, nSurfaceStride;
	__asm        add    pBufferCurrentPosition, eax;
// LINE 248:
	__asm        jmp    _T81;
// LINE 249:
_Ta6:
	__asm        mov    eax, nMidYPosition;
	__asm        imul   eax, nSurfaceStride;
	__asm        add    eax, nMidXPosition;
	__asm        add    eax, pBufferStart;
	__asm        sub    eax, 0xD;
	__asm        mov    pBufferCurrentPosition, eax;
// LINE 250:
	__asm        mov    i, 0;
	__asm        jmp    _Tc8;
_Tc5:
	__asm        inc    i;
_Tc8:
	__asm        cmp    i, 0x1C;
	__asm        jge    _Tea;
// LINE 251:
	__asm        mov    eax, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax], 0;
// LINE 252:
	__asm        mov    eax, nSurfaceStride;
	__asm        mov    ecx, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax+ecx], 0;
// LINE 253:
	__asm        inc    pBufferCurrentPosition;
// LINE 254:
	__asm        jmp    _Tc5;
// LINE 255:
_Tea:
	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, bufferToDrawTo;
	__asm        call   dword ptr [eax+4];
// LINE 257:
_Tf5:
	__asm        jmp    near ptr 0x004960BE;
}

// FUNCTION: COPTER_D 0x004960c5
void  CGameApp::S3ShowInfo() {
	long nTextBottom;
	long nTextTop;
	char szBuffer1[256];
	long nTextLeft;

// LINE 267:
	nTextLeft = 0x0;
// LINE 268:
	nTextTop = 0x0;
// LINE 269:
	nTextBottom = 0xc;
// LINE 271:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T42;
// LINE 272:
	__asm        jmp    _T2d9;
// LINE 275:
_T42:
	__asm        push   0;
	__asm        push   0xFF;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x44];
// LINE 283:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x118], eax;
	__asm        mov    eax, [ebp-0x118];
	__asm        mov    [ebp-0x114], eax;
	__asm        jmp    near ptr 0x00496148;

	__asm        jmp    near ptr 0x0049614D;

	__asm        mov    eax, [ebp-0x114];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x114], eax;
	__asm        jmp    near ptr 0x00496161;

	__asm        jmp    near ptr 0x00496166;

	__asm        jmp    near ptr 0x0049616B;

	__asm        mov    eax, [ebp-0x114];
	__asm        cmp    dword ptr [eax+8], 6;
	__asm        je     _T112;
// LINE 284:
	__asm        mov    eax, this;
	__asm        fld    dword ptr [eax+0x4344];
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        push   0x59A140;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x10;
// LINE 285:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 288:
	__asm        jmp    _T292;
// LINE 305:
// Block start:
	struct MISSION_DATA *md;
_T112:
	__asm        mov    eax, GridProjectEnd;
	__asm        sub    eax, NextProject;
	__asm        push   eax;
	__asm        mov    eax, G_alt;
	__asm        push   eax;
	__asm        mov    eax, G_ViewSize;
	__asm        push   eax;
	__asm        mov    eax, G_odpolys;
	__asm        push   eax;
	__asm        mov    eax, G_gdpolys;
	__asm        push   eax;
	__asm        mov    eax, G_opolys;
	__asm        push   eax;
	__asm        mov    eax, GridNSortFaces;
	__asm        push   eax;
	__asm        mov    eax, G_numcellsrej;
	__asm        push   eax;
	__asm        mov    eax, GridNSortCells;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        fld    dword ptr [eax+0x4344];
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        push   0x59A14C;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x34;
// LINE 306:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 314:
	__asm        mov    eax, IFlatImage::lTotalMemoryUsage;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        call   Sound::GetTotalMemoryUsage;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_max;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_used;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_curr;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        push   0x59A19C;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x1C;
// LINE 315:
	__asm        add    nTextTop, 0xC;
// LINE 316:
	__asm        add    nTextBottom, 0xC;
// LINE 317:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 319:
	__asm        call   S3MissionGetCurr;
	__asm        mov    md, eax;
// LINE 320:
	__asm        cmp    md, 0;
	__asm        je     _T292;
// LINE 321:
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissionDebugString;
	__asm        add    esp, 8;
// LINE 322:
	__asm        add    nTextTop, 0xC;
// LINE 323:
	__asm        add    nTextBottom, 0xC;
// LINE 324:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 379:
// Block end:
_T292:
	__asm        jmp    near ptr 0x0049635C;

	__asm        mov    eax, nTextBottom;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0xC];
// LINE 380:
	__asm        jmp    _T2d9;
_T2d9:
}



// Contribution: 3:00003140-000031c4 Module: 19, 4 byte alignment, initialized_data, read, write, 
