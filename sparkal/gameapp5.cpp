// Module: gameapp5.obj
// Source: C:\Copter\source\sparkal\gameapp5.cpp
// autogenerated by simcopter_tool from PDB file

// Type: class CGameApp (forward reference);
// CGameApp Class implementation not found

// Type: int32_t *;

// Type: struct SparkalRect;
struct SparkalRect{
	long left;
	long top;
	long right;
	long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: class CBackBuffer (forward reference);
class CBackBuffer : public IBackBuffer
{
public:
	void CBackBuffer(long, long, const struct SparkalColor*);
	void CBackBuffer(char *);
	void CBackBuffer();
	// vtable: 40
	intro void InitializeMemberVariables();
	void ~CBackBuffer();
	unsigned long Load();
	virtual unsigned long Lock();
	virtual unsigned long Unlock();
	// calltype: NearC
	static int32_t GetPaletteFromImage(char *, struct SparkalColor*);
	virtual unsigned long Swap(class CSparkalWindow*, long, long);
	virtual unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long);
	virtual unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long);
	// vtable: 44
	intro unsigned long Compose(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&);
	virtual unsigned long Compose(class IFlatImage*, long, long, long, long, long, long);
	virtual unsigned long StretchCompose(class IFlatImage*, long, long, long, long, long, long, long, long);
	// vtable: 48
	intro unsigned long StretchCompose(class IFlatImage*, const struct SparkalRect&, const struct SparkalRect&);
	// vtable: 52
	intro unsigned long Duplicate(class CBackBuffer*, int32_t);
	// vtable: 56
	intro unsigned long ComposeNoClip(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&);
	// vtable: 60
	intro unsigned long ComposeNoClip(class IFlatImage*, long, long, long, long, long, long);
	void UpdatePalette(long, long, const struct SparkalColor*);
	virtual void SetTransparentColor(int32_t, long);
	unsigned long GetTransparentColor(long&);
	unsigned long SetFont(class MFont*);
	void SetFontColor(struct SparkalColor&);
	void SetFontIndex(int32_t);
	void SetColor(struct SparkalColor&);
	void SetColorIndex(int32_t);
	// vtable: 64
	intro unsigned long DrawLine(long, long, long, long, long);
	// vtable: 68
	intro unsigned long FillRect(long, const struct SparkalRect*);
	// vtable: 72
	intro unsigned long DrawBufferText(char *, long, unsigned long, const class MRect&, class MFont*);
	// vtable: 76
	intro unsigned long DrawBufferText(char *, unsigned long, long *, long *, long *, long *, class MFont*);
	// vtable: 80
	intro unsigned long DrawLineUnclipped(long, long, long, long, long);
	// vtable: 84
	intro unsigned long DrawLineClipped(long, long, long, long, long);
	// vtable: 88
	intro unsigned long DrawRectangleOutline(const struct SparkalRect&, long);
	// vtable: 92
	intro unsigned long DrawRectangleOutlineUnclipped(const struct SparkalRect&, long);
	long IsLost();
	long Restore();
	char * szFilePath;
	struct tagRECT rectDirectDrawBuffer;
protected:
	int32_t bSurfacePrimary;
	int32_t bSurfaceTransparent;
	class MFont* mFont;
	struct SparkalColor colorFontCurrent;
	struct SparkalColor colorCurrent;
	int32_t nColorIndexFontCurrent;
	int32_t nColorIndexCurrent;
	int32_t nColorIndexTransparent;
	struct IDirectDrawSurface* mpFrontSurface;
	struct IDirectDrawSurface* mpBackSurface;
	struct IDirectDrawPalette* mpPalette;
	struct _DDSURFACEDESC mDDdesc;
	struct _DDBLTFX mDDBltFx;
	void * __ptr32 hPen;
	int32_t nPenThickness;
	struct SparkalColor colorPenCurrent;
	// vtable: 96
	intro struct IDirectDrawSurface* GetDDSurface();
};

// Type: char *;

// Type: int32_t;

// Type: long;

// Type: char;

// Type: struct MISSION_DATA (forward reference);
struct MISSION_DATA{
	char mtext[32];
	long type_ctr;
	long key;
	struct Point2d maploc;
	struct Point2d destmaploc;
	struct Point2d pickuploc;
	int32_t timer;
	long money_bonus;
	long points_bonus;
	long flags;
	long type;
	long state;
	struct MISSION_DATA::__unnamed mdata;
};

// Type: class IBackBuffer;
class IBackBuffer : public IFlatImage
{
public:
	// vtable: 28
	intro unsigned long Swap(class CSparkalWindow*, long, long);
	// vtable: 32
	intro unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long);
	// vtable: 36
	intro unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long);
};

// Type: class IFlatImage;
class IFlatImage{
public:
	void IFlatImage();
	// vtable: 0
	intro unsigned long Lock();
	// vtable: 4
	intro unsigned long Unlock();
	unsigned long GetLockCount();
	// vtable: 8
	intro void SetTransparentColor(int32_t, long);
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	// vtable: 12
	intro unsigned long Compose(class IFlatImage*, long, long, long, long, long, long);
	unsigned long Compose(class IFlatImage*, long, long);
	// vtable: 16
	intro unsigned long StretchCompose(class IFlatImage*, long, long, long, long, long, long, long, long);
	// vtable: 20
	intro unsigned long StretchCompose(class IFlatImage*, struct SparkalRect, struct SparkalRect);
	// vtable: 24
	intro unsigned long FillRect(long, struct SparkalRect*);
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	unsigned long mLockCount;
	long mWidth;
	long mHeight;
	void * __ptr32 mpBits;
	long mStride;
};



// Contribution: 1:00094b40-000953a2 Module: 19, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x00495b40
void  CGameApp::GetFullRenderingWindowSize(int32_t * nWidth, int32_t * nHeight) {
// LINE 68:
	__asm        cmp    gameResolution, 0;
	__asm        jne    _T30;
// LINE 69:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x140;
// LINE 70:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0xF0;
// LINE 72:
	__asm        jmp    _T97;
_T30:
	__asm        cmp    gameResolution, 1;
	__asm        jne    _T54;
// LINE 73:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x280;
// LINE 74:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0x1E0;
// LINE 76:
	__asm        jmp    _T97;
_T54:
	__asm        cmp    gameResolution, 2;
	__asm        jne    _T78;
// LINE 77:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x320;
// LINE 78:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0x258;
// LINE 80:
	__asm        jmp    _T97;
_T78:
	__asm        cmp    gameResolution, 3;
	__asm        jne    _T97;
// LINE 81:
	__asm        mov    eax, nWidth;
	__asm        mov    dword ptr [eax], 0x400;
// LINE 82:
	__asm        mov    eax, nHeight;
	__asm        mov    dword ptr [eax], 0x300;
// LINE 84:
_T97:
	__asm        jmp    near ptr 0x00495BDC;
}

// FUNCTION: COPTER_D 0x00495be3
int  CGameApp::S3PreRender() {
	struct SparkalRect rectFill;

// LINE 93:
	__asm        jmp    near ptr 0x00495BF4;
// LINE 95:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x42F8], 0x280;
	__asm        jl     _T171;
// LINE 96:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4308], 0;
	__asm        jne    _T6d;
// LINE 98:
	__asm        push   0x598EC0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 99:
	__asm        call   VRFrustSetNormals;
// LINE 100:
	__asm        mov    G_video_mode, 0x20;
// LINE 101:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 102:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 104:
	__asm        jmp    _T16c;
_T6d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4308], 1;
	__asm        jne    _T138;
// LINE 106:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _Te1;
// LINE 107:
	__asm        call   S3ViewerPosDelta;
	__asm        cmp    eax, 0x30000;
	__asm        jge    _Tdc;

	__asm        call   S3ViewerRotDelta;
	__asm        cmp    eax, 0x64;
	__asm        jge    _Tdc;
// LINE 108:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 109:
	__asm        call   VRFrustSetNormals;
// LINE 110:
	__asm        mov    G_video_mode, 0x10;
// LINE 111:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 112:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 115:
_Tdc:
	__asm        jmp    _T133;
// LINE 116:
_Te1:
	__asm        call   S3ViewerPosDelta;
	__asm        cmp    eax, 0x30000;
	__asm        jge    _Tff;

	__asm        call   S3ViewerRotDelta;
	__asm        cmp    eax, 0x64;
	__asm        jl     _T133;
// LINE 117:
_Tff:
	__asm        push   0x598EC0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 118:
	__asm        call   VRFrustSetNormals;
// LINE 119:
	__asm        mov    G_video_mode, 0x20;
// LINE 120:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 121:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 125:
_T133:
	__asm        jmp    _T16c;
// LINE 127:
_T138:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 128:
	__asm        call   VRFrustSetNormals;
// LINE 129:
	__asm        mov    G_video_mode, 0x10;
// LINE 130:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 131:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 134:
_T16c:
	__asm        jmp    _T1a5;
// LINE 135:
_T171:
	__asm        push   0x598EE0;
	__asm        call   0x004D6A69;
	__asm        add    esp, 4;
// LINE 136:
	__asm        call   VRFrustSetNormals;
// LINE 137:
	__asm        mov    G_video_mode, 0x10;
// LINE 138:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_ASPECT, cl;
// LINE 139:
	__asm        mov    cl, reinterpret_cast<uint8_t>(G_zoom_level);
	__asm        shl    HALF_WIDTH, cl;
// LINE 143:
_T1a5:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T267;
// LINE 144:
	__asm        mov    eax, qwindow.WindowX;
	__asm        mov    rectFill.left, eax;
// LINE 145:
	__asm        mov    eax, qwindow.WindowY;
	__asm        mov    rectFill.top, eax;
// LINE 146:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        add    eax, qwindow.WindowX;
	__asm        mov    rectFill.right, eax;
// LINE 147:
	__asm        mov    eax, qwindow.WindowY;
	__asm        add    eax, qwindow.WindowHigh;
	__asm        mov    rectFill.bottom, eax;
// LINE 150:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        mov    eax, G_ClearColor;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+0x44];
// LINE 153:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4330], 0;
	__asm        je     _T236;
// LINE 154:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xDC];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xDC];
	__asm        call   dword ptr [edx+0x64];
// LINE 158:
_T236:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx];
// LINE 159:
	__asm        jmp    near ptr 0x00495E34;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    buffer1, eax;
// LINE 161:
	__asm        jmp    _T305;
// LINE 162:
_T267:
	__asm        mov    eax, swindow.WindowX;
	__asm        mov    rectFill.left, eax;
// LINE 163:
	__asm        mov    eax, swindow.WindowY;
	__asm        mov    rectFill.top, eax;
// LINE 164:
	__asm        mov    eax, swindow.WindowWide;
	__asm        add    eax, swindow.WindowX;
	__asm        mov    rectFill.right, eax;
// LINE 165:
	__asm        mov    eax, swindow.WindowY;
	__asm        add    eax, swindow.WindowHigh;
	__asm        mov    rectFill.bottom, eax;
// LINE 169:
	__asm        lea    eax, rectFill.left;
	__asm        push   eax;
	__asm        mov    eax, G_ClearColor;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+0x18];
// LINE 172:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4330], 0;
	__asm        je     _T2e2;
// LINE 173:
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xDC];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xDC];
	__asm        call   dword ptr [edx+0x64];
// LINE 175:
_T2e2:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx];
// LINE 176:
	__asm        jmp    near ptr 0x00495EDA;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        mov    eax, [eax+0x10];
	__asm        mov    buffer1, eax;
// LINE 188:
_T305:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x00495EF2;
// LINE 189:
}

// FUNCTION: COPTER_D 0x00495ef7
void  CGameApp::S3PostRender() {
// LINE 198:
	__asm        cmp    G_video_mode, 0x20;
	__asm        jne    _T94;
// LINE 200:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+4];
// LINE 202:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xD8];
	__asm        push   eax;
	__asm        call   BodyDrawDebugInfo;
	__asm        add    esp, 4;
// LINE 206:
	__asm        mov    eax, qwindow.WindowHigh;
	__asm        push   eax;
	__asm        mov    eax, qwindow.WindowWide;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, swindow.WindowHigh;
	__asm        push   eax;
	__asm        mov    eax, swindow.WindowWide;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xD8];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0xD8];
	__asm        call   dword ptr [edx+0x10];
// LINE 207:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::DrawCrosshairs;
// LINE 209:
	__asm        jmp    _Tc3;
// LINE 210:
_T94:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   CGameApp::DrawCrosshairs;
// LINE 211:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x34];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x34];
	__asm        call   dword ptr [edx+4];
// LINE 213:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        call   BodyDrawDebugInfo;
	__asm        add    esp, 4;
// LINE 216:
_Tc3:
	__asm        jmp    near ptr 0x00495FBF;
}

// FUNCTION: COPTER_D 0x00495fc4
void  CGameApp::DrawCrosshairs(class CBackBuffer* bufferToDrawTo) {
	char * pBufferStart;
	int32_t nMidXPosition;
	int32_t nMidYPosition;
	int32_t i;
	int32_t nSurfaceStride;
	char * pBufferCurrentPosition;

// LINE 235:
	__asm        cmp    G_camera_mode, 0;
	__asm        je     _Tf5;

	__asm        cmp    G_camera_mode, 3;
	__asm        je     _Tf5;
// LINE 237:
	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, bufferToDrawTo;
	__asm        call   dword ptr [eax];
// LINE 238:
	__asm        jmp    near ptr 0x00495FF9;

	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax+0x10];
	__asm        mov    pBufferStart, eax;
// LINE 239:
	__asm        jmp    near ptr 0x00496007;

	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    nSurfaceStride, eax;
// LINE 241:
	__asm        mov    eax, swindow.WindowWide;
	__asm        sar    eax, 1;
	__asm        mov    nMidXPosition, eax;
// LINE 242:
	__asm        mov    eax, swindow.WindowHigh;
	__asm        sar    eax, 1;
	__asm        mov    nMidYPosition, eax;
// LINE 243:
	__asm        mov    eax, nMidYPosition;
	__asm        sub    eax, 0xD;
	__asm        imul   eax, nSurfaceStride;
	__asm        add    eax, nMidXPosition;
	__asm        add    eax, pBufferStart;
	__asm        mov    pBufferCurrentPosition, eax;
// LINE 244:
	__asm        mov    i, 0;
	__asm        jmp    _T84;
_T81:
	__asm        inc    i;
_T84:
	__asm        cmp    i, 0x1C;
	__asm        jge    _Ta6;
// LINE 245:
	__asm        mov    eax, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax], 0;
// LINE 246:
	__asm        mov    eax, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax+1], 0;
// LINE 247:
	__asm        mov    eax, nSurfaceStride;
	__asm        add    pBufferCurrentPosition, eax;
// LINE 248:
	__asm        jmp    _T81;
// LINE 249:
_Ta6:
	__asm        mov    eax, nMidYPosition;
	__asm        imul   eax, nSurfaceStride;
	__asm        add    eax, nMidXPosition;
	__asm        add    eax, pBufferStart;
	__asm        sub    eax, 0xD;
	__asm        mov    pBufferCurrentPosition, eax;
// LINE 250:
	__asm        mov    i, 0;
	__asm        jmp    _Tc8;
_Tc5:
	__asm        inc    i;
_Tc8:
	__asm        cmp    i, 0x1C;
	__asm        jge    _Tea;
// LINE 251:
	__asm        mov    eax, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax], 0;
// LINE 252:
	__asm        mov    eax, nSurfaceStride;
	__asm        mov    ecx, pBufferCurrentPosition;
	__asm        mov    byte ptr [eax+ecx], 0;
// LINE 253:
	__asm        inc    pBufferCurrentPosition;
// LINE 254:
	__asm        jmp    _Tc5;
// LINE 255:
_Tea:
	__asm        mov    eax, bufferToDrawTo;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, bufferToDrawTo;
	__asm        call   dword ptr [eax+4];
// LINE 257:
_Tf5:
	__asm        jmp    near ptr 0x004960BE;
}

// FUNCTION: COPTER_D 0x004960c5
void  CGameApp::S3ShowInfo() {
	long nTextBottom;
	long nTextTop;
	char szBuffer1[256];
	long nTextLeft;

// LINE 267:
	__asm        mov    nTextLeft, 0;
// LINE 268:
	__asm        mov    nTextTop, 0;
// LINE 269:
	__asm        mov    nTextBottom, 0xC;
// LINE 271:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T42;
// LINE 272:
	__asm        jmp    _T2d9;
// LINE 275:
_T42:
	__asm        push   0;
	__asm        push   0xFF;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x44];
// LINE 283:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4338];
	__asm        mov    [ebp-0x118], eax;
	__asm        mov    eax, [ebp-0x118];
	__asm        mov    [ebp-0x114], eax;
	__asm        jmp    near ptr 0x00496148;

	__asm        jmp    near ptr 0x0049614D;

	__asm        mov    eax, [ebp-0x114];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x114], eax;
	__asm        jmp    near ptr 0x00496161;

	__asm        jmp    near ptr 0x00496166;

	__asm        jmp    near ptr 0x0049616B;

	__asm        mov    eax, [ebp-0x114];
	__asm        cmp    dword ptr [eax+8], 6;
	__asm        je     _T112;
// LINE 284:
	__asm        mov    eax, this;
	__asm        fld    dword ptr [eax+0x4344];
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        push   0x59A140;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x10;
// LINE 285:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 288:
	__asm        jmp    _T292;
// LINE 305:
// Block start:
	struct MISSION_DATA* md;
_T112:
	__asm        mov    eax, GridProjectEnd;
	__asm        sub    eax, NextProject;
	__asm        push   eax;
	__asm        mov    eax, G_alt;
	__asm        push   eax;
	__asm        mov    eax, G_ViewSize;
	__asm        push   eax;
	__asm        mov    eax, G_odpolys;
	__asm        push   eax;
	__asm        mov    eax, G_gdpolys;
	__asm        push   eax;
	__asm        mov    eax, G_opolys;
	__asm        push   eax;
	__asm        mov    eax, GridNSortFaces;
	__asm        push   eax;
	__asm        mov    eax, G_numcellsrej;
	__asm        push   eax;
	__asm        mov    eax, GridNSortCells;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        fld    dword ptr [eax+0x4344];
	__asm        sub    esp, 8;
	__asm        fstp   qword ptr [esp];
	__asm        push   0x59A14C;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x34;
// LINE 306:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 314:
	__asm        mov    eax, IFlatImage::lTotalMemoryUsage;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        call   Sound::GetTotalMemoryUsage;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_max;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_used;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        mov    eax, G_alloc_curr;
	__asm        shr    eax, 0xA;
	__asm        push   eax;
	__asm        push   0x59A19C;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        call   sprintf;
	__asm        add    esp, 0x1C;
// LINE 315:
	__asm        add    nTextTop, 0xC;
// LINE 316:
	__asm        add    nTextBottom, 0xC;
// LINE 317:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 319:
	__asm        call   S3MissionGetCurr;
	__asm        mov    md, eax;
// LINE 320:
	__asm        cmp    md, 0;
	__asm        je     _T292;
// LINE 321:
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, md;
	__asm        push   eax;
	__asm        call   S3MissionDebugString;
	__asm        add    esp, 8;
// LINE 322:
	__asm        add    nTextTop, 0xC;
// LINE 323:
	__asm        add    nTextBottom, 0xC;
// LINE 324:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, nTextTop;
	__asm        push   eax;
	__asm        lea    eax, nTextLeft;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, szBuffer1[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0x4C];
// LINE 379:
// Block end:
_T292:
	__asm        jmp    near ptr 0x0049635C;

	__asm        mov    eax, nTextBottom;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x34];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x54];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x54];
	__asm        call   dword ptr [edx+0xC];
// LINE 380:
	__asm        jmp    _T2d9;
_T2d9:
}



// Contribution: 3:00003140-000031c4 Module: 19, 4 byte alignment, initialized_data, read, write, 
