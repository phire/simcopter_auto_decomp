// Module: Compress.obj
// Source: C:\Copter\source\sparkal\Compress.cpp
// autogenerated by simcopter_tool from PDB file

// Type: unsigned short *;

// Type: /*packed*/ class CRLECompressedImage (forward reference);
class CRLECompressedImage{ // packed(0xc bytes) TI: 0x2b8a
public:
	static unsigned short * RLEGraphicsPool;
	// calltype: NearC
	static void * __ptr32 operator new(uint32_t);
	// calltype: NearC
	static void operator delete(void * __ptr32);
	void CRLECompressedImage(const /*packed*/ class CFlatImage*, long, long, long, long, int32_t);
	void CRLECompressedImage(long);
	void ~CRLECompressedImage();
	unsigned long Lock();
	unsigned long Unlock();
	long GetHeight();
	long GetWidth();
	unsigned long Compose(/*unpacked*/ class IFlatImage*, long, long, long, long, long, long);
	unsigned long Compose(/*unpacked*/ class IFlatImage*, long, long);
protected:
	/*+0x0*/   void * __ptr32 mhRLEImage;
	/*+0x4*/   /*packed*/ struct RLEHeader *mpLockedImage;
	/*+0x8*/   unsigned long mLockCount;
};

// Type: long;

// Type: int32_t;

// Type: /*unpacked*/ class ifstream;
// VTABLE: COPTER_D 0x00593e2c
class ifstream : public virtual ios, public istream, public virtual <indirect> ios
{ // not packed(0x5c bytes) TI: 0x2177
public:
	void ifstream(int32_t, char *, int32_t);
	void ifstream(int32_t);
	void ifstream(char *, int32_t, int32_t);
	void ifstream();
	virtual void ~ifstream() /* override */;
	/*unpacked*/ class streambuf* setbuf(char *, int32_t);
	/*unpacked*/ class filebuf* rdbuf();
	void attach(int32_t);
	int32_t fd();
	int32_t is_open();
	void open(char *, int32_t, int32_t);
	void close();
	int32_t setmode(int32_t);
};

// Type: char;

// Type: /*unpacked*/ class ostrstream;
// VTABLE: COPTER_D 0x00593b34
class ostrstream : public ostream, public virtual <indirect> ios
{ // not packed(0x58 bytes) TI: 0x217a
public:
	int32_t *ios[0];
	void ostrstream(char *, int32_t, int32_t);
	void ostrstream();
	virtual void ~ostrstream() /* override */;
	int32_t pcount();
	/*unpacked*/ class strstreambuf* rdbuf();
	char * str();
};

// Type: void;

// Type: unsigned long;

// Type: /*packed*/ struct RLEHeader (forward reference);
struct RLEHeader{ // packed(0x8 bytes) TI: 0x218b
	/*+0x0*/   short Width; // 0x2 bytes
	/*+0x2*/   short Height; // 0x2 bytes
	/*+0x4*/   short XOffset; // 0x2 bytes
	/*+0x6*/   short YOffset; // 0x2 bytes
};

// Type: /*packed*/ class CFlatImage (forward reference);
// VTABLE: COPTER_D 0x00591070
class CFlatImage : public IFlatImage
{ // packed(0x1c bytes) TI: 0x20e3
public:
	void CFlatImage(/*unpacked*/ class IFlatImage*, long, long, long, long);
	void CFlatImage(long, long, unsigned char);
	void CFlatImage();
	virtual void ~CFlatImage(); // vtable+0x1c
	virtual unsigned long Lock() /* override */;
	virtual unsigned long Unlock() /* override */;
protected:
	/*+0x18*/  void * __ptr32 mBitsHandle;
};

// Type: /*packed*/ class IFlatImage (forward reference);
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(/*packed*/ class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, /*packed*/ struct SparkalRect, /*packed*/ struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	/*+0x4*/   unsigned long mLockCount;
	/*+0x8*/   long mWidth;
	/*+0xc*/   long mHeight;
	/*+0x10*/  void * __ptr32 mpBits;
	/*+0x14*/  long mStride;
};

// Type: unsigned char *;

// Type: short;

// Type: unsigned char;

// Type: /*unpacked*/ class IFlatImage (forward reference);
// IFlatImage Class implementation not found

// Type: /*unpacked*/ class ios (forward reference);
// ios Class implementation not found

// Type: /*unpacked*/ class istream;
// VTABLE: COPTER_D 0x00593ea4
class istream : public virtual ios
{ // not packed(0x5c bytes) TI: 0x4177
public:
	int32_t *ios[0];
	void istream(/*unpacked*/ class ios&);
	void istream(const /*unpacked*/ class istream&);
	void istream();
	void istream(/*unpacked*/ class streambuf*);
	virtual void ~istream() /* override */;
	int32_t ipfx(int32_t);
	void isfx();
	/*unpacked*/ class istream& operator>>(/*unpacked*/ class streambuf*);
	/*unpacked*/ class istream& operator>>(double&);
	/*unpacked*/ class istream& operator>>(double&);
	/*unpacked*/ class istream& operator>>(float&);
	/*unpacked*/ class istream& operator>>(unsigned long&);
	/*unpacked*/ class istream& operator>>(long&);
	/*unpacked*/ class istream& operator>>(uint32_t&);
	/*unpacked*/ class istream& operator>>(int32_t&);
	/*unpacked*/ class istream& operator>>(unsigned short&);
	/*unpacked*/ class istream& operator>>(short&);
	/*unpacked*/ class istream& operator>>(signed char&);
	/*unpacked*/ class istream& operator>>(unsigned char&);
	/*unpacked*/ class istream& operator>>(char&);
	/*unpacked*/ class istream& operator>>(signed char *);
	/*unpacked*/ class istream& operator>>(unsigned char *);
	/*unpacked*/ class istream& operator>>(char *);
	/*unpacked*/ class istream& operator>>(/*unpacked*/ class ios& (*)(/*unpacked*/ class ios&));
	/*unpacked*/ class istream& operator>>(/*unpacked*/ class istream& (*)(/*unpacked*/ class istream&));
	/*unpacked*/ class istream& get(char *, int32_t, int32_t);
	/*unpacked*/ class istream& get(/*unpacked*/ class streambuf&, char);
	/*unpacked*/ class istream& get(signed char&);
	/*unpacked*/ class istream& get(unsigned char&);
	/*unpacked*/ class istream& get(char&);
	/*unpacked*/ class istream& get(signed char *, int32_t, char);
	/*unpacked*/ class istream& get(unsigned char *, int32_t, char);
	/*unpacked*/ class istream& get(char *, int32_t, char);
	int32_t get();
	/*unpacked*/ class istream& getline(signed char *, int32_t, char);
	/*unpacked*/ class istream& getline(unsigned char *, int32_t, char);
	/*unpacked*/ class istream& getline(char *, int32_t, char);
	/*unpacked*/ class istream& ignore(int32_t, int32_t);
	/*unpacked*/ class istream& read(signed char *, int32_t);
	/*unpacked*/ class istream& read(unsigned char *, int32_t);
	/*unpacked*/ class istream& read(char *, int32_t);
	int32_t gcount();
	int32_t peek();
	/*unpacked*/ class istream& putback(char);
	int32_t sync();
	/*unpacked*/ class istream& seekg(long, enum ios::seek_dir);
	/*unpacked*/ class istream& seekg(long);
	long tellg();
	void eatwhite();
protected:
	/*unpacked*/ class istream& operator=(const /*unpacked*/ class istream&);
	/*unpacked*/ class istream& operator=(/*unpacked*/ class streambuf*);
	int32_t do_ipfx(int32_t);
private:
	int32_t getint(char *);
	int32_t getdouble(char *, int32_t);
	/*+0x4*/   int32_t _fGline;
	/*+0x8*/   int32_t x_gcount;
};

// Type: /*unpacked*/ class ios;
// VTABLE: COPTER_D 0x00593ad4
class ios{ // not packed(0x50 bytes) TI: 0x4126
	enum io_state {
		goodbit = 0,
		eofbit = 1,
		failbit = 2,
		badbit = 4,
	};
	enum open_mode {
		in = 1,
		out = 2,
		ate = 4,
		app = 8,
		trunc = 16,
		nocreate = 32,
		noreplace = 64,
		binary = 128,
	};
	enum seek_dir {
		beg = 0,
		cur = 1,
		end = 2,
	};
	enum /* __unnamed */ {
		skipws = 1,
		left = 2,
		right = 4,
		internal = 8,
		dec = 16,
		oct = 32,
		hex = 64,
		showbase = 128,
		showpoint = 256,
		uppercase = 512,
		showpos = 1024,
		scientific = 2048,
		fixed = 4096,
		unitbuf = 8192,
		stdio = 16384,
	};
public:
	static const long basefield;
	static const long adjustfield;
	static const long floatfield;
	void ios(const /*unpacked*/ class ios&);
	void ios();
	void ios(/*unpacked*/ class streambuf*);
	virtual void ~ios(); // vtable+0x0
	long flags(long);
	long flags();
	long setf(long);
	long setf(long, long);
	long unsetf(long);
	int32_t width(int32_t);
	int32_t width();
	/*unpacked*/ class ostream* tie();
	/*unpacked*/ class ostream* tie(/*unpacked*/ class ostream*);
	char fill(char);
	char fill();
	int32_t precision();
	int32_t precision(int32_t);
	int32_t rdstate();
	void clear(int32_t);
	void * __ptr32 operator void *();
	int32_t operator!();
	int32_t good();
	int32_t eof();
	int32_t fail();
	int32_t bad();
	/*unpacked*/ class streambuf* rdbuf();
	long& iword(int32_t);
	void * __ptr32& pword(int32_t);
	// calltype: NearC
	static long bitalloc();
	// calltype: NearC
	static int32_t xalloc();
	// calltype: NearC
	static void sync_with_stdio();
	// calltype: NearC
	void setlock();
	// calltype: NearC
	void clrlock();
	// calltype: NearC
	void lock();
	// calltype: NearC
	void unlock();
	// calltype: NearC
	void lockbuf();
	// calltype: NearC
	void unlockbuf();
protected:
	/*unpacked*/ class ios& operator=(const /*unpacked*/ class ios&);
	void init(/*unpacked*/ class streambuf*);
	enum /* __unnamed */ {
		skipping = 0,
		tied = 1,
	};
protected:
	/*+0x4*/   /*unpacked*/ class streambuf *bp;
	/*+0x8*/   int32_t state;
	/*+0xc*/   int32_t ispecial;
	/*+0x10*/  int32_t ospecial;
	/*+0x14*/  int32_t isfx_special;
	/*+0x18*/  int32_t osfx_special;
	/*+0x1c*/  int32_t x_delbuf;
	/*+0x20*/  /*unpacked*/ class ostream *x_tie;
	/*+0x24*/  long x_flags;
	/*+0x28*/  int32_t x_precision;
	/*+0x2c*/  char x_fill; // 0x1 bytes
	/*+0x30*/  int32_t x_width;
	static void (*stdioflush)();
	// calltype: NearC
	static void lockc();
	// calltype: NearC
	static void unlockc();
	/*unpacked*/ struct _CRT_CRITICAL_SECTION* lockptr();
public:
	void delbuf(int32_t);
	int32_t delbuf();
private:
	static long x_maxbit;
	static int32_t x_curindex;
	static int32_t sunk_with_stdio;
	static long x_statebuf[8];
	static int32_t fLockcInit;
	static /*unpacked*/ struct _CRT_CRITICAL_SECTION x_lockc;
	/*+0x34*/  int32_t LockFlg;
	/*+0x38*/  /*unpacked*/ struct _CRT_CRITICAL_SECTION x_lock; // 0x18 bytes
};

// Type: /*unpacked*/ class ostream (forward reference);
// ostream Class implementation not found



// Contribution: 1:000a9800-000aa528 Module: 7, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004aa800
void CRLECompressedImage::CRLECompressedImage(long ResourceID) {
	/*bp-0x58*/  /*unpacked*/ class ostrstream NameOut; // 0x58 bytes
	/*bp-0x68*/  char FileName[13]; // 0xd bytes
	/*bp-0xc4*/  /*unpacked*/ class ifstream InputFile; // 0x5c bytes
	/*bp-0xc8*/  int32_t InputMode;


	this->mhRLEImage = 0x0;
	this->mpLockedImage = 0x0;
	this->mLockCount = 0x0;
// LINE 51:
	__asm        push   1;
	__asm        push   2;
	__asm        push   0xD;
	__asm        lea    eax, FileName[0];
	__asm        push   eax;
	__asm        lea    ecx, NameOut.ios;
	__asm        call   ostrstream::ostrstream;
// LINE 52:
	__asm        push   0x59A9D8;
	__asm        lea    ecx, NameOut.ios;
	__asm        call   ostream::operator<<;
	__asm        mov    eax, NameOut.ios;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [ebp+eax-0x58];
	__asm        mov    [ebp-0xE0], eax;
// LINE 53:
	__asm        mov    eax, [ebp-0xE0];
	__asm        mov    eax, [eax+0x30];
	__asm        mov    [ebp-0xDC], eax;
	__asm        mov    eax, [ebp-0xE0];
	__asm        mov    dword ptr [eax+0x30], 5;
	__asm        jmp    _T88;
_T88:
	__asm        mov    eax, NameOut.ios;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [ebp+eax-0x58];
	__asm        mov    [ebp-0xE8], eax;
// LINE 54:
	__asm        mov    eax, [ebp-0xE8];
	__asm        mov    al, [eax+0x2C];
	__asm        mov    [ebp-0xE4], al;
	__asm        mov    eax, [ebp-0xE8];
	__asm        mov    byte ptr [eax+0x2C], 0x30;
	__asm        jmp    _Tb6;
_Tb6:
	__asm        mov    eax, NameOut.ios;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [ebp+eax-0x58];
	__asm        mov    [ebp-0xF0], eax;
// LINE 55:
	__asm        mov    eax, [ebp-0xF0];
	__asm        mov    eax, [eax+0x24];
	__asm        mov    [ebp-0xEC], eax;
	__asm        mov    eax, [ebp-0xF0];
	__asm        mov    dword ptr [eax+0x24], 0x14;
	__asm        jmp    _Te7;
_Te7:
	__asm        push   0x59A9DC;
	__asm        mov    eax, ResourceID;
	__asm        push   eax;
	__asm        lea    ecx, NameOut.ios;
	__asm        call   ostream::operator<<;
	__asm        mov    ecx, eax;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0xD8], eax;
// LINE 56:
	__asm        jmp    _T10a;
_T10a:
	__asm        push   0;
	__asm        mov    ecx, [ebp-0xD8];
	__asm        call   ostream::operator<<;
// LINE 58:
	InputMode = 0x81;
// LINE 60:
	__asm        or     InputMode, 0x20;
// LINE 65:
	__asm        push   1;
	__asm        mov    eax, ds:[0x593E30];
	__asm        push   eax;
	__asm        mov    eax, InputMode;
	__asm        push   eax;
	__asm        lea    eax, FileName[0];
	__asm        push   eax;
	__asm        lea    ecx, InputFile.ios;
	__asm        call   ifstream::ifstream;
// LINE 66:
	__asm        jmp    _T14b;
_T14b:
	__asm        jmp    _T150;
_T150:
	__asm        mov    eax, InputFile.ios;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [ebp+eax-0xC0];
	__asm        cmp    dword ptr [eax+0x4C], 0xFFFFFFFF;
	__asm        je     _T16f;

	__asm        jmp    _T174;
_T16f:
	__asm        jmp    _T375;
_T174:
	__asm        jmp    _T186;

	__asm        cmp    dword ptr [ebp-0xD4], 0;
	__asm        je     _T375;
// LINE 70:
// Block start:
	/*bp-0xcc*/  unsigned long ImageByteCount;
_T186:
	__asm        push   4;
	__asm        lea    eax, ImageByteCount;
	__asm        push   eax;
	__asm        lea    ecx, InputFile.ios;
	__asm        call   istream::read;
// LINE 71:
	__asm        jmp    _T19f;
_T19f:
	__asm        mov    eax, ImageByteCount;
	__asm        mov    [ebp-0x108], eax;
// LINE 76:
	__asm        mov    word ptr [ebp-0x104], 0;
	__asm        cmp    this, 0;
	__asm        je     _T1ce;

	__asm        cmp    dword ptr [ebp-0x108], 0;
	__asm        jne    _T1ea;
_T1ce:
	_assert(0x59a090, 0x597444, 0x12a);
	__asm        jmp    _T1ef;
_T1ea:
	__asm        jmp    _T1ef;
_T1ef:
	__asm        mov    eax, [ebp-0x108];
	__asm        push   eax;
	__asm        push   0x42;
	__asm        call   dword ptr ds:[0x6C3730];
	__asm        mov    ecx, this;
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _T21e;

	__asm        mov    word ptr [ebp-0x104], 0xFFFF;
_T21e:
	__asm        jmp    _T223;
// LINE 77:
_T223:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T375;
// LINE 79:
// Block start:
	/*bp-0xd0*/  /*packed*/ struct RLEHeader *pCompressedImage;
	__asm        mov    pCompressedImage, 0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x100], eax;
// LINE 80:
	__asm        mov    word ptr [ebp-0xFC], 0;
	__asm        cmp    dword ptr [ebp-0x100], 0;
	__asm        je     _T265;

	__asm        jmp    _T281;
_T265:
	_assert(0x59a068, 0x597444, 0x147);
	__asm        jmp    _T286;
_T281:
	__asm        jmp    _T286;
_T286:
	__asm        mov    eax, [ebp-0x100];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E4];
	__asm        mov    pCompressedImage, eax;
	__asm        cmp    pCompressedImage, 0;
	__asm        jne    _T2af;

	__asm        mov    word ptr [ebp-0xFC], 0xFFFF;
_T2af:
	__asm        jmp    _T2b4;
// LINE 81:
_T2b4:
	__asm        cmp    pCompressedImage, 0;
	__asm        je     _T375;
// LINE 83:
	__asm        mov    eax, ImageByteCount;
	__asm        push   eax;
	__asm        mov    eax, pCompressedImage;
	__asm        push   eax;
	__asm        lea    ecx, InputFile.ios;
	__asm        call   istream::read;
// LINE 84:
	__asm        jmp    _T2df;
_T2df:
	__asm        mov    eax, ImageByteCount;
	__asm        cmp    InputFile.x_gcount, eax;
	__asm        je     _T30a;

	_assert(0x59aa0c, 0x59a9e4, 0x54);
	__asm        jmp    _T30f;
_T30a:
	__asm        jmp    _T30f;
// LINE 86:
_T30f:
	__asm        mov    eax, pCompressedImage;
	__asm        push   eax;
	__asm        call   ConvertCompressedByteOrdering;
	__asm        add    esp, 4;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xF8], eax;
// LINE 87:
	__asm        mov    word ptr [ebp-0xF4], 0;
	__asm        cmp    dword ptr [ebp-0xF8], 0;
	__asm        jne    _T35e;

	_assert(0x59a080, 0x597444, 0x151);
	__asm        jmp    _T363;
_T35e:
	__asm        jmp    _T363;
_T363:
	__asm        mov    eax, [ebp-0xF8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3654];
	__asm        jmp    _T375;
// LINE 91:
// Block end:
// Block end:
_T375:
	__asm        jmp    _T37a;
_T37a:
	InputFile<ifstream+0x0c>->ifstream::~ifstream();
	InputFile<ifstream+0x0c>->ios::~ios();
	__asm        jmp    _T395;
_T395:
	NameOut<ostrstream+0x08>->ostrstream::~ostrstream();
	NameOut<ostrstream+0x08>->ios::~ios();
	__asm        jmp    __RETURN;
__RETURN:
	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004aabb7
void CRLECompressedImage::CRLECompressedImage(const /*packed*/ class CFlatImage *pImage, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom, int32_t TransparentIndex) {

	this->mhRLEImage = 0x0;
	this->mLockCount = 0x0;
// LINE 104:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004aabe5
void CRLECompressedImage::~CRLECompressedImage() {
// LINE 111:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T32;

	_assert(0x59aa60, 0x59aa38, 0x6f);
	__asm        jmp    _T37;
_T32:
	__asm        jmp    _T37;
// LINE 113:
_T37:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T8b;
// LINE 114:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-8], eax;
	__asm        mov    word ptr [ebp-4], 0;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T77;

	_assert(0x59a080, 0x597444, 0x134);
	__asm        jmp    _T7c;
_T77:
	__asm        jmp    _T7c;
_T7c:
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3650];
	__asm        jmp    _T8b;
// LINE 115:
_T8b:
	return;
}

// FUNCTION: COPTER_D 0x004aac7a
unsigned long CRLECompressedImage::Lock() {
// LINE 122:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jne    _Taa;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Taa;
// LINE 123:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-8], eax;
// LINE 124:
	__asm        mov    word ptr [ebp-4], 0;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T49;

	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        jne    _T65;
_T49:
	_assert(0x59a068, 0x597444, 0x147);
	__asm        jmp    _T6a;
_T65:
	__asm        jmp    _T6a;
_T6a:
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T8d;

	__asm        mov    word ptr [ebp-4], 0xFFFF;
_T8d:
	__asm        jmp    _T92;
// LINE 125:
_T92:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _Ta5;
// LINE 126:
	this->mLockCount++;
// LINE 128:
_Ta5:
	__asm        jmp    _Tb0;
// LINE 129:
_Taa:
	this->mLockCount++;
// LINE 131:
_Tb0:
	return this->mLockCount;
// LINE 132:
}

// FUNCTION: COPTER_D 0x004aad3a
unsigned long CRLECompressedImage::Unlock() {
// LINE 136:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        ja     _T35;

	_assert(0x59aa98, 0x59aa70, 0x88);
	__asm        jmp    _T3a;
_T35:
	__asm        jmp    _T3a;
// LINE 138:
_T3a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 1;
	__asm        jne    _Tb2;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Tb2;
// LINE 139:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-8], eax;
// LINE 140:
	__asm        mov    word ptr [ebp-4], 0;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T87;

	_assert(0x59a080, 0x597444, 0x151);
	__asm        jmp    _T8c;
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3654];
	__asm        jmp    _T9b;
_T9b:
	__asm        movsx  eax, word ptr [ebp-4];
	__asm        test   eax, eax;
	__asm        jne    _Tad;
// LINE 141:
	this->mLockCount--;
// LINE 143:
_Tad:
	__asm        jmp    _Tb8;
// LINE 144:
_Tb2:
	this->mLockCount--;
// LINE 146:
_Tb8:
	return this->mLockCount;
// LINE 147:
}

// FUNCTION: COPTER_D 0x004aae02
unsigned long CRLECompressedImage::Compose(/*packed*/ class IFlatImage *pDest, long DestLeft, long DestTop, long ClipLeft, long ClipTop, long ClipRight, long ClipBottom) {
// LINE 157:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        ja     _T35;

	_assert(0x59aad0, 0x59aaa8, 0x9d);
	__asm        jmp    _T3a;
_T35:
	__asm        jmp    _T3a;
// LINE 158:
_T3a:
	__asm        cmp    pDest, 0;
	__asm        jne    _T60;

	_assert(0x59ab08, 0x59aae0, 0x9e);
	__asm        jmp    _T65;
_T60:
	__asm        jmp    _T65;
// LINE 160:
_T65:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T253;
// LINE 162:
// Block start:
	/*bp-0x4*/   int32_t Bottom;
	/*bp-0x8*/   short Height;
	/*bp-0xc*/   short Width;
	/*bp-0x10*/  unsigned char TransparentColor;
	/*bp-0x14*/  int32_t Right;
	/*bp-0x18*/  int32_t Top;
	/*bp-0x1c*/  short LeftClipAmount;
	/*bp-0x20*/  unsigned char * pCompressedBits;
	/*bp-0x24*/  int32_t Left;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+4];
	__asm        add    eax, DestLeft;
	__asm        mov    Left, eax;
// LINE 163:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        add    eax, DestTop;
	__asm        mov    Top, eax;
// LINE 165:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax];
	__asm        add    eax, Left;
	__asm        mov    Right, eax;
// LINE 166:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        add    eax, Top;
	__asm        mov    Bottom, eax;
// LINE 169:
	pCompressedBits = (this->mpLockedImage + 0x8);
// LINE 171:
	__asm        mov    eax, pCompressedBits;
	__asm        mov    al, [eax];
	__asm        mov    TransparentColor, al;
	__asm        inc    pCompressedBits;
// LINE 173:
__WHILE_c8:
	while ((ClipTop > Top)) {
		// LINE 176:
			__asm        mov    eax, pCompressedBits;
			__asm        xor    ecx, ecx;
			__asm        mov    cx, [eax];
			__asm        add    pCompressedBits, ecx;
		// LINE 177:
			Top++;
	}
// LINE 180:
_Te7:
	__asm        mov    eax, Bottom;
	__asm        cmp    ClipBottom, eax;
	__asm        jge    _Tf9;
// LINE 181:
	Bottom = ClipBottom;
// LINE 184:
_Tf9:
	LeftClipAmount = 0x0;
// LINE 185:
	__asm        mov    eax, Left;
	__asm        cmp    ClipLeft, eax;
	__asm        jle    _T11b;
// LINE 187:
	__asm        mov    eax, ClipLeft;
	__asm        sub    eax, Left;
	__asm        mov    LeftClipAmount, ax;
// LINE 188:
	Left = ClipLeft;
// LINE 191:
_T11b:
	__asm        mov    eax, Right;
	__asm        cmp    ClipRight, eax;
	__asm        jge    _T12d;
// LINE 192:
	Right = ClipRight;
// LINE 195:
_T12d:
	__asm        mov    eax, Bottom;
	__asm        sub    eax, Top;
	__asm        mov    Height, ax;
// LINE 196:
	__asm        mov    eax, Right;
	__asm        sub    eax, Left;
	__asm        mov    Width, ax;
// LINE 199:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        movsx  ecx, Height;
	__asm        cmp    eax, ecx;
	__asm        jge    _T173;

	_assert(0x59ab38, 0x59ab10, 0xc7);
	__asm        jmp    _T178;
_T173:
	__asm        jmp    _T178;
// LINE 200:
_T178:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, Width;
	__asm        cmp    eax, ecx;
	__asm        jge    _T1a9;

	_assert(0x59ab80, 0x59ab58, 0xc8);
	__asm        jmp    _T1ae;
_T1a9:
	__asm        jmp    _T1ae;
// LINE 202:
_T1ae:
	__asm        movsx  eax, Height;
	__asm        test   eax, eax;
	__asm        jle    _T253;

	__asm        movsx  eax, Width;
	__asm        test   eax, eax;
	__asm        jle    _T253;
// LINE 204:
// Block start:
	/*bp-0x28*/  unsigned char * pBits;
	__asm        jmp    _T1cb;
_T1cb:
	pBits = pDest->mpBits;
// LINE 205:
	__asm        cmp    pBits, 0;
	__asm        je     _T253;
// LINE 207:
// Block start:
	/*bp-0x2c*/  long DestStride;
	DestStride = pDest->mStride;
	__asm        jmp    _T1ec;
// LINE 209:
_T1ec:
	pBits += ((Top * DestStride) + Left);
// LINE 211:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, Width;
	__asm        cmp    eax, ecx;
	__asm        jne    _T22f;
// LINE 213:
	RLEDecompressUnclippedX(pBits, DestStride, pCompressedBits, reinterpret_cast<uint32_t>(Height), reinterpret_cast<uint32_t>(TransparentColor));
// LINE 214:
	__asm        jmp    _T253;
// LINE 217:
_T22f:
	RLEDecompressClippedX(pBits, DestStride, pCompressedBits, reinterpret_cast<uint32_t>(LeftClipAmount), reinterpret_cast<uint32_t>(Width), reinterpret_cast<uint32_t>(Height), reinterpret_cast<uint32_t>(TransparentColor));
// LINE 223:
// Block end:
// Block end:
// Block end:
_T253:
	return 0x0;
// LINE 224:
}

// FUNCTION: COPTER_D 0x004ab063
static void ConvertCompressedByteOrdering(/*packed*/ struct RLEHeader *pCompressedImage) {
// LINE 312:
	return;
}

// FUNCTION: COPTER_D 0x004ab073
static void RLEDecompressUnclippedX(unsigned char * pDestBuffer, long DestStride, unsigned char * pSource, short Height, unsigned char TransparentColor) {
	/*bp-0x4*/   unsigned char * pNextSourceLine;
	/*bp-0x8*/   unsigned char * pDest;
	/*bp-0xc*/   unsigned char * pDestinationEdge;

// LINE 323:
	pDestinationEdge = pDestBuffer;
// LINE 324:
	pDest = pDestinationEdge;
// LINE 327:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax];
	__asm        add    ecx, pSource;
	__asm        mov    pNextSourceLine, ecx;
// LINE 328:
	pSource += 0x2;
// LINE 330:
__WHILE_27:
	while ((reinterpret_cast<int16_t>(Height) != 0x0)) {
		// LINE 336:
		// Block start:
			/*bp-0x10*/  unsigned char data;
			/*bp-0x14*/  unsigned char token;
			/*bp-0x18*/  int32_t counter;
			__asm        mov    eax, pSource;
			__asm        cmp    pNextSourceLine, eax;
			__asm        jne    _T66;
		// LINE 340:
			__asm        mov    eax, pSource;
			__asm        xor    ecx, ecx;
			__asm        mov    cx, [eax];
			__asm        add    ecx, pSource;
			__asm        mov    pNextSourceLine, ecx;
		// LINE 341:
			pSource += 0x2;
		// LINE 344:
			pDestinationEdge += DestStride;
		// LINE 345:
			pDest = pDestinationEdge;
		// LINE 347:
			Height--;
		// LINE 349:
			__asm        jmp    _T175;
		// LINE 352:
		_T66:
			__asm        mov    eax, pSource;
			__asm        mov    al, [eax];
			__asm        mov    token, al;
			__asm        inc    pSource;
		// LINE 353:
			__asm        mov    eax, pSource;
			__asm        mov    al, [eax];
			__asm        mov    data, al;
			__asm        inc    pSource;
		// LINE 355:
			__asm        xor    eax, eax;
			__asm        mov    al, token;
			__asm        mov    [ebp-0x20], eax;
			__asm        jmp    _T14e;
		// LINE 358:
		_T89:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        mov    counter, eax;
		// LINE 361:
			memcpy(pDest, pSource, counter);
		// LINE 362:
			pSource += counter;
		// LINE 363:
			pDest += counter;
		// LINE 364:
			__asm        jmp    _T175;
		// LINE 367:
		_Tb7:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        mov    counter, eax;
		// LINE 368:
			__asm        mov    eax, pSource;
			__asm        mov    al, [eax];
			__asm        mov    data, al;
			__asm        inc    pSource;
		// LINE 371:
			__asm        mov    eax, counter;
			__asm        push   eax;
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        push   eax;
			__asm        mov    eax, pDest;
			__asm        push   eax;
			__asm        call   memset;
			__asm        add    esp, 0xC;
		// LINE 372:
			pDest += counter;
		// LINE 373:
			__asm        jmp    _T175;
		// LINE 376:
		_Tec:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        add    pDest, eax;
		// LINE 377:
			__asm        jmp    _T175;
		// LINE 380:
		_Tfa:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        mov    counter, eax;
		// LINE 383:
		__WHILE_103:
			__asm        mov    eax, counter;
			__asm        mov    [ebp-0x1C], eax;
			__asm        dec    counter;
			__asm        cmp    dword ptr [ebp-0x1C], 0;
			__asm        je     _T13f;
		// LINE 385:
			__asm        mov    eax, pSource;
			__asm        xor    ecx, ecx;
			__asm        mov    cl, [eax];
			__asm        xor    eax, eax;
			__asm        mov    al, TransparentColor;
			__asm        cmp    ecx, eax;
			__asm        je     _T134;
		// LINE 386:
			__asm        mov    eax, pSource;
			__asm        mov    al, [eax];
			__asm        mov    ecx, pDest;
			__asm        mov    [ecx], al;
		// LINE 388:
		_T134:
			pDest++;
		// LINE 389:
			pSource++;
		// LINE 390:
			__asm        jmp    __WHILE_103;
		// LINE 391:
		_T13f:
			__asm        jmp    _T175;
		// LINE 395:
			__asm        jmp    _T175;
		// LINE 396:
			__asm        jmp    _T175;
		_T14e:
			__asm        dec    dword ptr [ebp-0x20];
			__asm        cmp    dword ptr [ebp-0x20], 3;
			__asm        ja     _T175;

			__asm        mov    eax, [ebp-0x20];
			__asm        jmp    _Switch_165[0][eax*4];
		// Switch pointers:
		//   _T89
		//   _Tb7
		//   _Tec
		//   _Tfa
		// LINE 398:
		// Block end:
		_T175:
	}
// LINE 399:
_T17a:
	return;
}

// FUNCTION: COPTER_D 0x004ab1f7
static void RLEDecompressClippedX(unsigned char * pDestBuffer, long DestStride, unsigned char * pSource, short LeftClip, short Width, short Height, unsigned char TransparentColor) {
	/*bp-0x4*/   unsigned char * pNextSourceLine;
	/*bp-0x8*/   unsigned char * pDest;
	/*bp-0xc*/   unsigned char * pDestinationEdge;
	/*bp-0x10*/  short PixelCount;

// LINE 405:
	pDestinationEdge = pDestBuffer;
// LINE 406:
	pDest = pDestinationEdge;
// LINE 409:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax];
	__asm        add    ecx, pSource;
	__asm        mov    pNextSourceLine, ecx;
// LINE 410:
	pSource += 0x2;
// LINE 413:
	__asm        movsx  eax, LeftClip;
	__asm        neg    eax;
	__asm        mov    PixelCount, ax;
// LINE 415:
__WHILE_31:
	while ((reinterpret_cast<int16_t>(Height) != 0x0)) {
		// LINE 421:
		// Block start:
			/*bp-0x14*/  unsigned char data;
			/*bp-0x18*/  unsigned char token;
			/*bp-0x1c*/  int32_t counter;
			__asm        mov    eax, pSource;
			__asm        cmp    pNextSourceLine, eax;
			__asm        jne    _T7a;
		// LINE 425:
			__asm        mov    eax, pSource;
			__asm        xor    ecx, ecx;
			__asm        mov    cx, [eax];
			__asm        add    ecx, pSource;
			__asm        mov    pNextSourceLine, ecx;
		// LINE 426:
			pSource += 0x2;
		// LINE 429:
			pDestinationEdge += DestStride;
		// LINE 430:
			pDest = pDestinationEdge;
		// LINE 432:
			Height--;
		// LINE 433:
			__asm        movsx  eax, LeftClip;
			__asm        neg    eax;
			__asm        mov    PixelCount, ax;
		// LINE 435:
			__asm        jmp    _T323;
		// LINE 439:
		_T7a:
			__asm        mov    eax, pSource;
			__asm        mov    al, [eax];
			__asm        mov    token, al;
			__asm        inc    pSource;
		// LINE 440:
			__asm        mov    eax, pSource;
			__asm        mov    al, [eax];
			__asm        mov    data, al;
			__asm        inc    pSource;
		// LINE 442:
			__asm        xor    eax, eax;
			__asm        mov    al, token;
			__asm        mov    [ebp-0x20], eax;
			__asm        jmp    _T2e6;
		// LINE 445:
		_T9d:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        mov    counter, eax;
		// LINE 448:
			__asm        movsx  eax, PixelCount;
			__asm        test   eax, eax;
			__asm        jge    __WHILE_fc;
		// LINE 451:
			__asm        movsx  eax, PixelCount;
			__asm        neg    eax;
			__asm        cmp    eax, counter;
			__asm        jl     _Tde;
		// LINE 454:
			pSource += counter;
		// LINE 455:
			__asm        movsx  eax, PixelCount;
			__asm        add    eax, counter;
			__asm        mov    PixelCount, ax;
		// LINE 456:
			counter = 0x0;
		// LINE 458:
			__asm        jmp    __WHILE_fc;
		// LINE 461:
		_Tde:
			__asm        movsx  eax, PixelCount;
			__asm        neg    eax;
			__asm        add    pSource, eax;
		// LINE 462:
			__asm        xor    eax, eax;
			__asm        movsx  ecx, PixelCount;
			__asm        neg    ecx;
			__asm        sub    eax, ecx;
			__asm        neg    eax;
			__asm        sub    counter, eax;
		// LINE 463:
			PixelCount = 0x0;
		// LINE 470:
		__WHILE_fc:
			while ((counter != 0x0)) {

					__asm        movsx  eax, Width;
					__asm        movsx  ecx, PixelCount;
					__asm        cmp    eax, ecx;
					__asm        jle    _T132;
				// LINE 472:
					__asm        mov    eax, pSource;
					__asm        mov    al, [eax];
					__asm        mov    ecx, pDest;
					__asm        mov    [ecx], al;
					__asm        inc    pSource;
					__asm        inc    pDest;
				// LINE 473:
					counter--;
				// LINE 474:
					PixelCount++;
			}
		// LINE 476:
		_T132:
			__asm        jmp    _T30d;
		// LINE 479:
		_T137:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        mov    counter, eax;
		// LINE 480:
			__asm        mov    eax, pSource;
			__asm        mov    al, [eax];
			__asm        mov    data, al;
			__asm        inc    pSource;
		// LINE 482:
			__asm        movsx  eax, PixelCount;
			__asm        test   eax, eax;
			__asm        jge    __WHILE_192;
		// LINE 485:
			__asm        movsx  eax, PixelCount;
			__asm        neg    eax;
			__asm        cmp    eax, counter;
			__asm        jl     _T17d;
		// LINE 488:
			__asm        movsx  eax, PixelCount;
			__asm        add    eax, counter;
			__asm        mov    PixelCount, ax;
		// LINE 489:
			counter = 0x0;
		// LINE 491:
			__asm        jmp    __WHILE_192;
		// LINE 494:
		_T17d:
			__asm        xor    eax, eax;
			__asm        movsx  ecx, PixelCount;
			__asm        neg    ecx;
			__asm        sub    eax, ecx;
			__asm        neg    eax;
			__asm        sub    counter, eax;
		// LINE 495:
			PixelCount = 0x0;
		// LINE 501:
		__WHILE_192:
			while ((counter != 0x0)) {

					__asm        movsx  eax, Width;
					__asm        movsx  ecx, PixelCount;
					__asm        cmp    eax, ecx;
					__asm        jle    _T1c3;
				// LINE 503:
					__asm        mov    al, data;
					__asm        mov    ecx, pDest;
					__asm        mov    [ecx], al;
					__asm        inc    pDest;
				// LINE 504:
					counter--;
				// LINE 505:
					PixelCount++;
			}
		// LINE 507:
		_T1c3:
			__asm        jmp    _T30d;
		// LINE 510:
		_T1c8:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        mov    counter, eax;
		// LINE 511:
			__asm        movsx  eax, PixelCount;
			__asm        test   eax, eax;
			__asm        jge    _T218;
		// LINE 514:
			__asm        movsx  eax, PixelCount;
			__asm        neg    eax;
			__asm        cmp    eax, counter;
			__asm        jl     _T203;
		// LINE 517:
			__asm        movsx  eax, PixelCount;
			__asm        add    eax, counter;
			__asm        mov    PixelCount, ax;
		// LINE 518:
			counter = 0x0;
		// LINE 520:
			__asm        jmp    _T218;
		// LINE 523:
		_T203:
			__asm        xor    eax, eax;
			__asm        movsx  ecx, PixelCount;
			__asm        neg    ecx;
			__asm        sub    eax, ecx;
			__asm        neg    eax;
			__asm        sub    counter, eax;
		// LINE 524:
			PixelCount = 0x0;
		// LINE 528:
		_T218:
			pDest += counter;
		// LINE 529:
			__asm        movsx  eax, PixelCount;
			__asm        add    eax, counter;
			__asm        mov    PixelCount, ax;
		// LINE 530:
			__asm        jmp    _T30d;
		// LINE 533:
		_T22e:
			__asm        xor    eax, eax;
			__asm        mov    al, data;
			__asm        inc    eax;
			__asm        mov    counter, eax;
		// LINE 536:
			__asm        movsx  eax, PixelCount;
			__asm        test   eax, eax;
			__asm        jge    __WHILE_28d;
		// LINE 539:
			__asm        movsx  eax, PixelCount;
			__asm        neg    eax;
			__asm        cmp    eax, counter;
			__asm        jl     _T26f;
		// LINE 542:
			pSource += counter;
		// LINE 543:
			__asm        movsx  eax, PixelCount;
			__asm        add    eax, counter;
			__asm        mov    PixelCount, ax;
		// LINE 544:
			counter = 0x0;
		// LINE 546:
			__asm        jmp    __WHILE_28d;
		// LINE 549:
		_T26f:
			__asm        movsx  eax, PixelCount;
			__asm        neg    eax;
			__asm        add    pSource, eax;
		// LINE 550:
			__asm        xor    eax, eax;
			__asm        movsx  ecx, PixelCount;
			__asm        neg    ecx;
			__asm        sub    eax, ecx;
			__asm        neg    eax;
			__asm        sub    counter, eax;
		// LINE 551:
			PixelCount = 0x0;
		// LINE 558:
		__WHILE_28d:
			while ((counter != 0x0)) {

					__asm        movsx  eax, Width;
					__asm        movsx  ecx, PixelCount;
					__asm        cmp    eax, ecx;
					__asm        jle    _T2d7;
				// LINE 560:
					__asm        mov    eax, pSource;
					__asm        xor    ecx, ecx;
					__asm        mov    cl, [eax];
					__asm        xor    eax, eax;
					__asm        mov    al, TransparentColor;
					__asm        cmp    ecx, eax;
					__asm        je     _T2c5;
				// LINE 561:
					__asm        mov    eax, pSource;
					__asm        mov    al, [eax];
					__asm        mov    ecx, pDest;
					__asm        mov    [ecx], al;
				// LINE 563:
				_T2c5:
					pDest++;
				// LINE 564:
					pSource++;
				// LINE 565:
					counter--;
				// LINE 566:
					PixelCount++;
			}
		// LINE 568:
		_T2d7:
			__asm        jmp    _T30d;
		// LINE 572:
			__asm        jmp    _T30d;
		// LINE 573:
			__asm        jmp    _T30d;
		_T2e6:
			__asm        dec    dword ptr [ebp-0x20];
			__asm        cmp    dword ptr [ebp-0x20], 3;
			__asm        ja     _T30d;

			__asm        mov    eax, [ebp-0x20];
			__asm        jmp    _Switch_2fd[0][eax*4];
		// Switch pointers:
		//   _T9d
		//   _T137
		//   _T1c8
		//   _T22e
		// LINE 576:
		_T30d:
			__asm        movsx  eax, Width;
			__asm        movsx  ecx, PixelCount;
			__asm        cmp    eax, ecx;
			__asm        jg     _T323;
		// LINE 577:
			pSource = pNextSourceLine;
		// LINE 579:
		// Block end:
		_T323:
	}
// LINE 580:
_T328:
	return;
}



// Contribution: 3:000039d4-00003b9d Module: 7, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x0059a9d4
unsigned short * CRLECompressedImage::RLEGraphicsPool = { 0 /* todo */ };

