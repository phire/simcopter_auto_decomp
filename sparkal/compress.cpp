// Module: Compress.obj
// Source: C:\Copter\source\sparkal\Compress.cpp
// autogenerated by simcopter_tool from PDB file

// Type: unsigned short *;

// Type: /*packed*/ class CRLECompressedImage (forward reference);
class CRLECompressedImage{ // packed(0xc bytes) TI: 0x2b8a
public:
	static unsigned short * RLEGraphicsPool;
	// calltype: NearC
	static void * __ptr32 operator new(uint32_t);
	// calltype: NearC
	static void operator delete(void * __ptr32);
	void CRLECompressedImage(const /*packed*/ class CFlatImage*, long, long, long, long, int32_t);
	void CRLECompressedImage(long);
	void ~CRLECompressedImage();
	unsigned long Lock();
	unsigned long Unlock();
	long GetHeight();
	long GetWidth();
	unsigned long Compose(/*unpacked*/ class IFlatImage*, long, long, long, long, long, long);
	unsigned long Compose(/*unpacked*/ class IFlatImage*, long, long);
protected:
	void * __ptr32 mhRLEImage;
	/*packed*/ struct RLEHeader *mpLockedImage;
	unsigned long mLockCount;
};

// Type: long;

// Type: int32_t;

// Type: /*unpacked*/ class ifstream;
// VTABLE: COPTER_D 0x00593e2c
class ifstream : public virtual ios, public istream, public virtual <indirect> ios
{ // not packed(0x5c bytes) TI: 0x2177
public:
	void ifstream(int32_t, char *, int32_t);
	void ifstream(int32_t);
	void ifstream(char *, int32_t, int32_t);
	void ifstream();
	virtual void ~ifstream() /* override */;
	/*unpacked*/ class streambuf* setbuf(char *, int32_t);
	/*unpacked*/ class filebuf* rdbuf();
	void attach(int32_t);
	int32_t fd();
	int32_t is_open();
	void open(char *, int32_t, int32_t);
	void close();
	int32_t setmode(int32_t);
};

// Type: char;

// Type: /*unpacked*/ class ostrstream;
// VTABLE: COPTER_D 0x00593b34
class ostrstream : public ostream, public virtual <indirect> ios
{ // not packed(0x58 bytes) TI: 0x217a
public:
	int32_t *ios[0];
	void ostrstream(char *, int32_t, int32_t);
	void ostrstream();
	virtual void ~ostrstream() /* override */;
	int32_t pcount();
	/*unpacked*/ class strstreambuf* rdbuf();
	char * str();
};

// Type: unsigned long;

// Type: /*packed*/ struct RLEHeader (forward reference);
struct RLEHeader{ // packed(0x8 bytes) TI: 0x218b
	short Width;
	short Height;
	short XOffset;
	short YOffset;
};

// Type: void;

// Type: /*packed*/ class CFlatImage (forward reference);
// VTABLE: COPTER_D 0x00591070
class CFlatImage : public IFlatImage
{ // packed(0x1c bytes) TI: 0x20e3
public:
	void CFlatImage(/*unpacked*/ class IFlatImage*, long, long, long, long);
	void CFlatImage(long, long, unsigned char);
	void CFlatImage();
	virtual void ~CFlatImage(); // vtable+0x1c
	virtual unsigned long Lock() /* override */;
	virtual unsigned long Unlock() /* override */;
protected:
	void * __ptr32 mBitsHandle;
};

// Type: /*packed*/ class IFlatImage (forward reference);
// VTABLE: COPTER_D 0x00591050
class IFlatImage{ // packed(0x18 bytes) TI: 0x13a1
public:
	void IFlatImage();
	virtual unsigned long Lock(); // vtable+0x0
	virtual unsigned long Unlock(); // vtable+0x4
	unsigned long GetLockCount();
	virtual void SetTransparentColor(int32_t, long); // vtable+0x8
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	virtual unsigned long Compose(/*packed*/ class IFlatImage*, long, long, long, long, long, long); // vtable+0xc
	unsigned long Compose(/*packed*/ class IFlatImage*, long, long);
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, long, long, long, long, long, long, long, long); // vtable+0x10
	virtual unsigned long StretchCompose(/*packed*/ class IFlatImage*, /*packed*/ struct SparkalRect, /*packed*/ struct SparkalRect); // vtable+0x14
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*); // vtable+0x18
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	unsigned long mLockCount;
	long mWidth;
	long mHeight;
	void * __ptr32 mpBits;
	long mStride;
};

// Type: unsigned char *;

// Type: short;

// Type: unsigned char;

// Type: /*unpacked*/ class IFlatImage (forward reference);
// IFlatImage Class implementation not found

// Type: /*unpacked*/ class ios (forward reference);
// ios Class implementation not found

// Type: /*unpacked*/ class istream;
// VTABLE: COPTER_D 0x00593ea4
class istream : public virtual ios
{ // not packed(0x5c bytes) TI: 0x4177
public:
	int32_t *ios[0];
	void istream(/*unpacked*/ class ios&);
	void istream(const /*unpacked*/ class istream&);
	void istream();
	void istream(/*unpacked*/ class streambuf*);
	virtual void ~istream() /* override */;
	int32_t ipfx(int32_t);
	void isfx();
	/*unpacked*/ class istream& operator>>(/*unpacked*/ class streambuf*);
	/*unpacked*/ class istream& operator>>(double&);
	/*unpacked*/ class istream& operator>>(double&);
	/*unpacked*/ class istream& operator>>(float&);
	/*unpacked*/ class istream& operator>>(unsigned long&);
	/*unpacked*/ class istream& operator>>(long&);
	/*unpacked*/ class istream& operator>>(uint32_t&);
	/*unpacked*/ class istream& operator>>(int32_t&);
	/*unpacked*/ class istream& operator>>(unsigned short&);
	/*unpacked*/ class istream& operator>>(short&);
	/*unpacked*/ class istream& operator>>(char&);
	/*unpacked*/ class istream& operator>>(unsigned char&);
	/*unpacked*/ class istream& operator>>(char&);
	/*unpacked*/ class istream& operator>>(char *);
	/*unpacked*/ class istream& operator>>(unsigned char *);
	/*unpacked*/ class istream& operator>>(char *);
	/*unpacked*/ class istream& operator>>(/*unpacked*/ class ios& (*)(/*unpacked*/ class ios&));
	/*unpacked*/ class istream& operator>>(/*unpacked*/ class istream& (*)(/*unpacked*/ class istream&));
	/*unpacked*/ class istream& get(char *, int32_t, int32_t);
	/*unpacked*/ class istream& get(/*unpacked*/ class streambuf&, char);
	/*unpacked*/ class istream& get(char&);
	/*unpacked*/ class istream& get(unsigned char&);
	/*unpacked*/ class istream& get(char&);
	/*unpacked*/ class istream& get(char *, int32_t, char);
	/*unpacked*/ class istream& get(unsigned char *, int32_t, char);
	/*unpacked*/ class istream& get(char *, int32_t, char);
	int32_t get();
	/*unpacked*/ class istream& getline(char *, int32_t, char);
	/*unpacked*/ class istream& getline(unsigned char *, int32_t, char);
	/*unpacked*/ class istream& getline(char *, int32_t, char);
	/*unpacked*/ class istream& ignore(int32_t, int32_t);
	/*unpacked*/ class istream& read(char *, int32_t);
	/*unpacked*/ class istream& read(unsigned char *, int32_t);
	/*unpacked*/ class istream& read(char *, int32_t);
	int32_t gcount();
	int32_t peek();
	/*unpacked*/ class istream& putback(char);
	int32_t sync();
	/*unpacked*/ class istream& seekg(long, enum ios::seek_dir);
	/*unpacked*/ class istream& seekg(long);
	long tellg();
	void eatwhite();
protected:
	/*unpacked*/ class istream& operator=(const /*unpacked*/ class istream&);
	/*unpacked*/ class istream& operator=(/*unpacked*/ class streambuf*);
	int32_t do_ipfx(int32_t);
private:
	int32_t getint(char *);
	int32_t getdouble(char *, int32_t);
	int32_t _fGline;
	int32_t x_gcount;
};

// Type: /*unpacked*/ class ios;
// VTABLE: COPTER_D 0x00593ad4
class ios{ // not packed(0x50 bytes) TI: 0x4126
	enum io_state {
		goodbit = 0,
		eofbit = 1,
		failbit = 2,
		badbit = 4,
	};
	enum open_mode {
		in = 1,
		out = 2,
		ate = 4,
		app = 8,
		trunc = 16,
		nocreate = 32,
		noreplace = 64,
		binary = 128,
	};
	enum seek_dir {
		beg = 0,
		cur = 1,
		end = 2,
	};
	enum /* __unnamed */ {
		skipws = 1,
		left = 2,
		right = 4,
		internal = 8,
		dec = 16,
		oct = 32,
		hex = 64,
		showbase = 128,
		showpoint = 256,
		uppercase = 512,
		showpos = 1024,
		scientific = 2048,
		fixed = 4096,
		unitbuf = 8192,
		stdio = 16384,
	};
public:
	static const long basefield;
	static const long adjustfield;
	static const long floatfield;
	void ios(const /*unpacked*/ class ios&);
	void ios();
	void ios(/*unpacked*/ class streambuf*);
	virtual void ~ios(); // vtable+0x0
	long flags(long);
	long flags();
	long setf(long);
	long setf(long, long);
	long unsetf(long);
	int32_t width(int32_t);
	int32_t width();
	/*unpacked*/ class ostream* tie();
	/*unpacked*/ class ostream* tie(/*unpacked*/ class ostream*);
	char fill(char);
	char fill();
	int32_t precision();
	int32_t precision(int32_t);
	int32_t rdstate();
	void clear(int32_t);
	void * __ptr32 operator void *();
	int32_t operator!();
	int32_t good();
	int32_t eof();
	int32_t fail();
	int32_t bad();
	/*unpacked*/ class streambuf* rdbuf();
	long& iword(int32_t);
	void * __ptr32& pword(int32_t);
	// calltype: NearC
	static long bitalloc();
	// calltype: NearC
	static int32_t xalloc();
	// calltype: NearC
	static void sync_with_stdio();
	// calltype: NearC
	void setlock();
	// calltype: NearC
	void clrlock();
	// calltype: NearC
	void lock();
	// calltype: NearC
	void unlock();
	// calltype: NearC
	void lockbuf();
	// calltype: NearC
	void unlockbuf();
protected:
	/*unpacked*/ class ios& operator=(const /*unpacked*/ class ios&);
	void init(/*unpacked*/ class streambuf*);
	enum /* __unnamed */ {
		skipping = 0,
		tied = 1,
	};
protected:
	/*unpacked*/ class streambuf *bp;
	int32_t state;
	int32_t ispecial;
	int32_t ospecial;
	int32_t isfx_special;
	int32_t osfx_special;
	int32_t x_delbuf;
	/*unpacked*/ class ostream *x_tie;
	long x_flags;
	int32_t x_precision;
	char x_fill;
	int32_t x_width;
	static void (*stdioflush)();
	// calltype: NearC
	static void lockc();
	// calltype: NearC
	static void unlockc();
	/*unpacked*/ struct _CRT_CRITICAL_SECTION* lockptr();
public:
	void delbuf(int32_t);
	int32_t delbuf();
private:
	static long x_maxbit;
	static int32_t x_curindex;
	static int32_t sunk_with_stdio;
	static long x_statebuf[8];
	static int32_t fLockcInit;
	static /*unpacked*/ struct _CRT_CRITICAL_SECTION x_lockc;
	int32_t LockFlg;
	/*unpacked*/ struct _CRT_CRITICAL_SECTION x_lock;
};

// Type: /*unpacked*/ class ostream (forward reference);
// ostream Class implementation not found



// Contribution: 1:000a9800-000aa528 Module: 7, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004aa800
void CRLECompressedImage::CRLECompressedImage(long ResourceID) {
	/*bp-0x58*/  /*unpacked*/ class ostrstream NameOut; // 0x58 bytes
	/*bp-0x68*/  char FileName[13]; // 0xd bytes
	/*bp-0xc4*/  /*unpacked*/ class ifstream InputFile; // 0x5c bytes
	/*bp-0xc8*/  int32_t InputMode;


	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+8], 0;
// LINE 51:
	__asm        push   1;
	__asm        push   2;
	__asm        push   0xD;
	__asm        lea    eax, FileName[0];
	__asm        push   eax;
	__asm        lea    ecx, NameOut.ios;
	__asm        call   ostrstream::ostrstream;
// LINE 52:
	__asm        push   0x59A9D8;
	__asm        lea    ecx, NameOut.ios;
	__asm        call   ostream::operator<<;
	__asm        mov    eax, NameOut.ios;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [ebp+eax-0x58];
	__asm        mov    [ebp-0xE0], eax;
// LINE 53:
	__asm        mov    eax, [ebp-0xE0];
	__asm        mov    eax, [eax+0x30];
	__asm        mov    [ebp-0xDC], eax;
	__asm        mov    eax, [ebp-0xE0];
	__asm        mov    dword ptr [eax+0x30], 5;
	__asm        jmp    near ptr 0x004AA888;

	__asm        mov    eax, NameOut.ios;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [ebp+eax-0x58];
	__asm        mov    [ebp-0xE8], eax;
// LINE 54:
	__asm        mov    eax, [ebp-0xE8];
	__asm        mov    al, [eax+0x2C];
	__asm        mov    [ebp-0xE4], al;
	__asm        mov    eax, [ebp-0xE8];
	__asm        mov    byte ptr [eax+0x2C], 0x30;
	__asm        jmp    near ptr 0x004AA8B6;

	__asm        mov    eax, NameOut.ios;
	__asm        mov    eax, [eax+4];
	__asm        lea    eax, [ebp+eax-0x58];
	__asm        mov    [ebp-0xF0], eax;
// LINE 55:
	__asm        mov    eax, [ebp-0xF0];
	__asm        mov    eax, [eax+0x24];
	__asm        mov    [ebp-0xEC], eax;
	__asm        mov    eax, [ebp-0xF0];
	__asm        mov    dword ptr [eax+0x24], 0x14;
	__asm        jmp    near ptr 0x004AA8E7;

	__asm        push   0x59A9DC;
	__asm        mov    eax, ResourceID;
	__asm        push   eax;
	__asm        lea    ecx, NameOut.ios;
	__asm        call   ostream::operator<<;
	__asm        mov    ecx, eax;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0xD8], eax;
// LINE 56:
	__asm        jmp    near ptr 0x004AA90A;

	__asm        push   0;
	__asm        mov    ecx, [ebp-0xD8];
	__asm        call   ostream::operator<<;
// LINE 58:
	InputMode = 0x81;
// LINE 60:
	__asm        or     InputMode, 0x20;
// LINE 65:
	__asm        push   1;
	__asm        mov    eax, Function(void *  ifstream::`scalar deleting destructor'(uint32_t __flags), 0x56fc10);
	__asm        push   eax;
	__asm        mov    eax, InputMode;
	__asm        push   eax;
	__asm        lea    eax, FileName[0];
	__asm        push   eax;
	__asm        lea    ecx, InputFile.ios;
	__asm        call   ifstream::ifstream;
// LINE 66:
	__asm        jmp    near ptr 0x004AA94B;

	__asm        jmp    near ptr 0x004AA950;

	__asm        mov    eax, InputFile.ios;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [ebp+eax-0xC0];
	__asm        cmp    dword ptr [eax+0x4C], 0xFFFFFFFF;
	__asm        je     _T16f;

	__asm        jmp    _T174;
_T16f:
	__asm        jmp    _T375;
_T174:
	__asm        jmp    _T186;

	__asm        cmp    dword ptr [ebp-0xD4], 0;
	__asm        je     _T375;
// LINE 70:
// Block start:
	/*bp-0xcc*/  unsigned long ImageByteCount;
_T186:
	__asm        push   4;
	__asm        lea    eax, ImageByteCount;
	__asm        push   eax;
	__asm        lea    ecx, InputFile.ios;
	__asm        call   istream::read;
// LINE 71:
	__asm        jmp    near ptr 0x004AA99F;

	None = ImageByteCount;
// LINE 76:
	__asm        mov    word ptr [ebp-0x104], 0;
	__asm        cmp    this, 0;
	__asm        je     _T1ce;

	__asm        cmp    dword ptr [ebp-0x108], 0;
	__asm        jne    _T1ea;
_T1ce:
	__asm        push   0x12A;
	__asm        push   0x597444;
	__asm        push   0x59A090;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T1ef;
_T1ea:
	__asm        jmp    _T1ef;
_T1ef:
	__asm        mov    eax, [ebp-0x108];
	__asm        push   eax;
	__asm        push   0x42;
	__asm        call   dword ptr ds:[0x6C3730];
	__asm        mov    ecx, this;
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _T21e;

	None = 0xffff;
_T21e:
	__asm        jmp    near ptr 0x004AAA23;
// LINE 77:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T375;
// LINE 79:
// Block start:
	/*bp-0xd0*/  /*packed*/ struct RLEHeader *pCompressedImage;
	__asm        mov    pCompressedImage, 0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x100], eax;
// LINE 80:
	__asm        mov    word ptr [ebp-0xFC], 0;
	__asm        cmp    dword ptr [ebp-0x100], 0;
	__asm        je     _T265;

	__asm        jmp    _T281;
_T265:
	__asm        push   0x147;
	__asm        push   0x597444;
	__asm        push   0x59A068;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T286;
_T281:
	__asm        jmp    _T286;
_T286:
	__asm        mov    eax, [ebp-0x100];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E4];
	__asm        mov    pCompressedImage, eax;
	__asm        cmp    pCompressedImage, 0;
	__asm        jne    _T2af;

	None = 0xffff;
_T2af:
	__asm        jmp    near ptr 0x004AAAB4;
// LINE 81:
	__asm        cmp    pCompressedImage, 0;
	__asm        je     _T375;
// LINE 83:
	__asm        mov    eax, ImageByteCount;
	__asm        push   eax;
	__asm        mov    eax, pCompressedImage;
	__asm        push   eax;
	__asm        lea    ecx, InputFile.ios;
	__asm        call   istream::read;
// LINE 84:
	__asm        jmp    near ptr 0x004AAADF;

	__asm        mov    eax, ImageByteCount;
	__asm        cmp    InputFile.x_gcount, eax;
	__asm        je     _T30a;

	__asm        push   0x54;
	__asm        push   0x59A9E4;
	__asm        push   0x59AA0C;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T30f;
_T30a:
	__asm        jmp    _T30f;
// LINE 86:
_T30f:
	__asm        mov    eax, pCompressedImage;
	__asm        push   eax;
	__asm        call   ConvertCompressedByteOrdering;
	__asm        add    esp, 4;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xF8], eax;
// LINE 87:
	__asm        mov    word ptr [ebp-0xF4], 0;
	__asm        cmp    dword ptr [ebp-0xF8], 0;
	__asm        jne    _T35e;

	__asm        push   0x151;
	__asm        push   0x597444;
	__asm        push   0x59A080;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T363;
_T35e:
	__asm        jmp    _T363;
_T363:
	__asm        mov    eax, [ebp-0xF8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3654];
	__asm        jmp    _T375;
// LINE 91:
// Block end:
// Block end:
_T375:
	__asm        jmp    near ptr 0x004AAB7A;

	__asm        lea    ecx, InputFile<ifstream+0x0c>;
	__asm        call   ifstream::~ifstream;
	__asm        lea    ecx, InputFile<ifstream+0x0c>;
	__asm        call   ios::~ios;
	__asm        jmp    near ptr 0x004AAB95;

	__asm        lea    ecx, NameOut<ostrstream+0x08>;
	__asm        call   ostrstream::~ostrstream;
	__asm        lea    ecx, NameOut<ostrstream+0x08>;
	__asm        call   ios::~ios;
	__asm        jmp    near ptr 0x004AABAA;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004aabb7
void CRLECompressedImage::CRLECompressedImage(const /*packed*/ class CFlatImage *pImage, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom, int32_t TransparentIndex) {

	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+8], 0;
// LINE 104:
	__asm        jmp    near ptr 0x004AABDB;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004aabe5
void CRLECompressedImage::~CRLECompressedImage() {
// LINE 111:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T32;

	__asm        push   0x6F;
	__asm        push   0x59AA38;
	__asm        push   0x59AA60;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T37;
_T32:
	__asm        jmp    _T37;
// LINE 113:
_T37:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _T8b;
// LINE 114:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-8], eax;
	__asm        mov    word ptr [ebp-4], 0;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T77;

	__asm        push   0x134;
	__asm        push   0x597444;
	__asm        push   0x59A080;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T7c;
_T77:
	__asm        jmp    _T7c;
_T7c:
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3650];
	__asm        jmp    _T8b;
// LINE 115:
_T8b:
	__asm        jmp    near ptr 0x004AAC75;
}

// FUNCTION: COPTER_D 0x004aac7a
unsigned long CRLECompressedImage::Lock() {
// LINE 122:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        jne    _Taa;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Taa;
// LINE 123:
	None = this->mhRLEImage;
// LINE 124:
	__asm        mov    word ptr [ebp-4], 0;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T49;

	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        jne    _T65;
_T49:
	__asm        push   0x147;
	__asm        push   0x597444;
	__asm        push   0x59A068;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T6a;
_T65:
	__asm        jmp    _T6a;
_T6a:
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C35E4];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jne    _T8d;

	None = 0xffff;
_T8d:
	__asm        jmp    near ptr 0x004AAD0C;
// LINE 125:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _Ta5;
// LINE 126:
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+8];
// LINE 128:
_Ta5:
	__asm        jmp    _Tb0;
// LINE 129:
_Taa:
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+8];
// LINE 131:
_Tb0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        jmp    near ptr 0x004AAD35;
// LINE 132:
}

// FUNCTION: COPTER_D 0x004aad3a
unsigned long CRLECompressedImage::Unlock() {
// LINE 136:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        ja     _T35;

	__asm        push   0x88;
	__asm        push   0x59AA70;
	__asm        push   0x59AA98;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T3a;
_T35:
	__asm        jmp    _T3a;
// LINE 138:
_T3a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 1;
	__asm        jne    _Tb2;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax], 0;
	__asm        je     _Tb2;
// LINE 139:
	None = this->mhRLEImage;
// LINE 140:
	__asm        mov    word ptr [ebp-4], 0;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T87;

	__asm        push   0x151;
	__asm        push   0x597444;
	__asm        push   0x59A080;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T8c;
_T87:
	__asm        jmp    _T8c;
_T8c:
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3654];
	__asm        jmp    near ptr 0x004AADD5;

	__asm        movsx  eax, word ptr [ebp-4];
	__asm        test   eax, eax;
	__asm        jne    _Tad;
// LINE 141:
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+8];
// LINE 143:
_Tad:
	__asm        jmp    _Tb8;
// LINE 144:
_Tb2:
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+8];
// LINE 146:
_Tb8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        jmp    near ptr 0x004AADFD;
// LINE 147:
}

// FUNCTION: COPTER_D 0x004aae02
unsigned long CRLECompressedImage::Compose(/*packed*/ class IFlatImage *pDest, long DestLeft, long DestTop, long ClipLeft, long ClipTop, long ClipRight, long ClipBottom) {
// LINE 157:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        ja     _T35;

	__asm        push   0x9D;
	__asm        push   0x59AAA8;
	__asm        push   0x59AAD0;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T3a;
_T35:
	__asm        jmp    _T3a;
// LINE 158:
_T3a:
	__asm        cmp    pDest, 0;
	__asm        jne    _T60;

	__asm        push   0x9E;
	__asm        push   0x59AAE0;
	__asm        push   0x59AB08;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T65;
_T60:
	__asm        jmp    _T65;
// LINE 160:
_T65:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T253;
// LINE 162:
// Block start:
	/*bp-0x4*/   int32_t Bottom;
	/*bp-0x8*/   short Height;
	/*bp-0xc*/   short Width;
	/*bp-0x10*/  unsigned char TransparentColor;
	/*bp-0x14*/  int32_t Right;
	/*bp-0x18*/  int32_t Top;
	/*bp-0x1c*/  short LeftClipAmount;
	/*bp-0x20*/  unsigned char * pCompressedBits;
	/*bp-0x24*/  int32_t Left;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+4];
	__asm        add    eax, DestLeft;
	__asm        mov    Left, eax;
// LINE 163:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+6];
	__asm        add    eax, DestTop;
	__asm        mov    Top, eax;
// LINE 165:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax];
	__asm        add    eax, Left;
	__asm        mov    Right, eax;
// LINE 166:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        add    eax, Top;
	__asm        mov    Bottom, eax;
// LINE 169:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, 8;
	__asm        mov    pCompressedBits, eax;
// LINE 171:
	__asm        mov    eax, pCompressedBits;
	__asm        mov    al, [eax];
	__asm        mov    TransparentColor, al;
	__asm        inc    pCompressedBits;
// LINE 173:
_Tc8:
	__asm        mov    eax, Top;
	__asm        cmp    ClipTop, eax;
	__asm        jle    _Te7;
// LINE 176:
	__asm        mov    eax, pCompressedBits;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax];
	__asm        add    pCompressedBits, ecx;
// LINE 177:
	__asm        inc    Top;
// LINE 178:
	__asm        jmp    _Tc8;
// LINE 180:
_Te7:
	__asm        mov    eax, Bottom;
	__asm        cmp    ClipBottom, eax;
	__asm        jge    _Tf9;
// LINE 181:
	Bottom = ClipBottom;
// LINE 184:
_Tf9:
	LeftClipAmount = 0x0;
// LINE 185:
	__asm        mov    eax, Left;
	__asm        cmp    ClipLeft, eax;
	__asm        jle    _T11b;
// LINE 187:
	__asm        mov    eax, ClipLeft;
	__asm        sub    eax, Left;
	__asm        mov    LeftClipAmount, ax;
// LINE 188:
	Left = ClipLeft;
// LINE 191:
_T11b:
	__asm        mov    eax, Right;
	__asm        cmp    ClipRight, eax;
	__asm        jge    _T12d;
// LINE 192:
	Right = ClipRight;
// LINE 195:
_T12d:
	__asm        mov    eax, Bottom;
	__asm        sub    eax, Top;
	__asm        mov    Height, ax;
// LINE 196:
	__asm        mov    eax, Right;
	__asm        sub    eax, Left;
	__asm        mov    Width, ax;
// LINE 199:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax+2];
	__asm        movsx  ecx, Height;
	__asm        cmp    eax, ecx;
	__asm        jge    _T173;

	__asm        push   0xC7;
	__asm        push   0x59AB10;
	__asm        push   0x59AB38;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T178;
_T173:
	__asm        jmp    _T178;
// LINE 200:
_T178:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, Width;
	__asm        cmp    eax, ecx;
	__asm        jge    _T1a9;

	__asm        push   0xC8;
	__asm        push   0x59AB58;
	__asm        push   0x59AB80;
	__asm        call   _assert;
	__asm        add    esp, 0xC;
	__asm        jmp    _T1ae;
_T1a9:
	__asm        jmp    _T1ae;
// LINE 202:
_T1ae:
	__asm        movsx  eax, Height;
	__asm        test   eax, eax;
	__asm        jle    _T253;

	__asm        movsx  eax, Width;
	__asm        test   eax, eax;
	__asm        jle    _T253;
// LINE 204:
// Block start:
	/*bp-0x28*/  unsigned char * pBits;
	__asm        jmp    near ptr 0x004AAFCD;

	pBits = pDest->mpBits;
// LINE 205:
	__asm        cmp    pBits, 0;
	__asm        je     _T253;
// LINE 207:
// Block start:
	/*bp-0x2c*/  long DestStride;
	__asm        mov    eax, pDest;
	__asm        mov    eax, [eax+0x14];
	__asm        mov    DestStride, eax;
	__asm        jmp    near ptr 0x004AAFEE;
// LINE 209:
	__asm        mov    eax, Top;
	__asm        imul   eax, DestStride;
	__asm        add    eax, Left;
	__asm        add    pBits, eax;
// LINE 211:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        movsx  eax, word ptr [eax];
	__asm        movsx  ecx, Width;
	__asm        cmp    eax, ecx;
	__asm        jne    _T22f;
// LINE 213:
	__asm        mov    eax, reinterpret_cast<uint32_t>(TransparentColor);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(Height);
	__asm        push   eax;
	__asm        mov    eax, pCompressedBits;
	__asm        push   eax;
	__asm        mov    eax, DestStride;
	__asm        push   eax;
	__asm        mov    eax, pBits;
	__asm        push   eax;
	__asm        call   RLEDecompressUnclippedX;
	__asm        add    esp, 0x14;
// LINE 214:
	__asm        jmp    _T253;
// LINE 217:
_T22f:
	__asm        mov    eax, reinterpret_cast<uint32_t>(TransparentColor);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(Height);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(Width);
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(LeftClipAmount);
	__asm        push   eax;
	__asm        mov    eax, pCompressedBits;
	__asm        push   eax;
	__asm        mov    eax, DestStride;
	__asm        push   eax;
	__asm        mov    eax, pBits;
	__asm        push   eax;
	__asm        call   RLEDecompressClippedX;
	__asm        add    esp, 0x1C;
// LINE 223:
// Block end:
// Block end:
// Block end:
_T253:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004AB05C;
// LINE 224:
}

// FUNCTION: COPTER_D 0x004ab063
static void ConvertCompressedByteOrdering(/*packed*/ struct RLEHeader *pCompressedImage) {
// LINE 312:
	__asm        jmp    near ptr 0x004AB06E;
}

// FUNCTION: COPTER_D 0x004ab073
static void RLEDecompressUnclippedX(unsigned char * pDestBuffer, long DestStride, unsigned char * pSource, short Height, unsigned char TransparentColor) {
	/*bp-0x4*/   unsigned char * pNextSourceLine;
	/*bp-0x8*/   unsigned char * pDest;
	/*bp-0xc*/   unsigned char * pDestinationEdge;

// LINE 323:
	pDestinationEdge = pDestBuffer;
// LINE 324:
	pDest = pDestinationEdge;
// LINE 327:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax];
	__asm        add    ecx, pSource;
	__asm        mov    pNextSourceLine, ecx;
// LINE 328:
	__asm        add    pSource, 2;
// LINE 330:
_T27:
	__asm        movsx  eax, Height;
	__asm        test   eax, eax;
	__asm        je     _T17a;
// LINE 336:
// Block start:
	/*bp-0x10*/  unsigned char data;
	/*bp-0x14*/  unsigned char token;
	/*bp-0x18*/  int32_t counter;
	__asm        mov    eax, pSource;
	__asm        cmp    pNextSourceLine, eax;
	__asm        jne    _T66;
// LINE 340:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax];
	__asm        add    ecx, pSource;
	__asm        mov    pNextSourceLine, ecx;
// LINE 341:
	__asm        add    pSource, 2;
// LINE 344:
	__asm        mov    eax, DestStride;
	__asm        add    pDestinationEdge, eax;
// LINE 345:
	pDest = pDestinationEdge;
// LINE 347:
	__asm        dec    Height;
// LINE 349:
	__asm        jmp    _T175;
// LINE 352:
_T66:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    token, al;
	__asm        inc    pSource;
// LINE 353:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    data, al;
	__asm        inc    pSource;
// LINE 355:
	__asm        xor    eax, eax;
	__asm        mov    al, token;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T14e;
// LINE 358:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        mov    counter, eax;
// LINE 361:
	__asm        mov    eax, counter;
	__asm        push   eax;
	__asm        mov    eax, pSource;
	__asm        push   eax;
	__asm        mov    eax, pDest;
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
// LINE 362:
	__asm        mov    eax, counter;
	__asm        add    pSource, eax;
// LINE 363:
	__asm        mov    eax, counter;
	__asm        add    pDest, eax;
// LINE 364:
	__asm        jmp    _T175;
// LINE 367:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        mov    counter, eax;
// LINE 368:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    data, al;
	__asm        inc    pSource;
// LINE 371:
	__asm        mov    eax, counter;
	__asm        push   eax;
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        push   eax;
	__asm        mov    eax, pDest;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 372:
	__asm        mov    eax, counter;
	__asm        add    pDest, eax;
// LINE 373:
	__asm        jmp    _T175;
// LINE 376:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        add    pDest, eax;
// LINE 377:
	__asm        jmp    _T175;
// LINE 380:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        mov    counter, eax;
// LINE 383:
_T103:
	__asm        mov    eax, counter;
	__asm        mov    [ebp-0x1C], eax;
	__asm        dec    counter;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T13f;
// LINE 385:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        xor    eax, eax;
	__asm        mov    al, TransparentColor;
	__asm        cmp    ecx, eax;
	__asm        je     _T134;
// LINE 386:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    ecx, pDest;
	__asm        mov    [ecx], al;
// LINE 388:
_T134:
	__asm        inc    pDest;
// LINE 389:
	__asm        inc    pSource;
// LINE 390:
	__asm        jmp    _T103;
// LINE 391:
_T13f:
	__asm        jmp    _T175;
// LINE 395:
	__asm        jmp    _T175;
// LINE 396:
	__asm        jmp    _T175;
_T14e:
	__asm        dec    dword ptr [ebp-0x20];
	__asm        cmp    dword ptr [ebp-0x20], 3;
	__asm        ja     _T175;

	__asm        mov    eax, [ebp-0x20];
	__asm        jmp    SwitchPointers4895192[0][eax*4];
// Switch pointers
// LINE 398:
// Block end:
_T175:
	__asm        jmp    _T27;
// LINE 399:
_T17a:
	__asm        jmp    near ptr 0x004AB1F2;
}

// FUNCTION: COPTER_D 0x004ab1f7
static void RLEDecompressClippedX(unsigned char * pDestBuffer, long DestStride, unsigned char * pSource, short LeftClip, short Width, short Height, unsigned char TransparentColor) {
	/*bp-0x4*/   unsigned char * pNextSourceLine;
	/*bp-0x8*/   unsigned char * pDest;
	/*bp-0xc*/   unsigned char * pDestinationEdge;
	/*bp-0x10*/  short PixelCount;

// LINE 405:
	pDestinationEdge = pDestBuffer;
// LINE 406:
	pDest = pDestinationEdge;
// LINE 409:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax];
	__asm        add    ecx, pSource;
	__asm        mov    pNextSourceLine, ecx;
// LINE 410:
	__asm        add    pSource, 2;
// LINE 413:
	__asm        movsx  eax, LeftClip;
	__asm        neg    eax;
	__asm        mov    PixelCount, ax;
// LINE 415:
_T31:
	__asm        movsx  eax, Height;
	__asm        test   eax, eax;
	__asm        je     _T328;
// LINE 421:
// Block start:
	/*bp-0x14*/  unsigned char data;
	/*bp-0x18*/  unsigned char token;
	/*bp-0x1c*/  int32_t counter;
	__asm        mov    eax, pSource;
	__asm        cmp    pNextSourceLine, eax;
	__asm        jne    _T7a;
// LINE 425:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cx, [eax];
	__asm        add    ecx, pSource;
	__asm        mov    pNextSourceLine, ecx;
// LINE 426:
	__asm        add    pSource, 2;
// LINE 429:
	__asm        mov    eax, DestStride;
	__asm        add    pDestinationEdge, eax;
// LINE 430:
	pDest = pDestinationEdge;
// LINE 432:
	__asm        dec    Height;
// LINE 433:
	__asm        movsx  eax, LeftClip;
	__asm        neg    eax;
	__asm        mov    PixelCount, ax;
// LINE 435:
	__asm        jmp    _T323;
// LINE 439:
_T7a:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    token, al;
	__asm        inc    pSource;
// LINE 440:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    data, al;
	__asm        inc    pSource;
// LINE 442:
	__asm        xor    eax, eax;
	__asm        mov    al, token;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T2e6;
// LINE 445:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        mov    counter, eax;
// LINE 448:
	__asm        movsx  eax, PixelCount;
	__asm        test   eax, eax;
	__asm        jge    _Tfc;
// LINE 451:
	__asm        movsx  eax, PixelCount;
	__asm        neg    eax;
	__asm        cmp    eax, counter;
	__asm        jl     _Tde;
// LINE 454:
	__asm        mov    eax, counter;
	__asm        add    pSource, eax;
// LINE 455:
	__asm        movsx  eax, PixelCount;
	__asm        add    eax, counter;
	__asm        mov    PixelCount, ax;
// LINE 456:
	counter = 0x0;
// LINE 458:
	__asm        jmp    _Tfc;
// LINE 461:
_Tde:
	__asm        movsx  eax, PixelCount;
	__asm        neg    eax;
	__asm        add    pSource, eax;
// LINE 462:
	__asm        xor    eax, eax;
	__asm        movsx  ecx, PixelCount;
	__asm        neg    ecx;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    counter, eax;
// LINE 463:
	PixelCount = 0x0;
// LINE 470:
_Tfc:
	__asm        cmp    counter, 0;
	__asm        je     _T132;

	__asm        movsx  eax, Width;
	__asm        movsx  ecx, PixelCount;
	__asm        cmp    eax, ecx;
	__asm        jle    _T132;
// LINE 472:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    ecx, pDest;
	__asm        mov    [ecx], al;
	__asm        inc    pSource;
	__asm        inc    pDest;
// LINE 473:
	__asm        dec    counter;
// LINE 474:
	__asm        inc    PixelCount;
// LINE 475:
	__asm        jmp    _Tfc;
// LINE 476:
_T132:
	__asm        jmp    _T30d;
// LINE 479:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        mov    counter, eax;
// LINE 480:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    data, al;
	__asm        inc    pSource;
// LINE 482:
	__asm        movsx  eax, PixelCount;
	__asm        test   eax, eax;
	__asm        jge    _T192;
// LINE 485:
	__asm        movsx  eax, PixelCount;
	__asm        neg    eax;
	__asm        cmp    eax, counter;
	__asm        jl     _T17d;
// LINE 488:
	__asm        movsx  eax, PixelCount;
	__asm        add    eax, counter;
	__asm        mov    PixelCount, ax;
// LINE 489:
	counter = 0x0;
// LINE 491:
	__asm        jmp    _T192;
// LINE 494:
_T17d:
	__asm        xor    eax, eax;
	__asm        movsx  ecx, PixelCount;
	__asm        neg    ecx;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    counter, eax;
// LINE 495:
	PixelCount = 0x0;
// LINE 501:
_T192:
	__asm        cmp    counter, 0;
	__asm        je     _T1c3;

	__asm        movsx  eax, Width;
	__asm        movsx  ecx, PixelCount;
	__asm        cmp    eax, ecx;
	__asm        jle    _T1c3;
// LINE 503:
	__asm        mov    al, data;
	__asm        mov    ecx, pDest;
	__asm        mov    [ecx], al;
	__asm        inc    pDest;
// LINE 504:
	__asm        dec    counter;
// LINE 505:
	__asm        inc    PixelCount;
// LINE 506:
	__asm        jmp    _T192;
// LINE 507:
_T1c3:
	__asm        jmp    _T30d;
// LINE 510:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        mov    counter, eax;
// LINE 511:
	__asm        movsx  eax, PixelCount;
	__asm        test   eax, eax;
	__asm        jge    _T218;
// LINE 514:
	__asm        movsx  eax, PixelCount;
	__asm        neg    eax;
	__asm        cmp    eax, counter;
	__asm        jl     _T203;
// LINE 517:
	__asm        movsx  eax, PixelCount;
	__asm        add    eax, counter;
	__asm        mov    PixelCount, ax;
// LINE 518:
	counter = 0x0;
// LINE 520:
	__asm        jmp    _T218;
// LINE 523:
_T203:
	__asm        xor    eax, eax;
	__asm        movsx  ecx, PixelCount;
	__asm        neg    ecx;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    counter, eax;
// LINE 524:
	PixelCount = 0x0;
// LINE 528:
_T218:
	__asm        mov    eax, counter;
	__asm        add    pDest, eax;
// LINE 529:
	__asm        movsx  eax, PixelCount;
	__asm        add    eax, counter;
	__asm        mov    PixelCount, ax;
// LINE 530:
	__asm        jmp    _T30d;
// LINE 533:
	__asm        xor    eax, eax;
	__asm        mov    al, data;
	__asm        inc    eax;
	__asm        mov    counter, eax;
// LINE 536:
	__asm        movsx  eax, PixelCount;
	__asm        test   eax, eax;
	__asm        jge    _T28d;
// LINE 539:
	__asm        movsx  eax, PixelCount;
	__asm        neg    eax;
	__asm        cmp    eax, counter;
	__asm        jl     _T26f;
// LINE 542:
	__asm        mov    eax, counter;
	__asm        add    pSource, eax;
// LINE 543:
	__asm        movsx  eax, PixelCount;
	__asm        add    eax, counter;
	__asm        mov    PixelCount, ax;
// LINE 544:
	counter = 0x0;
// LINE 546:
	__asm        jmp    _T28d;
// LINE 549:
_T26f:
	__asm        movsx  eax, PixelCount;
	__asm        neg    eax;
	__asm        add    pSource, eax;
// LINE 550:
	__asm        xor    eax, eax;
	__asm        movsx  ecx, PixelCount;
	__asm        neg    ecx;
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    counter, eax;
// LINE 551:
	PixelCount = 0x0;
// LINE 558:
_T28d:
	__asm        cmp    counter, 0;
	__asm        je     _T2d7;

	__asm        movsx  eax, Width;
	__asm        movsx  ecx, PixelCount;
	__asm        cmp    eax, ecx;
	__asm        jle    _T2d7;
// LINE 560:
	__asm        mov    eax, pSource;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [eax];
	__asm        xor    eax, eax;
	__asm        mov    al, TransparentColor;
	__asm        cmp    ecx, eax;
	__asm        je     _T2c5;
// LINE 561:
	__asm        mov    eax, pSource;
	__asm        mov    al, [eax];
	__asm        mov    ecx, pDest;
	__asm        mov    [ecx], al;
// LINE 563:
_T2c5:
	__asm        inc    pDest;
// LINE 564:
	__asm        inc    pSource;
// LINE 565:
	__asm        dec    counter;
// LINE 566:
	__asm        inc    PixelCount;
// LINE 567:
	__asm        jmp    _T28d;
// LINE 568:
_T2d7:
	__asm        jmp    _T30d;
// LINE 572:
	__asm        jmp    _T30d;
// LINE 573:
	__asm        jmp    _T30d;
_T2e6:
	__asm        dec    dword ptr [ebp-0x20];
	__asm        cmp    dword ptr [ebp-0x20], 3;
	__asm        ja     _T30d;

	__asm        mov    eax, [ebp-0x20];
	__asm        jmp    SwitchPointers4895988[0][eax*4];
// Switch pointers
// LINE 576:
_T30d:
	__asm        movsx  eax, Width;
	__asm        movsx  ecx, PixelCount;
	__asm        cmp    eax, ecx;
	__asm        jg     _T323;
// LINE 577:
	pSource = pNextSourceLine;
// LINE 579:
// Block end:
_T323:
	__asm        jmp    _T31;
// LINE 580:
_T328:
	__asm        jmp    near ptr 0x004AB524;
}



// Contribution: 3:000039d4-00003b9d Module: 7, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x0059a9d4
unsigned short * CRLECompressedImage::RLEGraphicsPool = { 0 /* todo */ };

