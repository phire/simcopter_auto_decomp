// Module: cpuid.obj
// Source: C:\Copter\source\sparkal\cpuid.c
// autogenerated by simcopter_tool from PDB file

// Type: int32_t;

// Type: unsigned short;

// Type: unsigned char;

// Type: unsigned long;

// Type: /*packed*/ struct TIME_STAMP;
struct TIME_STAMP{ // packed(0x8 bytes) TI: 0x26fa
	/*+0x0*/   unsigned long High;
	/*+0x4*/   unsigned long Low;
};

// Type: /*packed*/ struct TIME_STAMP (forward reference);
struct TIME_STAMP{ // packed(0x8 bytes) TI: 0x26fa
	/*+0x0*/   unsigned long High;
	/*+0x4*/   unsigned long Low;
};

// Type: short;



// Contribution: 1:0007a640-0007ab67 Module: 33, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0047b640
unsigned short wincpuidsupport() {
	/*bp-0x4*/   int32_t cpuid_support;

// LINE 64:
	cpuid_support = 0x1;
// LINE 67:
	__asm        pushfd;
// LINE 68:
	__asm        pop    eax;
// LINE 69:
	__asm        mov    ecx, eax;
// LINE 70:
	__asm        xor    eax, 0x200000;
// LINE 71:
	__asm        push   eax;
// LINE 73:
	__asm        popfd;
// LINE 74:
	__asm        pushfd;
// LINE 75:
	__asm        pop    eax;
// LINE 76:
	__asm        xor    eax, ecx;
// LINE 77:
	__asm        jne    support;
// LINE 79:
	cpuid_support = 0x0;
// LINE 83:
support:
	return reinterpret_cast<uint16_t>(cpuid_support);
// LINE 85:
}

// FUNCTION: COPTER_D 0x0047b67a
unsigned short wincpuid() {
	/*bp-0x4*/   unsigned short cpuid;

// LINE 110:
	__asm        call   wincpuidsupport;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _T27;
// LINE 112:
	__asm        call   check_IDProc;
	__asm        mov    cpuid, ax;
// LINE 114:
	__asm        jmp    end;
// LINE 116:
_T27:
	__asm        call   check_clone;
	__asm        movzx  eax, ax;
	__asm        mov    clone_flag, eax;
// LINE 118:
	__asm        call   check_8086;
	__asm        mov    cpuid, ax;
// LINE 119:
	__asm        test   reinterpret_cast<uint32_t>(cpuid), 0xFFFF;
	__asm        jne    _T4f;

	__asm        jmp    end;
// LINE 121:
_T4f:
	__asm        call   check_80286;
	__asm        mov    cpuid, ax;
// LINE 122:
	__asm        mov    eax, reinterpret_cast<uint32_t>(cpuid);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 2;
	__asm        jne    _T6e;

	__asm        jmp    end;
// LINE 124:
_T6e:
	__asm        call   check_80386;
	__asm        mov    cpuid, ax;
// LINE 125:
	__asm        mov    eax, reinterpret_cast<uint32_t>(cpuid);
	__asm        and    eax, 0xFFFF;
	__asm        cmp    eax, 3;
	__asm        jne    _T8d;

	__asm        jmp    end;
// LINE 127:
_T8d:
	cpuid = 0x4;
// LINE 133:
end:
	__asm        cmp    clone_flag, 0;
	__asm        je     _Tb1;
// LINE 134:
	__asm        mov    eax, reinterpret_cast<uint32_t>(cpuid);
	__asm        and    eax, 0xFFFF;
	__asm        or     eax, 0x8000;
	__asm        mov    cpuid, ax;
// LINE 137:
_Tb1:
	return cpuid;
// LINE 139:
}

// FUNCTION: COPTER_D 0x0047b739
unsigned short wincpuidext() {
	/*bp-0x4*/   unsigned short cpu_type;
	/*bp-0x10*/  unsigned char vendor_id[12]; // 0xc bytes
	/*bp-0x14*/  unsigned short cpuidext;
	/*bp-0x18*/  int32_t i;
	/*bp-0x24*/  unsigned char intel_id[12]; // 0xc bytes

// LINE 164:
	i = 0x0;
// LINE 165:
	cpu_type = 0x0;
// LINE 166:
	cpuidext = 0x0;
// LINE 167:
	__asm        mov    eax, 0x5999D0;
	__asm        lea    ecx, vendor_id[0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 168:
	__asm        mov    eax, 0x5999E0;
	__asm        lea    ecx, intel_id[0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 170:
	__asm        call   wincpuidsupport;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _Tc6;
// LINE 174:
	__asm        xor    eax, eax;
// LINE 176:
	__asm        cpuid;
// LINE 178:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[0]), ebx;
// LINE 179:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[4]), edx;
// LINE 180:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[8]), ecx;
// LINE 183:
	__asm        mov    i, 0;
	__asm        jmp    _T78;
_T75:
	i++;
_T78:
	__asm        cmp    i, 0xC;
	__asm        jge    _Tab;
// LINE 185:
	__asm        mov    eax, i;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [ebp+eax-0x24];
	__asm        mov    eax, i;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ebp+eax-0x10];
	__asm        cmp    ecx, edx;
	__asm        je     _Ta6;
// LINE 186:
	clone_flag = 0x1;
// LINE 187:
_Ta6:
	__asm        jmp    _T75;
// LINE 191:
_Tab:
	__asm        cmp    eax, 1;
// LINE 194:
	__asm        jl     end_cpuidext;
// LINE 195:
	__asm        xor    eax, eax;
// LINE 196:
	__asm        inc    eax;
// LINE 197:
	__asm        cpuid;
// LINE 200:
	__asm        mov    cpuidext, ax;
// LINE 203:
end_cpuidext:
	__asm        mov    ax, cpuidext;
// LINE 206:
	__asm        jmp    _Tde;
// LINE 208:
_Tc6:
	__asm        call   wincpuid;
	__asm        mov    cpu_type, ax;
// LINE 209:
	__asm        mov    eax, reinterpret_cast<uint32_t>(cpu_type);
	__asm        and    eax, 0xFFFF;
	__asm        shl    eax, 8;
	__asm        mov    cpuidext, ax;
// LINE 213:
_Tde:
	return cpuidext;
// LINE 215:
}

// FUNCTION: COPTER_D 0x0047b825
unsigned long wincpufeatures() {
	/*bp-0xc*/   unsigned char vendor_id[12]; // 0xc bytes
	/*bp-0x10*/  unsigned long cpuff;
	/*bp-0x14*/  int32_t i;
	/*bp-0x20*/  unsigned char intel_id[12]; // 0xc bytes

// LINE 255:
	i = 0x0;
// LINE 256:
	cpuff = 0x0;
// LINE 257:
	__asm        mov    eax, 0x5999F0;
	__asm        lea    ecx, vendor_id[0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 258:
	__asm        mov    eax, 0x599A00;
	__asm        lea    ecx, intel_id[0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 260:
	__asm        call   wincpuidsupport;
	__asm        movzx  eax, ax;
	__asm        test   eax, eax;
	__asm        je     _Tba;
// LINE 264:
	__asm        xor    eax, eax;
// LINE 266:
	__asm        cpuid;
// LINE 268:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[0]), ebx;
// LINE 269:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[4]), edx;
// LINE 270:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[8]), ecx;
// LINE 273:
	__asm        mov    i, 0;
	__asm        jmp    _T73;
_T70:
	i++;
_T73:
	__asm        cmp    i, 0xC;
	__asm        jge    _Ta6;
// LINE 275:
	__asm        mov    eax, i;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [ebp+eax-0x20];
	__asm        mov    eax, i;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ebp+eax-0xC];
	__asm        cmp    ecx, edx;
	__asm        je     _Ta1;
// LINE 276:
	clone_flag = 0x1;
// LINE 277:
_Ta1:
	__asm        jmp    _T70;
// LINE 281:
_Ta6:
	__asm        cmp    eax, 1;
// LINE 284:
	__asm        jl     end_cpuff;
// LINE 285:
	__asm        xor    eax, eax;
// LINE 286:
	__asm        inc    eax;
// LINE 287:
	__asm        cpuid;
// LINE 290:
	__asm        mov    cpuff, edx;
// LINE 293:
end_cpuff:
	__asm        mov    eax, cpuff;
// LINE 297:
_Tba:
	return cpuff;
// LINE 299:
}

// FUNCTION: COPTER_D 0x0047b8ec
/*packed*/ struct TIME_STAMP winrdtsc() {
	/*bp-0x4*/   unsigned long features;
	/*bp-0xc*/   /*packed*/ struct TIME_STAMP timestamp; // 0x8 bytes

// LINE 324:
	__asm        call   wincpufeatures;
	__asm        mov    features, eax;
// LINE 326:
	timestamp.Low = 0x0;
// LINE 327:
	timestamp.High = 0x0;
// LINE 329:
	__asm        test   reinterpret_cast<uint8_t>(features), 0x10;
	__asm        je     _T31;
// LINE 331:
	__asm        rdtsc;
// LINE 335:
	__asm        mov    timestamp.Low, eax;
// LINE 336:
	__asm        mov    timestamp.High, edx;
// LINE 341:
_T31:
	__asm        mov    eax, timestamp.High;
	__asm        mov    edx, timestamp.Low;
	__asm        jmp    __RETURN;
// LINE 343:
__RETURN:
}

// FUNCTION: COPTER_D 0x0047b92d
unsigned short getdllversion() {
	/*bp-0x4*/   unsigned short Version;

// LINE 360:
	Version = 0x100;
// LINE 362:
	return Version;
// LINE 364:
}

// FUNCTION: COPTER_D 0x0047b94a
static unsigned short check_clone() {
	/*bp-0x4*/   short cpu_type;

// LINE 382:
	cpu_type = 0x0;
// LINE 386:
	__asm        mov    ax, 0x5555;
// LINE 387:
	__asm        xor    dx, dx;
// LINE 388:
	__asm        mov    cx, 2;
// LINE 389:
	__asm        div    cx;
// LINE 390:
	__asm        clc;
// LINE 391:
	__asm        jne    no_clone;
// LINE 392:
	__asm        jmp    clone;
// LINE 393:
no_clone:
	__asm        stc;
// LINE 394:
clone:
	__asm        pushf;
// LINE 395:
	__asm        pop    ax;
// LINE 396:
	__asm        and    al, 1;
// LINE 397:
	__asm        xor    al, 1;
// LINE 400:
	__asm        mov    cpu_type, ax;
// LINE 403:
	__asm        movsx  eax, cpu_type;
	__asm        and    eax, 1;
	__asm        mov    cpu_type, ax;
// LINE 405:
	return cpu_type;
// LINE 407:
}

// FUNCTION: COPTER_D 0x0047b999
static unsigned short check_8086() {
	/*bp-0x4*/   unsigned short cpu_type;

// LINE 424:
	cpu_type = 0xffff;
// LINE 427:
	__asm        pushf;
// LINE 428:
	__asm        pop    ax;
// LINE 429:
	__asm        mov    cx, ax;
// LINE 430:
	__asm        and    ax, 0xFFF;
// LINE 431:
	__asm        push   ax;
// LINE 432:
	__asm        popf;
// LINE 433:
	__asm        pushf;
// LINE 434:
	__asm        pop    ax;
// LINE 435:
	__asm        and    ax, 0xF000;
// LINE 436:
	__asm        cmp    ax, 0xF000;
// LINE 437:
	cpu_type = 0x0;
// LINE 438:
	__asm        je     end_8086;
// LINE 440:
	cpu_type = 0xffff;
// LINE 442:
end_8086:
	__asm        push   cx;
// LINE 443:
	__asm        popf;
// LINE 444:
	__asm        mov    ax, cpu_type;
// LINE 448:
	return cpu_type;
// LINE 450:
}

// FUNCTION: COPTER_D 0x0047b9eb
static unsigned short check_80286() {
	/*bp-0x4*/   unsigned short cpu_type;

// LINE 467:
	cpu_type = 0xffff;
// LINE 470:
	__asm        pushf;
// LINE 471:
	__asm        pop    cx;
// LINE 472:
	__asm        mov    bx, cx;
// LINE 473:
	__asm        or     cx, 0xF000;
// LINE 474:
	__asm        push   cx;
// LINE 475:
	__asm        popf;
// LINE 476:
	__asm        pushf;
// LINE 477:
	__asm        pop    ax;
// LINE 478:
	__asm        and    ax, 0xF000;
// LINE 480:
	cpu_type = 0x2;
// LINE 483:
	__asm        je     end_80286;
// LINE 486:
	cpu_type = 0xffff;
// LINE 488:
end_80286:
	__asm        push   bx;
// LINE 489:
	__asm        popf;
// LINE 490:
	__asm        mov    ax, cpu_type;
// LINE 494:
	return cpu_type;
// LINE 496:
}

// FUNCTION: COPTER_D 0x0047ba3a
static unsigned short check_80386() {
	/*bp-0x4*/   unsigned short cpu_type;

// LINE 513:
	cpu_type = 0xffff;
// LINE 516:
	__asm        mov    bx, sp;
// LINE 517:
	__asm        and    sp, 0xFFFC;
// LINE 518:
	__asm        pushfd;
// LINE 519:
	__asm        pop    eax;
// LINE 520:
	__asm        mov    ecx, eax;
// LINE 521:
	__asm        xor    eax, 0x40000;
// LINE 523:
	__asm        push   eax;
// LINE 526:
	__asm        popfd;
// LINE 527:
	__asm        pushfd;
// LINE 528:
	__asm        pop    eax;
// LINE 530:
	__asm        xor    eax, ecx;
// LINE 533:
	cpu_type = 0x3;
// LINE 534:
	__asm        je     end_80386;
// LINE 535:
	cpu_type = 0xffff;
// LINE 537:
end_80386:
	__asm        push   ecx;
// LINE 538:
	__asm        popfd;
// LINE 539:
	__asm        mov    sp, bx;
// LINE 540:
	__asm        mov    ax, cpu_type;
// LINE 541:
	__asm        and    eax, 0xFFFF;
// LINE 544:
	return cpu_type;
// LINE 546:
}

// FUNCTION: COPTER_D 0x0047ba8d
static unsigned short check_IDProc() {
	/*bp-0x4*/   unsigned char model;
	/*bp-0x8*/   unsigned short cpu_type;
	/*bp-0x14*/  unsigned char vendor_id[12]; // 0xc bytes
	/*bp-0x18*/  int32_t i;
	/*bp-0x1c*/  unsigned char stepping;
	/*bp-0x28*/  unsigned char intel_id[12]; // 0xc bytes

// LINE 563:
	i = 0x0;
// LINE 564:
	cpu_type = 0xffff;
// LINE 565:
	stepping = 0x0;
// LINE 566:
	model = 0x0;
// LINE 567:
	__asm        mov    eax, 0x599A10;
	__asm        lea    ecx, vendor_id[0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 568:
	__asm        mov    eax, 0x599A20;
	__asm        lea    ecx, intel_id[0];
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ecx+8], eax;
// LINE 572:
	__asm        xor    eax, eax;
// LINE 574:
	__asm        cpuid;
// LINE 576:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[0]), ebx;
// LINE 577:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[4]), edx;
// LINE 578:
	__asm        mov    reinterpret_cast<uint32_t>(vendor_id[8]), ecx;
// LINE 581:
	__asm        mov    i, 0;
	__asm        jmp    _T6a;
_T67:
	i++;
_T6a:
	__asm        cmp    i, 0xC;
	__asm        jge    _T9d;
// LINE 583:
	__asm        mov    eax, i;
	__asm        xor    ecx, ecx;
	__asm        mov    cl, [ebp+eax-0x28];
	__asm        mov    eax, i;
	__asm        xor    edx, edx;
	__asm        mov    dl, [ebp+eax-0x14];
	__asm        cmp    ecx, edx;
	__asm        je     _T98;
// LINE 584:
	clone_flag = 0x1;
// LINE 585:
_T98:
	__asm        jmp    _T67;
// LINE 589:
_T9d:
	__asm        cmp    eax, 1;
// LINE 592:
	__asm        jl     end_IDProc;
// LINE 593:
	__asm        xor    eax, eax;
// LINE 594:
	__asm        inc    eax;
// LINE 595:
	__asm        cpuid;
// LINE 598:
	__asm        mov    stepping, al;
// LINE 599:
	__asm        and    stepping, 0xF;
// LINE 601:
	__asm        and    al, 0xF0;
// LINE 602:
	__asm        shr    al, 4;
// LINE 603:
	__asm        mov    model, al;
// LINE 605:
	__asm        and    eax, 0xF00;
// LINE 606:
	__asm        shr    eax, 8;
// LINE 607:
	__asm        and    eax, 0xF;
// LINE 608:
	__asm        mov    cpu_type, ax;
// LINE 611:
end_IDProc:
	__asm        mov    ax, cpu_type;
// LINE 614:
	return cpu_type;
// LINE 616:
}



// Contribution: 3:000029d0-00002a2c Module: 33, 4 byte alignment, initialized_data, read, write, 


// Unknown globals:
// The PDB was slightly corrupted and we aren't sure which file these globals belong to.
// GLOBAL: COPTER_D 0x00638ed4
int32_t clone_flag; // Contrib missing

// GLOBAL: COPTER_D 0x00638ed4
int32_t clone_flag; // Contrib missing

