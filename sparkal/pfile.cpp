// Module: Pfile.obj
// Source: C:\Copter\source\sparkal\Pfile.cpp
// autogenerated by simcopter_tool from PDB file

// Type: class PFile (forward reference);
class PFile{
		enum __unnamed {
			FileNull = -1,
		};
		enum SeekTypes {
			N_SEEK_FROM_FILE_START = 0,
			N_SEEK_FROM_FILE_CURRENT = 1,
			N_SEEK_FROM_FILE_END = 2,
		};
		enum AccessTypes {
			ReadOnly = 0,
			ReadWrite = 2,
			WriteOnly = 1,
			Create = 768,
			CreateExcl = 1280,
			Append = 8,
			Binary = 32768,
			Compat = 0,
			DenyNone = 64,
			DenyRead = 48,
			DenyWrite = 32,
			DenyRdWr = 16,
			NoInherit = 128,
		};
		enum PermissionTypes {
			PermRead = 256,
			PermWrite = 128,
			PermRdWr = 384,
		};
		enum seek_dir {
			beg = 0,
			cur = 1,
			end = 2,
		};
public:
	void PFile(char *);
	void PFile(const class PFile&);
	void PFile(int32_t);
	void PFile();
	// vtable: 0
	intro void ~PFile();
	int32_t Open(char *, unsigned short, unsigned short, int32_t);
	int32_t Close();
	int32_t GetHandle();
	long Position();
	void Length(long);
	long Length();
	long Seek(long, int32_t);
	long SeekToBegin();
	long SeekToEnd();
	int32_t IsOpen();
	int32_t Read(void * __ptr32, int32_t);
	int32_t Write(void * __ptr32, int32_t);
	void Flush();
	// calltype: NearC
	static void Remove(char *);
	// calltype: NearC
	static void Rename(char *, char *);
	// calltype: NearC
	static unsigned long Checksum(char *);
	long SetPath(char *);
	long FileCreate(char *, int32_t);
	long FileExists(char *);
	char szFilePath[260];
	int32_t Handle;
private:
	int32_t ShouldClose;
};

// Type: char *;

// Type: unsigned short;

// Type: int32_t;

// Type: uint32_t;

// Type: long;

// Type: struct _OFSTRUCT;
class _OFSTRUCT{
public:
	unsigned char cBytes;
	unsigned char fFixedDisk;
	unsigned short nErrCode;
	unsigned short Reserved1;
	unsigned short Reserved2;
	char szPathName[128];
};

// Type: unsigned char;

// Type: class PFile;
class PFile{
		enum __unnamed {
			FileNull = -1,
		};
		enum SeekTypes {
			N_SEEK_FROM_FILE_START = 0,
			N_SEEK_FROM_FILE_CURRENT = 1,
			N_SEEK_FROM_FILE_END = 2,
		};
		enum AccessTypes {
			ReadOnly = 0,
			ReadWrite = 2,
			WriteOnly = 1,
			Create = 768,
			CreateExcl = 1280,
			Append = 8,
			Binary = 32768,
			Compat = 0,
			DenyNone = 64,
			DenyRead = 48,
			DenyWrite = 32,
			DenyRdWr = 16,
			NoInherit = 128,
		};
		enum PermissionTypes {
			PermRead = 256,
			PermWrite = 128,
			PermRdWr = 384,
		};
		enum seek_dir {
			beg = 0,
			cur = 1,
			end = 2,
		};
public:
	void PFile(char *);
	void PFile(const class PFile&);
	void PFile(int32_t);
	void PFile();
	// vtable: 0
	intro void ~PFile();
	int32_t Open(char *, unsigned short, unsigned short, int32_t);
	int32_t Close();
	int32_t GetHandle();
	long Position();
	void Length(long);
	long Length();
	long Seek(long, int32_t);
	long SeekToBegin();
	long SeekToEnd();
	int32_t IsOpen();
	int32_t Read(void * __ptr32, int32_t);
	int32_t Write(void * __ptr32, int32_t);
	void Flush();
	// calltype: NearC
	static void Remove(char *);
	// calltype: NearC
	static void Rename(char *, char *);
	// calltype: NearC
	static unsigned long Checksum(char *);
	long SetPath(char *);
	long FileCreate(char *, int32_t);
	long FileExists(char *);
	char szFilePath[260];
	int32_t Handle;
private:
	int32_t ShouldClose;
};

// Type: unsigned char *;

// Type: unsigned long;



// Contribution: 1:0009f3a0-0009f9f6 Module: 10, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004a03a0
int32_t PFile::Open(char * name, unsigned short access, unsigned short __formal, int32_t bCreateIfNotFound) {
	const uint32_t shareFlags;

// LINE 34:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x10;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 37:
	__asm        mov    shareFlags, 0xF0;
// LINE 39:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A03C8;
	__asm        jmp    near ptr 0x004A03CD;
	__asm        jmp    near ptr 0x004A03E6;
	__asm        jmp    near ptr 0x004A03DC;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     near ptr 0x004A03E6;
// LINE 40:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x004A04E9;
// LINE 43:
	__asm        cmp    name, 0;
	__asm        je     near ptr 0x004A041D;
// LINE 44:
	__asm        mov    eax, name;
	__asm        movsx  eax, byte ptr [eax];
	__asm        test   eax, eax;
	__asm        je     near ptr 0x004A0416;
// LINE 45:
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   0x0056CEB0;
	__asm        add    esp, 8;
// LINE 46:
	__asm        jmp    near ptr 0x004A041D;
// LINE 47:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A04E9;
// LINE 49:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        jne    near ptr 0x004A0433;
// LINE 50:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A04E9;
// LINE 53:
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x004A06E6;
	__asm        test   eax, eax;
	__asm        jne    near ptr 0x004A047D;
// LINE 54:
	__asm        cmp    bCreateIfNotFound, 0;
	__asm        je     near ptr 0x004A0471;
// LINE 55:
	__asm        mov    eax, reinterpret_cast<uint32_t>(access);
	__asm        and    eax, 0xFFFF;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x004A05F3;
// LINE 56:
	__asm        jmp    near ptr 0x004A0478;
// LINE 57:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A04E9;
// LINE 59:
	__asm        jmp    near ptr 0x004A04C0;
// LINE 60:
	__asm        test   reinterpret_cast<uint8_t>(access), 0xF0;
	__asm        jne    near ptr 0x004A0496;
// LINE 61:
	__asm        mov    eax, reinterpret_cast<uint32_t>(access);
	__asm        and    eax, 0xFFFF;
	__asm        or     eax, 0x40;
	__asm        mov    access, ax;
// LINE 64:
	__asm        mov    eax, reinterpret_cast<uint32_t>(access);
	__asm        and    eax, 0xF0;
	__asm        push   eax;
	__asm        mov    eax, reinterpret_cast<uint32_t>(access);
	__asm        and    eax, 0xFE0F;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   0x00586690;
	__asm        add    esp, 0xC;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x108], eax;
// LINE 66:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A04DA;
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x004A04DC;
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A04E4;
	__asm        mov    eax, [ebp-0xC];
	__asm        jmp    near ptr 0x004A04E9;
// LINE 67:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    0x10;
}

// FUNCTION: COPTER_D 0x004a04f0
int32_t PFile::Close() {
// LINE 75:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 8;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 76:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A0511;
	__asm        jmp    near ptr 0x004A0516;
	__asm        jmp    near ptr 0x004A0556;
	__asm        jmp    near ptr 0x004A0525;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     near ptr 0x004A0556;
// LINE 77:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x00578E50;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        jne    near ptr 0x004A0556;
// LINE 78:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x108], 0xFFFFFFFF;
// LINE 79:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x004A055D;
// LINE 82:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A055D;
// LINE 83:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x004a0562
long PFile::Length() {
	long lFileLength;

// LINE 91:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0xC;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 94:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A0588;
	__asm        jmp    near ptr 0x004A05D7;
	__asm        jmp    near ptr 0x004A0588;
	__asm        jmp    near ptr 0x004A0597;
	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    near ptr 0x004A05D7;
// LINE 95:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   0x004A03A0;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x004A05D7;
// LINE 96:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x0058E450;
	__asm        add    esp, 4;
	__asm        mov    lFileLength, eax;
// LINE 97:
	__asm        mov    ecx, this;
	__asm        call   0x004A04F0;
// LINE 98:
	__asm        mov    eax, lFileLength;
	__asm        jmp    near ptr 0x004A05EE;
// LINE 101:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   0x0058E450;
	__asm        add    esp, 4;
	__asm        jmp    near ptr 0x004A05EE;
// LINE 102:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x004a05f3
long PFile::FileCreate(char * name, int32_t nAccessMode) {
// LINE 112:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0xC;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 113:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A0614;
	__asm        jmp    near ptr 0x004A0619;
	__asm        jmp    near ptr 0x004A062F;
	__asm        jmp    near ptr 0x004A0628;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     near ptr 0x004A062F;
// LINE 114:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A06DF;
// LINE 117:
	__asm        cmp    name, 0;
	__asm        je     near ptr 0x004A0666;
// LINE 118:
	__asm        mov    eax, name;
	__asm        movsx  eax, byte ptr [eax];
	__asm        test   eax, eax;
	__asm        je     near ptr 0x004A065F;
// LINE 119:
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   0x0056CEB0;
	__asm        add    esp, 8;
// LINE 120:
	__asm        jmp    near ptr 0x004A0666;
// LINE 121:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A06DF;
// LINE 123:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+4];
	__asm        test   eax, eax;
	__asm        jne    near ptr 0x004A067C;
// LINE 124:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A06DF;
// LINE 125:
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x004A06E6;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x004A069A;
// LINE 126:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A06DF;
// LINE 127:
	__asm        mov    eax, nAccessMode;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   0x0058E540;
	__asm        add    esp, 8;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x108], eax;
// LINE 129:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A06D0;
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x004A06D2;
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A06DA;
	__asm        mov    eax, [ebp-8];
	__asm        jmp    near ptr 0x004A06DF;
// LINE 130:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    8;
}

// FUNCTION: COPTER_D 0x004a06e6
long PFile::FileExists(char * name) {
	char * szFilePathToUse;
	struct _OFSTRUCT ofStruct;

// LINE 139:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x90;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 142:
	__asm        cmp    name, 0;
	__asm        je     near ptr 0x004A0710;
// LINE 143:
	__asm        mov    eax, name;
	__asm        mov    szFilePathToUse, eax;
// LINE 144:
	__asm        jmp    near ptr 0x004A071F;
// LINE 145:
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        mov    szFilePathToUse, eax;
// LINE 148:
	__asm        push   0x4000;
	__asm        lea    eax, ofStruct.cBytes;
	__asm        push   eax;
	__asm        mov    eax, szFilePathToUse;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3638];
	__asm        cmp    eax, 0xFFFFFFFF;
	__asm        je     near ptr 0x004A074B;
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x004A074D;
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A0752;
// LINE 152:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}

// FUNCTION: COPTER_D 0x004a0759
long PFile::SetPath(char * szPath) {
// LINE 160:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 8;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 162:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A077A;
	__asm        jmp    near ptr 0x004A077F;
	__asm        jmp    near ptr 0x004A0795;
	__asm        jmp    near ptr 0x004A078E;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     near ptr 0x004A0795;
// LINE 163:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x004A07B2;
// LINE 164:
	__asm        mov    eax, szPath;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 4;
	__asm        push   eax;
	__asm        call   0x0056CEB0;
	__asm        add    esp, 8;
// LINE 165:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x004A07B2;
// LINE 166:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}

// FUNCTION: COPTER_D 0x004a07b9
unsigned long PFile::Checksum(char * name) {
	unsigned char chValue;
	long lIndex;
	class PFile tempPFile;
	const long lBlockSize;
	long lCurrentValue;
	long lFileLength;
	unsigned char * chBuffer;
	long lCurrentBlockStartPosition;
	long lUsedBlockSize;

// LINE 172:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x140;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
// LINE 174:
	__asm        mov    lCurrentValue, 0;
// LINE 180:
	__asm        mov    lBlockSize, 0x7D00;
// LINE 182:
	__asm        mov    tempPFile.Handle, 0xFFFFFFFF;
	__asm        mov    tempPFile.ShouldClose, 1;
	__asm        mov    tempPFile.<vftable>, 0x590468;
	__asm        mov    dword ptr ds:[0x5C0920], 0x8000;
	__asm        cmp    name, 0;
	__asm        je     near ptr 0x004A0817;
	__asm        mov    eax, name;
	__asm        push   eax;
	__asm        lea    eax, tempPFile.szFilePath[0];
	__asm        push   eax;
	__asm        call   0x0056CEB0;
	__asm        add    esp, 8;
	__asm        jmp    near ptr 0x004A081E;
	__asm        mov    tempPFile.szFilePath[0], 0;
	__asm        jmp    near ptr 0x004A0823;
// LINE 183:
	__asm        push   0;
	__asm        push   0x100;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    ecx, tempPFile.<vftable>;
	__asm        call   0x004A03A0;
	__asm        test   eax, eax;
	__asm        je     near ptr 0x004A0993;
// LINE 184:
	__asm        lea    ecx, tempPFile.<vftable>;
	__asm        call   0x004A0562;
	__asm        mov    lFileLength, eax;
// LINE 186:
	__asm        push   0x7D00;
	__asm        call   0x0056A600;
	__asm        add    esp, 4;
	__asm        mov    chBuffer, eax;
// LINE 187:
	__asm        cmp    chBuffer, 0;
	__asm        je     near ptr 0x004A0934;
// LINE 189:
	__asm        mov    lCurrentValue, 0;
// LINE 191:
	__asm        mov    lCurrentBlockStartPosition, 0;
// LINE 193:
	__asm        jmp    near ptr 0x004A0883;
	__asm        add    lCurrentBlockStartPosition, 0x7D00;
	__asm        mov    eax, lFileLength;
	__asm        cmp    lCurrentBlockStartPosition, eax;
	__asm        jge    near ptr 0x004A090B;
// LINE 195:
	__asm        mov    lUsedBlockSize, 0x7D00;
// LINE 196:
	__asm        mov    eax, lCurrentBlockStartPosition;
	__asm        add    eax, 0x7D00;
	__asm        cmp    eax, lFileLength;
	__asm        jle    near ptr 0x004A08B0;
// LINE 197:
	__asm        mov    eax, lFileLength;
	__asm        sub    eax, lCurrentBlockStartPosition;
	__asm        mov    lUsedBlockSize, eax;
// LINE 198:
	__asm        jmp    near ptr 0x004A08B5;
	__asm        mov    eax, lUsedBlockSize;
	__asm        push   eax;
	__asm        mov    eax, chBuffer;
	__asm        push   eax;
	__asm        mov    eax, tempPFile.Handle;
	__asm        push   eax;
	__asm        call   0x00580B50;
	__asm        add    esp, 0xC;
	__asm        mov    lUsedBlockSize, eax;
// LINE 199:
	__asm        mov    lIndex, 0;
	__asm        jmp    near ptr 0x004A08E1;
	__asm        inc    lIndex;
	__asm        mov    eax, lIndex;
	__asm        cmp    lUsedBlockSize, eax;
	__asm        jle    near ptr 0x004A0906;
// LINE 200:
	__asm        mov    eax, chBuffer;
	__asm        mov    ecx, lIndex;
	__asm        xor    edx, edx;
	__asm        mov    dl, [eax+ecx];
	__asm        add    lCurrentValue, edx;
	__asm        jmp    near ptr 0x004A08DB;
// LINE 201:
	__asm        jmp    near ptr 0x004A087C;
// LINE 202:
	__asm        mov    eax, chBuffer;
	__asm        mov    [ebp-0x134], eax;
	__asm        mov    eax, [ebp-0x134];
	__asm        mov    [ebp-0x13C], eax;
	__asm        mov    eax, [ebp-0x13C];
	__asm        push   eax;
	__asm        call   0x0056A740;
	__asm        add    esp, 4;
// LINE 204:
	__asm        jmp    near ptr 0x004A0988;
// LINE 206:
	__asm        mov    lCurrentValue, 0;
	__asm        mov    eax, lCurrentValue;
	__asm        mov    lIndex, eax;
	__asm        jmp    near ptr 0x004A094F;
	__asm        inc    lIndex;
	__asm        mov    eax, lIndex;
	__asm        cmp    lFileLength, eax;
	__asm        jle    near ptr 0x004A0988;
// LINE 207:
	__asm        push   1;
	__asm        lea    eax, chValue;
	__asm        push   eax;
	__asm        mov    eax, tempPFile.Handle;
	__asm        push   eax;
	__asm        call   0x00580B50;
	__asm        add    esp, 0xC;
	__asm        jmp    near ptr 0x004A0978;
// LINE 208:
	__asm        xor    eax, eax;
	__asm        mov    al, chValue;
	__asm        add    lCurrentValue, eax;
// LINE 209:
	__asm        jmp    near ptr 0x004A0949;
// LINE 211:
	__asm        lea    ecx, tempPFile.<vftable>;
	__asm        call   0x004A04F0;
// LINE 213:
	__asm        mov    eax, lCurrentValue;
	__asm        mov    [ebp-0x138], eax;
	__asm        mov    tempPFile.<vftable>, 0x590468;
	__asm        cmp    tempPFile.Handle, 0xFFFFFFFF;
	__asm        jle    near ptr 0x004A09B5;
	__asm        jmp    near ptr 0x004A09BA;
	__asm        jmp    near ptr 0x004A09E2;
	__asm        jmp    near ptr 0x004A09CC;
	__asm        cmp    dword ptr [ebp-0x140], 0;
	__asm        je     near ptr 0x004A09E2;
	__asm        cmp    tempPFile.ShouldClose, 0;
	__asm        je     near ptr 0x004A09E2;
	__asm        mov    eax, tempPFile.Handle;
	__asm        push   eax;
	__asm        call   0x00578E50;
	__asm        add    esp, 4;
	__asm        jmp    near ptr 0x004A09E7;
	__asm        mov    eax, [ebp-0x138];
	__asm        jmp    near ptr 0x004A09F2;
// LINE 214:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

