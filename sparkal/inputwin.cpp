// Module: Inputwin.obj
// Source: C:\Copter\source\sparkal\Inputwin.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ struct list<Shortcut>::list_node_buffer (forward reference);
struct list<Shortcut>::list_node_buffer{ // packed(0x8 bytes) TI: 0x1b8c
	/*+0x0*/   void * __ptr32 next_buffer;
	/*+0x4*/   /*packed*/ struct list<Shortcut>::list_node *buffer;
};

// Type: /*packed*/ struct list<Shortcut>::list_node (forward reference);
struct list<Shortcut>::list_node{ // packed(0x20 bytes) TI: 0x1b8e
	/*+0x0*/   void * __ptr32 next;
	/*+0x4*/   void * __ptr32 prev;
	/*+0x8*/   /*packed*/ struct Shortcut data; // 0x18 bytes
};

// Type: uint32_t;

// Type: /*packed*/ struct list<HotSpot>::list_node_buffer (forward reference);
struct list<HotSpot>::list_node_buffer{ // packed(0x8 bytes) TI: 0x1242
	/*+0x0*/   void * __ptr32 next_buffer;
	/*+0x4*/   /*packed*/ struct list<HotSpot>::list_node *buffer;
};

// Type: /*packed*/ struct list<HotSpot>::list_node (forward reference);
struct list<HotSpot>::list_node{ // packed(0x1c bytes) TI: 0x1244
	/*+0x0*/   void * __ptr32 next;
	/*+0x4*/   void * __ptr32 prev;
	/*+0x8*/   /*packed*/ class HotSpot data; // 0x14 bytes
};

// Type: char *;

// Type: /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer (forward reference);
struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer{ // packed(0x8 bytes) TI: 0x2cb2
	/*+0x0*/   void * __ptr32 next_buffer;
	/*+0x4*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *buffer;
};

// Type: /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node (forward reference);
struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node{ // packed(0x14 bytes) TI: 0x2cb4
	/*+0x0*/   enum rb_tree<long,long,ident<long,long>,less<long>>::color_type color_field;
	/*+0x4*/   void * __ptr32 parent_link;
	/*+0x8*/   void * __ptr32 left_link;
	/*+0xc*/   void * __ptr32 right_link;
	/*+0x10*/  long value_field;
};

// Type: /*packed*/ struct SparkalColor;
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: void ();

// Type: /*packed*/ struct list<StringIDAssociation>::list_node_buffer (forward reference);
struct list<StringIDAssociation>::list_node_buffer{ // packed(0x8 bytes) TI: 0x2958
	/*+0x0*/   void * __ptr32 next_buffer;
	/*+0x4*/   /*packed*/ struct list<StringIDAssociation>::list_node *buffer;
};

// Type: /*packed*/ struct list<StringIDAssociation>::list_node (forward reference);
struct list<StringIDAssociation>::list_node{ // packed(0x14 bytes) TI: 0x295a
	/*+0x0*/   void * __ptr32 next;
	/*+0x4*/   void * __ptr32 prev;
	/*+0x8*/   /*packed*/ struct StringIDAssociation data; // 0xc bytes
};

// Type: /*packed*/ struct list<KeyColors>::list_node_buffer (forward reference);
struct list<KeyColors>::list_node_buffer{ // packed(0x8 bytes) TI: 0x29dc
	/*+0x0*/   void * __ptr32 next_buffer;
	/*+0x4*/   /*packed*/ struct list<KeyColors>::list_node *buffer;
};

// Type: /*packed*/ struct list<KeyColors>::list_node (forward reference);
struct list<KeyColors>::list_node{ // packed(0x10 bytes) TI: 0x29de
	/*+0x0*/   void * __ptr32 next;
	/*+0x4*/   void * __ptr32 prev;
	/*+0x8*/   /*packed*/ struct KeyColors data; // 0x8 bytes
};

// Type: void;

// Type: /*packed*/ class KeyboardWindow (forward reference);
// VTABLE: COPTER_D 0x0058f058
class KeyboardWindow : public GraphicWindow
{ // packed(0xb0 bytes) TI: 0x2c31
public:
	void KeyboardWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual void ~KeyboardWindow() /* override */;
	virtual int32_t Initialize() /* override */;
	virtual int32_t CreateImage(int32_t) /* override */;
	virtual void DestroyImage() /* override */;
	virtual int32_t ComposeSelf() /* override */;
	virtual int32_t DoesWindowNeedUpdating() /* override */;
	virtual int32_t DoesKeyExistOnKeyboard(long); // vtable+0xc4
	virtual long DoKeyDown(long, char) /* override */;
	virtual long DoKeyUp(long, char) /* override */;
	virtual long DoCursorDown(long, long, unsigned long) /* override */;
	virtual long DoCursorUp(long, long, unsigned long) /* override */;
	virtual long DoCursorMove(long, long) /* override */;
	/*+0x74*/  /*packed*/ class list<HotSpot> myHotSpotList; // 0x8 bytes
	/*+0x7c*/  /*packed*/ class list<HotSpot> myNumLockOnHotSpotList; // 0x8 bytes
	/*+0x84*/  /*packed*/ class list<HotSpot> myNumLockOffHotSpotList; // 0x8 bytes
	/*+0x8c*/  /*packed*/ class list<HotSpot> *myCurrentlyUsedNumLockHotSpotList;
	/*+0x90*/  /*packed*/ class list<KeyColors> myKeyColorsList; // 0x8 bytes
protected:
	virtual void DrawKeyColorsOnKeyboard(); // vtable+0xc8
	virtual void DrawCharactersOnKeyboard(); // vtable+0xcc
	virtual void DrawLightsOnKeyboard(); // vtable+0xd0
	virtual int32_t DoesKeyRequireTextDraw(long); // vtable+0xd4
	virtual int32_t DoesPositionHitKey(long, long, long&); // vtable+0xd8
	virtual int32_t ConvertKeyToString(int32_t, long, /*packed*/ class basic_string<char>&); // vtable+0xdc
	virtual int32_t GetRectOfNonTextImage(long, /*packed*/ class MRect&); // vtable+0xe0
	/*+0x98*/  /*unpacked*/ class CBackBuffer *myKeyLightImage;
	/*+0x9c*/  /*unpacked*/ class CBackBuffer *myNonTextKeyImage;
	/*+0xa0*/  /*packed*/ class MFont *mFontToUse;
	/*+0xa4*/  int32_t bNumLockLastSetting;
	/*+0xa8*/  int32_t bCapsLockLastSetting;
	/*+0xac*/  int32_t bScrollLockLastSetting;
};

// Type: /*packed*/ class MRect (forward reference);
class MRect : public SparkalRect
{ // packed(0x10 bytes) TI: 0x1067
public:
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalSize);
	void MRect(/*packed*/ struct SparkalRect*);
	void MRect(/*packed*/ class MRect*);
	void MRect(const /*packed*/ struct SparkalRect&);
	void MRect(long, long, long, long);
	void MRect();
	long Width();
	long Height();
	/*packed*/ class MSize Size();
	const /*packed*/ class MPoint& TopLeft();
	/*packed*/ class MPoint& TopLeft();
	const /*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint CenterPoint();
	/*packed*/ struct SparkalRect* operator struct SparkalRect *();
	/*packed*/ class MRect* operator class MRect *();
	int32_t IsRectEmpty();
	int32_t IsRectNull();
	int32_t PtInRect(/*packed*/ struct SparkalPoint);
	int32_t PtInRect(long, long);
	int32_t DoesRectOverlap(/*packed*/ struct SparkalRect*);
	void SetRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void SetRect(long, long, long, long);
	void SetRectEmpty();
	void CopyRect(/*packed*/ class MRect*);
	int32_t EqualRect(/*packed*/ class MRect*);
	void InflateRect(long, long, long, long);
	void InflateRect(/*packed*/ class MRect*);
	void InflateRect(/*packed*/ struct SparkalSize);
	void InflateRect(long, long);
	void DeflateRect(long, long, long, long);
	void DeflateRect(/*packed*/ class MRect*);
	void DeflateRect(/*packed*/ struct SparkalSize);
	void DeflateRect(long, long);
	void MoveRect(/*packed*/ struct SparkalPoint);
	void MoveRect(long, long);
	void OffsetRect(/*packed*/ struct SparkalPoint);
	void OffsetRect(/*packed*/ struct SparkalSize);
	void OffsetRect(long, long);
	void NormalizeRect();
	int32_t IntersectRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t UnionRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t SubtractRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t operator==(const /*packed*/ struct SparkalRect&);
	int32_t operator!=(const /*packed*/ struct SparkalRect&);
	void operator+=(/*packed*/ class MRect*);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ class MRect*);
	void operator-=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator&=(const /*packed*/ struct SparkalRect&);
	void operator|=(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(/*packed*/ class MRect*);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator-(/*packed*/ class MRect*);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator&(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator|(const /*packed*/ struct SparkalRect&);
};

// Type: int32_t;

// Type: /*unpacked*/ class GraphicWindow (forward reference);
// GraphicWindow Class implementation not found

// Type: /*packed*/ class GraphicWindowOwner (forward reference);
// VTABLE: COPTER_D 0x00590f2c
class GraphicWindowOwner{ // packed(0x4 bytes) TI: 0x1647
public:
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32); // vtable+0x0
};

// Type: /*packed*/ class basic_string<char>;
class basic_string<char>{ // packed(0x8 bytes) TI: 0x1380
	using reference_class = /*unpacked*/ class basic_string_ref<char>;
	using reference_pointer = /*unpacked*/ class basic_string_ref<char>*;
private:
	/*+0x0*/   char * c_str_ptr;
	/*+0x4*/   /*unpacked*/ class basic_string_ref<char> *reference;
	char * point();
	uint32_t& len();
	uint32_t ref_count();
	// calltype: NearC
	static char eos();
	void assign_str(char *, uint32_t);
	void append_str(char *, uint32_t);
	void insert_str(uint32_t, char *, uint32_t);
	void replace_str(uint32_t, uint32_t, char *, uint32_t);
	int32_t compare_str(uint32_t, char *, uint32_t, uint32_t);
	uint32_t find_str(char *, uint32_t, uint32_t);
	uint32_t rfind_str(char *, uint32_t, uint32_t);
	uint32_t find_first_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_of_str(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of_str(char *, uint32_t, uint32_t);
public:
	void basic_string<char>(const /*packed*/ class vector<char>&);
	void basic_string<char>(char, uint32_t);
	void basic_string<char>(char *);
	void basic_string<char>(char *, uint32_t);
	void basic_string<char>(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	void basic_string<char>(uint32_t, enum capacity);
	void basic_string<char>();
protected:
	void basic_string<char>(char *, uint32_t, uint32_t);
	void delete_ref();
	using char_type = char;
	using baggage_type = /*packed*/ struct string_char_baggage<char>;
public:
	void ~basic_string<char>();
	/*packed*/ class basic_string<char>& operator=(char);
	/*packed*/ class basic_string<char>& operator=(char *);
	/*packed*/ class basic_string<char>& operator=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class basic_string<char>& operator+=(char);
	/*packed*/ class basic_string<char>& operator+=(char *);
	/*packed*/ class basic_string<char>& operator+=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class vector<char> operator class vector<char>();
	/*packed*/ class basic_string<char>& append(char, uint32_t);
	/*packed*/ class basic_string<char>& append(char *);
	/*packed*/ class basic_string<char>& append(char *, uint32_t);
	/*packed*/ class basic_string<char>& append(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& assign(char, uint32_t);
	/*packed*/ class basic_string<char>& assign(char *);
	/*packed*/ class basic_string<char>& assign(char *, uint32_t);
	/*packed*/ class basic_string<char>& assign(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& remove(uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	char get_at(uint32_t);
	void put_at(uint32_t, char);
	char& operator[](uint32_t);
	char operator[](uint32_t);
	char * c_str();
	char * data();
	uint32_t length();
	void resize(uint32_t);
	void resize(uint32_t, char);
	void reserve(uint32_t);
	uint32_t reserve();
	uint32_t copy(char *, uint32_t, uint32_t);
	uint32_t find(char, uint32_t);
	uint32_t find(char *, uint32_t);
	uint32_t find(char *, uint32_t, uint32_t);
	uint32_t find(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t rfind(char, uint32_t);
	uint32_t rfind(char *, uint32_t);
	uint32_t rfind(char *, uint32_t, uint32_t);
	uint32_t rfind(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_of(char, uint32_t);
	uint32_t find_first_of(char *, uint32_t);
	uint32_t find_first_of(char *, uint32_t, uint32_t);
	uint32_t find_first_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_of(char, uint32_t);
	uint32_t find_last_of(char *, uint32_t);
	uint32_t find_last_of(char *, uint32_t, uint32_t);
	uint32_t find_last_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_not_of(char, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_not_of(char, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	/*packed*/ class basic_string<char> substr(uint32_t, uint32_t);
	int32_t compare(char, uint32_t, uint32_t);
	int32_t compare(char *, uint32_t);
	int32_t compare(char *, uint32_t, uint32_t);
	int32_t compare(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
};

// Type: long;

// Type: /*packed*/ class basic_string<char> (forward reference);
class basic_string<char>{ // packed(0x8 bytes) TI: 0x1380
	using reference_class = /*unpacked*/ class basic_string_ref<char>;
	using reference_pointer = /*unpacked*/ class basic_string_ref<char>*;
private:
	/*+0x0*/   char * c_str_ptr;
	/*+0x4*/   /*unpacked*/ class basic_string_ref<char> *reference;
	char * point();
	uint32_t& len();
	uint32_t ref_count();
	// calltype: NearC
	static char eos();
	void assign_str(char *, uint32_t);
	void append_str(char *, uint32_t);
	void insert_str(uint32_t, char *, uint32_t);
	void replace_str(uint32_t, uint32_t, char *, uint32_t);
	int32_t compare_str(uint32_t, char *, uint32_t, uint32_t);
	uint32_t find_str(char *, uint32_t, uint32_t);
	uint32_t rfind_str(char *, uint32_t, uint32_t);
	uint32_t find_first_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_of_str(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of_str(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of_str(char *, uint32_t, uint32_t);
public:
	void basic_string<char>(const /*packed*/ class vector<char>&);
	void basic_string<char>(char, uint32_t);
	void basic_string<char>(char *);
	void basic_string<char>(char *, uint32_t);
	void basic_string<char>(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	void basic_string<char>(uint32_t, enum capacity);
	void basic_string<char>();
protected:
	void basic_string<char>(char *, uint32_t, uint32_t);
	void delete_ref();
	using char_type = char;
	using baggage_type = /*packed*/ struct string_char_baggage<char>;
public:
	void ~basic_string<char>();
	/*packed*/ class basic_string<char>& operator=(char);
	/*packed*/ class basic_string<char>& operator=(char *);
	/*packed*/ class basic_string<char>& operator=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class basic_string<char>& operator+=(char);
	/*packed*/ class basic_string<char>& operator+=(char *);
	/*packed*/ class basic_string<char>& operator+=(const /*packed*/ class basic_string<char>&);
	/*packed*/ class vector<char> operator class vector<char>();
	/*packed*/ class basic_string<char>& append(char, uint32_t);
	/*packed*/ class basic_string<char>& append(char *);
	/*packed*/ class basic_string<char>& append(char *, uint32_t);
	/*packed*/ class basic_string<char>& append(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& assign(char, uint32_t);
	/*packed*/ class basic_string<char>& assign(char *);
	/*packed*/ class basic_string<char>& assign(char *, uint32_t);
	/*packed*/ class basic_string<char>& assign(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *);
	/*packed*/ class basic_string<char>& insert(uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& insert(uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& remove(uint32_t, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, char *, uint32_t);
	/*packed*/ class basic_string<char>& replace(uint32_t, uint32_t, const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
	char get_at(uint32_t);
	void put_at(uint32_t, char);
	char& operator[](uint32_t);
	char operator[](uint32_t);
	char * c_str();
	char * data();
	uint32_t length();
	void resize(uint32_t);
	void resize(uint32_t, char);
	void reserve(uint32_t);
	uint32_t reserve();
	uint32_t copy(char *, uint32_t, uint32_t);
	uint32_t find(char, uint32_t);
	uint32_t find(char *, uint32_t);
	uint32_t find(char *, uint32_t, uint32_t);
	uint32_t find(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t rfind(char, uint32_t);
	uint32_t rfind(char *, uint32_t);
	uint32_t rfind(char *, uint32_t, uint32_t);
	uint32_t rfind(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_of(char, uint32_t);
	uint32_t find_first_of(char *, uint32_t);
	uint32_t find_first_of(char *, uint32_t, uint32_t);
	uint32_t find_first_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_of(char, uint32_t);
	uint32_t find_last_of(char *, uint32_t);
	uint32_t find_last_of(char *, uint32_t, uint32_t);
	uint32_t find_last_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_first_not_of(char, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t);
	uint32_t find_first_not_of(char *, uint32_t, uint32_t);
	uint32_t find_first_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	uint32_t find_last_not_of(char, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t);
	uint32_t find_last_not_of(char *, uint32_t, uint32_t);
	uint32_t find_last_not_of(const /*packed*/ class basic_string<char>&, uint32_t);
	/*packed*/ class basic_string<char> substr(uint32_t, uint32_t);
	int32_t compare(char, uint32_t, uint32_t);
	int32_t compare(char *, uint32_t);
	int32_t compare(char *, uint32_t, uint32_t);
	int32_t compare(const /*packed*/ class basic_string<char>&, uint32_t, uint32_t);
};

// Type: /*packed*/ class list<HotSpot>::iterator;
class list<HotSpot>::iterator : public bidirectional_iterator<HotSpot,int>
{ // packed(0x4 bytes) TI: 0x1240
protected:
	/*+0x0*/   /*packed*/ struct list<HotSpot>::list_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct list<HotSpot>::list_node*);
public:
	int32_t operator==(const /*packed*/ class list<HotSpot>::iterator&);
	/*packed*/ class HotSpot& operator*();
	/*packed*/ class list<HotSpot>::iterator operator++(int32_t);
	/*packed*/ class list<HotSpot>::iterator& operator++();
	/*packed*/ class list<HotSpot>::iterator operator--(int32_t);
	/*packed*/ class list<HotSpot>::iterator& operator--();
};

// Type: /*packed*/ class list<KeyColors>::iterator;
class list<KeyColors>::iterator : public bidirectional_iterator<KeyColors,int>
{ // packed(0x4 bytes) TI: 0x29da
protected:
	/*+0x0*/   /*packed*/ struct list<KeyColors>::list_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct list<KeyColors>::list_node*);
public:
	int32_t operator==(const /*packed*/ class list<KeyColors>::iterator&);
	/*packed*/ struct KeyColors& operator*();
	/*packed*/ class list<KeyColors>::iterator operator++(int32_t);
	/*packed*/ class list<KeyColors>::iterator& operator++();
	/*packed*/ class list<KeyColors>::iterator operator--(int32_t);
	/*packed*/ class list<KeyColors>::iterator& operator--();
};

// Type: /*packed*/ class MRect;
class MRect : public SparkalRect
{ // packed(0x10 bytes) TI: 0x1067
public:
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void MRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalSize);
	void MRect(/*packed*/ struct SparkalRect*);
	void MRect(/*packed*/ class MRect*);
	void MRect(const /*packed*/ struct SparkalRect&);
	void MRect(long, long, long, long);
	void MRect();
	long Width();
	long Height();
	/*packed*/ class MSize Size();
	const /*packed*/ class MPoint& TopLeft();
	/*packed*/ class MPoint& TopLeft();
	const /*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint& BottomRight();
	/*packed*/ class MPoint CenterPoint();
	/*packed*/ struct SparkalRect* operator struct SparkalRect *();
	/*packed*/ class MRect* operator class MRect *();
	int32_t IsRectEmpty();
	int32_t IsRectNull();
	int32_t PtInRect(/*packed*/ struct SparkalPoint);
	int32_t PtInRect(long, long);
	int32_t DoesRectOverlap(/*packed*/ struct SparkalRect*);
	void SetRect(/*packed*/ struct SparkalPoint, /*packed*/ struct SparkalPoint);
	void SetRect(long, long, long, long);
	void SetRectEmpty();
	void CopyRect(/*packed*/ class MRect*);
	int32_t EqualRect(/*packed*/ class MRect*);
	void InflateRect(long, long, long, long);
	void InflateRect(/*packed*/ class MRect*);
	void InflateRect(/*packed*/ struct SparkalSize);
	void InflateRect(long, long);
	void DeflateRect(long, long, long, long);
	void DeflateRect(/*packed*/ class MRect*);
	void DeflateRect(/*packed*/ struct SparkalSize);
	void DeflateRect(long, long);
	void MoveRect(/*packed*/ struct SparkalPoint);
	void MoveRect(long, long);
	void OffsetRect(/*packed*/ struct SparkalPoint);
	void OffsetRect(/*packed*/ struct SparkalSize);
	void OffsetRect(long, long);
	void NormalizeRect();
	int32_t IntersectRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t UnionRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t SubtractRect(/*packed*/ class MRect*, /*packed*/ class MRect*);
	int32_t operator==(const /*packed*/ struct SparkalRect&);
	int32_t operator!=(const /*packed*/ struct SparkalRect&);
	void operator+=(/*packed*/ class MRect*);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ class MRect*);
	void operator-=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator&=(const /*packed*/ struct SparkalRect&);
	void operator|=(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(/*packed*/ class MRect*);
	/*packed*/ class MRect operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator-(/*packed*/ class MRect*);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MRect operator&(const /*packed*/ struct SparkalRect&);
	/*packed*/ class MRect operator|(const /*packed*/ struct SparkalRect&);
};

// Type: char;

// Type: unsigned long;

// Type: /*packed*/ struct KeyboardWindowMessage;
struct KeyboardWindowMessage{ // packed(0x8 bytes) TI: 0x2bde
	/*+0x0*/   long lKey;
	/*+0x4*/   long lCursorButton;
};

// Type: /*packed*/ class JoystickWindow (forward reference);
// VTABLE: COPTER_D 0x0058f140
class JoystickWindow : public GraphicWindow
{ // packed(0x1de bytes) TI: 0x2c3f
public:
	void JoystickWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual void ~JoystickWindow() /* override */;
	virtual int32_t Initialize() /* override */;
	virtual int32_t CreateImage(int32_t) /* override */;
	virtual void DestroyImage() /* override */;
	virtual int32_t ComposeSelf() /* override */;
	virtual int32_t DoesWindowNeedUpdating() /* override */;
	virtual long DoCursorDown(long, long, unsigned long) /* override */;
	virtual long DoCursorUp(long, long, unsigned long) /* override */;
	virtual long DoCursorMove(long, long) /* override */;
	virtual void SetCurrentJoystick(int32_t); // vtable+0xc4
	/*+0x74*/  int32_t nCurrentJoystick;
	/*+0x78*/  long lJoystickControlStates[14]; // 0x38 bytes
	/*+0xb0*/  char lJoystickControlColors[14]; // 0xe bytes
protected:
	virtual int32_t GetHandleImageToUse(); // vtable+0xc8
	virtual void DrawCurrentJoystick(); // vtable+0xcc
	virtual void DrawButton(int32_t); // vtable+0xd0
	virtual void DrawSlider(int32_t); // vtable+0xd4
	virtual void DrawHandle(); // vtable+0xd8
	virtual void GetNewJoystickControlStates(long *); // vtable+0xdc
	virtual int32_t DoesPositionHitKey(long, long, long&); // vtable+0xe0
	virtual void GetSourceHandleBaseRects(/*packed*/ class MRect*); // vtable+0xe4
	/*+0xbe*/  /*packed*/ class MRect rectButtons[8]; // 0x80 bytes
	/*+0x13e*/ /*packed*/ class MRect rectSliders[4]; // 0x40 bytes
	/*+0x17e*/ /*packed*/ class MRect rectHandle; // 0x10 bytes
	/*+0x18e*/ /*packed*/ class MRect rectHandleBaseGraphics[4]; // 0x40 bytes
	/*+0x1ce*/ /*unpacked*/ class CBackBuffer *myButtonImage;
	/*+0x1d2*/ /*unpacked*/ class CBackBuffer *mySliderImage;
	/*+0x1d6*/ /*unpacked*/ class CBackBuffer *myHandleImage;
	/*+0x1da*/ /*unpacked*/ class CBackBuffer *myHandleBaseImage;
};

// Type: long *;

// Type: /*packed*/ class UserInputWindow (forward reference);
// VTABLE: COPTER_D 0x0058f228
class UserInputWindow : public GraphicWindow
{ // packed(0xb0 bytes) TI: 0x28a7
	enum KeyUsageType {
		nKeyUsageTypeFree = 0,
		nKeyUsageTypeReserved = 1,
		nKeyUsageTypeCurrentCommand = 2,
		nKeyUsageTypeOtherCommand = 3,
	};
public:
	void UserInputWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual int32_t Initialize() /* override */;
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual long DoKeyDown(long, char) /* override */;
	virtual void SetupAllInputDevices(); // vtable+0xc4
	virtual void SetupAllCommands(); // vtable+0xc8
	virtual void ReadShortcuts(/*packed*/ class list<Shortcut>&); // vtable+0xcc
	virtual void WriteShortcutsToPreferenceFile(); // vtable+0xd0
	int32_t HaveCommandsChanged();
	long GetCurrentDevice();
	long GetCurrentCommand();
	enum UserInputWindow::KeyUsageType GetKeyUsageType(long, long);
	void RemoveShortcutFromList(long, long, long);
protected:
	void UpdateDisplay(int32_t);
	int32_t DoJoystickWindowMessage(long, void * __ptr32);
	int32_t DoKeyboardWindowMessage(long, void * __ptr32);
	int32_t DoInputDeviceListBoxWindowMessage(long, void * __ptr32);
	int32_t DoCommandListBoxWindowMessage(long, void * __ptr32);
	void DisplayError(int32_t);
	void ClearDeviceArea();
	void AddJoystickTwinCommand(long, long, long);
	void RemoveJoystickTwinCommand(long, long, long);
	int32_t DoesTwinCommandExistForShortcut(long, long, long);
	/*+0x74*/  /*packed*/ class JoystickWindow *myJoystickWindow;
	/*+0x78*/  /*packed*/ class KeyboardWindow *myKeyboardWindow;
	/*+0x7c*/  /*packed*/ class ListBoxWindow *myInputDeviceListBoxWindow;
	/*+0x80*/  /*packed*/ class ListBoxWindow *myCommandListBoxWindow;
	/*+0x84*/  /*packed*/ class TextWindow *myStatusTextWindow;
	/*+0x88*/  /*packed*/ class list<StringIDAssociation> myInputDeviceStringIDAssociationList; // 0x8 bytes
	/*+0x90*/  /*packed*/ class list<StringIDAssociation> myCommandStringIDAssociationList; // 0x8 bytes
	/*+0x98*/  /*packed*/ class list<Shortcut> myShortcutListNonConfigurable; // 0x8 bytes
	/*+0xa0*/  /*packed*/ class list<Shortcut> myShortcutListConfigurable; // 0x8 bytes
	/*+0xa8*/  int32_t bCommandsHaveChanged;
	/*+0xac*/  int32_t bInitializing;
};

// Type: /*packed*/ class ButtonWindow (forward reference);
// VTABLE: COPTER_D 0x00591b78
class ButtonWindow : public GraphicWindow
{ // packed(0x94 bytes) TI: 0x1a48
	enum ButtonState {
		nButtonStateDisabled = 0,
		nButtonStateOff = 1,
		nButtonStateOn = 2,
	};
public:
	void ButtonWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, char *, /*packed*/ class GraphicWindowOwner*, int32_t);
	void ButtonWindow();
	virtual int32_t Initialize() /* override */;
	virtual int32_t GetImageCount(); // vtable+0xc4
	virtual void SetState(int32_t); // vtable+0xc8
	virtual int32_t GetState(); // vtable+0xcc
	virtual void Enable(); // vtable+0xd0
	virtual void Disable(); // vtable+0xd4
	virtual int32_t ComposeSelf() /* override */;
	virtual int32_t CreateImage(int32_t) /* override */;
	virtual long DoCursorDown(long, long, unsigned long) /* override */;
	virtual long DoCursorUp(long, long, unsigned long) /* override */;
	virtual long DoCursorMove(long, long) /* override */;
	virtual void SetTextColor(const /*packed*/ struct SparkalColor*, const /*packed*/ struct SparkalColor*); // vtable+0xd8
	virtual int32_t CanWeRespondToMessage() /* override */;
protected:
	/*+0x74*/  int32_t nButtonState;
	/*+0x78*/  int32_t bEnabled;
	/*+0x7c*/  int32_t nButtonTextHeight;
	/*+0x80*/  /*packed*/ class MSize sizeTextOffset; // 0x8 bytes
	/*+0x88*/  int32_t bBusySettingState;
	/*+0x8c*/  /*packed*/ struct SparkalColor colorFont;
	/*+0x90*/  /*packed*/ struct SparkalColor colorFontHighlighted;
};

// Type: void * __ptr32;

// Type: /*packed*/ class ControlDisplayWindow (forward reference);
// VTABLE: COPTER_D 0x0058f300
class ControlDisplayWindow : public GraphicWindow
{ // packed(0x80 bytes) TI: 0x2adb
public:
	void ControlDisplayWindow(/*packed*/ class MRect&, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	virtual int32_t Initialize() /* override */;
	virtual int32_t DoMessage(/*unpacked*/ class GraphicWindow*, long, long, void * __ptr32) /* override */;
	virtual void ReadShortcuts(/*packed*/ class list<Shortcut>*); // vtable+0xc4
protected:
	void GetCommandString(/*packed*/ class basic_string<char>&, long);
	void AppendKeysString(/*packed*/ class basic_string<char>&, long, long, int32_t);
	/*+0x74*/  int32_t bInitializing;
	/*+0x78*/  /*packed*/ class ListBoxWindow *myCommandListBoxWindow;
	/*+0x7c*/  /*packed*/ class ListBoxWindow *myKeysListBoxWindow;
};

// Type: enum UserInputWindow::KeyUsageType;
enum KeyUsageType {
	nKeyUsageTypeFree = 0,
	nKeyUsageTypeReserved = 1,
	nKeyUsageTypeCurrentCommand = 2,
	nKeyUsageTypeOtherCommand = 3,
};

// Type: /*packed*/ struct Shortcut;
struct Shortcut{ // packed(0x18 bytes) TI: 0x1083
	/*+0x0*/   long lDeviceID;
	/*+0x4*/   long lCommand;
	/*+0x8*/   long lKey;
	/*+0xc*/   long lModifiers;
	/*+0x10*/  long lPush;
	/*+0x14*/  long lIgnoreModifiers;
};

// Type: /*packed*/ class list<Shortcut>::iterator;
class list<Shortcut>::iterator : public bidirectional_iterator<Shortcut,int>
{ // packed(0x4 bytes) TI: 0x1081
protected:
	/*+0x0*/   /*packed*/ struct list<Shortcut>::list_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct list<Shortcut>::list_node*);
public:
	int32_t operator==(const /*packed*/ class list<Shortcut>::iterator&);
	/*packed*/ struct Shortcut& operator*();
	/*packed*/ class list<Shortcut>::iterator operator++(int32_t);
	/*packed*/ class list<Shortcut>::iterator& operator++();
	/*packed*/ class list<Shortcut>::iterator operator--(int32_t);
	/*packed*/ class list<Shortcut>::iterator& operator--();
};

// Type: /*packed*/ class list<StringIDAssociation>::iterator;
class list<StringIDAssociation>::iterator : public bidirectional_iterator<StringIDAssociation,int>
{ // packed(0x4 bytes) TI: 0x2956
protected:
	/*+0x0*/   /*packed*/ struct list<StringIDAssociation>::list_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct list<StringIDAssociation>::list_node*);
public:
	int32_t operator==(const /*packed*/ class list<StringIDAssociation>::iterator&);
	/*packed*/ struct StringIDAssociation& operator*();
	/*packed*/ class list<StringIDAssociation>::iterator operator++(int32_t);
	/*packed*/ class list<StringIDAssociation>::iterator& operator++();
	/*packed*/ class list<StringIDAssociation>::iterator operator--(int32_t);
	/*packed*/ class list<StringIDAssociation>::iterator& operator--();
};

// Type: /*packed*/ struct KeyColors;
struct KeyColors{ // packed(0x8 bytes) TI: 0x28cf
	/*+0x0*/   long lKey;
	/*+0x4*/   long lColorIndex;
};

// Type: /*packed*/ class MPoint;
class MPoint : public SparkalPoint
{ // packed(0x8 bytes) TI: 0x159a
public:
	void MPoint(unsigned long);
	void MPoint(/*packed*/ struct SparkalSize);
	void MPoint(/*packed*/ struct SparkalPoint);
	void MPoint(long, long);
	void MPoint();
	void Offset(/*packed*/ struct SparkalSize);
	void Offset(/*packed*/ struct SparkalPoint);
	void Offset(long, long);
	int32_t operator==(/*packed*/ struct SparkalPoint);
	int32_t operator!=(/*packed*/ struct SparkalPoint);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(const /*packed*/ struct SparkalRect*);
	/*packed*/ class MPoint operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MPoint operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(const /*packed*/ struct SparkalRect*);
	/*packed*/ class MSize operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MPoint operator-();
	/*packed*/ class MPoint operator-(/*packed*/ struct SparkalSize);
};

// Type: /*unpacked*/ class CBackBuffer (forward reference);
// CBackBuffer Class implementation not found

// Type: /*packed*/ class list<Shortcut> (forward reference);
class list<Shortcut>{ // packed(0x8 bytes) TI: 0x1b79
	using void_pointer = void * __ptr32;
	struct list<Shortcut>::list_node{ // packed(0x20 bytes) TI: 0x1b8e
		/*+0x0*/   void * __ptr32 next;
		/*+0x4*/   void * __ptr32 prev;
		/*+0x8*/   /*packed*/ struct Shortcut data; // 0x18 bytes
	};
protected:
	static /*packed*/ class allocator<list<Shortcut>::list_node> list_node_allocator;
	static /*packed*/ class allocator<Shortcut> value_allocator;
	using value_type = /*packed*/ struct Shortcut;
	using value_allocator_type = /*packed*/ class allocator<Shortcut>;
	using pointer = /*packed*/ struct Shortcut*;
	using reference = /*packed*/ struct Shortcut&;
	using const_reference = const /*packed*/ struct Shortcut&;
	using list_node_allocator_type = /*packed*/ class allocator<list<Shortcut>::list_node>;
	using link_type = /*packed*/ struct list<Shortcut>::list_node*;
	using size_type = uint32_t;
	using difference_type = int32_t;
protected:
	uint32_t buffer_size();
	struct list<Shortcut>::list_node_buffer{ // packed(0x8 bytes) TI: 0x1b8c
		/*+0x0*/   void * __ptr32 next_buffer;
		/*+0x4*/   /*packed*/ struct list<Shortcut>::list_node *buffer;
	};
	using buffer_allocator_type = /*packed*/ class allocator<list<Shortcut>::list_node_buffer>;
	using buffer_pointer = /*packed*/ struct list<Shortcut>::list_node_buffer*;
protected:
	static /*packed*/ class allocator<list<Shortcut>::list_node_buffer> buffer_allocator;
	static /*packed*/ struct list<Shortcut>::list_node_buffer *buffer_list;
	static /*packed*/ struct list<Shortcut>::list_node *free_list;
	static /*packed*/ struct list<Shortcut>::list_node *next_avail;
	static /*packed*/ struct list<Shortcut>::list_node *last;
	void add_new_buffer();
	static uint32_t number_of_lists;
	void deallocate_buffers();
	/*packed*/ struct list<Shortcut>::list_node* get_node();
	void put_node(/*packed*/ struct list<Shortcut>::list_node*);
	/*+0x0*/   /*packed*/ struct list<Shortcut>::list_node *node;
	/*+0x4*/   uint32_t length;
	class list<Shortcut>::iterator : public bidirectional_iterator<Shortcut,int>
	{ // packed(0x4 bytes) TI: 0x1081
	protected:
		/*+0x0*/   /*packed*/ struct list<Shortcut>::list_node *node;
	public:
		void iterator();
	protected:
		void iterator(/*packed*/ struct list<Shortcut>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<Shortcut>::iterator&);
		/*packed*/ struct Shortcut& operator*();
		/*packed*/ class list<Shortcut>::iterator operator++(int32_t);
		/*packed*/ class list<Shortcut>::iterator& operator++();
		/*packed*/ class list<Shortcut>::iterator operator--(int32_t);
		/*packed*/ class list<Shortcut>::iterator& operator--();
	};
	class list<Shortcut>::const_iterator : public bidirectional_iterator<Shortcut,int>
	{ // packed(0x4 bytes) TI: 0x1b8a
	protected:
		/*+0x0*/   /*packed*/ struct list<Shortcut>::list_node *node;
	public:
		void const_iterator(const /*packed*/ class list<Shortcut>::iterator&);
		void const_iterator();
	protected:
		void const_iterator(/*packed*/ struct list<Shortcut>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<Shortcut>::const_iterator&);
		const /*packed*/ struct Shortcut& operator*();
		/*packed*/ class list<Shortcut>::const_iterator operator++(int32_t);
		/*packed*/ class list<Shortcut>::const_iterator& operator++();
		/*packed*/ class list<Shortcut>::const_iterator operator--(int32_t);
		/*packed*/ class list<Shortcut>::const_iterator& operator--();
	};
	using const_reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<Shortcut>::const_iterator,Shortcut,Shortcut const &,int>;
	using reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<Shortcut>::iterator,Shortcut,Shortcut &,int>;
public:
	void list<Shortcut>(const /*packed*/ class list<Shortcut>&);
	void list<Shortcut>(const /*packed*/ struct Shortcut*, const /*packed*/ struct Shortcut*);
	void list<Shortcut>(uint32_t, const /*packed*/ struct Shortcut&);
	void list<Shortcut>();
	/*packed*/ class list<Shortcut>::const_iterator begin();
	/*packed*/ class list<Shortcut>::iterator begin();
	/*packed*/ class list<Shortcut>::const_iterator end();
	/*packed*/ class list<Shortcut>::iterator end();
	/*unpacked*/ class reverse_bidirectional_iterator<list<Shortcut>::const_iterator,Shortcut,Shortcut const &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<Shortcut>::iterator,Shortcut,Shortcut &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<Shortcut>::const_iterator,Shortcut,Shortcut const &,int> rend();
	/*unpacked*/ class reverse_bidirectional_iterator<list<Shortcut>::iterator,Shortcut,Shortcut &,int> rend();
	int32_t empty();
	uint32_t size();
	uint32_t max_size();
	const /*packed*/ struct Shortcut& front();
	/*packed*/ struct Shortcut& front();
	const /*packed*/ struct Shortcut& back();
	/*packed*/ struct Shortcut& back();
	void swap(/*packed*/ class list<Shortcut>&);
	void insert(/*packed*/ class list<Shortcut>::iterator, uint32_t, const /*packed*/ struct Shortcut&);
	void insert(/*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>::const_iterator, /*packed*/ class list<Shortcut>::const_iterator);
	void insert(/*packed*/ class list<Shortcut>::iterator, const /*packed*/ struct Shortcut*, const /*packed*/ struct Shortcut*);
	/*packed*/ class list<Shortcut>::iterator insert(/*packed*/ class list<Shortcut>::iterator, const /*packed*/ struct Shortcut&);
	void push_front(const /*packed*/ struct Shortcut&);
	void push_back(const /*packed*/ struct Shortcut&);
	void erase(/*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>::iterator);
	void erase(/*packed*/ class list<Shortcut>::iterator);
	void pop_front();
	void pop_back();
	void ~list<Shortcut>();
	/*packed*/ class list<Shortcut>& operator=(const /*packed*/ class list<Shortcut>&);
protected:
	void transfer(/*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>::iterator);
public:
	void splice(/*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>&, /*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>::iterator);
	void splice(/*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>&, /*packed*/ class list<Shortcut>::iterator);
	void splice(/*packed*/ class list<Shortcut>::iterator, /*packed*/ class list<Shortcut>&);
	void remove(const /*packed*/ struct Shortcut&);
	void unique();
	void merge(/*packed*/ class list<Shortcut>&);
	void reverse();
	void sort();
};

// Type: /*packed*/ class TextWindow (forward reference);
// VTABLE: COPTER_D 0x00591a90
class TextWindow : public GraphicWindow
{ // packed(0xa4 bytes) TI: 0x4411
public:
	void TextWindow(/*packed*/ class MRect&, int32_t, const /*packed*/ class basic_string<char>&, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	void TextWindow(/*packed*/ class MRect&, int32_t, int32_t, /*unpacked*/ class GraphicWindow*, /*packed*/ class GraphicWindowOwner*, int32_t);
	void TextWindow();
	virtual int32_t DrawSelf() /* override */;
	virtual void SetWindowTitle(const /*packed*/ class basic_string<char>&); // vtable+0xc4
	virtual void SetWindowTitle(int32_t); // vtable+0xc8
	virtual void SetFontCharacteristics(long, long, long); // vtable+0xcc
	virtual void SetTextDrawStyle(unsigned long); // vtable+0xd0
	virtual void SetTextColor(const /*packed*/ struct SparkalColor&); // vtable+0xd4
	virtual void SetBackgroundDrawing(int32_t); // vtable+0xd8
	virtual void LoadStrings(); // vtable+0xdc
	virtual void FitWindowToText(); // vtable+0xe0
	virtual int32_t ResizeWindowForExactLineHeights(); // vtable+0xe4
protected:
	/*+0x74*/  int32_t bDrawOpaqueBackground;
	/*+0x78*/  /*packed*/ struct SparkalColor colorFont;
	/*+0x7c*/  int32_t nBackgroundPaletteIndex;
	/*+0x80*/  int32_t nWindowTitleTextID;
	/*+0x84*/  /*packed*/ class MFont fontText; // 0x1c bytes
	/*+0xa0*/  unsigned long nTextDrawStyle;
};

// Type: /*packed*/ class set<long,less<long>>;
class set<long,less<long>>{ // packed(0xd bytes) TI: 0x2c0e
	using key_type = long;
	using value_type = long;
	using key_compare = /*packed*/ struct less<long>;
	using value_compare = /*packed*/ struct less<long>;
	using rep_type = /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>;
private:
	/*+0x0*/   /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>> t; // 0xd bytes
	using reference = const long&;
	using const_reference = const long&;
	using iterator = /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator;
	using const_iterator = /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator;
	using reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,long,long const &,int>;
	using const_reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,long,long const &,int>;
	using size_type = uint32_t;
	using difference_type = int32_t;
public:
	void set<long,less<long>>(const /*packed*/ class set<long,less<long>>&);
	void set<long,less<long>>(long *, long *, const /*packed*/ struct less<long>&);
	void set<long,less<long>>(const /*packed*/ struct less<long>&);
	/*packed*/ class set<long,less<long>>& operator=(const /*packed*/ class set<long,less<long>>&);
	/*packed*/ struct less<long> key_comp();
	/*packed*/ struct less<long> value_comp();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator begin();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator end();
	/*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,long,long const &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,long,long const &,int> rend();
	int32_t empty();
	uint32_t size();
	uint32_t max_size();
	void swap(/*packed*/ class set<long,less<long>>&);
	using pair_iterator_bool = /*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,int>;
public:
	void insert(long *, long *);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator insert(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator, const long&);
	/*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,int> insert(const long&);
	void erase(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator, /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator);
	uint32_t erase(const long&);
	void erase(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator find(const long&);
	uint32_t count(const long&);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator lower_bound(const long&);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator upper_bound(const long&);
	using pair_iterator_iterator = /*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,rb_tree<long,long,ident<long,long>,less<long>>::const_iterator>;
public:
	/*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,rb_tree<long,long,ident<long,long>,less<long>>::const_iterator> equal_range(const long&);
};

// Type: /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator;
class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator : public bidirectional_iterator<long,int>
{ // packed(0x4 bytes) TI: 0x2c27
protected:
	/*+0x0*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *node;
public:
	void const_iterator(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator&);
	void const_iterator();
protected:
	void const_iterator(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
public:
	int32_t operator==(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator&);
	int32_t operator!=(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator&);
	const long& operator*();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator operator++(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator& operator++();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator operator--(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator& operator--();
};

// Type: /*packed*/ struct Shortcut (forward reference);
struct Shortcut{ // packed(0x18 bytes) TI: 0x1083
	/*+0x0*/   long lDeviceID;
	/*+0x4*/   long lCommand;
	/*+0x8*/   long lKey;
	/*+0xc*/   long lModifiers;
	/*+0x10*/  long lPush;
	/*+0x14*/  long lIgnoreModifiers;
};

// Type: /*packed*/ class vector<char> (forward reference);
class vector<char>{ // packed(0xc bytes) TI: 0x1e45
	using vector_allocator = /*packed*/ class allocator<char>;
	using value_type = char;
	using pointer = char *;
	using iterator = char *;
	using const_iterator = char *;
	using reference = char&;
	using const_reference = const char&;
	using size_type = uint32_t;
	using difference_type = int32_t;
	using const_reverse_iterator = /*unpacked*/ class reverse_iterator<char const *,char,char const &,int>;
	using reverse_iterator = /*unpacked*/ class reverse_iterator<char *,char,char &,int>;
protected:
	static /*packed*/ class allocator<char> static_allocator;
	/*+0x0*/   char * start;
	/*+0x4*/   char * finish;
	/*+0x8*/   char * end_of_storage;
	void insert_aux(char *, const char&);
public:
	char * begin();
	char * begin();
	char * end();
	char * end();
	/*unpacked*/ class reverse_iterator<char const *,char,char const &,int> rbegin();
	/*unpacked*/ class reverse_iterator<char *,char,char &,int> rbegin();
	/*unpacked*/ class reverse_iterator<char const *,char,char const &,int> rend();
	/*unpacked*/ class reverse_iterator<char *,char,char &,int> rend();
	uint32_t size();
	uint32_t max_size();
	uint32_t capacity();
	int32_t empty();
	const char& operator[](uint32_t);
	char& operator[](uint32_t);
	void vector<char>(char *, char *);
	void vector<char>(const /*packed*/ class vector<char>&);
	void vector<char>(uint32_t, const char&);
	void vector<char>();
	void ~vector<char>();
	/*packed*/ class vector<char>& operator=(const /*packed*/ class vector<char>&);
	void reserve(uint32_t);
	const char& front();
	char& front();
	const char& back();
	char& back();
	void push_back(const char&);
	void swap(/*packed*/ class vector<char>&);
	void insert(char *, uint32_t, const char&);
	void insert(char *, char *, char *);
	char * insert(char *, const char&);
	void pop_back();
	void erase(char *, char *);
	void erase(char *);
};

// Type: /*unpacked*/ class ostream (forward reference);
// ostream Class implementation not found

// Type: void (void * __ptr32);

// Type: /*packed*/ class MPoint (forward reference);
class MPoint : public SparkalPoint
{ // packed(0x8 bytes) TI: 0x159a
public:
	void MPoint(unsigned long);
	void MPoint(/*packed*/ struct SparkalSize);
	void MPoint(/*packed*/ struct SparkalPoint);
	void MPoint(long, long);
	void MPoint();
	void Offset(/*packed*/ struct SparkalSize);
	void Offset(/*packed*/ struct SparkalPoint);
	void Offset(long, long);
	int32_t operator==(/*packed*/ struct SparkalPoint);
	int32_t operator!=(/*packed*/ struct SparkalPoint);
	void operator+=(/*packed*/ struct SparkalPoint);
	void operator+=(/*packed*/ struct SparkalSize);
	void operator-=(/*packed*/ struct SparkalPoint);
	void operator-=(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator+(const /*packed*/ struct SparkalRect*);
	/*packed*/ class MPoint operator+(/*packed*/ struct SparkalPoint);
	/*packed*/ class MPoint operator+(/*packed*/ struct SparkalSize);
	/*packed*/ class MRect operator-(const /*packed*/ struct SparkalRect*);
	/*packed*/ class MSize operator-(/*packed*/ struct SparkalPoint);
	/*packed*/ class MPoint operator-();
	/*packed*/ class MPoint operator-(/*packed*/ struct SparkalSize);
};

// Type: /*packed*/ class list<KeyColors> (forward reference);
class list<KeyColors>{ // packed(0x8 bytes) TI: 0x29b8
	using void_pointer = void * __ptr32;
	struct list<KeyColors>::list_node{ // packed(0x10 bytes) TI: 0x29de
		/*+0x0*/   void * __ptr32 next;
		/*+0x4*/   void * __ptr32 prev;
		/*+0x8*/   /*packed*/ struct KeyColors data; // 0x8 bytes
	};
protected:
	static /*packed*/ class allocator<list<KeyColors>::list_node> list_node_allocator;
	static /*packed*/ class allocator<KeyColors> value_allocator;
	using value_type = /*packed*/ struct KeyColors;
	using value_allocator_type = /*packed*/ class allocator<KeyColors>;
	using pointer = /*packed*/ struct KeyColors*;
	using reference = /*packed*/ struct KeyColors&;
	using const_reference = const /*packed*/ struct KeyColors&;
	using list_node_allocator_type = /*packed*/ class allocator<list<KeyColors>::list_node>;
	using link_type = /*packed*/ struct list<KeyColors>::list_node*;
	using size_type = uint32_t;
	using difference_type = int32_t;
protected:
	uint32_t buffer_size();
	struct list<KeyColors>::list_node_buffer{ // packed(0x8 bytes) TI: 0x29dc
		/*+0x0*/   void * __ptr32 next_buffer;
		/*+0x4*/   /*packed*/ struct list<KeyColors>::list_node *buffer;
	};
	using buffer_allocator_type = /*packed*/ class allocator<list<KeyColors>::list_node_buffer>;
	using buffer_pointer = /*packed*/ struct list<KeyColors>::list_node_buffer*;
protected:
	static /*packed*/ class allocator<list<KeyColors>::list_node_buffer> buffer_allocator;
	static /*packed*/ struct list<KeyColors>::list_node_buffer *buffer_list;
	static /*packed*/ struct list<KeyColors>::list_node *free_list;
	static /*packed*/ struct list<KeyColors>::list_node *next_avail;
	static /*packed*/ struct list<KeyColors>::list_node *last;
	void add_new_buffer();
	static uint32_t number_of_lists;
	void deallocate_buffers();
	/*packed*/ struct list<KeyColors>::list_node* get_node();
	void put_node(/*packed*/ struct list<KeyColors>::list_node*);
	/*+0x0*/   /*packed*/ struct list<KeyColors>::list_node *node;
	/*+0x4*/   uint32_t length;
	class list<KeyColors>::iterator : public bidirectional_iterator<KeyColors,int>
	{ // packed(0x4 bytes) TI: 0x29da
	protected:
		/*+0x0*/   /*packed*/ struct list<KeyColors>::list_node *node;
	public:
		void iterator();
	protected:
		void iterator(/*packed*/ struct list<KeyColors>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<KeyColors>::iterator&);
		/*packed*/ struct KeyColors& operator*();
		/*packed*/ class list<KeyColors>::iterator operator++(int32_t);
		/*packed*/ class list<KeyColors>::iterator& operator++();
		/*packed*/ class list<KeyColors>::iterator operator--(int32_t);
		/*packed*/ class list<KeyColors>::iterator& operator--();
	};
	class list<KeyColors>::const_iterator : public bidirectional_iterator<KeyColors,int>
	{ // packed(0x4 bytes) TI: 0x29cd
	protected:
		/*+0x0*/   /*packed*/ struct list<KeyColors>::list_node *node;
	public:
		void const_iterator(const /*packed*/ class list<KeyColors>::iterator&);
		void const_iterator();
	protected:
		void const_iterator(/*packed*/ struct list<KeyColors>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<KeyColors>::const_iterator&);
		const /*packed*/ struct KeyColors& operator*();
		/*packed*/ class list<KeyColors>::const_iterator operator++(int32_t);
		/*packed*/ class list<KeyColors>::const_iterator& operator++();
		/*packed*/ class list<KeyColors>::const_iterator operator--(int32_t);
		/*packed*/ class list<KeyColors>::const_iterator& operator--();
	};
	using const_reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<KeyColors>::const_iterator,KeyColors,KeyColors const &,int>;
	using reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<KeyColors>::iterator,KeyColors,KeyColors &,int>;
public:
	void list<KeyColors>(const /*packed*/ class list<KeyColors>&);
	void list<KeyColors>(const /*packed*/ struct KeyColors*, const /*packed*/ struct KeyColors*);
	void list<KeyColors>(uint32_t, const /*packed*/ struct KeyColors&);
	void list<KeyColors>();
	/*packed*/ class list<KeyColors>::const_iterator begin();
	/*packed*/ class list<KeyColors>::iterator begin();
	/*packed*/ class list<KeyColors>::const_iterator end();
	/*packed*/ class list<KeyColors>::iterator end();
	/*unpacked*/ class reverse_bidirectional_iterator<list<KeyColors>::const_iterator,KeyColors,KeyColors const &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<KeyColors>::iterator,KeyColors,KeyColors &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<KeyColors>::const_iterator,KeyColors,KeyColors const &,int> rend();
	/*unpacked*/ class reverse_bidirectional_iterator<list<KeyColors>::iterator,KeyColors,KeyColors &,int> rend();
	int32_t empty();
	uint32_t size();
	uint32_t max_size();
	const /*packed*/ struct KeyColors& front();
	/*packed*/ struct KeyColors& front();
	const /*packed*/ struct KeyColors& back();
	/*packed*/ struct KeyColors& back();
	void swap(/*packed*/ class list<KeyColors>&);
	void insert(/*packed*/ class list<KeyColors>::iterator, uint32_t, const /*packed*/ struct KeyColors&);
	void insert(/*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>::const_iterator, /*packed*/ class list<KeyColors>::const_iterator);
	void insert(/*packed*/ class list<KeyColors>::iterator, const /*packed*/ struct KeyColors*, const /*packed*/ struct KeyColors*);
	/*packed*/ class list<KeyColors>::iterator insert(/*packed*/ class list<KeyColors>::iterator, const /*packed*/ struct KeyColors&);
	void push_front(const /*packed*/ struct KeyColors&);
	void push_back(const /*packed*/ struct KeyColors&);
	void erase(/*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>::iterator);
	void erase(/*packed*/ class list<KeyColors>::iterator);
	void pop_front();
	void pop_back();
	void ~list<KeyColors>();
	/*packed*/ class list<KeyColors>& operator=(const /*packed*/ class list<KeyColors>&);
protected:
	void transfer(/*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>::iterator);
public:
	void splice(/*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>&, /*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>::iterator);
	void splice(/*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>&, /*packed*/ class list<KeyColors>::iterator);
	void splice(/*packed*/ class list<KeyColors>::iterator, /*packed*/ class list<KeyColors>&);
	void remove(const /*packed*/ struct KeyColors&);
	void unique();
	void merge(/*packed*/ class list<KeyColors>&);
	void reverse();
	void sort();
};

// Type: /*packed*/ class list<HotSpot>::iterator (forward reference);
class list<HotSpot>::iterator : public bidirectional_iterator<HotSpot,int>
{ // packed(0x4 bytes) TI: 0x1240
protected:
	/*+0x0*/   /*packed*/ struct list<HotSpot>::list_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct list<HotSpot>::list_node*);
public:
	int32_t operator==(const /*packed*/ class list<HotSpot>::iterator&);
	/*packed*/ class HotSpot& operator*();
	/*packed*/ class list<HotSpot>::iterator operator++(int32_t);
	/*packed*/ class list<HotSpot>::iterator& operator++();
	/*packed*/ class list<HotSpot>::iterator operator--(int32_t);
	/*packed*/ class list<HotSpot>::iterator& operator--();
};

// Type: /*packed*/ class list<HotSpot> (forward reference);
class list<HotSpot>{ // packed(0x8 bytes) TI: 0x121e
	using void_pointer = void * __ptr32;
	struct list<HotSpot>::list_node{ // packed(0x1c bytes) TI: 0x1244
		/*+0x0*/   void * __ptr32 next;
		/*+0x4*/   void * __ptr32 prev;
		/*+0x8*/   /*packed*/ class HotSpot data; // 0x14 bytes
	};
protected:
	static /*packed*/ class allocator<list<HotSpot>::list_node> list_node_allocator;
	static /*packed*/ class allocator<HotSpot> value_allocator;
	using value_type = /*packed*/ class HotSpot;
	using value_allocator_type = /*packed*/ class allocator<HotSpot>;
	using pointer = /*packed*/ class HotSpot*;
	using reference = /*packed*/ class HotSpot&;
	using const_reference = const /*packed*/ class HotSpot&;
	using list_node_allocator_type = /*packed*/ class allocator<list<HotSpot>::list_node>;
	using link_type = /*packed*/ struct list<HotSpot>::list_node*;
	using size_type = uint32_t;
	using difference_type = int32_t;
protected:
	uint32_t buffer_size();
	struct list<HotSpot>::list_node_buffer{ // packed(0x8 bytes) TI: 0x1242
		/*+0x0*/   void * __ptr32 next_buffer;
		/*+0x4*/   /*packed*/ struct list<HotSpot>::list_node *buffer;
	};
	using buffer_allocator_type = /*packed*/ class allocator<list<HotSpot>::list_node_buffer>;
	using buffer_pointer = /*packed*/ struct list<HotSpot>::list_node_buffer*;
protected:
	static /*packed*/ class allocator<list<HotSpot>::list_node_buffer> buffer_allocator;
	static /*packed*/ struct list<HotSpot>::list_node_buffer *buffer_list;
	static /*packed*/ struct list<HotSpot>::list_node *free_list;
	static /*packed*/ struct list<HotSpot>::list_node *next_avail;
	static /*packed*/ struct list<HotSpot>::list_node *last;
	void add_new_buffer();
	static uint32_t number_of_lists;
	void deallocate_buffers();
	/*packed*/ struct list<HotSpot>::list_node* get_node();
	void put_node(/*packed*/ struct list<HotSpot>::list_node*);
	/*+0x0*/   /*packed*/ struct list<HotSpot>::list_node *node;
	/*+0x4*/   uint32_t length;
	class list<HotSpot>::iterator : public bidirectional_iterator<HotSpot,int>
	{ // packed(0x4 bytes) TI: 0x1240
	protected:
		/*+0x0*/   /*packed*/ struct list<HotSpot>::list_node *node;
	public:
		void iterator();
	protected:
		void iterator(/*packed*/ struct list<HotSpot>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<HotSpot>::iterator&);
		/*packed*/ class HotSpot& operator*();
		/*packed*/ class list<HotSpot>::iterator operator++(int32_t);
		/*packed*/ class list<HotSpot>::iterator& operator++();
		/*packed*/ class list<HotSpot>::iterator operator--(int32_t);
		/*packed*/ class list<HotSpot>::iterator& operator--();
	};
	class list<HotSpot>::const_iterator : public bidirectional_iterator<HotSpot,int>
	{ // packed(0x4 bytes) TI: 0x1233
	protected:
		/*+0x0*/   /*packed*/ struct list<HotSpot>::list_node *node;
	public:
		void const_iterator(const /*packed*/ class list<HotSpot>::iterator&);
		void const_iterator();
	protected:
		void const_iterator(/*packed*/ struct list<HotSpot>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<HotSpot>::const_iterator&);
		const /*packed*/ class HotSpot& operator*();
		/*packed*/ class list<HotSpot>::const_iterator operator++(int32_t);
		/*packed*/ class list<HotSpot>::const_iterator& operator++();
		/*packed*/ class list<HotSpot>::const_iterator operator--(int32_t);
		/*packed*/ class list<HotSpot>::const_iterator& operator--();
	};
	using const_reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<HotSpot>::const_iterator,HotSpot,HotSpot const &,int>;
	using reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<HotSpot>::iterator,HotSpot,HotSpot &,int>;
public:
	void list<HotSpot>(const /*packed*/ class list<HotSpot>&);
	void list<HotSpot>(const /*packed*/ class HotSpot*, const /*packed*/ class HotSpot*);
	void list<HotSpot>(uint32_t, const /*packed*/ class HotSpot&);
	void list<HotSpot>();
	/*packed*/ class list<HotSpot>::const_iterator begin();
	/*packed*/ class list<HotSpot>::iterator begin();
	/*packed*/ class list<HotSpot>::const_iterator end();
	/*packed*/ class list<HotSpot>::iterator end();
	/*unpacked*/ class reverse_bidirectional_iterator<list<HotSpot>::const_iterator,HotSpot,HotSpot const &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<HotSpot>::iterator,HotSpot,HotSpot &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<HotSpot>::const_iterator,HotSpot,HotSpot const &,int> rend();
	/*unpacked*/ class reverse_bidirectional_iterator<list<HotSpot>::iterator,HotSpot,HotSpot &,int> rend();
	int32_t empty();
	uint32_t size();
	uint32_t max_size();
	const /*packed*/ class HotSpot& front();
	/*packed*/ class HotSpot& front();
	const /*packed*/ class HotSpot& back();
	/*packed*/ class HotSpot& back();
	void swap(/*packed*/ class list<HotSpot>&);
	void insert(/*packed*/ class list<HotSpot>::iterator, uint32_t, const /*packed*/ class HotSpot&);
	void insert(/*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>::const_iterator, /*packed*/ class list<HotSpot>::const_iterator);
	void insert(/*packed*/ class list<HotSpot>::iterator, const /*packed*/ class HotSpot*, const /*packed*/ class HotSpot*);
	/*packed*/ class list<HotSpot>::iterator insert(/*packed*/ class list<HotSpot>::iterator, const /*packed*/ class HotSpot&);
	void push_front(const /*packed*/ class HotSpot&);
	void push_back(const /*packed*/ class HotSpot&);
	void erase(/*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>::iterator);
	void erase(/*packed*/ class list<HotSpot>::iterator);
	void pop_front();
	void pop_back();
	void ~list<HotSpot>();
	/*packed*/ class list<HotSpot>& operator=(const /*packed*/ class list<HotSpot>&);
protected:
	void transfer(/*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>::iterator);
public:
	void splice(/*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>&, /*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>::iterator);
	void splice(/*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>&, /*packed*/ class list<HotSpot>::iterator);
	void splice(/*packed*/ class list<HotSpot>::iterator, /*packed*/ class list<HotSpot>&);
	void remove(const /*packed*/ class HotSpot&);
	void unique();
	void merge(/*packed*/ class list<HotSpot>&);
	void reverse();
	void sort();
};

// Type: /*packed*/ class list<Shortcut>::iterator (forward reference);
class list<Shortcut>::iterator : public bidirectional_iterator<Shortcut,int>
{ // packed(0x4 bytes) TI: 0x1081
protected:
	/*+0x0*/   /*packed*/ struct list<Shortcut>::list_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct list<Shortcut>::list_node*);
public:
	int32_t operator==(const /*packed*/ class list<Shortcut>::iterator&);
	/*packed*/ struct Shortcut& operator*();
	/*packed*/ class list<Shortcut>::iterator operator++(int32_t);
	/*packed*/ class list<Shortcut>::iterator& operator++();
	/*packed*/ class list<Shortcut>::iterator operator--(int32_t);
	/*packed*/ class list<Shortcut>::iterator& operator--();
};

// Type: /*packed*/ class list<StringIDAssociation>::iterator (forward reference);
class list<StringIDAssociation>::iterator : public bidirectional_iterator<StringIDAssociation,int>
{ // packed(0x4 bytes) TI: 0x2956
protected:
	/*+0x0*/   /*packed*/ struct list<StringIDAssociation>::list_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct list<StringIDAssociation>::list_node*);
public:
	int32_t operator==(const /*packed*/ class list<StringIDAssociation>::iterator&);
	/*packed*/ struct StringIDAssociation& operator*();
	/*packed*/ class list<StringIDAssociation>::iterator operator++(int32_t);
	/*packed*/ class list<StringIDAssociation>::iterator& operator++();
	/*packed*/ class list<StringIDAssociation>::iterator operator--(int32_t);
	/*packed*/ class list<StringIDAssociation>::iterator& operator--();
};

// Type: /*packed*/ class list<StringIDAssociation> (forward reference);
class list<StringIDAssociation>{ // packed(0x8 bytes) TI: 0x2934
	using void_pointer = void * __ptr32;
	struct list<StringIDAssociation>::list_node{ // packed(0x14 bytes) TI: 0x295a
		/*+0x0*/   void * __ptr32 next;
		/*+0x4*/   void * __ptr32 prev;
		/*+0x8*/   /*packed*/ struct StringIDAssociation data; // 0xc bytes
	};
protected:
	static /*packed*/ class allocator<list<StringIDAssociation>::list_node> list_node_allocator;
	static /*packed*/ class allocator<StringIDAssociation> value_allocator;
	using value_type = /*packed*/ struct StringIDAssociation;
	using value_allocator_type = /*packed*/ class allocator<StringIDAssociation>;
	using pointer = /*packed*/ struct StringIDAssociation*;
	using reference = /*packed*/ struct StringIDAssociation&;
	using const_reference = const /*packed*/ struct StringIDAssociation&;
	using list_node_allocator_type = /*packed*/ class allocator<list<StringIDAssociation>::list_node>;
	using link_type = /*packed*/ struct list<StringIDAssociation>::list_node*;
	using size_type = uint32_t;
	using difference_type = int32_t;
protected:
	uint32_t buffer_size();
	struct list<StringIDAssociation>::list_node_buffer{ // packed(0x8 bytes) TI: 0x2958
		/*+0x0*/   void * __ptr32 next_buffer;
		/*+0x4*/   /*packed*/ struct list<StringIDAssociation>::list_node *buffer;
	};
	using buffer_allocator_type = /*packed*/ class allocator<list<StringIDAssociation>::list_node_buffer>;
	using buffer_pointer = /*packed*/ struct list<StringIDAssociation>::list_node_buffer*;
protected:
	static /*packed*/ class allocator<list<StringIDAssociation>::list_node_buffer> buffer_allocator;
	static /*packed*/ struct list<StringIDAssociation>::list_node_buffer *buffer_list;
	static /*packed*/ struct list<StringIDAssociation>::list_node *free_list;
	static /*packed*/ struct list<StringIDAssociation>::list_node *next_avail;
	static /*packed*/ struct list<StringIDAssociation>::list_node *last;
	void add_new_buffer();
	static uint32_t number_of_lists;
	void deallocate_buffers();
	/*packed*/ struct list<StringIDAssociation>::list_node* get_node();
	void put_node(/*packed*/ struct list<StringIDAssociation>::list_node*);
	/*+0x0*/   /*packed*/ struct list<StringIDAssociation>::list_node *node;
	/*+0x4*/   uint32_t length;
	class list<StringIDAssociation>::iterator : public bidirectional_iterator<StringIDAssociation,int>
	{ // packed(0x4 bytes) TI: 0x2956
	protected:
		/*+0x0*/   /*packed*/ struct list<StringIDAssociation>::list_node *node;
	public:
		void iterator();
	protected:
		void iterator(/*packed*/ struct list<StringIDAssociation>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<StringIDAssociation>::iterator&);
		/*packed*/ struct StringIDAssociation& operator*();
		/*packed*/ class list<StringIDAssociation>::iterator operator++(int32_t);
		/*packed*/ class list<StringIDAssociation>::iterator& operator++();
		/*packed*/ class list<StringIDAssociation>::iterator operator--(int32_t);
		/*packed*/ class list<StringIDAssociation>::iterator& operator--();
	};
	class list<StringIDAssociation>::const_iterator : public bidirectional_iterator<StringIDAssociation,int>
	{ // packed(0x4 bytes) TI: 0x2949
	protected:
		/*+0x0*/   /*packed*/ struct list<StringIDAssociation>::list_node *node;
	public:
		void const_iterator(const /*packed*/ class list<StringIDAssociation>::iterator&);
		void const_iterator();
	protected:
		void const_iterator(/*packed*/ struct list<StringIDAssociation>::list_node*);
	public:
		int32_t operator==(const /*packed*/ class list<StringIDAssociation>::const_iterator&);
		const /*packed*/ struct StringIDAssociation& operator*();
		/*packed*/ class list<StringIDAssociation>::const_iterator operator++(int32_t);
		/*packed*/ class list<StringIDAssociation>::const_iterator& operator++();
		/*packed*/ class list<StringIDAssociation>::const_iterator operator--(int32_t);
		/*packed*/ class list<StringIDAssociation>::const_iterator& operator--();
	};
	using const_reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<StringIDAssociation>::const_iterator,StringIDAssociation,StringIDAssociation const &,int>;
	using reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<list<StringIDAssociation>::iterator,StringIDAssociation,StringIDAssociation &,int>;
public:
	void list<StringIDAssociation>(const /*packed*/ class list<StringIDAssociation>&);
	void list<StringIDAssociation>(const /*packed*/ struct StringIDAssociation*, const /*packed*/ struct StringIDAssociation*);
	void list<StringIDAssociation>(uint32_t, const /*packed*/ struct StringIDAssociation&);
	void list<StringIDAssociation>();
	/*packed*/ class list<StringIDAssociation>::const_iterator begin();
	/*packed*/ class list<StringIDAssociation>::iterator begin();
	/*packed*/ class list<StringIDAssociation>::const_iterator end();
	/*packed*/ class list<StringIDAssociation>::iterator end();
	/*unpacked*/ class reverse_bidirectional_iterator<list<StringIDAssociation>::const_iterator,StringIDAssociation,StringIDAssociation const &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<StringIDAssociation>::iterator,StringIDAssociation,StringIDAssociation &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<list<StringIDAssociation>::const_iterator,StringIDAssociation,StringIDAssociation const &,int> rend();
	/*unpacked*/ class reverse_bidirectional_iterator<list<StringIDAssociation>::iterator,StringIDAssociation,StringIDAssociation &,int> rend();
	int32_t empty();
	uint32_t size();
	uint32_t max_size();
	const /*packed*/ struct StringIDAssociation& front();
	/*packed*/ struct StringIDAssociation& front();
	const /*packed*/ struct StringIDAssociation& back();
	/*packed*/ struct StringIDAssociation& back();
	void swap(/*packed*/ class list<StringIDAssociation>&);
	void insert(/*packed*/ class list<StringIDAssociation>::iterator, uint32_t, const /*packed*/ struct StringIDAssociation&);
	void insert(/*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>::const_iterator, /*packed*/ class list<StringIDAssociation>::const_iterator);
	void insert(/*packed*/ class list<StringIDAssociation>::iterator, const /*packed*/ struct StringIDAssociation*, const /*packed*/ struct StringIDAssociation*);
	/*packed*/ class list<StringIDAssociation>::iterator insert(/*packed*/ class list<StringIDAssociation>::iterator, const /*packed*/ struct StringIDAssociation&);
	void push_front(const /*packed*/ struct StringIDAssociation&);
	void push_back(const /*packed*/ struct StringIDAssociation&);
	void erase(/*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>::iterator);
	void erase(/*packed*/ class list<StringIDAssociation>::iterator);
	void pop_front();
	void pop_back();
	void ~list<StringIDAssociation>();
	/*packed*/ class list<StringIDAssociation>& operator=(const /*packed*/ class list<StringIDAssociation>&);
protected:
	void transfer(/*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>::iterator);
public:
	void splice(/*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>&, /*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>::iterator);
	void splice(/*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>&, /*packed*/ class list<StringIDAssociation>::iterator);
	void splice(/*packed*/ class list<StringIDAssociation>::iterator, /*packed*/ class list<StringIDAssociation>&);
	void remove(const /*packed*/ struct StringIDAssociation&);
	void unique();
	void merge(/*packed*/ class list<StringIDAssociation>&);
	void reverse();
	void sort();
};

// Type: /*packed*/ struct StringIDAssociation (forward reference);
struct StringIDAssociation{ // packed(0xc bytes) TI: 0x29e4
	/*+0x0*/   /*packed*/ class basic_string<char> sName; // 0x8 bytes
	/*+0x8*/   long lID;
	void StringIDAssociation(/*packed*/ class basic_string<char>&, long);
	void StringIDAssociation();
};

// Type: /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator (forward reference);
class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator : public bidirectional_iterator<long,int>
{ // packed(0x4 bytes) TI: 0x2c27
protected:
	/*+0x0*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *node;
public:
	void const_iterator(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator&);
	void const_iterator();
protected:
	void const_iterator(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
public:
	int32_t operator==(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator&);
	int32_t operator!=(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator&);
	const long& operator*();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator operator++(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator& operator++();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator operator--(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator& operator--();
};

// Type: /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>> (forward reference);
class rb_tree<long,long,ident<long,long>,less<long>>{ // packed(0xd bytes) TI: 0x2ca3
	enum color_type {
		red = 0,
		black = 1,
	};
	using void_pointer = void * __ptr32;
	struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node{ // packed(0x14 bytes) TI: 0x2cb4
		/*+0x0*/   enum rb_tree<long,long,ident<long,long>,less<long>>::color_type color_field;
		/*+0x4*/   void * __ptr32 parent_link;
		/*+0x8*/   void * __ptr32 left_link;
		/*+0xc*/   void * __ptr32 right_link;
		/*+0x10*/  long value_field;
	};
protected:
	static /*packed*/ class allocator<rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node> rb_tree_node_allocator;
	static /*packed*/ class allocator<long> value_allocator;
	using key_type = long;
	using value_type = long;
	using pointer = long *;
	using reference = long&;
	using const_reference = const long&;
	using rb_tree_node_allocator_type = /*packed*/ class allocator<rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node>;
	using link_type = /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*;
	using size_type = uint32_t;
	using difference_type = int32_t;
protected:
	uint32_t buffer_size();
	struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer{ // packed(0x8 bytes) TI: 0x2cb2
		/*+0x0*/   void * __ptr32 next_buffer;
		/*+0x4*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *buffer;
	};
	using buffer_allocator_type = /*packed*/ class allocator<rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer>;
	using buffer_pointer = /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer*;
protected:
	static /*packed*/ class allocator<rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer> buffer_allocator;
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer *buffer_list;
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *free_list;
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *next_avail;
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *last;
	void add_new_buffer();
	static uint32_t number_of_trees;
	void deallocate_buffers();
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node* get_node();
	void put_node(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	/*+0x0*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *header;
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& root();
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& root();
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& leftmost();
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& leftmost();
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& rightmost();
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& rightmost();
	/*+0x4*/   uint32_t node_count;
	/*+0x8*/   int32_t insert_always;
	/*+0xc*/   /*packed*/ struct less<long> key_compare; // 0x1 bytes
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *NIL;
	// calltype: NearC
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& left(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	// calltype: NearC
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& right(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	// calltype: NearC
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*& parent(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	// calltype: NearC
	static long& value(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	// calltype: NearC
	static const long& key(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	// calltype: NearC
	static enum rb_tree<long,long,ident<long,long>,less<long>>::color_type& color(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	// calltype: NearC
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node* minimum(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	// calltype: NearC
	static /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node* maximum(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	class rb_tree<long,long,ident<long,long>,less<long>>::iterator : public bidirectional_iterator<long,int>
	{ // packed(0x4 bytes) TI: 0x2cb0
	protected:
		/*+0x0*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *node;
	public:
		void iterator();
	protected:
		void iterator(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	public:
		int32_t operator==(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator&);
		long& operator*();
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator operator++(int32_t);
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator& operator++();
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator operator--(int32_t);
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator& operator--();
	};
	class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator : public bidirectional_iterator<long,int>
	{ // packed(0x4 bytes) TI: 0x2c27
	protected:
		/*+0x0*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *node;
	public:
		void const_iterator(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator&);
		void const_iterator();
	protected:
		void const_iterator(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	public:
		int32_t operator==(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator&);
		int32_t operator!=(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator&);
		const long& operator*();
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator operator++(int32_t);
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator& operator++();
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator operator--(int32_t);
		/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator& operator--();
	};
	using reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::iterator,long,long &,int>;
	using const_reverse_iterator = /*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,long,long const &,int>;
private:
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator __insert(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*, /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*, const long&);
	/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node* __copy(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*, /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	void __erase(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	void init();
public:
	void rb_tree<long,long,ident<long,long>,less<long>>(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>&, int32_t);
	void rb_tree<long,long,ident<long,long>,less<long>>(long *, long *, const /*packed*/ struct less<long>&, int32_t);
	void rb_tree<long,long,ident<long,long>,less<long>>(const /*packed*/ struct less<long>&, int32_t);
	void ~rb_tree<long,long,ident<long,long>,less<long>>();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>& operator=(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>&);
	/*packed*/ struct less<long> key_comp();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator begin();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator begin();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator end();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator end();
	/*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,long,long const &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::iterator,long,long &,int> rbegin();
	/*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,long,long const &,int> rend();
	/*unpacked*/ class reverse_bidirectional_iterator<rb_tree<long,long,ident<long,long>,less<long>>::iterator,long,long &,int> rend();
	int32_t empty();
	uint32_t size();
	uint32_t max_size();
	void swap(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>&);
	using pair_iterator_bool = /*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::iterator,int>;
public:
	void insert(long *, long *);
	void insert(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator, /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator insert(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator, const long&);
	/*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::iterator,int> insert(const long&);
	void erase(long *, long *);
	void erase(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator, /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator);
	uint32_t erase(const long&);
	void erase(/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator find(const long&);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator find(const long&);
	uint32_t count(const long&);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator lower_bound(const long&);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator lower_bound(const long&);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator upper_bound(const long&);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator upper_bound(const long&);
	using pair_iterator_iterator = /*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::iterator,rb_tree<long,long,ident<long,long>,less<long>>::iterator>;
public:
	/*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,rb_tree<long,long,ident<long,long>,less<long>>::const_iterator> equal_range(const long&);
	/*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::iterator,rb_tree<long,long,ident<long,long>,less<long>>::iterator> equal_range(const long&);
	using pair_citerator_citerator = /*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::const_iterator,rb_tree<long,long,ident<long,long>,less<long>>::const_iterator>;
public:
	void rotate_left(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
	void rotate_right(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
};

// Type: /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator (forward reference);
class rb_tree<long,long,ident<long,long>,less<long>>::iterator : public bidirectional_iterator<long,int>
{ // packed(0x4 bytes) TI: 0x2cb0
protected:
	/*+0x0*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
public:
	int32_t operator==(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator&);
	long& operator*();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator operator++(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator& operator++();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator operator--(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator& operator--();
};

// Type: /*unpacked*/ class basic_string_ref<char> (forward reference);
// basic_string_ref<char> Class implementation not found

// Type: enum capacity;
enum capacity {
	default_size = 0,
	reserve = 1,
};

// Type: /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator;
class rb_tree<long,long,ident<long,long>,less<long>>::iterator : public bidirectional_iterator<long,int>
{ // packed(0x4 bytes) TI: 0x2cb0
protected:
	/*+0x0*/   /*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *node;
public:
	void iterator();
protected:
	void iterator(/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node*);
public:
	int32_t operator==(const /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator&);
	long& operator*();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator operator++(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator& operator++();
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator operator--(int32_t);
	/*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::iterator& operator--();
};

// Type: /*unpacked*/ struct pair<rb_tree<long,long,ident<long,long>,less<long>>::iterator,int> (forward reference);
// pair<rb_tree<long,long,ident<long,long>,less<long>>::iterator,int> Class implementation not found

// Type: /*packed*/ struct bidirectional_iterator<Shortcut,int>;
struct bidirectional_iterator<Shortcut,int>{ // packed(0x1 bytes) TI: 0x1ee7
};

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: /*packed*/ struct bidirectional_iterator<long,int>;
struct bidirectional_iterator<long,int>{ // packed(0x1 bytes) TI: 0x2c2e
};

// Type: /*packed*/ struct SparkalPoint;
struct SparkalPoint{ // packed(0x8 bytes) TI: 0x1a54
	/*+0x0*/   long x;
	/*+0x4*/   long y;
	void SparkalPoint(long, long);
	void SparkalPoint();
};

// Type: /*packed*/ struct bidirectional_iterator<HotSpot,int>;
struct bidirectional_iterator<HotSpot,int>{ // packed(0x1 bytes) TI: 0x1f71
};

// Type: /*packed*/ struct bidirectional_iterator<StringIDAssociation,int>;
struct bidirectional_iterator<StringIDAssociation,int>{ // packed(0x1 bytes) TI: 0x2878
};

// Type: /*packed*/ struct bidirectional_iterator<KeyColors,int>;
struct bidirectional_iterator<KeyColors,int>{ // packed(0x1 bytes) TI: 0x2877
};



// Contribution: 1:00000000-000001ac Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00401000
// basic_string<char>::operator vector<char>



// Contribution: 1:000001b0-000001e8 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004011b0
// endl



// Contribution: 1:000001f0-00000207 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004011f0
// flush



// Contribution: 1:00000210-0000023b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00401210
// `vector constructor iterator'



// Contribution: 1:00000240-00000279 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x00401240
// `vector destructor iterator'



// Contribution: 1:00000280-0000c7d4 Module: 75, 16 byte alignment, code, execute, read, 
// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x00401280
static void $E97() {

	__asm        call   $E96;
	__asm        jmp    __RETURN;
__RETURN:
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x00401295
static void $E96() {

	__asm        mov    colorTextGamePaletteNormal.Blue, 0xA;
	__asm        mov    colorTextGamePaletteNormal.Green, 0x85;
	__asm        mov    colorTextGamePaletteNormal.Red, 0xDA;
	__asm        jmp    _T20;
_T20:
	return;
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x004012bf
static void $E100() {

	__asm        call   $E99;
	__asm        jmp    __RETURN;
__RETURN:
}

// STATIC INITIALIZER:
// SYNTHETIC: COPTER_D 0x004012d4
static void $E99() {

	__asm        mov    colorTextGamePaletteHighlighted.Blue, 0x6F;
	__asm        mov    colorTextGamePaletteHighlighted.Green, 0xDA;
	__asm        mov    colorTextGamePaletteHighlighted.Red, 0xFF;
	__asm        jmp    _T20;
_T20:
	return;
}

// FUNCTION: COPTER_D 0x004012fe
void KeyboardWindow::KeyboardWindow(/*packed*/ class MRect& rectNewPosition, int32_t nNewID, /*unpacked*/ class GraphicWindow *windowNewParent, /*packed*/ class GraphicWindowOwner *myNewOwner, int32_t bAddToParentList) {

	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, bAddToParentList;
	__asm        push   eax;
	__asm        mov    eax, myNewOwner;
	__asm        push   eax;
	__asm        mov    eax, windowNewParent;
	__asm        push   eax;
	__asm        mov    eax, nNewID;
	__asm        push   eax;
	__asm        mov    eax, rectNewPosition;
	__asm        push   eax;
	__asm        mov    eax, SZ_KEYBOARD_IMAGE_FILE_NAME;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::GraphicWindow;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x78], 0;
	__asm        inc    list<HotSpot>::number_of_lists;
	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    [ebp-4], eax;
	__asm        cmp    list<HotSpot>::free_list, 0;
	__asm        je     _T78;

	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<HotSpot>::free_list, eax;
	__asm        mov    eax, [ebp-4];
	__asm        mov    [ebp-0x48], eax;
	__asm        jmp    _T213;
_T78:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        cmp    list<HotSpot>::last, eax;
	__asm        jne    _T1fe;

	__asm        jmp    _T8e;
_T8e:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    dword ptr [ebp-0x14], 0x92;
	__asm        lea    eax, [ebp-0x14];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    dword ptr [ebp-0x18], 1;
	__asm        lea    eax, [ebp-0x18];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    ecx, [ebp-0x1C];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _Td2;

	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _Td8;
_Td2:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x24], eax;
_Td8:
	__asm        jmp    _Tdd;
_Tdd:
	__asm        jmp    _Te2;
_Te2:
	__asm        jmp    _Te7;
_Te7:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x44], eax;
	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    ecx, eax;
	__asm        shl    eax, 3;
	__asm        sub    eax, ecx;
	__asm        shl    eax, 2;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x3C], eax;
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        jne    _T149;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T13f;
_T13f:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T149:
	__asm        jmp    _T14e;
_T14e:
	__asm        jmp    _T153;
_T153:
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    ecx, [ebp-0x10];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    ecx, [ebp-0x10];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    list<HotSpot>::buffer_list, eax;
	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<HotSpot>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x28], 0x92;
	__asm        lea    eax, [ebp-0x28];
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    dword ptr [ebp-0x2C], 1;
	__asm        lea    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x34], eax;
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    ecx, [ebp-0x30];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T1b0;

	__asm        mov    eax, [ebp-0x34];
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    _T1b6;
_T1b0:
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x38], eax;
_T1b6:
	__asm        jmp    _T1bb;
_T1bb:
	__asm        jmp    _T1c0;
_T1c0:
	__asm        jmp    _T1c5;
_T1c5:
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        shl    eax, 3;
	__asm        sub    eax, ecx;
	__asm        shl    eax, 2;
	__asm        add    eax, list<HotSpot>::next_avail;
	__asm        mov    list<HotSpot>::last, eax;
	__asm        jmp    _T1e4;
_T1e4:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        mov    [ebp-8], eax;
	__asm        add    list<HotSpot>::next_avail, 0x1C;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-0x48], eax;
	__asm        jmp    _T213;
_T1fe:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        mov    [ebp-0xC], eax;
	__asm        add    list<HotSpot>::next_avail, 0x1C;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    [ebp-0x48], eax;
_T213:
	__asm        jmp    _T218;
_T218:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x74], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T252;
_T252:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x80], 0;
	__asm        inc    list<HotSpot>::number_of_lists;
	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    [ebp-0x4C], eax;
	__asm        cmp    list<HotSpot>::free_list, 0;
	__asm        je     _T297;

	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<HotSpot>::free_list, eax;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _T3ea;
_T297:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        cmp    list<HotSpot>::last, eax;
	__asm        jne    _T3d2;

	__asm        jmp    _T2ad;
_T2ad:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    dword ptr [ebp-0x5C], 0x92;
	__asm        lea    eax, [ebp-0x5C];
	__asm        mov    [ebp-0x64], eax;
	__asm        mov    dword ptr [ebp-0x60], 1;
	__asm        lea    eax, [ebp-0x60];
	__asm        mov    [ebp-0x68], eax;
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    ecx, [ebp-0x64];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T2f1;

	__asm        mov    eax, [ebp-0x68];
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T2f7;
_T2f1:
	__asm        mov    eax, [ebp-0x64];
	__asm        mov    [ebp-0x6C], eax;
_T2f7:
	__asm        jmp    _T2fc;
_T2fc:
	__asm        jmp    _T301;
_T301:
	__asm        jmp    _T306;
_T306:
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x84], eax;
	__asm        jmp    _T316;
_T316:
	__asm        push   0;
	__asm        mov    eax, [ebp-0x84];
	__asm        push   eax;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    ecx, [ebp-0x58];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    ecx, [ebp-0x58];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    list<HotSpot>::buffer_list, eax;
	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<HotSpot>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x70], 0x92;
	__asm        lea    eax, [ebp-0x70];
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    dword ptr [ebp-0x74], 1;
	__asm        lea    eax, [ebp-0x74];
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    ecx, [ebp-0x78];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T381;

	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    [ebp-0x80], eax;
	__asm        jmp    _T387;
_T381:
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    [ebp-0x80], eax;
_T387:
	__asm        jmp    _T38c;
_T38c:
	__asm        jmp    _T391;
_T391:
	__asm        jmp    _T396;
_T396:
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        shl    eax, 3;
	__asm        sub    eax, ecx;
	__asm        shl    eax, 2;
	__asm        add    eax, list<HotSpot>::next_avail;
	__asm        mov    list<HotSpot>::last, eax;
	__asm        jmp    _T3b5;
_T3b5:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        mov    [ebp-0x50], eax;
	__asm        add    list<HotSpot>::next_avail, 0x1C;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _T3ea;
_T3d2:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        mov    [ebp-0x54], eax;
	__asm        add    list<HotSpot>::next_avail, 0x1C;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    [ebp-0x88], eax;
_T3ea:
	__asm        jmp    _T3ef;
_T3ef:
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x7C], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T42c;
_T42c:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x88], 0;
	__asm        inc    list<HotSpot>::number_of_lists;
	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    [ebp-0x8C], eax;
	__asm        cmp    list<HotSpot>::free_list, 0;
	__asm        je     _T477;

	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<HotSpot>::free_list, eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    [ebp-0xC8], eax;
	__asm        jmp    _T630;
_T477:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        cmp    list<HotSpot>::last, eax;
	__asm        jne    _T612;

	__asm        jmp    _T48d;
_T48d:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    dword ptr [ebp-0x9C], 0x92;
	__asm        lea    eax, [ebp-0x9C];
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    dword ptr [ebp-0xA0], 1;
	__asm        lea    eax, [ebp-0xA0];
	__asm        mov    [ebp-0xA8], eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    ecx, [ebp-0xA4];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T4f2;

	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    [ebp-0xAC], eax;
	__asm        jmp    _T4fe;
_T4f2:
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    [ebp-0xAC], eax;
_T4fe:
	__asm        jmp    _T503;
_T503:
	__asm        jmp    _T508;
_T508:
	__asm        jmp    _T50d;
_T50d:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xC4], eax;
	__asm        jmp    _T520;
_T520:
	__asm        push   0;
	__asm        mov    eax, [ebp-0xC4];
	__asm        push   eax;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    ecx, [ebp-0x98];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    ecx, [ebp-0x98];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    list<HotSpot>::buffer_list, eax;
	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<HotSpot>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0xB0], 0x92;
	__asm        lea    eax, [ebp-0xB0];
	__asm        mov    [ebp-0xB8], eax;
	__asm        mov    dword ptr [ebp-0xB4], 1;
	__asm        lea    eax, [ebp-0xB4];
	__asm        mov    [ebp-0xBC], eax;
	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    ecx, [ebp-0xB8];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T5b2;

	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    [ebp-0xC0], eax;
	__asm        jmp    _T5be;
_T5b2:
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    [ebp-0xC0], eax;
_T5be:
	__asm        jmp    _T5c3;
_T5c3:
	__asm        jmp    _T5c8;
_T5c8:
	__asm        jmp    _T5cd;
_T5cd:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, eax;
	__asm        shl    eax, 3;
	__asm        sub    eax, ecx;
	__asm        shl    eax, 2;
	__asm        add    eax, list<HotSpot>::next_avail;
	__asm        mov    list<HotSpot>::last, eax;
	__asm        jmp    _T5ef;
_T5ef:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        mov    [ebp-0x90], eax;
	__asm        add    list<HotSpot>::next_avail, 0x1C;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0xC8], eax;
	__asm        jmp    _T630;
_T612:
	__asm        mov    eax, list<HotSpot>::next_avail;
	__asm        mov    [ebp-0x94], eax;
	__asm        add    list<HotSpot>::next_avail, 0x1C;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0xC8], eax;
_T630:
	__asm        jmp    _T635;
_T635:
	__asm        mov    eax, [ebp-0xC8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x84], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x84];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x84];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x84];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x84];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T681;
_T681:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x94], 0;
	__asm        inc    list<KeyColors>::number_of_lists;
	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    [ebp-0xCC], eax;
	__asm        cmp    list<KeyColors>::free_list, 0;
	__asm        je     _T6cc;

	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<KeyColors>::free_list, eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    [ebp-0xD8], eax;
	__asm        jmp    _T72f;
_T6cc:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        cmp    list<KeyColors>::last, eax;
	__asm        jne    _T711;

	__asm        mov    ecx, this;
	__asm        add    ecx, 0x90;
	__asm        call   list<KeyColors>::add_new_buffer;
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0xD0], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0xD0];
	__asm        mov    [ebp-0xD8], eax;
	__asm        jmp    _T72f;
_T711:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0xD4], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    [ebp-0xD8], eax;
_T72f:
	__asm        jmp    _T734;
_T734:
	__asm        mov    eax, [ebp-0xD8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x90], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x90];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x90];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T780;
_T780:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x98], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x9C], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xA0], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x58F058;
// LINE 69:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00401acc
void KeyboardWindow::~KeyboardWindow() {

	this-><KeyboardWindow+0x00> = 0x58f058;
// LINE 77:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xA0], 0;
	__asm        je     _T7e;
// LINE 78:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T6e;

	__asm        mov    ecx, [ebp-4];
	__asm        call   MFont::~MFont;
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T69;
_T69:
	__asm        jmp    _T6e;
// LINE 79:
_T6e:
	this->mFontToUse = 0x0;
// LINE 81:
_T7e:
	__asm        mov    ecx, this;
	__asm        call   KeyboardWindow::DestroyImage;
// LINE 82:
	__asm        jmp    _T8e;
_T8e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Ta8;
_Ta8:
	__asm        jmp    _Tad;
_Tad:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _Tc9;
_Tc9:
	__asm        jmp    _Tce;
_Tce:
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0x34], eax;
_Tda:
	__asm        mov    eax, [ebp-0x30];
	__asm        cmp    [ebp-0x34], eax;
	__asm        jne    _Tf0;

	__asm        jmp    _T104;

	__asm        jmp    _Tf0;
_Tf0:
	__asm        jmp    _Tff;

	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        jne    _T104;
_Tff:
	__asm        jmp    _T109;
_T104:
	__asm        jmp    _T150;
_T109:
	__asm        jmp    _T118;

	__asm        cmp    dword ptr [ebp-0x2C], 0;
	__asm        je     _T150;
_T118:
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    [ebp-0x24], eax;
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T12b;
_T12b:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T136;
_T136:
	__asm        mov    eax, [ebp-0x20];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x90;
	__asm        call   list<KeyColors>::erase;
	__asm        jmp    _Tda;
_T150:
	__asm        jmp    _T155;
_T155:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    [ebp-0x14], eax;
	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    ecx, [ebp-0x14];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    list<KeyColors>::free_list, eax;
	__asm        jmp    _T17b;
_T17b:
	__asm        dec    list<KeyColors>::number_of_lists;
	__asm        jne    _T198;

	__asm        mov    ecx, this;
	__asm        add    ecx, 0x90;
	__asm        call   list<KeyColors>::deallocate_buffers;
_T198:
	__asm        jmp    _T19d;
_T19d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x84];
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    _T1b7;
_T1b7:
	__asm        jmp    _T1bc;
_T1bc:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x84];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    _T1d8;
_T1d8:
	__asm        jmp    _T1dd;
_T1dd:
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x5C], eax;
_T1e9:
	__asm        mov    eax, [ebp-0x58];
	__asm        cmp    [ebp-0x5C], eax;
	__asm        jne    _T1ff;

	__asm        jmp    _T213;

	__asm        jmp    _T1ff;
_T1ff:
	__asm        jmp    _T20e;

	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        jne    _T213;
_T20e:
	__asm        jmp    _T218;
_T213:
	__asm        jmp    _T24e;
_T218:
	__asm        jmp    _T227;

	__asm        cmp    dword ptr [ebp-0x54], 0;
	__asm        je     _T24e;
_T227:
	__asm        push   0;
	__asm        lea    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        lea    ecx, [ebp-0x5C];
	__asm        call   list<HotSpot>::iterator::operator++;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x84;
	__asm        call   list<HotSpot>::erase;
	__asm        jmp    _T1e9;
_T24e:
	__asm        jmp    _T253;
_T253:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x84];
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    ecx, [ebp-0x40];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    list<HotSpot>::free_list, eax;
	__asm        jmp    _T279;
_T279:
	__asm        dec    list<HotSpot>::number_of_lists;
	__asm        jne    _T303;
_T285:
	__asm        cmp    list<HotSpot>::buffer_list, 0;
	__asm        je     _T2e0;

	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    [ebp-0x60], eax;
	__asm        mov    eax, list<HotSpot>::buffer_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<HotSpot>::buffer_list, eax;
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x64], eax;
	__asm        mov    eax, [ebp-0x64];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T2c0;
_T2c0:
	__asm        jmp    _T2c5;
_T2c5:
	__asm        mov    eax, [ebp-0x60];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T2d6;
_T2d6:
	__asm        jmp    _T2db;
_T2db:
	__asm        jmp    _T285;
_T2e0:
	__asm        mov    list<HotSpot>::free_list, 0;
	__asm        mov    list<HotSpot>::next_avail, 0;
	__asm        mov    list<HotSpot>::last, 0;
	__asm        jmp    _T303;
_T303:
	__asm        jmp    _T308;
_T308:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        mov    [ebp-0x74], eax;
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    [ebp-0x68], eax;
	__asm        jmp    _T31f;
_T31f:
	__asm        jmp    _T324;
_T324:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T33d;
_T33d:
	__asm        jmp    _T342;
_T342:
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    [ebp-0x88], eax;
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    [ebp-0x8C], eax;
_T354:
	__asm        mov    eax, [ebp-0x8C];
	__asm        cmp    [ebp-0x88], eax;
	__asm        jne    _T370;

	__asm        jmp    _T384;

	__asm        jmp    _T370;
_T370:
	__asm        jmp    _T37f;

	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        jne    _T384;
_T37f:
	__asm        jmp    _T389;
_T384:
	__asm        jmp    _T3c2;
_T389:
	__asm        jmp    _T39b;

	__asm        cmp    dword ptr [ebp-0x84], 0;
	__asm        je     _T3c2;
_T39b:
	__asm        push   0;
	__asm        lea    eax, [ebp-0x7C];
	__asm        push   eax;
	__asm        lea    ecx, [ebp-0x8C];
	__asm        call   list<HotSpot>::iterator::operator++;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x7C;
	__asm        call   list<HotSpot>::erase;
	__asm        jmp    _T354;
_T3c2:
	__asm        jmp    _T3c7;
_T3c7:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        mov    [ebp-0x70], eax;
	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    ecx, [ebp-0x70];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x70];
	__asm        mov    list<HotSpot>::free_list, eax;
	__asm        jmp    _T3ea;
_T3ea:
	__asm        dec    list<HotSpot>::number_of_lists;
	__asm        jne    _T404;

	__asm        mov    ecx, this;
	__asm        add    ecx, 0x7C;
	__asm        call   list<HotSpot>::deallocate_buffers;
_T404:
	__asm        jmp    _T409;
_T409:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0x9C], eax;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T429;
_T429:
	__asm        jmp    _T42e;
_T42e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xA0], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    [ebp-0x94], eax;
	__asm        jmp    _T450;
_T450:
	__asm        jmp    _T455;
_T455:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0xB4], eax;
_T46d:
	__asm        mov    eax, [ebp-0xB0];
	__asm        cmp    [ebp-0xB4], eax;
	__asm        jne    _T489;

	__asm        jmp    _T4a0;

	__asm        jmp    _T489;
_T489:
	__asm        jmp    _T49b;

	__asm        cmp    dword ptr [ebp-0xA8], 0;
	__asm        jne    _T4a0;
_T49b:
	__asm        jmp    _T4a5;
_T4a0:
	__asm        jmp    _T4e1;
_T4a5:
	__asm        jmp    _T4b7;

	__asm        cmp    dword ptr [ebp-0xAC], 0;
	__asm        je     _T4e1;
_T4b7:
	__asm        push   0;
	__asm        lea    eax, [ebp-0xA4];
	__asm        push   eax;
	__asm        lea    ecx, [ebp-0xB4];
	__asm        call   list<HotSpot>::iterator::operator++;
	__asm        mov    eax, [eax];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x74;
	__asm        call   list<HotSpot>::erase;
	__asm        jmp    _T46d;
_T4e1:
	__asm        jmp    _T4e6;
_T4e6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    eax, list<HotSpot>::free_list;
	__asm        mov    ecx, [ebp-0x98];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    list<HotSpot>::free_list, eax;
	__asm        jmp    _T512;
_T512:
	__asm        dec    list<HotSpot>::number_of_lists;
	__asm        jne    _T52c;

	__asm        mov    ecx, this;
	__asm        add    ecx, 0x74;
	__asm        call   list<HotSpot>::deallocate_buffers;
_T52c:
	return;

	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::~GraphicWindow;
}

// FUNCTION: COPTER_D 0x0040200d
int32_t KeyboardWindow::Initialize() {
// LINE 90:
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::Initialize;
// LINE 91:
	__asm        mov    eax, gDefaultLanguage;
	__asm        add    eax, 0xC8;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x74;
	__asm        push   eax;
	__asm        call   LoadListFromResource;
	__asm        add    esp, 8;
// LINE 92:
	__asm        mov    eax, gDefaultLanguage;
	__asm        add    eax, 0x12C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x7C;
	__asm        push   eax;
	__asm        call   LoadListFromResource;
	__asm        add    esp, 8;
// LINE 93:
	__asm        mov    eax, gDefaultLanguage;
	__asm        add    eax, 0x190;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x84;
	__asm        push   eax;
	__asm        call   LoadListFromResource;
	__asm        add    esp, 8;
// LINE 94:
	__asm        push   0x90;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA4], eax;
// LINE 95:
	__asm        push   0x14;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA8], eax;
// LINE 96:
	__asm        push   0x91;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xAC], eax;
// LINE 97:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xA4], 0;
	__asm        je     _Tc7;
// LINE 98:
	this->myCurrentlyUsedNumLockHotSpotList = (this + 0x7c);
// LINE 99:
	__asm        jmp    _Td8;
// LINE 100:
_Tc7:
	this->myCurrentlyUsedNumLockHotSpotList = (this + 0x84);
// LINE 101:
_Td8:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   GraphicWindow::MakeFocus;
	__asm        add    esp, 4;
// LINE 103:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
	__asm        jmp    __RETURN;
// LINE 104:
__RETURN:
}

// FUNCTION: COPTER_D 0x00402108
int32_t KeyboardWindow::CreateImage(int32_t bResizeWindowToFitImage) {
	/*bp-0x8*/   /*packed*/ class basic_string<char> sNonTextKeyPath; // 0x8 bytes
	/*bp-0x10*/  /*packed*/ class basic_string<char> sKeyLightPath; // 0x8 bytes

// LINE 112:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x80], eax;
	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        je     _T62;

	__asm        mov    eax, [ebp-0x80];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x80];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T57;
_T57:
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    sKeyLightPath.reference, eax;
	__asm        jmp    _T69;
_T62:
	sKeyLightPath.reference = 0x0;
_T69:
	__asm        mov    sKeyLightPath.c_str_ptr, 0;
	__asm        jmp    _T75;
// LINE 113:
_T75:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x84], eax;
	__asm        cmp    dword ptr [ebp-0x84], 0;
	__asm        je     _Tdd;

	__asm        mov    eax, [ebp-0x84];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x84];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _Tcf;
_Tcf:
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    sNonTextKeyPath.reference, eax;
	__asm        jmp    _Te4;
_Tdd:
	sNonTextKeyPath.reference = 0x0;
_Te4:
	__asm        mov    sNonTextKeyPath.c_str_ptr, 0;
	__asm        jmp    _Tf0;
// LINE 116:
_Tf0:
	__asm        mov    eax, bResizeWindowToFitImage;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::CreateImage;
// LINE 117:
	__asm        mov    eax, GraphicWindow::colorConstants.nPaletteIndexTransparent;
	__asm        push   eax;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x40];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x40];
	__asm        call   dword ptr [edx+8];
// LINE 119:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        jne    _T32a;

	__asm        mov    eax, SZ_KEYBOARD_LIGHT_IMAGE_FILE_NAME;
	__asm        mov    [ebp-0x7C], eax;
// LINE 120:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x78], eax;
	__asm        cmp    dword ptr [ebp-0x78], 0;
	__asm        je     _T164;

	__asm        mov    eax, [ebp-0x7C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x78];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T16b;
_T164:
	__asm        mov    dword ptr [ebp-0x14], 0;
_T16b:
	__asm        mov    dword ptr [ebp-0x18], 0;
	__asm        jmp    _T177;
_T177:
	__asm        lea    eax, sKeyLightPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x18];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   6;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T192;
_T192:
	__asm        mov    eax, [ebp-0x14];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x14];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T1ca;

	__asm        mov    eax, [ebp-0x14];
	__asm        mov    [ebp-0x74], eax;
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    [ebp-0x70], eax;
	__asm        cmp    dword ptr [ebp-0x70], 0;
	__asm        je     _T1ca;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x70];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T1ca;
_T1ca:
	__asm        jmp    _T1cf;
_T1cf:
	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        je     _T1f1;

	__asm        mov    eax, [ebp-0x18];
	__asm        mov    [ebp-0x68], eax;
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    [ebp-0x6C], eax;
	__asm        mov    eax, [ebp-0x6C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T1f1:
	__asm        jmp    _T1f6;
// LINE 121:
_T1f6:
	__asm        push   0x134;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1C], eax;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T31a;

	__asm        cmp    sKeyLightPath.c_str_ptr, 0;
	__asm        je     _T23e;

	__asm        mov    eax, sKeyLightPath.c_str_ptr;
	__asm        mov    [ebp-0x88], eax;
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    [ebp-0x90], eax;
	__asm        mov    eax, [ebp-0x90];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T23e:
	__asm        jmp    _T243;
_T243:
	__asm        mov    eax, sKeyLightPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        inc    eax;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    sKeyLightPath.c_str_ptr, eax;
	__asm        jmp    _T25b;
_T25b:
	__asm        mov    eax, sKeyLightPath.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T2b2;

	__asm        jmp    _T26d;
_T26d:
	__asm        mov    eax, sKeyLightPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x9C], eax;
	__asm        lea    ecx, sKeyLightPath.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        mov    [ebp-0xA0], eax;
	__asm        mov    eax, sKeyLightPath.c_str_ptr;
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    eax, [ebp-0x9C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xA4];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T2b2;
_T2b2:
	__asm        jmp    _T2b7;
_T2b7:
	__asm        mov    byte ptr [ebp-0x8C], 0;
	__asm        jmp    _T2c3;
_T2c3:
	__asm        lea    eax, [ebp-0x8C];
	__asm        mov    [ebp-0x94], eax;
	__asm        jmp    _T2d4;
_T2d4:
	__asm        mov    eax, sKeyLightPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, sKeyLightPath.c_str_ptr;
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    al, [eax];
	__asm        mov    ecx, [ebp-0x98];
	__asm        mov    [ecx], al;
	__asm        jmp    _T2f8;
_T2f8:
	__asm        jmp    _T2fd;
_T2fd:
	__asm        mov    eax, sKeyLightPath.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x1C];
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x98], eax;
	__asm        jmp    _T32a;
_T31a:
	this->myKeyLightImage = 0x0;
// LINE 123:
_T32a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9C], 0;
	__asm        jne    _T473;

	__asm        mov    eax, SZ_KEYBOARD_NON_TEXT_IMAGE_FILE_NAME;
	__asm        mov    [ebp-0x64], eax;
// LINE 124:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x60], eax;
	__asm        cmp    dword ptr [ebp-0x60], 0;
	__asm        je     _T370;

	__asm        mov    eax, [ebp-0x64];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x60];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T377;
_T370:
	__asm        mov    dword ptr [ebp-0x20], 0;
_T377:
	__asm        mov    dword ptr [ebp-0x24], 0;
	__asm        jmp    _T383;
_T383:
	__asm        lea    eax, sNonTextKeyPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x24];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   6;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T39e;
_T39e:
	__asm        mov    eax, [ebp-0x20];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x20];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T3d6;

	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x38], eax;
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _T3d6;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x38];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T3d6;
_T3d6:
	__asm        jmp    _T3db;
_T3db:
	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        je     _T3fd;

	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x34], eax;
	__asm        mov    eax, [ebp-0x34];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T3fd:
	__asm        jmp    _T402;
// LINE 125:
_T402:
	__asm        push   0x134;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x28], eax;
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T43e;

	__asm        lea    ecx, sNonTextKeyPath.c_str_ptr;
	__asm        call   basic_string<char>::c_str;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x28];
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x9C], eax;
	__asm        jmp    _T44e;
_T43e:
	this->myNonTextKeyImage = 0x0;
// LINE 126:
_T44e:
	__asm        mov    eax, GraphicWindow::colorConstants.nPaletteIndexTransparent;
	__asm        push   eax;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x9C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x9C];
	__asm        call   dword ptr [edx+8];
// LINE 129:
_T473:
	__asm        mov    dword ptr [ebp-0x2C], 1;
	__asm        mov    eax, sNonTextKeyPath.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sNonTextKeyPath.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T4b2;

	__asm        mov    eax, sNonTextKeyPath.reference;
	__asm        mov    [ebp-0x4C], eax;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    [ebp-0x48], eax;
	__asm        cmp    dword ptr [ebp-0x48], 0;
	__asm        je     _T4b2;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x48];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T4b2;
_T4b2:
	__asm        jmp    _T4b7;
_T4b7:
	__asm        cmp    sNonTextKeyPath.c_str_ptr, 0;
	__asm        je     _T4d9;

	__asm        mov    eax, sNonTextKeyPath.c_str_ptr;
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T4d9:
	__asm        jmp    _T4de;
_T4de:
	__asm        mov    eax, sKeyLightPath.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sKeyLightPath.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T516;

	__asm        mov    eax, sKeyLightPath.reference;
	__asm        mov    [ebp-0x5C], eax;
	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    [ebp-0x58], eax;
	__asm        cmp    dword ptr [ebp-0x58], 0;
	__asm        je     _T516;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x58];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T516;
_T516:
	__asm        jmp    _T51b;
_T51b:
	__asm        cmp    sKeyLightPath.c_str_ptr, 0;
	__asm        je     _T53d;

	__asm        mov    eax, sKeyLightPath.c_str_ptr;
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x54], eax;
	__asm        mov    eax, [ebp-0x54];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T53d:
	__asm        jmp    _T542;
_T542:
	__asm        mov    eax, [ebp-0x2C];
	__asm        jmp    __RETURN;
// LINE 130:
__RETURN:
}

// FUNCTION: COPTER_D 0x00402659
void KeyboardWindow::DestroyImage() {
// LINE 139:
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::DestroyImage;
// LINE 141:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x98], 0;
	__asm        je     _T6b;
// LINE 142:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T5e;

	__asm        mov    ecx, [ebp-4];
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T59;
_T59:
	__asm        jmp    _T5e;
// LINE 143:
_T5e:
	this->myKeyLightImage = 0x0;
// LINE 145:
_T6b:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x9C], 0;
	__asm        je     _Tc2;
// LINE 146:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x9C];
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Tb5;

	__asm        mov    ecx, [ebp-0xC];
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        mov    eax, [ebp-0xC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _Tb0;
_Tb0:
	__asm        jmp    _Tb5;
// LINE 147:
_Tb5:
	this->myNonTextKeyImage = 0x0;
// LINE 149:
_Tc2:
	return;
}

// FUNCTION: COPTER_D 0x00402725
int32_t KeyboardWindow::ConvertKeyToString(int32_t nLanguage, long lKey, /*packed*/ class basic_string<char>& sKey) {
	/*bp-0x4*/   int32_t nFullStringID;

// LINE 165:
	__asm        mov    eax, nLanguage;
	__asm        push   eax;
	__asm        mov    eax, lKey;
	__asm        add    eax, 0x2BC;
	__asm        push   eax;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 166:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1008], eax;
	__asm        cmp    dword ptr [ebp-0x1008], 0;
	__asm        jne    _T452;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1008], eax;
	__asm        jmp    _T8d;
_T8d:
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1024], eax;
	__asm        cmp    dword ptr [ebp-0x1024], 0xFFFFFFFF;
	__asm        jne    _Te7;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1018], eax;
	__asm        mov    eax, [ebp-0x1018];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _Td8;
_Td8:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _Te7;
_Te7:
	__asm        jmp    _Tec;
_Tec:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T123;

	__asm        cmp    dword ptr [ebp-0x1024], 0;
	__asm        je     _T1d4;

	__asm        jmp    _T10e;
_T10e:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x1024];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T1d4;
_T123:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1010], eax;
	__asm        cmp    dword ptr [ebp-0x1010], 0;
	__asm        je     _T164;

	__asm        mov    eax, [ebp-0x1024];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x1010];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x100C], eax;
	__asm        jmp    _T16e;
_T164:
	__asm        mov    dword ptr [ebp-0x100C], 0;
_T16e:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T1be;

	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1020], eax;
	__asm        mov    eax, [ebp-0x1020];
	__asm        mov    [ebp-0x101C], eax;
	__asm        cmp    dword ptr [ebp-0x101C], 0;
	__asm        je     _T1be;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x101C];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T1be;
_T1be:
	__asm        jmp    _T1c3;
_T1c3:
	__asm        mov    eax, [ebp-0x100C];
	__asm        mov    ecx, sKey;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T216;
_T1d4:
	__asm        cmp    dword ptr [ebp-0x1024], 0;
	__asm        je     _T216;

	__asm        jmp    _T1e6;
_T1e6:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1014], eax;
	__asm        mov    eax, [ebp-0x1024];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1014];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T216;
_T216:
	__asm        mov    eax, [ebp-0x1024];
	__asm        mov    ecx, sKey;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T22a;
_T22a:
	__asm        jmp    _T22f;
_T22f:
	__asm        jmp    _T234;
_T234:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1044], eax;
	__asm        jmp    _T24c;
_T24c:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, 0xFFFFFFFF;
	__asm        sub    ecx, [ebp-0x1044];
	__asm        cmp    [eax+4], ecx;
	__asm        jb     _T29e;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1038], eax;
	__asm        mov    eax, [ebp-0x1038];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T28f;
_T28f:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T29e;
_T29e:
	__asm        jmp    _T2a3;
_T2a3:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T2db;

	__asm        jmp    _T2b8;
_T2b8:
	__asm        jmp    _T2bd;
_T2bd:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, sKey;
	__asm        mov    ecx, [ecx+4];
	__asm        sub    eax, [ecx+4];
	__asm        cmp    eax, [ebp-0x1044];
	__asm        jae    _T3e0;
_T2db:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x102C], eax;
	__asm        cmp    dword ptr [ebp-0x102C], 0;
	__asm        je     _T375;

	__asm        jmp    _T2fd;
_T2fd:
	__asm        jmp    _T302;
_T302:
	__asm        jmp    _T307;
_T307:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T32f;

	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1034], eax;
	__asm        jmp    _T33e;

	__asm        jmp    _T33e;
_T32f:
	__asm        mov    dword ptr [ebp-0x1034], 0;
	__asm        jmp    _T33e;
_T33e:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        add    eax, [ebp-0x1044];
	__asm        push   eax;
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1034];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x102C];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x1028], eax;
	__asm        jmp    _T37f;
_T375:
	__asm        mov    dword ptr [ebp-0x1028], 0;
_T37f:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T3cf;

	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1040], eax;
	__asm        mov    eax, [ebp-0x1040];
	__asm        mov    [ebp-0x103C], eax;
	__asm        cmp    dword ptr [ebp-0x103C], 0;
	__asm        je     _T3cf;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x103C];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T3cf;
_T3cf:
	__asm        jmp    _T3d4;
_T3d4:
	__asm        mov    eax, [ebp-0x1028];
	__asm        mov    ecx, sKey;
	__asm        mov    [ecx+4], eax;
_T3e0:
	__asm        cmp    dword ptr [ebp-0x1044], 0;
	__asm        je     _T42e;

	__asm        jmp    _T3f2;
_T3f2:
	__asm        jmp    _T3f7;
_T3f7:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, sKey;
	__asm        mov    ecx, [ecx+4];
	__asm        add    eax, [ecx];
	__asm        mov    [ebp-0x1030], eax;
	__asm        mov    eax, [ebp-0x1044];
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        mov    eax, [ebp-0x1030];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T42e;
_T42e:
	__asm        mov    eax, [ebp-0x1044];
	__asm        mov    ecx, sKey;
	__asm        mov    ecx, [ecx+4];
	__asm        add    [ecx+4], eax;
	__asm        jmp    _T442;
_T442:
	__asm        jmp    _T447;
_T447:
	__asm        mov    eax, [ebp-0x1008];
	__asm        jmp    _T700;
_T452:
	__asm        jmp    _T457;
_T457:
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x106C], eax;
	__asm        cmp    dword ptr [ebp-0x106C], 0xFFFFFFFF;
	__asm        jne    _T4b1;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1054], eax;
	__asm        mov    eax, [ebp-0x1054];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T4a2;
_T4a2:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T4b1;
_T4b1:
	__asm        jmp    _T4b6;
_T4b6:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T4ed;

	__asm        cmp    dword ptr [ebp-0x106C], 0;
	__asm        je     _T694;

	__asm        jmp    _T4d8;
_T4d8:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x106C];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T694;
_T4ed:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x104C], eax;
	__asm        cmp    dword ptr [ebp-0x104C], 0;
	__asm        je     _T60d;

	__asm        cmp    dword ptr [ebp-0x106C], 0xFFFFFFFF;
	__asm        jne    _T54f;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1068], eax;
	__asm        mov    eax, [ebp-0x1068];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T540;
_T540:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T54f;
_T54f:
	__asm        mov    eax, [ebp-0x106C];
	__asm        mov    ecx, [ebp-0x104C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x104C];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T5de;

	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x104C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1060], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1064], eax;
	__asm        mov    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1064];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T5d9;
_T5d9:
	__asm        jmp    _T5ea;
_T5de:
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    dword ptr [eax], 0;
_T5ea:
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T5fc;
_T5fc:
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    [ebp-0x1048], eax;
	__asm        jmp    _T617;
_T60d:
	__asm        mov    dword ptr [ebp-0x1048], 0;
_T617:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T67e;

	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x105C], eax;
	__asm        mov    eax, [ebp-0x105C];
	__asm        mov    [ebp-0x1058], eax;
	__asm        cmp    dword ptr [ebp-0x1058], 0;
	__asm        je     _T67e;

	__asm        mov    ecx, [ebp-0x1058];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T665;
_T665:
	__asm        mov    eax, [ebp-0x1058];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T679;
_T679:
	__asm        jmp    _T67e;
_T67e:
	__asm        jmp    _T683;
_T683:
	__asm        mov    eax, [ebp-0x1048];
	__asm        mov    ecx, sKey;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T6d6;
_T694:
	__asm        cmp    dword ptr [ebp-0x106C], 0;
	__asm        je     _T6d6;

	__asm        jmp    _T6a6;
_T6a6:
	__asm        mov    eax, sKey;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1050], eax;
	__asm        mov    eax, [ebp-0x106C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1050];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T6d6;
_T6d6:
	__asm        mov    eax, [ebp-0x106C];
	__asm        mov    ecx, sKey;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T6ea;
_T6ea:
	__asm        jmp    _T6ef;
_T6ef:
	__asm        mov    eax, [ebp-0x1008];
	__asm        jmp    _T700;

	__asm        mov    eax, [ebp-0x1070];
_T700:
	__asm        jmp    __RETURN;
// LINE 167:
__RETURN:
}

// FUNCTION: COPTER_D 0x00402e31
int32_t KeyboardWindow::DoesKeyExistOnKeyboard(long lKey) {
	/*bp-0x4*/   /*packed*/ class list<HotSpot>::iterator tempHotSpotListIterator;

// LINE 175:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x38], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T22;
_T22:
	__asm        jmp    _T27;
// LINE 178:
_T27:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0x2C], eax;
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        cmp    [ebp-8], eax;
	__asm        jne    _T56;

	__asm        jmp    _T6a;

	__asm        jmp    _T56;
_T56:
	__asm        jmp    _T65;

	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        jne    _T6a;
_T65:
	__asm        jmp    _T6f;
_T6a:
	__asm        jmp    _Tbf;
_T6f:
	__asm        jmp    _T7e;

	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        je     _Tbf;
// LINE 179:
_T7e:
	__asm        jmp    _T83;
_T83:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    ecx, lKey;
	__asm        cmp    [eax+8], ecx;
	__asm        jne    _T9c;
// LINE 180:
	return 0x1;
// LINE 181:
_T9c:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _Taf;
_Taf:
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Tba;
// LINE 182:
_Tba:
	__asm        jmp    _T27;
_Tbf:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0x40], eax;
// LINE 185:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _Te0;
_Te0:
	__asm        jmp    _Te5;
_Te5:
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    tempHotSpotListIterator.node, eax;
// LINE 23:
_Teb:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0x20], eax;
// LINE 186:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T10a;
_T10a:
	__asm        jmp    _T10f;
_T10f:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        cmp    [ebp-0x14], eax;
	__asm        jne    _T125;

	__asm        jmp    _T139;

	__asm        jmp    _T125;
_T125:
	__asm        jmp    _T134;

	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        jne    _T139;
_T134:
	__asm        jmp    _T13e;
_T139:
	__asm        jmp    _T18e;
_T13e:
	__asm        jmp    _T14d;

	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T18e;
// LINE 187:
_T14d:
	__asm        jmp    _T152;
_T152:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    ecx, lKey;
	__asm        cmp    [eax+8], ecx;
	__asm        jne    _T16b;
// LINE 188:
	return 0x1;
// LINE 189:
_T16b:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T17e;
_T17e:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T189;
// LINE 190:
_T189:
	__asm        jmp    _Teb;
// LINE 191:
_T18e:
	return 0x0;
// LINE 192:
}

// FUNCTION: COPTER_D 0x00402fcd
int32_t KeyboardWindow::DoesPositionHitKey(long lXPosition, long lYPosition, long& lKey) {
	/*bp-0x4*/   /*packed*/ class list<HotSpot>::iterator tempHotSpotListIterator;

// LINE 200:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x38], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T22;
_T22:
	__asm        jmp    _T27;
// LINE 203:
_T27:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0x2C], eax;
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T3b;
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        mov    eax, [ebp-8];
	__asm        cmp    tempHotSpotListIterator.node, eax;
	__asm        jne    _T56;

	__asm        jmp    _T6a;

	__asm        jmp    _T56;
_T56:
	__asm        jmp    _T65;

	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        jne    _T6a;
_T65:
	__asm        jmp    _T6f;
_T6a:
	__asm        jmp    _Tdb;
_T6f:
	__asm        jmp    _T7e;

	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        je     _Tdb;
// LINE 204:
_T7e:
	__asm        jmp    _T83;
_T83:
	__asm        mov    eax, lYPosition;
	__asm        push   eax;
	__asm        mov    eax, lXPosition;
	__asm        push   eax;
	__asm        mov    ecx, tempHotSpotListIterator.node;
	__asm        add    ecx, 8;
	__asm        call   HotSpot::IsPointInHotspot;
	__asm        test   eax, eax;
	__asm        je     _Tb8;
// LINE 205:
	__asm        jmp    _Ta3;
_Ta3:
	lKey. = tempHotSpotListIterator.node->data.lID;
// LINE 206:
	return 0x1;
// LINE 208:
_Tb8:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _Tcb;
_Tcb:
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Td6;
// LINE 209:
_Td6:
	__asm        jmp    _T27;
_Tdb:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0x40], eax;
// LINE 212:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _Tfc;
_Tfc:
	__asm        jmp    _T101;
_T101:
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    tempHotSpotListIterator.node, eax;
// LINE 23:
_T107:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0x20], eax;
// LINE 213:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T126;
_T126:
	__asm        jmp    _T12b;
_T12b:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        cmp    [ebp-0x14], eax;
	__asm        jne    _T141;

	__asm        jmp    _T155;

	__asm        jmp    _T141;
_T141:
	__asm        jmp    _T150;

	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        jne    _T155;
_T150:
	__asm        jmp    _T15a;
_T155:
	__asm        jmp    _T1c6;
_T15a:
	__asm        jmp    _T169;

	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T1c6;
// LINE 214:
_T169:
	__asm        jmp    _T16e;
_T16e:
	__asm        mov    eax, lYPosition;
	__asm        push   eax;
	__asm        mov    eax, lXPosition;
	__asm        push   eax;
	__asm        mov    ecx, tempHotSpotListIterator.node;
	__asm        add    ecx, 8;
	__asm        call   HotSpot::IsPointInHotspot;
	__asm        test   eax, eax;
	__asm        je     _T1a3;
// LINE 215:
	__asm        jmp    _T18e;
_T18e:
	lKey. = tempHotSpotListIterator.node->data.lID;
// LINE 216:
	return 0x1;
// LINE 218:
_T1a3:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T1b6;
_T1b6:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T1c1;
// LINE 219:
_T1c1:
	__asm        jmp    _T107;
// LINE 220:
_T1c6:
	return 0x0;
// LINE 221:
}

// FUNCTION: COPTER_D 0x004031a1
int32_t KeyboardWindow::DoesKeyRequireTextDraw(long lKey) {
// LINE 243:
	__asm        cmp    lKey, 9;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x10;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x26;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x28;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x25;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x27;
	__asm        je     _T98;

	__asm        cmp    lKey, 0xD;
	__asm        je     _T98;

	__asm        cmp    lKey, 8;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x6A;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x6F;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x6B;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x6D;
	__asm        je     _T98;

	__asm        cmp    lKey, 0x20;
	__asm        je     _T98;

	__asm        mov    eax, 1;
	__asm        jmp    _T9a;
_T98:
	__asm        xor    eax, eax;
_T9a:
	__asm        jmp    __RETURN;
// LINE 244:
__RETURN:
}

// FUNCTION: COPTER_D 0x00403247
int32_t KeyboardWindow::GetRectOfNonTextImage(long lKey, /*packed*/ class MRect& rectImage) {
// LINE 253:
	__asm        cmp    lKey, 9;
	__asm        jne    _T47;
// LINE 254:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0xD;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T42;
// LINE 255:
_T42:
	__asm        jmp    _T2b0;
_T47:
	__asm        cmp    lKey, 0x10;
	__asm        je     _T5b;

	__asm        cmp    lKey, 0x26;
	__asm        jne    _T8c;
// LINE 256:
_T5b:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0xD;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x1A;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T87;
// LINE 257:
_T87:
	__asm        jmp    _T2b0;
_T8c:
	__asm        cmp    lKey, 8;
	__asm        je     _Ta0;

	__asm        cmp    lKey, 0x25;
	__asm        jne    _Td1;
// LINE 258:
_Ta0:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x1A;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x27;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _Tcc;
// LINE 259:
_Tcc:
	__asm        jmp    _T2b0;
_Td1:
	__asm        cmp    lKey, 0xD;
	__asm        jne    _T10c;
// LINE 260:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x27;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x34;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T107;
// LINE 261:
_T107:
	__asm        jmp    _T2b0;
_T10c:
	__asm        cmp    lKey, 0x28;
	__asm        jne    _T147;
// LINE 262:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x34;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x41;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T142;
// LINE 263:
_T142:
	__asm        jmp    _T2b0;
_T147:
	__asm        cmp    lKey, 0x27;
	__asm        jne    _T182;
// LINE 264:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x41;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x4E;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T17d;
// LINE 265:
_T17d:
	__asm        jmp    _T2b0;
_T182:
	__asm        cmp    lKey, 0x6F;
	__asm        jne    _T1bd;
// LINE 266:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x4E;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x5B;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T1b8;
// LINE 267:
_T1b8:
	__asm        jmp    _T2b0;
_T1bd:
	__asm        cmp    lKey, 0x6A;
	__asm        jne    _T1f8;
// LINE 268:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x5B;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x68;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T1f3;
// LINE 269:
_T1f3:
	__asm        jmp    _T2b0;
_T1f8:
	__asm        cmp    lKey, 0x6D;
	__asm        jne    _T233;
// LINE 270:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x68;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x75;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T22e;
// LINE 271:
_T22e:
	__asm        jmp    _T2b0;
_T233:
	__asm        cmp    lKey, 0x6B;
	__asm        jne    _T26e;
// LINE 272:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0x75;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 0x82;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 0xA;
	__asm        jmp    _T269;
// LINE 273:
_T269:
	__asm        jmp    _T2b0;
_T26e:
	__asm        cmp    lKey, 0x20;
	__asm        jne    _T2a9;
// LINE 274:
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+8], 1;
	__asm        mov    eax, rectImage;
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T2a4;
// LINE 275:
_T2a4:
	__asm        jmp    _T2b0;
// LINE 276:
_T2a9:
	return 0x0;
// LINE 277:
_T2b0:
	return 0x1;
// LINE 278:
}

// FUNCTION: COPTER_D 0x00403508
int32_t KeyboardWindow::ComposeSelf() {
// LINE 288:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T23;
// LINE 289:
	return 0x1;
// LINE 290:
_T23:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC0];
	__asm        test   eax, eax;
	__asm        jne    _T43;
// LINE 291:
	return 0x1;
// LINE 292:
_T43:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x30];
// LINE 295:
	__asm        push   0x90;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA4], eax;
// LINE 296:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xA4], 0;
	__asm        je     _T8c;
// LINE 297:
	this->myCurrentlyUsedNumLockHotSpotList = (this + 0x7c);
// LINE 298:
	__asm        jmp    _T9d;
// LINE 299:
_T8c:
	this->myCurrentlyUsedNumLockHotSpotList = (this + 0x84);
// LINE 300:
_T9d:
	__asm        push   0x14;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA8], eax;
// LINE 301:
	__asm        push   0x91;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xAC], eax;
// LINE 302:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD0];
// LINE 304:
	__asm        jmp    _Td9;
_Td9:
	__asm        jmp    _Tde;
_Tde:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x40];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x40];
	__asm        call   dword ptr [edx+0xC];
// LINE 306:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC8];
// LINE 307:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xCC];
// LINE 308:
	return 0x1;
// LINE 309:
}

// FUNCTION: COPTER_D 0x0040364f
void KeyboardWindow::DrawKeyColorsOnKeyboard() {
	/*bp-0x10*/  /*packed*/ class MRect rectCurrentKey; // 0x10 bytes
	/*bp-0x14*/  long lCurrentKeyColorID;
	/*bp-0x18*/  long lCurrentColorIndex;
	/*bp-0x1c*/  /*packed*/ class list<KeyColors>::iterator tempKeyColorsListIterator;
	/*bp-0x20*/  long lCurrentHotSpotID;
	/*bp-0x24*/  /*packed*/ class list<HotSpot>::iterator tempHotSpotListIterator;

// LINE 320:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x88], eax;
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T31;
_T31:
	__asm        jmp    _T36;
// LINE 321:
_T36:
	__asm        jmp    _T3b;
// LINE 325:
_T3b:
	__asm        jmp    _T40;
_T40:
	__asm        jmp    _T45;
// LINE 328:
_T45:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _T5c;
_T5c:
	__asm        jmp    _T61;
_T61:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        cmp    [ebp-0x28], eax;
	__asm        jne    _T77;

	__asm        jmp    _T8b;

	__asm        jmp    _T77;
_T77:
	__asm        jmp    _T86;

	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        jne    _T8b;
_T86:
	__asm        jmp    _T90;
_T8b:
	__asm        jmp    _T21c;
_T90:
	__asm        jmp    _Ta2;

	__asm        cmp    dword ptr [ebp-0x84], 0;
	__asm        je     _T21c;
// LINE 331:
_Ta2:
	__asm        jmp    _Ta7;
_Ta7:
	lCurrentHotSpotID = tempHotSpotListIterator.node->data.lID;
// LINE 332:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x8C], eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _Td2;
_Td2:
	__asm        jmp    _Td7;
_Td7:
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    tempKeyColorsListIterator.node, eax;
// LINE 333:
_Tdd:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    [ebp-0x70], eax;
	__asm        mov    eax, [ebp-0x70];
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _Tf7;
_Tf7:
	__asm        jmp    _Tfc;
_Tfc:
	__asm        mov    eax, tempKeyColorsListIterator.node;
	__asm        cmp    [ebp-0x30], eax;
	__asm        jne    _T112;

	__asm        jmp    _T126;

	__asm        jmp    _T112;
_T112:
	__asm        jmp    _T121;

	__asm        cmp    dword ptr [ebp-0x74], 0;
	__asm        jne    _T126;
_T121:
	__asm        jmp    _T12b;
_T126:
	__asm        jmp    _T1f3;
_T12b:
	__asm        jmp    _T13a;

	__asm        cmp    dword ptr [ebp-0x78], 0;
	__asm        je     _T1f3;
// LINE 334:
_T13a:
	__asm        jmp    _T13f;
_T13f:
	lCurrentKeyColorID = tempKeyColorsListIterator.node->data.lKey;
// LINE 335:
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        cmp    lCurrentKeyColorID, eax;
	__asm        jne    _T1ca;
// LINE 337:
	__asm        jmp    _T159;
_T159:
	lCurrentColorIndex = tempKeyColorsListIterator.node->data.lColorIndex;
// LINE 339:
	__asm        jmp    _T167;
_T167:
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    ecx, tempHotSpotListIterator.node;
	__asm        add    ecx, 8;
	__asm        call   HotSpot::GetBoundingRect;
// LINE 341:
	rectCurrentKey.left += this-><KeyboardWindow+0x20>;
// LINE 342:
	rectCurrentKey.top += this-><KeyboardWindow+0x24>;
// LINE 343:
	rectCurrentKey.right += this-><KeyboardWindow+0x20>;
// LINE 344:
	rectCurrentKey.bottom += this-><KeyboardWindow+0x24>;
// LINE 345:
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    eax, lCurrentColorIndex;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x44];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x44];
	__asm        call   dword ptr [edx+0x44];
// LINE 346:
	__asm        jmp    _T1f3;
// LINE 348:
_T1ca:
	__asm        mov    eax, tempKeyColorsListIterator.node;
	__asm        mov    [ebp-0x9C], eax;
	__asm        mov    eax, tempKeyColorsListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempKeyColorsListIterator.node, eax;
	__asm        jmp    _T1e0;
_T1e0:
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T1ee;
// LINE 349:
_T1ee:
	__asm        jmp    _Tdd;
// LINE 350:
_T1f3:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0xA0], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T209;
_T209:
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    _T217;
// LINE 351:
_T217:
	__asm        jmp    _T45;
_T21c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0x94], eax;
// LINE 354:
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x90], eax;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    _T24c;
_T24c:
	__asm        jmp    _T251;
_T251:
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    tempHotSpotListIterator.node, eax;
// LINE 23:
_T257:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0x64], eax;
// LINE 355:
	__asm        mov    eax, [ebp-0x64];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x60], eax;
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    [ebp-0x40], eax;
	__asm        jmp    _T279;
_T279:
	__asm        jmp    _T27e;
_T27e:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        cmp    [ebp-0x40], eax;
	__asm        jne    _T294;

	__asm        jmp    _T2a8;

	__asm        jmp    _T294;
_T294:
	__asm        jmp    _T2a3;

	__asm        cmp    dword ptr [ebp-0x68], 0;
	__asm        jne    _T2a8;
_T2a3:
	__asm        jmp    _T2ad;
_T2a8:
	__asm        jmp    _T436;
_T2ad:
	__asm        jmp    _T2bc;

	__asm        cmp    dword ptr [ebp-0x6C], 0;
	__asm        je     _T436;
// LINE 358:
_T2bc:
	__asm        jmp    _T2c1;
_T2c1:
	lCurrentHotSpotID = tempHotSpotListIterator.node->data.lID;
// LINE 359:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    [ebp-0x44], eax;
	__asm        jmp    _T2ec;
_T2ec:
	__asm        jmp    _T2f1;
_T2f1:
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    tempKeyColorsListIterator.node, eax;
// LINE 360:
_T2f7:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    [ebp-0x54], eax;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    [ebp-0x48], eax;
	__asm        jmp    _T311;
_T311:
	__asm        jmp    _T316;
_T316:
	__asm        mov    eax, tempKeyColorsListIterator.node;
	__asm        cmp    [ebp-0x48], eax;
	__asm        jne    _T32c;

	__asm        jmp    _T340;

	__asm        jmp    _T32c;
_T32c:
	__asm        jmp    _T33b;

	__asm        cmp    dword ptr [ebp-0x58], 0;
	__asm        jne    _T340;
_T33b:
	__asm        jmp    _T345;
_T340:
	__asm        jmp    _T40d;
_T345:
	__asm        jmp    _T354;

	__asm        cmp    dword ptr [ebp-0x5C], 0;
	__asm        je     _T40d;
// LINE 361:
_T354:
	__asm        jmp    _T359;
_T359:
	lCurrentKeyColorID = tempKeyColorsListIterator.node->data.lKey;
// LINE 362:
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        cmp    lCurrentKeyColorID, eax;
	__asm        jne    _T3e4;
// LINE 364:
	__asm        jmp    _T373;
_T373:
	lCurrentColorIndex = tempKeyColorsListIterator.node->data.lColorIndex;
// LINE 366:
	__asm        jmp    _T381;
_T381:
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    ecx, tempHotSpotListIterator.node;
	__asm        add    ecx, 8;
	__asm        call   HotSpot::GetBoundingRect;
// LINE 368:
	rectCurrentKey.left += this-><KeyboardWindow+0x20>;
// LINE 369:
	rectCurrentKey.top += this-><KeyboardWindow+0x24>;
// LINE 370:
	rectCurrentKey.right += this-><KeyboardWindow+0x20>;
// LINE 371:
	rectCurrentKey.bottom += this-><KeyboardWindow+0x24>;
// LINE 372:
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    eax, lCurrentColorIndex;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x44];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x44];
	__asm        call   dword ptr [edx+0x44];
// LINE 373:
	__asm        jmp    _T40d;
// LINE 375:
_T3e4:
	__asm        mov    eax, tempKeyColorsListIterator.node;
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    eax, tempKeyColorsListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempKeyColorsListIterator.node, eax;
	__asm        jmp    _T3fa;
_T3fa:
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    _T408;
// LINE 376:
_T408:
	__asm        jmp    _T2f7;
// LINE 377:
_T40d:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0xA8], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T423;
_T423:
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    [ebp-0x50], eax;
	__asm        jmp    _T431;
// LINE 378:
_T431:
	__asm        jmp    _T257;
// LINE 379:
_T436:
	return;
}

// FUNCTION: COPTER_D 0x00403a8f
void KeyboardWindow::DrawCharactersOnKeyboard() {
	/*bp-0x8*/   /*packed*/ class basic_string<char> sKey; // 0x8 bytes
	/*bp-0x18*/  /*packed*/ class MRect rectCurrentImage; // 0x10 bytes
	/*bp-0x28*/  /*packed*/ class MRect rectCurrentKey; // 0x10 bytes
	/*bp-0x68*/  char szTypeface[64]; // 0x40 bytes
	/*bp-0x6c*/  /*packed*/ class list<HotSpot>::iterator tempHotSpotListIterator;
	/*bp-0x70*/  long lCurrentHotSpotID;

// LINE 387:
	__asm        jmp    _T17;
_T17:
	__asm        jmp    _T1c;
// LINE 388:
_T1c:
	__asm        jmp    _T21;
_T21:
	__asm        jmp    _T26;
// LINE 389:
_T26:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xC0], eax;
	__asm        cmp    dword ptr [ebp-0xC0], 0;
	__asm        je     _T8e;

	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xC0];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T80;
_T80:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    sKey.reference, eax;
	__asm        jmp    _T95;
_T8e:
	sKey.reference = 0x0;
_T95:
	__asm        mov    sKey.c_str_ptr, 0;
	__asm        jmp    _Ta1;
// LINE 391:
_Ta1:
	__asm        jmp    _Ta6;
// LINE 395:
_Ta6:
	__asm        lea    eax, szTypeface[0];
	__asm        push   eax;
	__asm        push   2;
	__asm        push   0;
	__asm        call   LanguageManager::GetTypefaceForLanguage;
	__asm        add    esp, 0xC;
// LINE 396:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xA0], 0;
	__asm        jne    _T115;
// LINE 397:
	__asm        push   0x1C;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x74], eax;
	__asm        cmp    dword ptr [ebp-0x74], 0;
	__asm        je     _T105;

	__asm        push   1;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0xA;
	__asm        lea    eax, szTypeface[0];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x74];
	__asm        call   MFont::MFont;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA0], eax;
	__asm        jmp    _T115;
_T105:
	this->mFontToUse = 0x0;
// LINE 398:
_T115:
	__asm        mov    byte ptr [ebp-0x78], 0;
	__asm        mov    byte ptr [ebp-0x77], 0;
	__asm        mov    byte ptr [ebp-0x76], 0;
	__asm        jmp    _T126;
_T126:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        mov    [ebp-0xBC], eax;
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    ecx, [ebp-0xBC];
	__asm        mov    [ecx+0x38], eax;
	__asm        jmp    _T146;
// LINE 401:
_T146:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0xB0];
	__asm        mov    [ebp-0x7C], eax;
	__asm        jmp    _T165;
_T165:
	__asm        jmp    _T16a;
_T16a:
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    tempHotSpotListIterator.node, eax;
// LINE 402:
_T170:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    [ebp-0x80], eax;
	__asm        jmp    _T18d;
_T18d:
	__asm        jmp    _T192;
_T192:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        cmp    [ebp-0x80], eax;
	__asm        jne    _T1a8;

	__asm        jmp    _T1bf;

	__asm        jmp    _T1a8;
_T1a8:
	__asm        jmp    _T1ba;

	__asm        cmp    dword ptr [ebp-0xA8], 0;
	__asm        jne    _T1bf;
_T1ba:
	__asm        jmp    _T1c4;
_T1bf:
	__asm        jmp    _T441;
_T1c4:
	__asm        jmp    _T1d6;

	__asm        cmp    dword ptr [ebp-0xAC], 0;
	__asm        je     _T441;
// LINE 403:
_T1d6:
	__asm        jmp    _T1db;
_T1db:
	lCurrentHotSpotID = tempHotSpotListIterator.node->data.lID;
// LINE 404:
	__asm        jmp    _T1e9;
_T1e9:
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    ecx, tempHotSpotListIterator.node;
	__asm        add    ecx, 8;
	__asm        call   HotSpot::GetBoundingRect;
// LINE 405:
	rectCurrentKey.left += this-><KeyboardWindow+0x20>;
// LINE 406:
	rectCurrentKey.top += this-><KeyboardWindow+0x24>;
// LINE 409:
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD4];
	__asm        test   eax, eax;
	__asm        je     _T3ba;
// LINE 410:
	rectCurrentKey.right += this-><KeyboardWindow+0x20>;
// LINE 411:
	rectCurrentKey.bottom += this-><KeyboardWindow+0x24>;
// LINE 412:
	__asm        lea    eax, sKey.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xDC];
// LINE 415:
	__asm        cmp    sKey.c_str_ptr, 0;
	__asm        je     _T294;

	__asm        mov    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0xE4], eax;
	__asm        mov    eax, [ebp-0xE4];
	__asm        mov    [ebp-0xEC], eax;
	__asm        mov    eax, [ebp-0xEC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T294:
	__asm        jmp    _T299;
_T299:
	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax+4];
	__asm        inc    eax;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    sKey.c_str_ptr, eax;
	__asm        jmp    _T2b1;
_T2b1:
	__asm        mov    eax, sKey.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T330;

	__asm        jmp    _T2c3;
_T2c3:
	__asm        jmp    _T2c8;
_T2c8:
	__asm        mov    eax, sKey.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T2ea;

	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xF8], eax;
	__asm        jmp    _T2f9;

	__asm        jmp    _T2f9;
_T2ea:
	__asm        mov    dword ptr [ebp-0xF8], 0;
	__asm        jmp    _T2f9;
_T2f9:
	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xFC], eax;
	__asm        mov    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0x100], eax;
	__asm        mov    eax, [ebp-0xFC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xF8];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x100];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T330;
_T330:
	__asm        jmp    _T335;
_T335:
	__asm        mov    byte ptr [ebp-0xE8], 0;
	__asm        jmp    _T341;
_T341:
	__asm        lea    eax, [ebp-0xE8];
	__asm        mov    [ebp-0xF0], eax;
	__asm        jmp    _T352;
_T352:
	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0xF4], eax;
	__asm        mov    eax, [ebp-0xF0];
	__asm        mov    al, [eax];
	__asm        mov    ecx, [ebp-0xF4];
	__asm        mov    [ecx], al;
	__asm        jmp    _T376;
_T376:
	__asm        jmp    _T37b;
_T37b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.bottom;
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.right;
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.top;
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, sKey.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x44];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x44];
	__asm        call   dword ptr [edx+0x4C];
// LINE 417:
	__asm        jmp    _T415;
// LINE 418:
_T3ba:
	__asm        lea    eax, rectCurrentImage.left;
	__asm        push   eax;
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xE0];
// LINE 420:
	__asm        mov    eax, rectCurrentImage.bottom;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentImage.right;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentImage.top;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentImage.left;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentKey.top;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x9C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x9C];
	__asm        call   dword ptr [edx+0xC];
// LINE 422:
_T415:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0xDC], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T42b;
_T42b:
	__asm        mov    eax, [ebp-0xDC];
	__asm        mov    [ebp-0x84], eax;
	__asm        jmp    _T43c;
// LINE 423:
_T43c:
	__asm        jmp    _T170;
_T441:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0xB8], eax;
// LINE 425:
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xB4], eax;
	__asm        mov    eax, [ebp-0xB4];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _T474;
_T474:
	__asm        jmp    _T479;
_T479:
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    tempHotSpotListIterator.node, eax;
// LINE 23:
_T482:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x8C];
	__asm        mov    [ebp-0x98], eax;
// LINE 426:
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _T4b3;
_T4b3:
	__asm        jmp    _T4b8;
_T4b8:
	__asm        mov    eax, [ebp-0x8C];
	__asm        cmp    tempHotSpotListIterator.node, eax;
	__asm        jne    _T4d1;

	__asm        jmp    _T4e8;

	__asm        jmp    _T4d1;
_T4d1:
	__asm        jmp    _T4e3;

	__asm        cmp    dword ptr [ebp-0x9C], 0;
	__asm        jne    _T4e8;
_T4e3:
	__asm        jmp    _T4ed;
_T4e8:
	__asm        jmp    _T76a;
_T4ed:
	__asm        jmp    _T4ff;

	__asm        cmp    dword ptr [ebp-0xA0], 0;
	__asm        je     _T76a;
// LINE 427:
_T4ff:
	__asm        jmp    _T504;
_T504:
	lCurrentHotSpotID = tempHotSpotListIterator.node->data.lID;
// LINE 428:
	__asm        jmp    _T512;
_T512:
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    ecx, tempHotSpotListIterator.node;
	__asm        add    ecx, 8;
	__asm        call   HotSpot::GetBoundingRect;
// LINE 429:
	rectCurrentKey.left += this-><KeyboardWindow+0x20>;
// LINE 430:
	rectCurrentKey.top += this-><KeyboardWindow+0x24>;
// LINE 433:
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD4];
	__asm        test   eax, eax;
	__asm        je     _T6e3;
// LINE 434:
	rectCurrentKey.right += this-><KeyboardWindow+0x20>;
// LINE 435:
	rectCurrentKey.bottom += this-><KeyboardWindow+0x24>;
// LINE 436:
	__asm        lea    eax, sKey.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xDC];
// LINE 439:
	__asm        cmp    sKey.c_str_ptr, 0;
	__asm        je     _T5bd;

	__asm        mov    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0x104], eax;
	__asm        mov    eax, [ebp-0x104];
	__asm        mov    [ebp-0x10C], eax;
	__asm        mov    eax, [ebp-0x10C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T5bd:
	__asm        jmp    _T5c2;
_T5c2:
	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax+4];
	__asm        inc    eax;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    sKey.c_str_ptr, eax;
	__asm        jmp    _T5da;
_T5da:
	__asm        mov    eax, sKey.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T659;

	__asm        jmp    _T5ec;
_T5ec:
	__asm        jmp    _T5f1;
_T5f1:
	__asm        mov    eax, sKey.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T613;

	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x118], eax;
	__asm        jmp    _T622;

	__asm        jmp    _T622;
_T613:
	__asm        mov    dword ptr [ebp-0x118], 0;
	__asm        jmp    _T622;
_T622:
	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x11C], eax;
	__asm        mov    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0x120], eax;
	__asm        mov    eax, [ebp-0x11C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x118];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x120];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T659;
_T659:
	__asm        jmp    _T65e;
_T65e:
	__asm        mov    byte ptr [ebp-0x108], 0;
	__asm        jmp    _T66a;
_T66a:
	__asm        lea    eax, [ebp-0x108];
	__asm        mov    [ebp-0x110], eax;
	__asm        jmp    _T67b;
_T67b:
	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0x114], eax;
	__asm        mov    eax, [ebp-0x110];
	__asm        mov    al, [eax];
	__asm        mov    ecx, [ebp-0x114];
	__asm        mov    [ecx], al;
	__asm        jmp    _T69f;
_T69f:
	__asm        jmp    _T6a4;
_T6a4:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.bottom;
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.right;
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.top;
	__asm        push   eax;
	__asm        lea    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, sKey.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x44];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x44];
	__asm        call   dword ptr [edx+0x4C];
// LINE 441:
	__asm        jmp    _T73e;
// LINE 442:
_T6e3:
	__asm        lea    eax, rectCurrentImage.left;
	__asm        push   eax;
	__asm        mov    eax, lCurrentHotSpotID;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xE0];
// LINE 444:
	__asm        mov    eax, rectCurrentImage.bottom;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentImage.right;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentImage.top;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentImage.left;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentKey.top;
	__asm        push   eax;
	__asm        mov    eax, rectCurrentKey.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x9C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x9C];
	__asm        call   dword ptr [edx+0xC];
// LINE 446:
_T73e:
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    [ebp-0xE0], eax;
	__asm        mov    eax, tempHotSpotListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempHotSpotListIterator.node, eax;
	__asm        jmp    _T754;
_T754:
	__asm        mov    eax, [ebp-0xE0];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T765;
// LINE 447:
_T765:
	__asm        jmp    _T482;
// LINE 448:
_T76a:
	__asm        mov    eax, sKey.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sKey.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T814;

	__asm        mov    eax, sKey.reference;
	__asm        mov    [ebp-0xD0], eax;
	__asm        mov    eax, [ebp-0xD0];
	__asm        mov    [ebp-0xCC], eax;
	__asm        cmp    dword ptr [ebp-0xCC], 0;
	__asm        je     _T814;

	__asm        mov    eax, [ebp-0xCC];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T7f1;

	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xD4], eax;
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    [ebp-0xD8], eax;
	__asm        mov    eax, [ebp-0xD8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    dword ptr [eax+8], 0;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    dword ptr [eax], 0;
_T7f1:
	__asm        jmp    _T7f6;
_T7f6:
	__asm        jmp    _T7fb;
_T7fb:
	__asm        mov    eax, [ebp-0xCC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T80f;
_T80f:
	__asm        jmp    _T814;
_T814:
	__asm        jmp    _T819;
_T819:
	__asm        cmp    sKey.c_str_ptr, 0;
	__asm        je     _T847;

	__asm        mov    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0xC4], eax;
	__asm        mov    eax, [ebp-0xC4];
	__asm        mov    [ebp-0xC8], eax;
	__asm        mov    eax, [ebp-0xC8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T847:
	__asm        jmp    _T84c;
_T84c:
	return;
}

// FUNCTION: COPTER_D 0x004042e5
void KeyboardWindow::DrawLightsOnKeyboard() {
	/*bp-0x4*/   int32_t nNumLockLightImageX;
	/*bp-0x8*/   int32_t nScrollLockLightImageX;
	/*bp-0xc*/   int32_t nCapsLockLightImageX;

// LINE 463:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xA4], 0;
	__asm        je     _T28;
// LINE 464:
	nNumLockLightImageX = 0x0;
// LINE 465:
	__asm        jmp    _T2f;
// LINE 466:
_T28:
	nNumLockLightImageX = 0x5;
// LINE 468:
_T2f:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xA8], 0;
	__asm        je     _T4b;
// LINE 469:
	nCapsLockLightImageX = 0x0;
// LINE 470:
	__asm        jmp    _T52;
// LINE 471:
_T4b:
	nCapsLockLightImageX = 0x5;
// LINE 473:
_T52:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xAC], 0;
	__asm        je     _T6e;
// LINE 474:
	nScrollLockLightImageX = 0x0;
// LINE 475:
	__asm        jmp    _T75;
// LINE 476:
_T6e:
	nScrollLockLightImageX = 0x5;
// LINE 479:
_T75:
	__asm        push   8;
	__asm        mov    eax, nNumLockLightImageX;
	__asm        add    eax, 5;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, nNumLockLightImageX;
	__asm        push   eax;
	__asm        push   0x1E;
	__asm        push   0x1C4;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x98];
	__asm        call   dword ptr [edx+0xC];
// LINE 481:
	__asm        push   8;
	__asm        mov    eax, nCapsLockLightImageX;
	__asm        add    eax, 5;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, nCapsLockLightImageX;
	__asm        push   eax;
	__asm        push   0x1E;
	__asm        push   0x1D4;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x98];
	__asm        call   dword ptr [edx+0xC];
// LINE 483:
	__asm        push   8;
	__asm        mov    eax, nScrollLockLightImageX;
	__asm        add    eax, 5;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, nScrollLockLightImageX;
	__asm        push   eax;
	__asm        push   0x1E;
	__asm        push   0x1E4;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x98];
	__asm        call   dword ptr [edx+0xC];
// LINE 484:
	return;
}

// FUNCTION: COPTER_D 0x00404400
int32_t KeyboardWindow::DoesWindowNeedUpdating() {
// LINE 496:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x48], 0;
	__asm        jne    _T6f;

	__asm        push   0x90;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+0xA4];
	__asm        jne    _T6f;

	__asm        push   0x14;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+0xA8];
	__asm        jne    _T6f;

	__asm        push   0x91;
	__asm        call   Keyboard::IsToggleKeySet;
	__asm        add    esp, 4;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+0xAC];
	__asm        je     _T79;
_T6f:
	__asm        mov    eax, 1;
	__asm        jmp    _T7b;
_T79:
	__asm        xor    eax, eax;
_T7b:
	__asm        jmp    __RETURN;
// LINE 497:
__RETURN:
}

// FUNCTION: COPTER_D 0x00404485
long KeyboardWindow::DoKeyDown(long lKey, char chModifiers) {
// LINE 505:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T20;
// LINE 506:
	return 0x0;
// LINE 507:
_T20:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T51;
// LINE 508:
	__asm        lea    eax, lKey;
	__asm        push   eax;
	__asm        push   0x10001;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 509:
_T51:
	return 0x1;
// LINE 510:
}

// FUNCTION: COPTER_D 0x004044e7
long KeyboardWindow::DoKeyUp(long lKey, char chModifiers) {
// LINE 518:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T20;
// LINE 519:
	return 0x0;
// LINE 520:
_T20:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T51;
// LINE 521:
	__asm        lea    eax, lKey;
	__asm        push   eax;
	__asm        push   0x10002;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 522:
_T51:
	return 0x1;
// LINE 523:
}

// FUNCTION: COPTER_D 0x00404549
long KeyboardWindow::DoCursorDown(long nCursorX, long nCursorY, unsigned long nButton) {
	/*bp-0x8*/   /*packed*/ struct KeyboardWindowMessage tempKeyboardWindowMessage; // 0x8 bytes

// LINE 533:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   GraphicWindow::MakeFocus;
	__asm        add    esp, 4;
// LINE 534:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T71;
// LINE 535:
	__asm        lea    eax, tempKeyboardWindowMessage.lKey;
	__asm        push   eax;
	__asm        mov    eax, nCursorY;
	__asm        push   eax;
	__asm        mov    eax, nCursorX;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD8];
	__asm        test   eax, eax;
	__asm        je     _T71;
// LINE 536:
	tempKeyboardWindowMessage.lCursorButton = nButton;
// LINE 538:
	__asm        lea    eax, tempKeyboardWindowMessage.lKey;
	__asm        push   eax;
	__asm        push   0x10003;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 541:
_T71:
	return 0x1;
// LINE 542:
}

// FUNCTION: COPTER_D 0x004045cb
long KeyboardWindow::DoCursorUp(long nCursorX, long nCursorY, unsigned long nButton) {
	/*bp-0x8*/   /*packed*/ struct KeyboardWindowMessage tempKeyboardWindowMessage; // 0x8 bytes

// LINE 552:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T65;
// LINE 553:
	__asm        lea    eax, tempKeyboardWindowMessage.lKey;
	__asm        push   eax;
	__asm        mov    eax, nCursorY;
	__asm        push   eax;
	__asm        mov    eax, nCursorX;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD8];
	__asm        test   eax, eax;
	__asm        je     _T65;
// LINE 554:
	tempKeyboardWindowMessage.lCursorButton = nButton;
// LINE 556:
	__asm        lea    eax, tempKeyboardWindowMessage.lKey;
	__asm        push   eax;
	__asm        push   0x10004;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 559:
_T65:
	return 0x1;
// LINE 560:
}

// FUNCTION: COPTER_D 0x00404641
long KeyboardWindow::DoCursorMove(long nCursorX, long nCursorY) {
	/*bp-0x8*/   /*packed*/ struct KeyboardWindowMessage tempKeyboardWindowMessage; // 0x8 bytes

// LINE 570:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T66;
// LINE 571:
	__asm        lea    eax, tempKeyboardWindowMessage.lKey;
	__asm        push   eax;
	__asm        mov    eax, nCursorY;
	__asm        push   eax;
	__asm        mov    eax, nCursorX;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD8];
	__asm        test   eax, eax;
	__asm        je     _T66;
// LINE 572:
	tempKeyboardWindowMessage.lCursorButton = 0x0;
// LINE 574:
	__asm        lea    eax, tempKeyboardWindowMessage.lKey;
	__asm        push   eax;
	__asm        push   0x10005;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 577:
_T66:
	return 0x1;
// LINE 578:
}

// FUNCTION: COPTER_D 0x004046b8
void JoystickWindow::JoystickWindow(/*packed*/ class MRect& rectNewPosition, int32_t nNewID, /*unpacked*/ class GraphicWindow *windowNewParent, /*packed*/ class GraphicWindowOwner *myNewOwner, int32_t bAddToParentList) {
	/*bp-0x4*/   int32_t i;


	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, bAddToParentList;
	__asm        push   eax;
	__asm        mov    eax, myNewOwner;
	__asm        push   eax;
	__asm        mov    eax, windowNewParent;
	__asm        push   eax;
	__asm        mov    eax, nNewID;
	__asm        push   eax;
	__asm        mov    eax, rectNewPosition;
	__asm        push   eax;
	__asm        mov    eax, SZ_JOYSTICK_IMAGE_FILE_NAME;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::GraphicWindow;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x74], 0;
	__asm        mov    dword ptr [ebp-8], 8;
	__asm        mov    eax, this;
	__asm        add    eax, 0xBE;
	__asm        mov    [ebp-0xC], eax;
_T4c:
	__asm        dec    dword ptr [ebp-8];
	__asm        js     _T66;

	__asm        mov    ecx, [ebp-0xC];
	__asm        call   MRect::MRect;
	__asm        add    dword ptr [ebp-0xC], 0x10;
	__asm        jmp    _T4c;
_T66:
	__asm        jmp    _T6b;
_T6b:
	__asm        mov    dword ptr [ebp-0x10], 4;
	__asm        mov    eax, this;
	__asm        add    eax, 0x13E;
	__asm        mov    [ebp-0x14], eax;
_T7d:
	__asm        dec    dword ptr [ebp-0x10];
	__asm        js     _T97;

	__asm        mov    ecx, [ebp-0x14];
	__asm        call   MRect::MRect;
	__asm        add    dword ptr [ebp-0x14], 0x10;
	__asm        jmp    _T7d;
_T97:
	__asm        jmp    _T9c;
_T9c:
	__asm        jmp    _Ta1;
_Ta1:
	__asm        jmp    _Ta6;
_Ta6:
	__asm        mov    dword ptr [ebp-0x18], 4;
	__asm        mov    eax, this;
	__asm        add    eax, 0x18E;
	__asm        mov    [ebp-0x1C], eax;
_Tb8:
	__asm        dec    dword ptr [ebp-0x18];
	__asm        js     _Td2;

	__asm        mov    ecx, [ebp-0x1C];
	__asm        call   MRect::MRect;
	__asm        add    dword ptr [ebp-0x1C], 0x10;
	__asm        jmp    _Tb8;
_Td2:
	__asm        jmp    _Td7;
_Td7:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1CE], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1D2], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1D6], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1DA], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x58F140;
// LINE 615:
	__asm        mov    i, 0;
	__asm        jmp    _T123;
_T120:
	i++;
_T123:
	__asm        cmp    i, 0xE;
	__asm        jge    _T14e;
// LINE 616:
	__asm        mov    eax, i;
	__asm        mov    ecx, this;
	__asm        mov    dword ptr [ecx+eax*4+0x78], 0;
// LINE 617:
	__asm        mov    eax, i;
	__asm        mov    ecx, this;
	__asm        mov    byte ptr [eax+ecx+0xB0], 0;
// LINE 618:
	__asm        jmp    _T120;
// LINE 620:
_T14e:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xBE], 0x16;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC2], 0x72;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC6], 0x30;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xCA], 0x89;
	__asm        jmp    _T187;
// LINE 621:
_T187:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xCE], 0x32;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xD2], 0x7C;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xD6], 0x4C;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xDA], 0x93;
	__asm        jmp    _T1c0;
// LINE 622:
_T1c0:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xDE], 0x4E;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xE2], 0x86;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xE6], 0x68;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xEA], 0x9D;
	__asm        jmp    _T1f9;
// LINE 623:
_T1f9:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xEE], 0x6A;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xF2], 0x90;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xF6], 0x84;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xFA], 0xA7;
	__asm        jmp    _T232;
// LINE 624:
_T232:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xFE], 0xC;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x102], 0x86;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x106], 0x26;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x10A], 0x9D;
	__asm        jmp    _T26b;
// LINE 625:
_T26b:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x10E], 0x28;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x112], 0x90;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x116], 0x42;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11A], 0xA7;
	__asm        jmp    _T2a4;
// LINE 626:
_T2a4:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x11E], 0x46;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x122], 0x9A;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x126], 0x60;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x12A], 0xB1;
	__asm        jmp    _T2dd;
// LINE 627:
_T2dd:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x12E], 0x60;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x132], 0xA4;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x136], 0x7A;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x13A], 0xBB;
	__asm        jmp    _T316;
// LINE 629:
_T316:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x13E], 0x22;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x142], 0x37;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x146], 0x3F;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x14A], 0x6B;
	__asm        jmp    _T34f;
// LINE 630:
_T34f:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x14E], 0x2D;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x152], 0x3A;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0x4A;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15A], 0x6E;
	__asm        jmp    _T388;
// LINE 631:
_T388:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15E], 0x77;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x162], 0x54;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x166], 0x94;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x16A], 0x88;
	__asm        jmp    _T3c1;
// LINE 632:
_T3c1:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x16E], 0x82;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x172], 0x56;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x176], 0x9F;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x17A], 0x8A;
	__asm        jmp    _T3fa;
// LINE 634:
_T3fa:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x17E], 0x1D;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x182], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x186], 0x1E;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x18A], 1;
	__asm        jmp    _T433;
// LINE 636:
_T433:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x18E], 0x44;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x192], 0x58;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x196], 0x57;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x19A], 0x63;
	__asm        jmp    _T46c;
// LINE 637:
_T46c:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x19E], 0x67;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1A2], 0x5C;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1A6], 0x7F;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1AA], 0x71;
	__asm        jmp    _T4a5;
// LINE 638:
_T4a5:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1AE], 0x52;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1B2], 0x63;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1B6], 0x67;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1BA], 0x7D;
	__asm        jmp    _T4de;
// LINE 639:
_T4de:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1BE], 0x67;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1C2], 0x50;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1C6], 0x73;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x1CA], 0x5C;
	__asm        jmp    _T517;
// LINE 640:
_T517:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x00404bde
void JoystickWindow::~JoystickWindow() {

	this-><JoystickWindow+0x00> = 0x58f140;
// LINE 647:
	__asm        mov    ecx, this;
	__asm        call   JoystickWindow::DestroyImage;
// LINE 648:
	return;

	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::~GraphicWindow;
}

// FUNCTION: COPTER_D 0x00404c0d
int32_t JoystickWindow::Initialize() {
// LINE 655:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
// LINE 656:
	return 0x1;
// LINE 657:
}

// FUNCTION: COPTER_D 0x00404c35
int32_t JoystickWindow::CreateImage(int32_t bResizeWindowToFitImage) {
	/*bp-0x8*/   /*packed*/ class basic_string<char> sPath; // 0x8 bytes

// LINE 664:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x90], eax;
	__asm        cmp    dword ptr [ebp-0x90], 0;
	__asm        je     _T7a;

	__asm        mov    eax, [ebp-0x90];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x90];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T6c;
_T6c:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    sPath.reference, eax;
	__asm        jmp    _T81;
_T7a:
	sPath.reference = 0x0;
_T81:
	__asm        mov    sPath.c_str_ptr, 0;
	__asm        jmp    _T8d;
// LINE 667:
_T8d:
	__asm        mov    eax, bResizeWindowToFitImage;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::CreateImage;
// LINE 668:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1CE], 0;
	__asm        jne    _T30a;

	__asm        mov    eax, SZ_JOYSTICK_BUTTON_IMAGE_FILE_NAME;
	__asm        mov    [ebp-0x8C], eax;
// LINE 669:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x88], eax;
	__asm        cmp    dword ptr [ebp-0x88], 0;
	__asm        je     _Tf1;

	__asm        mov    eax, [ebp-0x8C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x88];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Tf8;
_Tf1:
	__asm        mov    dword ptr [ebp-0xC], 0;
_Tf8:
	__asm        mov    dword ptr [ebp-0x10], 0;
	__asm        jmp    _T104;
_T104:
	__asm        lea    eax, sPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   6;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T11f;
_T11f:
	__asm        mov    eax, [ebp-0xC];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0xC];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T15d;

	__asm        mov    eax, [ebp-0xC];
	__asm        mov    [ebp-0x84], eax;
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    [ebp-0x80], eax;
	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        je     _T15d;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x80];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T15d;
_T15d:
	__asm        jmp    _T162;
_T162:
	__asm        cmp    dword ptr [ebp-0x10], 0;
	__asm        je     _T184;

	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T184:
	__asm        jmp    _T189;
// LINE 670:
_T189:
	__asm        push   0x134;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _T2d5;

	__asm        cmp    sPath.c_str_ptr, 0;
	__asm        je     _T1d1;

	__asm        mov    eax, sPath.c_str_ptr;
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0x9C], eax;
	__asm        mov    eax, [ebp-0x9C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T1d1:
	__asm        jmp    _T1d6;
_T1d6:
	__asm        mov    eax, sPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        inc    eax;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    sPath.c_str_ptr, eax;
	__asm        jmp    _T1ee;
_T1ee:
	__asm        mov    eax, sPath.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T26d;

	__asm        jmp    _T200;
_T200:
	__asm        jmp    _T205;
_T205:
	__asm        mov    eax, sPath.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T227;

	__asm        mov    eax, sPath.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xA8], eax;
	__asm        jmp    _T236;

	__asm        jmp    _T236;
_T227:
	__asm        mov    dword ptr [ebp-0xA8], 0;
	__asm        jmp    _T236;
_T236:
	__asm        mov    eax, sPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xAC], eax;
	__asm        mov    eax, sPath.c_str_ptr;
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0xAC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xB0];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T26d;
_T26d:
	__asm        jmp    _T272;
_T272:
	__asm        mov    byte ptr [ebp-0x98], 0;
	__asm        jmp    _T27e;
_T27e:
	__asm        lea    eax, [ebp-0x98];
	__asm        mov    [ebp-0xA0], eax;
	__asm        jmp    _T28f;
_T28f:
	__asm        mov    eax, sPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, sPath.c_str_ptr;
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    al, [eax];
	__asm        mov    ecx, [ebp-0xA4];
	__asm        mov    [ecx], al;
	__asm        jmp    _T2b3;
_T2b3:
	__asm        jmp    _T2b8;
_T2b8:
	__asm        mov    eax, sPath.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x14];
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1CE], eax;
	__asm        jmp    _T2e5;
_T2d5:
	this->myButtonImage = 0x0;
// LINE 671:
_T2e5:
	__asm        mov    eax, GraphicWindow::colorConstants.nPaletteIndexTransparent;
	__asm        push   eax;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CE];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x1CE];
	__asm        call   dword ptr [edx+8];
// LINE 673:
_T30a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1D2], 0;
	__asm        jne    _T506;

	__asm        mov    eax, SZ_JOYSTICK_SLIDER_IMAGE_FILE_NAME;
	__asm        mov    [ebp-0x74], eax;
// LINE 674:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x70], eax;
	__asm        cmp    dword ptr [ebp-0x70], 0;
	__asm        je     _T350;

	__asm        mov    eax, [ebp-0x74];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x70];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T357;
_T350:
	__asm        mov    dword ptr [ebp-0x18], 0;
_T357:
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        jmp    _T363;
_T363:
	__asm        lea    eax, sPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   6;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T37e;
_T37e:
	__asm        lea    ecx, [ebp-0x1C];
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T3a8;

	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x68], eax;
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    [ebp-0x6C], eax;
	__asm        mov    eax, [ebp-0x6C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T3a8:
	__asm        jmp    _T3ad;
// LINE 675:
_T3ad:
	__asm        push   0x134;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x20], eax;
	__asm        cmp    dword ptr [ebp-0x20], 0;
	__asm        je     _T4d1;

	__asm        cmp    sPath.c_str_ptr, 0;
	__asm        je     _T3f5;

	__asm        mov    eax, sPath.c_str_ptr;
	__asm        mov    [ebp-0xB4], eax;
	__asm        mov    eax, [ebp-0xB4];
	__asm        mov    [ebp-0xBC], eax;
	__asm        mov    eax, [ebp-0xBC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T3f5:
	__asm        jmp    _T3fa;
_T3fa:
	__asm        mov    eax, sPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        inc    eax;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    sPath.c_str_ptr, eax;
	__asm        jmp    _T412;
_T412:
	__asm        mov    eax, sPath.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T469;

	__asm        jmp    _T424;
_T424:
	__asm        mov    eax, sPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0xC8], eax;
	__asm        lea    ecx, sPath.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        mov    [ebp-0xCC], eax;
	__asm        mov    eax, sPath.c_str_ptr;
	__asm        mov    [ebp-0xD0], eax;
	__asm        mov    eax, [ebp-0xC8];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xD0];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T469;
_T469:
	__asm        jmp    _T46e;
_T46e:
	__asm        mov    byte ptr [ebp-0xB8], 0;
	__asm        jmp    _T47a;
_T47a:
	__asm        lea    eax, [ebp-0xB8];
	__asm        mov    [ebp-0xC0], eax;
	__asm        jmp    _T48b;
_T48b:
	__asm        mov    eax, sPath.reference;
	__asm        mov    eax, [eax+4];
	__asm        add    eax, sPath.c_str_ptr;
	__asm        mov    [ebp-0xC4], eax;
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    al, [eax];
	__asm        mov    ecx, [ebp-0xC4];
	__asm        mov    [ecx], al;
	__asm        jmp    _T4af;
_T4af:
	__asm        jmp    _T4b4;
_T4b4:
	__asm        mov    eax, sPath.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x20];
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1D2], eax;
	__asm        jmp    _T4e1;
_T4d1:
	this->mySliderImage = 0x0;
// LINE 676:
_T4e1:
	__asm        mov    eax, GraphicWindow::colorConstants.nPaletteIndexTransparent;
	__asm        push   eax;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1D2];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x1D2];
	__asm        call   dword ptr [edx+8];
// LINE 678:
_T506:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1D6], 0;
	__asm        jne    _T61a;

	__asm        mov    eax, SZ_JOYSTICK_HANDLE_IMAGE_FILE_NAME;
	__asm        mov    [ebp-0x64], eax;
// LINE 679:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x60], eax;
	__asm        cmp    dword ptr [ebp-0x60], 0;
	__asm        je     _T54c;

	__asm        mov    eax, [ebp-0x64];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x60];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T553;
_T54c:
	__asm        mov    dword ptr [ebp-0x24], 0;
_T553:
	__asm        mov    dword ptr [ebp-0x28], 0;
	__asm        jmp    _T55f;
_T55f:
	__asm        lea    eax, sPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x28];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   6;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T57a;
_T57a:
	__asm        lea    ecx, [ebp-0x28];
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T5a4;

	__asm        mov    eax, [ebp-0x28];
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    [ebp-0x5C], eax;
	__asm        mov    eax, [ebp-0x5C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T5a4:
	__asm        jmp    _T5a9;
// LINE 680:
_T5a9:
	__asm        push   0x134;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x2C], eax;
	__asm        cmp    dword ptr [ebp-0x2C], 0;
	__asm        je     _T5e5;

	__asm        lea    ecx, sPath.c_str_ptr;
	__asm        call   basic_string<char>::c_str;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x2C];
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1D6], eax;
	__asm        jmp    _T5f5;
_T5e5:
	this->myHandleImage = 0x0;
// LINE 681:
_T5f5:
	__asm        mov    eax, GraphicWindow::colorConstants.nPaletteIndexTransparent;
	__asm        push   eax;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1D6];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x1D6];
	__asm        call   dword ptr [edx+8];
// LINE 683:
_T61a:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1DA], 0;
	__asm        jne    _T709;

	__asm        mov    eax, SZ_JOYSTICK_HANDLE_BASE_IMAGE_FILE_NAME;
	__asm        mov    [ebp-0x54], eax;
// LINE 684:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x50], eax;
	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        je     _T660;

	__asm        mov    eax, [ebp-0x54];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x50];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _T667;
_T660:
	__asm        mov    dword ptr [ebp-0x30], 0;
_T667:
	__asm        mov    dword ptr [ebp-0x34], 0;
	__asm        jmp    _T673;
_T673:
	__asm        lea    eax, sPath.c_str_ptr;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x34];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   6;
	__asm        mov    ecx, 0x604C00;
	__asm        call   FileServices::GetPathForFileString;
	__asm        jmp    _T68e;
_T68e:
	__asm        lea    ecx, [ebp-0x34];
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        je     _T6b8;

	__asm        mov    eax, [ebp-0x34];
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T6b8:
	__asm        jmp    _T6bd;
// LINE 685:
_T6bd:
	__asm        push   0x134;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x38], eax;
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _T6f9;

	__asm        lea    ecx, sPath.c_str_ptr;
	__asm        call   basic_string<char>::c_str;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x38];
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1DA], eax;
	__asm        jmp    _T709;
_T6f9:
	this->myHandleBaseImage = 0x0;
// LINE 690:
_T709:
	__asm        mov    dword ptr [ebp-0x3C], 1;
	__asm        lea    ecx, sPath.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    sPath.c_str_ptr, 0;
	__asm        je     _T73a;

	__asm        mov    eax, sPath.c_str_ptr;
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x4C], eax;
	__asm        mov    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T73a:
	__asm        jmp    _T73f;
_T73f:
	__asm        mov    eax, [ebp-0x3C];
	__asm        jmp    __RETURN;
// LINE 691:
__RETURN:
}

// FUNCTION: COPTER_D 0x00405383
void JoystickWindow::DestroyImage() {
// LINE 699:
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::DestroyImage;
// LINE 701:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1CE], 0;
	__asm        je     _T6b;
// LINE 702:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CE];
	__asm        mov    [ebp-8], eax;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-4], eax;
	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T5e;

	__asm        mov    ecx, [ebp-4];
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        mov    eax, [ebp-4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T59;
_T59:
	__asm        jmp    _T5e;
// LINE 703:
_T5e:
	this->myButtonImage = 0x0;
// LINE 705:
_T6b:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1D2], 0;
	__asm        je     _Tc2;
// LINE 706:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D2];
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    [ebp-0xC], eax;
	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Tb5;

	__asm        mov    ecx, [ebp-0xC];
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        mov    eax, [ebp-0xC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _Tb0;
_Tb0:
	__asm        jmp    _Tb5;
// LINE 707:
_Tb5:
	this->mySliderImage = 0x0;
// LINE 709:
_Tc2:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1D6], 0;
	__asm        je     _T119;
// LINE 710:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D6];
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _T10c;

	__asm        mov    ecx, [ebp-0x14];
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        mov    eax, [ebp-0x14];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T107;
_T107:
	__asm        jmp    _T10c;
// LINE 711:
_T10c:
	this->myHandleImage = 0x0;
// LINE 713:
_T119:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x1DA], 0;
	__asm        je     _T170;
// LINE 714:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1DA];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x1C], eax;
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T163;

	__asm        mov    ecx, [ebp-0x1C];
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        mov    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T15e;
_T15e:
	__asm        jmp    _T163;
// LINE 715:
_T163:
	this->myHandleBaseImage = 0x0;
// LINE 717:
_T170:
	return;
}

// FUNCTION: COPTER_D 0x004054fd
int32_t JoystickWindow::ComposeSelf() {
	/*bp-0x38*/  long lNewJoystickControlStates[14]; // 0x38 bytes
	/*bp-0x3c*/  int32_t i;
	/*bp-0x40*/  int32_t j;

// LINE 733:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T23;
// LINE 734:
	return 0x1;
// LINE 737:
_T23:
	__asm        jmp    _T28;
_T28:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x48], 0;
	__asm        je     _T57;
// LINE 738:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xCC];
// LINE 739:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x30];
// LINE 741:
	__asm        jmp    _Te0;
// LINE 742:
_T57:
	__asm        lea    eax, lNewJoystickControlStates[0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xDC];
// LINE 744:
	__asm        mov    i, 0;
	__asm        jmp    _T78;
_T75:
	i++;
_T78:
	__asm        cmp    i, 0xE;
	__asm        jge    _Te0;
// LINE 745:
	__asm        mov    eax, i;
	__asm        mov    ecx, this;
	__asm        mov    edx, i;
	__asm        mov    edx, [ebp+edx*4-0x38];
	__asm        cmp    [ecx+eax*4+0x78], edx;
	__asm        je     _Tdb;
// LINE 746:
	__asm        mov    j, 0;
	__asm        jmp    _Ta8;
_Ta5:
	j++;
_Ta8:
	__asm        cmp    j, 0xE;
	__asm        jge    _Tc8;
// LINE 747:
	__asm        mov    eax, i;
	__asm        mov    eax, [ebp+eax*4-0x38];
	__asm        mov    ecx, i;
	__asm        mov    edx, this;
	__asm        mov    [edx+ecx*4+0x78], eax;
	__asm        jmp    _Ta5;
// LINE 748:
_Tc8:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xCC];
// LINE 749:
	__asm        jmp    _Te0;
// LINE 751:
_Tdb:
	__asm        jmp    _T75;
// LINE 754:
_Te0:
	return 0x1;
// LINE 755:
}

// FUNCTION: COPTER_D 0x004055ec
void JoystickWindow::DrawCurrentJoystick() {
	/*bp-0x4*/   int32_t i;

// LINE 765:
	__asm        jmp    _T11;
_T11:
	__asm        jmp    _T16;
_T16:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x40];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x40];
	__asm        call   dword ptr [edx+0xC];
// LINE 768:
	__asm        mov    i, 0;
	__asm        jmp    _T63;
_T60:
	i++;
_T63:
	__asm        cmp    i, 8;
	__asm        jge    _T84;
// LINE 769:
	__asm        mov    eax, i;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD0];
	__asm        jmp    _T60;
// LINE 772:
_T84:
	__asm        mov    i, 2;
	__asm        jmp    _T93;
_T90:
	i++;
_T93:
	__asm        cmp    i, 6;
	__asm        jge    _Tb4;
// LINE 773:
	__asm        mov    eax, i;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD4];
	__asm        jmp    _T90;
// LINE 776:
_Tb4:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD8];
// LINE 777:
	return;
}

// FUNCTION: COPTER_D 0x004056b8
void JoystickWindow::DrawButton(int32_t nButton) {
	/*bp-0x4*/   int32_t nImageWidth;
	/*bp-0x8*/   int32_t x1;
	/*bp-0xc*/   int32_t x2;

// LINE 791:
	__asm        jmp    _T11;
_T11:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CE];
	__asm        mov    ecx, 6;
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    nImageWidth, eax;
// LINE 793:
	__asm        mov    eax, nButton;
	__asm        mov    ecx, this;
	__asm        movsx  eax, byte ptr [eax+ecx+0xB6];
	__asm        add    eax, eax;
	__asm        mov    ecx, nButton;
	__asm        mov    edx, this;
	__asm        add    eax, [edx+ecx*4+0x90];
	__asm        imul   eax, nImageWidth;
	__asm        mov    x1, eax;
// LINE 794:
	x2 = (x1 + nImageWidth);
// LINE 798:
	__asm        jmp    _T5a;
_T5a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1CE];
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, x2;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, x1;
	__asm        push   eax;
	__asm        mov    eax, nButton;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    eax, [eax+ecx+0xC2];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x24];
	__asm        push   eax;
	__asm        mov    eax, nButton;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    eax, [eax+ecx+0xBE];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1CE];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x1CE];
	__asm        call   dword ptr [edx+0xC];
// LINE 799:
	return;
}

// FUNCTION: COPTER_D 0x00405781
void JoystickWindow::DrawSlider(int32_t nSlider) {
	/*bp-0x4*/   int32_t nImageWidth;
	/*bp-0x8*/   int32_t x1;
	/*bp-0xc*/   int32_t x2;

// LINE 814:
	__asm        cmp    nSlider, 1;
	__asm        jg     _T24;
// LINE 815:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xD8];
// LINE 817:
_T24:
	__asm        jmp    _T29;
_T29:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D2];
	__asm        mov    ecx, 9;
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    nImageWidth, eax;
// LINE 819:
	__asm        mov    eax, nSlider;
	__asm        mov    ecx, this;
	__asm        movsx  eax, byte ptr [eax+ecx+0xB0];
	__asm        lea    eax, [eax+eax*2];
	__asm        mov    ecx, nSlider;
	__asm        mov    edx, this;
	__asm        add    eax, [edx+ecx*4+0x78];
	__asm        inc    eax;
	__asm        imul   eax, nImageWidth;
	__asm        mov    x1, eax;
// LINE 820:
	x2 = (nImageWidth + x1);
// LINE 824:
	__asm        jmp    _T71;
_T71:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D2];
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, x2;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, x1;
	__asm        push   eax;
	__asm        mov    eax, nSlider;
	__asm        sub    eax, 2;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    eax, [eax+ecx+0x142];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x24];
	__asm        push   eax;
	__asm        mov    eax, nSlider;
	__asm        sub    eax, 2;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    eax, [eax+ecx+0x13E];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1D2];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x1D2];
	__asm        call   dword ptr [edx+0xC];
// LINE 825:
	return;
}

// FUNCTION: COPTER_D 0x00405867
void JoystickWindow::DrawHandle() {
	/*bp-0x4*/   int32_t nHandleImageToUse;
	/*bp-0x8*/   int32_t nImageWidth;
	/*bp-0xc*/   int32_t x1;
	/*bp-0x4c*/  /*packed*/ class MRect rectHandleBaseSources[4]; // 0x40 bytes
	/*bp-0x50*/  int32_t x2;
	/*bp-0x54*/  int32_t i;


	__asm        mov    dword ptr [ebp-0x58], 4;
	__asm        lea    eax, rectHandleBaseSources[0].left;
	__asm        mov    [ebp-0x5C], eax;
// LINE 838:
_T19:
	__asm        dec    dword ptr [ebp-0x58];
	__asm        js     _T33;

	__asm        mov    ecx, [ebp-0x5C];
	__asm        call   MRect::MRect;
	__asm        add    dword ptr [ebp-0x5C], 0x10;
	__asm        jmp    _T19;
_T33:
	__asm        jmp    _T38;
// LINE 842:
_T38:
	__asm        lea    eax, rectHandleBaseSources[0].left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xE4];
// LINE 843:
	__asm        mov    i, 0;
	__asm        jmp    _T59;
_T56:
	i++;
_T59:
	__asm        cmp    i, 4;
	__asm        jge    _Te0;
// LINE 848:
	__asm        mov    eax, i;
	__asm        shl    eax, 4;
	__asm        mov    eax, [ebp+eax-0x40];
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        shl    eax, 4;
	__asm        mov    eax, [ebp+eax-0x44];
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        shl    eax, 4;
	__asm        mov    eax, [ebp+eax-0x48];
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        shl    eax, 4;
	__asm        mov    eax, [ebp+eax-0x4C];
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    eax, [eax+ecx+0x192];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x24];
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    eax, [eax+ecx+0x18E];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1DA];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x1DA];
	__asm        call   dword ptr [edx+0xC];
// LINE 849:
	__asm        jmp    _T56;
// LINE 852:
_Te0:
	__asm        jmp    _Te5;
_Te5:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D6];
	__asm        mov    ecx, 9;
	__asm        mov    eax, [eax+8];
	__asm        cdq;
	__asm        idiv   ecx;
	__asm        mov    nImageWidth, eax;
// LINE 853:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC8];
	__asm        mov    nHandleImageToUse, eax;
// LINE 854:
	__asm        mov    eax, nHandleImageToUse;
	__asm        imul   eax, nImageWidth;
	__asm        mov    x1, eax;
// LINE 855:
	x2 = (nImageWidth + x1);
// LINE 859:
	__asm        jmp    _T125;
_T125:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x1D6];
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, x2;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, x1;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x182];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x24];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x17E];
	__asm        mov    ecx, this;
	__asm        add    eax, [ecx+0x20];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x44];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x1D6];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x1D6];
	__asm        call   dword ptr [edx+0xC];
// LINE 860:
	return;
}

// FUNCTION: COPTER_D 0x004059eb
void JoystickWindow::GetSourceHandleBaseRects(/*packed*/ class MRect *rectHandleBaseSources) {
// LINE 872:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB0];
	__asm        test   eax, eax;
	__asm        jne    _T7c;
// LINE 873:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+8], 0x13;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0xC], 0xB;
	__asm        jmp    _T4a;
// LINE 874:
_T4a:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x10], 0;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x14], 0x31;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x18], 0x18;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x1C], 0x46;
	__asm        jmp    _T77;
// LINE 876:
_T77:
	__asm        jmp    _T146;
_T7c:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB0];
	__asm        cmp    eax, 1;
	__asm        jne    _Ted;
// LINE 877:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax], 0x18;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+8], 0x2B;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0xC], 0xB;
	__asm        jmp    _Tbb;
// LINE 878:
_Tbb:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x10], 0x18;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x14], 0x31;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x18], 0x30;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x1C], 0x46;
	__asm        jmp    _Te8;
// LINE 880:
_Te8:
	__asm        jmp    _T146;
// LINE 881:
_Ted:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax], 0x30;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+8], 0x43;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0xC], 0xB;
	__asm        jmp    _T119;
// LINE 882:
_T119:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x10], 0x30;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x14], 0x31;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x18], 0x48;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x1C], 0x46;
	__asm        jmp    _T146;
// LINE 886:
_T146:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB1];
	__asm        test   eax, eax;
	__asm        jne    _T1b7;
// LINE 887:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x20], 0;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x24], 0xB;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x28], 0x15;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x2C], 0x25;
	__asm        jmp    _T185;
// LINE 888:
_T185:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x30], 0;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x34], 0x25;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x38], 0xC;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x3C], 0x31;
	__asm        jmp    _T1b2;
// LINE 890:
_T1b2:
	__asm        jmp    _T283;
_T1b7:
	__asm        mov    eax, this;
	__asm        movsx  eax, byte ptr [eax+0xB1];
	__asm        cmp    eax, 1;
	__asm        jne    _T229;
// LINE 891:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x20], 0x18;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x24], 0xB;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x28], 0x2D;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x2C], 0x25;
	__asm        jmp    _T1f7;
// LINE 892:
_T1f7:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x30], 0x18;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x34], 0x25;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x38], 0x24;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x3C], 0x31;
	__asm        jmp    _T224;
// LINE 894:
_T224:
	__asm        jmp    _T283;
// LINE 895:
_T229:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x20], 0x30;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x24], 0xB;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x28], 0x45;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x2C], 0x25;
	__asm        jmp    _T256;
// LINE 896:
_T256:
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x30], 0x30;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x34], 0x25;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x38], 0x3C;
	__asm        mov    eax, rectHandleBaseSources;
	__asm        mov    dword ptr [eax+0x3C], 0x31;
	__asm        jmp    _T283;
// LINE 898:
_T283:
	return;
}

// FUNCTION: COPTER_D 0x00405c7a
int32_t JoystickWindow::GetHandleImageToUse() {
// LINE 914:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x7C];
	__asm        lea    eax, [eax+eax*2+3];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        lea    eax, [eax+ecx+1];
	__asm        jmp    __RETURN;
// LINE 915:
__RETURN:
}

// FUNCTION: COPTER_D 0x00405ca4
void JoystickWindow::GetNewJoystickControlStates(long * lNewJoystickControlStates) {
	/*bp-0x4*/   int32_t i;

// LINE 928:
	__asm        mov    i, 6;
	__asm        jmp    _T1b;
_T18:
	i++;
_T1b:
	__asm        cmp    i, 0xE;
	__asm        jge    _T6a;
// LINE 929:
	__asm        push   1;
	__asm        mov    eax, i;
	__asm        sub    eax, 6;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        push   eax;
	__asm        mov    ecx, 0x604C78;
	__asm        call   JoystickManager::GetButtonState;
	__asm        mov    ecx, i;
	__asm        mov    edx, lNewJoystickControlStates;
	__asm        mov    [edx+ecx*4], eax;
// LINE 930:
	__asm        mov    eax, i;
	__asm        mov    ecx, lNewJoystickControlStates;
	__asm        cmp    dword ptr [ecx+eax*4], 0;
	__asm        je     _T65;
// LINE 931:
	lNewJoystickControlStates[i] = 0x1;
// LINE 932:
_T65:
	__asm        jmp    _T18;
// LINE 933:
_T6a:
	__asm        mov    i, 0;
	__asm        jmp    _T79;
_T76:
	i++;
_T79:
	__asm        cmp    i, 6;
	__asm        jge    _Ta8;
// LINE 934:
	__asm        push   1;
	__asm        mov    eax, i;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        push   eax;
	__asm        mov    ecx, 0x604C78;
	__asm        call   JoystickManager::GetPositionQualitative;
	__asm        mov    ecx, i;
	__asm        mov    edx, lNewJoystickControlStates;
	__asm        mov    [edx+ecx*4], eax;
// LINE 935:
	__asm        jmp    _T76;
// LINE 936:
_Ta8:
	return;
}

// FUNCTION: COPTER_D 0x00405d58
int32_t JoystickWindow::DoesWindowNeedUpdating() {
// LINE 943:
	return 0x1;
// LINE 944:
}

// FUNCTION: COPTER_D 0x00405d73
void JoystickWindow::SetCurrentJoystick(int32_t nNewCurrentJoystick) {
// LINE 955:
	this->nCurrentJoystick = nNewCurrentJoystick;
// LINE 956:
	__asm        mov    eax, this;
	__asm        add    eax, 0x78;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xDC];
// LINE 957:
	__asm        push   1;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x30];
// LINE 958:
	return;
}

// FUNCTION: COPTER_D 0x00405db8
long JoystickWindow::DoCursorDown(long nCursorX, long nCursorY, unsigned long nButton) {
	/*bp-0x4*/   long lKey;

// LINE 967:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   GraphicWindow::MakeFocus;
	__asm        add    esp, 4;
// LINE 968:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T6b;
// LINE 969:
	__asm        lea    eax, lKey;
	__asm        push   eax;
	__asm        mov    eax, nCursorY;
	__asm        push   eax;
	__asm        mov    eax, nCursorX;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xE0];
	__asm        test   eax, eax;
	__asm        je     _T6b;
// LINE 970:
	__asm        lea    eax, lKey;
	__asm        push   eax;
	__asm        push   0x10001;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 972:
_T6b:
	return 0x1;
// LINE 973:
}

// FUNCTION: COPTER_D 0x00405e34
long JoystickWindow::DoCursorUp(long nCursorX, long nCursorY, unsigned long nButton) {
// LINE 980:
	return 0x1;
// LINE 981:
}

// FUNCTION: COPTER_D 0x00405e51
long JoystickWindow::DoCursorMove(long nCursorX, long nCursorY) {
// LINE 988:
	return 0x1;
// LINE 989:
}

// FUNCTION: COPTER_D 0x00405e6e
int32_t JoystickWindow::DoesPositionHitKey(long lXPosition, long lYPosition, long& lKey) {
	/*bp-0x4*/   int32_t i;

// LINE 1000:
	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x18E], ecx;
	__asm        jg     _T5e;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x192], ecx;
	__asm        jg     _T5e;

	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x196], ecx;
	__asm        jle    _T5e;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x19A], ecx;
	__asm        jle    _T5e;

	__asm        jmp    _Tce;

	__asm        jmp    _T5e;
_T5e:
	__asm        jmp    _T6d;

	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _Tce;
_T6d:
	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x19E], ecx;
	__asm        jg     _Tba;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x1A2], ecx;
	__asm        jg     _Tba;

	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x1A6], ecx;
	__asm        jle    _Tba;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x1AA], ecx;
	__asm        jle    _Tba;

	__asm        jmp    _Tbf;
_Tba:
	__asm        jmp    _Te1;
_Tbf:
	__asm        jmp    _Tce;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _Te1;
// LINE 1002:
_Tce:
	lKey. = 0x0;
// LINE 1003:
	return 0x1;
// LINE 1008:
_Te1:
	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x1AE], ecx;
	__asm        jg     _T133;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x1B2], ecx;
	__asm        jg     _T133;

	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x1B6], ecx;
	__asm        jle    _T133;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x1BA], ecx;
	__asm        jle    _T133;

	__asm        jmp    _T1a3;

	__asm        jmp    _T133;
_T133:
	__asm        jmp    _T142;

	__asm        cmp    dword ptr [ebp-0x10], 0;
	__asm        jne    _T1a3;
_T142:
	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x1BE], ecx;
	__asm        jg     _T18f;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x1C2], ecx;
	__asm        jg     _T18f;

	__asm        mov    eax, this;
	__asm        mov    ecx, lXPosition;
	__asm        cmp    [eax+0x1C6], ecx;
	__asm        jle    _T18f;

	__asm        mov    eax, this;
	__asm        mov    ecx, lYPosition;
	__asm        cmp    [eax+0x1CA], ecx;
	__asm        jle    _T18f;

	__asm        jmp    _T194;
_T18f:
	__asm        jmp    _T1b6;
_T194:
	__asm        jmp    _T1a3;

	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _T1b6;
// LINE 1010:
_T1a3:
	lKey. = 0x1;
// LINE 1011:
	return 0x1;
// LINE 1015:
_T1b6:
	__asm        mov    i, 2;
	__asm        jmp    _T1c5;
_T1c2:
	i++;
_T1c5:
	__asm        cmp    i, 6;
	__asm        jge    _T26f;
// LINE 1016:
	__asm        mov    eax, i;
	__asm        sub    eax, 2;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lXPosition;
	__asm        cmp    [eax+ecx+0x13E], edx;
	__asm        jg     _T244;

	__asm        mov    eax, i;
	__asm        sub    eax, 2;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lYPosition;
	__asm        cmp    [eax+ecx+0x142], edx;
	__asm        jg     _T244;

	__asm        mov    eax, i;
	__asm        sub    eax, 2;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lXPosition;
	__asm        cmp    [eax+ecx+0x146], edx;
	__asm        jle    _T244;

	__asm        mov    eax, i;
	__asm        sub    eax, 2;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lYPosition;
	__asm        cmp    [eax+ecx+0x14A], edx;
	__asm        jle    _T244;

	__asm        jmp    _T249;
_T244:
	__asm        jmp    _T26a;
_T249:
	__asm        jmp    _T258;

	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        je     _T26a;
// LINE 1017:
_T258:
	lKey. = i;
// LINE 1018:
	return 0x1;
// LINE 1020:
_T26a:
	__asm        jmp    _T1c2;
// LINE 1023:
_T26f:
	__asm        mov    i, 6;
	__asm        jmp    _T27e;
_T27b:
	i++;
_T27e:
	__asm        cmp    i, 0xE;
	__asm        jge    _T328;
// LINE 1024:
	__asm        mov    eax, i;
	__asm        sub    eax, 6;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lXPosition;
	__asm        cmp    [eax+ecx+0xBE], edx;
	__asm        jg     _T2fd;

	__asm        mov    eax, i;
	__asm        sub    eax, 6;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lYPosition;
	__asm        cmp    [eax+ecx+0xC2], edx;
	__asm        jg     _T2fd;

	__asm        mov    eax, i;
	__asm        sub    eax, 6;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lXPosition;
	__asm        cmp    [eax+ecx+0xC6], edx;
	__asm        jle    _T2fd;

	__asm        mov    eax, i;
	__asm        sub    eax, 6;
	__asm        shl    eax, 4;
	__asm        mov    ecx, this;
	__asm        mov    edx, lYPosition;
	__asm        cmp    [eax+ecx+0xCA], edx;
	__asm        jle    _T2fd;

	__asm        jmp    _T302;
_T2fd:
	__asm        jmp    _T323;
_T302:
	__asm        jmp    _T311;

	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T323;
// LINE 1025:
_T311:
	lKey. = i;
// LINE 1026:
	return 0x1;
// LINE 1028:
_T323:
	__asm        jmp    _T27b;
// LINE 1029:
_T328:
	return 0x0;
// LINE 1030:
}

// FUNCTION: COPTER_D 0x004061a4
void UserInputWindow::UserInputWindow(/*packed*/ class MRect& rectNewPosition, int32_t nNewID, /*unpacked*/ class GraphicWindow *windowNewParent, /*packed*/ class GraphicWindowOwner *myNewOwner, int32_t bAddToParentList) {

	__asm        mov    eax, GraphicWindow::colorConstants.nPaletteIndexTransparent;
	__asm        push   eax;
	__asm        mov    eax, bAddToParentList;
	__asm        push   eax;
	__asm        mov    eax, myNewOwner;
	__asm        push   eax;
	__asm        mov    eax, windowNewParent;
	__asm        push   eax;
	__asm        mov    eax, nNewID;
	__asm        push   eax;
	__asm        mov    eax, rectNewPosition;
	__asm        push   eax;
	__asm        mov    eax, SZ_USER_INPUT_WINDOW_IMAGE_FILE_NAME;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::GraphicWindow;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x74], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x78], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x7C], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x80], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x84], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x8C], 0;
	__asm        inc    list<StringIDAssociation>::number_of_lists;
	__asm        mov    eax, list<StringIDAssociation>::free_list;
	__asm        mov    [ebp-4], eax;
	__asm        cmp    list<StringIDAssociation>::free_list, 0;
	__asm        je     _Tc6;

	__asm        mov    eax, list<StringIDAssociation>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<StringIDAssociation>::free_list, eax;
	__asm        mov    eax, [ebp-4];
	__asm        mov    [ebp-0x48], eax;
	__asm        jmp    _T259;
_Tc6:
	__asm        mov    eax, list<StringIDAssociation>::next_avail;
	__asm        cmp    list<StringIDAssociation>::last, eax;
	__asm        jne    _T244;

	__asm        jmp    _Tdc;
_Tdc:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0x10], eax;
	__asm        mov    dword ptr [ebp-0x14], 0xCC;
	__asm        lea    eax, [ebp-0x14];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    dword ptr [ebp-0x18], 1;
	__asm        lea    eax, [ebp-0x18];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    ecx, [ebp-0x1C];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T120;

	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T126;
_T120:
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x24], eax;
_T126:
	__asm        jmp    _T12b;
_T12b:
	__asm        jmp    _T130;
_T130:
	__asm        jmp    _T135;
_T135:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x44], eax;
	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x44];
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x3C], eax;
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        jne    _T193;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T189;
_T189:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T193:
	__asm        jmp    _T198;
_T198:
	__asm        jmp    _T19d;
_T19d:
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    ecx, [ebp-0x10];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<StringIDAssociation>::buffer_list;
	__asm        mov    ecx, [ebp-0x10];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x10];
	__asm        mov    list<StringIDAssociation>::buffer_list, eax;
	__asm        mov    eax, list<StringIDAssociation>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<StringIDAssociation>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x28], 0xCC;
	__asm        lea    eax, [ebp-0x28];
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    dword ptr [ebp-0x2C], 1;
	__asm        lea    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x34], eax;
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    ecx, [ebp-0x30];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T1fa;

	__asm        mov    eax, [ebp-0x34];
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    _T200;
_T1fa:
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x38], eax;
_T200:
	__asm        jmp    _T205;
_T205:
	__asm        jmp    _T20a;
_T20a:
	__asm        jmp    _T20f;
_T20f:
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, list<StringIDAssociation>::next_avail;
	__asm        mov    list<StringIDAssociation>::last, eax;
	__asm        jmp    _T22a;
_T22a:
	__asm        mov    eax, list<StringIDAssociation>::next_avail;
	__asm        mov    [ebp-8], eax;
	__asm        add    list<StringIDAssociation>::next_avail, 0x14;
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-0x48], eax;
	__asm        jmp    _T259;
_T244:
	__asm        mov    eax, list<StringIDAssociation>::next_avail;
	__asm        mov    [ebp-0xC], eax;
	__asm        add    list<StringIDAssociation>::next_avail, 0x14;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    [ebp-0x48], eax;
_T259:
	__asm        jmp    _T25e;
_T25e:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x88], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x88];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x88];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x88];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x88];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T2a7;
_T2a7:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x94], 0;
	__asm        inc    list<StringIDAssociation>::number_of_lists;
	__asm        mov    eax, list<StringIDAssociation>::free_list;
	__asm        mov    [ebp-0x4C], eax;
	__asm        cmp    list<StringIDAssociation>::free_list, 0;
	__asm        je     _T2ec;

	__asm        mov    eax, list<StringIDAssociation>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<StringIDAssociation>::free_list, eax;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _T43b;
_T2ec:
	__asm        mov    eax, list<StringIDAssociation>::next_avail;
	__asm        cmp    list<StringIDAssociation>::last, eax;
	__asm        jne    _T423;

	__asm        jmp    _T302;
_T302:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    dword ptr [ebp-0x5C], 0xCC;
	__asm        lea    eax, [ebp-0x5C];
	__asm        mov    [ebp-0x64], eax;
	__asm        mov    dword ptr [ebp-0x60], 1;
	__asm        lea    eax, [ebp-0x60];
	__asm        mov    [ebp-0x68], eax;
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    ecx, [ebp-0x64];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T346;

	__asm        mov    eax, [ebp-0x68];
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T34c;
_T346:
	__asm        mov    eax, [ebp-0x64];
	__asm        mov    [ebp-0x6C], eax;
_T34c:
	__asm        jmp    _T351;
_T351:
	__asm        jmp    _T356;
_T356:
	__asm        jmp    _T35b;
_T35b:
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x84], eax;
	__asm        jmp    _T36b;
_T36b:
	__asm        push   0;
	__asm        mov    eax, [ebp-0x84];
	__asm        push   eax;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    ecx, [ebp-0x58];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<StringIDAssociation>::buffer_list;
	__asm        mov    ecx, [ebp-0x58];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    list<StringIDAssociation>::buffer_list, eax;
	__asm        mov    eax, list<StringIDAssociation>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<StringIDAssociation>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x70], 0xCC;
	__asm        lea    eax, [ebp-0x70];
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    dword ptr [ebp-0x74], 1;
	__asm        lea    eax, [ebp-0x74];
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    ecx, [ebp-0x78];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T3d6;

	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    [ebp-0x80], eax;
	__asm        jmp    _T3dc;
_T3d6:
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    [ebp-0x80], eax;
_T3dc:
	__asm        jmp    _T3e1;
_T3e1:
	__asm        jmp    _T3e6;
_T3e6:
	__asm        jmp    _T3eb;
_T3eb:
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 2;
	__asm        lea    eax, [eax+eax*4];
	__asm        add    eax, list<StringIDAssociation>::next_avail;
	__asm        mov    list<StringIDAssociation>::last, eax;
	__asm        jmp    _T406;
_T406:
	__asm        mov    eax, list<StringIDAssociation>::next_avail;
	__asm        mov    [ebp-0x50], eax;
	__asm        add    list<StringIDAssociation>::next_avail, 0x14;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _T43b;
_T423:
	__asm        mov    eax, list<StringIDAssociation>::next_avail;
	__asm        mov    [ebp-0x54], eax;
	__asm        add    list<StringIDAssociation>::next_avail, 0x14;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    [ebp-0x88], eax;
_T43b:
	__asm        jmp    _T440;
_T440:
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x90], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x90];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x90];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T48c;
_T48c:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x9C], 0;
	__asm        inc    list<Shortcut>::number_of_lists;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0x8C], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _T4d7;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    [ebp-0xC8], eax;
	__asm        jmp    _T689;
_T4d7:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T66b;

	__asm        jmp    _T4ed;
_T4ed:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    dword ptr [ebp-0x9C], 0x80;
	__asm        lea    eax, [ebp-0x9C];
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    dword ptr [ebp-0xA0], 1;
	__asm        lea    eax, [ebp-0xA0];
	__asm        mov    [ebp-0xA8], eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    ecx, [ebp-0xA4];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T552;

	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    [ebp-0xAC], eax;
	__asm        jmp    _T55e;
_T552:
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    [ebp-0xAC], eax;
_T55e:
	__asm        jmp    _T563;
_T563:
	__asm        jmp    _T568;
_T568:
	__asm        jmp    _T56d;
_T56d:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xC4], eax;
	__asm        jmp    _T580;
_T580:
	__asm        push   0;
	__asm        mov    eax, [ebp-0xC4];
	__asm        push   eax;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    ecx, [ebp-0x98];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    ecx, [ebp-0x98];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    list<Shortcut>::buffer_list, eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<Shortcut>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0xB0], 0x80;
	__asm        lea    eax, [ebp-0xB0];
	__asm        mov    [ebp-0xB8], eax;
	__asm        mov    dword ptr [ebp-0xB4], 1;
	__asm        lea    eax, [ebp-0xB4];
	__asm        mov    [ebp-0xBC], eax;
	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    ecx, [ebp-0xB8];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T612;

	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    [ebp-0xC0], eax;
	__asm        jmp    _T61e;
_T612:
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    [ebp-0xC0], eax;
_T61e:
	__asm        jmp    _T623;
_T623:
	__asm        jmp    _T628;
_T628:
	__asm        jmp    _T62d;
_T62d:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 5;
	__asm        add    eax, list<Shortcut>::next_avail;
	__asm        mov    list<Shortcut>::last, eax;
	__asm        jmp    _T648;
_T648:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x90], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0xC8], eax;
	__asm        jmp    _T689;
_T66b:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x94], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0xC8], eax;
_T689:
	__asm        jmp    _T68e;
_T68e:
	__asm        mov    eax, [ebp-0xC8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x98], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x98];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T6da;
_T6da:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xA4], 0;
	__asm        inc    list<Shortcut>::number_of_lists;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0xCC], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _T725;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    [ebp-0xD8], eax;
	__asm        jmp    _T788;
_T725:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T76a;

	__asm        mov    ecx, this;
	__asm        add    ecx, 0xA0;
	__asm        call   list<Shortcut>::add_new_buffer;
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0xD0], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0xD0];
	__asm        mov    [ebp-0xD8], eax;
	__asm        jmp    _T788;
_T76a:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0xD4], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    [ebp-0xD8], eax;
_T788:
	__asm        jmp    _T78d;
_T78d:
	__asm        mov    eax, [ebp-0xD8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xA0], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0xA0];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T7d9;
_T7d9:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xA8], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xAC], 1;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x58F228;
// LINE 1079:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004069bb
int32_t UserInputWindow::Initialize() {
	/*bp-0x4*/   int32_t nFullStringID;
	/*bp-0xc*/   /*packed*/ class basic_string<char> sText; // 0x8 bytes
	/*bp-0x10*/  /*packed*/ class ButtonWindow *tempButtonWindow;

// LINE 1089:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xCC], eax;
	__asm        cmp    dword ptr [ebp-0xCC], 0;
	__asm        je     _T7e;

	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xCC];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T70;
_T70:
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _T85;
_T7e:
	sText.reference = 0x0;
_T85:
	__asm        mov    sText.c_str_ptr, 0;
	__asm        jmp    _T91;
// LINE 1092:
_T91:
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::Initialize;
// LINE 1095:
	__asm        push   0xB0;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x14], eax;
	__asm        cmp    dword ptr [ebp-0x14], 0;
	__asm        je     _T108;

	__asm        jmp    _Tbb;
_Tbb:
	__asm        mov    dword ptr [ebp-0x24], 0x28;
	__asm        mov    dword ptr [ebp-0x20], 0x1A;
	__asm        mov    dword ptr [ebp-0x1C], 0x29;
	__asm        mov    dword ptr [ebp-0x18], 0x1B;
	__asm        jmp    _Tdc;
_Tdc:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   5;
	__asm        lea    eax, [ebp-0x24];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x14];
	__asm        call   KeyboardWindow::KeyboardWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x78], eax;
	__asm        jmp    _T115;
_T108:
	this->myKeyboardWindow = 0x0;
// LINE 1096:
_T115:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+4];
// LINE 1099:
	__asm        push   0x1DE;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x28], eax;
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T198;

	__asm        jmp    _T14b;
_T14b:
	__asm        mov    dword ptr [ebp-0x38], 0xD2;
	__asm        mov    dword ptr [ebp-0x34], 0xA;
	__asm        mov    dword ptr [ebp-0x30], 0xD3;
	__asm        mov    dword ptr [ebp-0x2C], 0xB;
	__asm        jmp    _T16c;
_T16c:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   6;
	__asm        lea    eax, [ebp-0x38];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x28];
	__asm        call   JoystickWindow::JoystickWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x74], eax;
	__asm        jmp    _T1a5;
_T198:
	this->myJoystickWindow = 0x0;
// LINE 1100:
_T1a5:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x74];
	__asm        call   dword ptr [edx+4];
// LINE 1101:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x74];
	__asm        call   dword ptr [edx+0x14];
// LINE 1104:
	__asm        push   0xCC;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x3C], eax;
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        je     _T23f;

	__asm        jmp    _T1f2;
_T1f2:
	__asm        mov    dword ptr [ebp-0x4C], 0x20;
	__asm        mov    dword ptr [ebp-0x48], 0xF0;
	__asm        mov    dword ptr [ebp-0x44], 0x126;
	__asm        mov    dword ptr [ebp-0x40], 0x14E;
	__asm        jmp    _T213;
_T213:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   7;
	__asm        lea    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x3C];
	__asm        call   ListBoxWindow::ListBoxWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x7C], eax;
	__asm        jmp    _T24c;
_T23f:
	this->myInputDeviceListBoxWindow = 0x0;
// LINE 1105:
_T24c:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+4];
// LINE 1106:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x10;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x128];
// LINE 1107:
	__asm        push   0x5C2794;
	__asm        push   0x5C2790;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x124];
// LINE 1108:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xD8];
// LINE 1109:
	__asm        push   0xFFFFFFFF;
	__asm        push   0x33;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x120];
// LINE 1110:
	__asm        push   0;
	__asm        push   0;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x12C];
// LINE 1113:
	__asm        push   0xCC;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x50], eax;
	__asm        cmp    dword ptr [ebp-0x50], 0;
	__asm        je     _T36e;

	__asm        jmp    _T31e;
_T31e:
	__asm        mov    dword ptr [ebp-0x60], 0x12E;
	__asm        mov    dword ptr [ebp-0x5C], 0xF0;
	__asm        mov    dword ptr [ebp-0x58], 0x230;
	__asm        mov    dword ptr [ebp-0x54], 0x14E;
	__asm        jmp    _T33f;
_T33f:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   8;
	__asm        lea    eax, [ebp-0x60];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x50];
	__asm        call   ListBoxWindow::ListBoxWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x80], eax;
	__asm        jmp    _T37e;
_T36e:
	this->myCommandListBoxWindow = 0x0;
// LINE 1114:
_T37e:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+4];
// LINE 1115:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x10;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+0x128];
// LINE 1116:
	__asm        push   0x5C2794;
	__asm        push   0x5C2790;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+0x124];
// LINE 1117:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+0xD8];
// LINE 1118:
	__asm        push   0xFFFFFFFF;
	__asm        push   0x33;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+0x120];
// LINE 1119:
	__asm        push   0;
	__asm        push   0;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+0x12C];
// LINE 1121:
	__asm        push   0;
	__asm        push   6;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1122:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x10DC];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x10E0], eax;
	__asm        cmp    dword ptr [ebp-0x10E0], 0;
	__asm        jne    _T511;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x10DC];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x10E0], eax;
	__asm        jmp    _T4c3;
_T4c3:
	__asm        lea    eax, [ebp-0x10DC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10DC];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T4e7;
_T4e7:
	__asm        jmp    _T4ec;
_T4ec:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T50c;
_T50c:
	__asm        jmp    _T6a5;
_T511:
	__asm        jmp    _T516;
_T516:
	__asm        lea    eax, [ebp-0x10DC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x10FC], eax;
	__asm        cmp    dword ptr [ebp-0x10FC], 0xFFFFFFFF;
	__asm        jne    _T570;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x10F0], eax;
	__asm        mov    eax, [ebp-0x10F0];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T561;
_T561:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T570;
_T570:
	__asm        jmp    _T575;
_T575:
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T5a6;

	__asm        cmp    dword ptr [ebp-0x10FC], 0;
	__asm        je     _T64b;

	__asm        jmp    _T594;
_T594:
	__asm        mov    eax, sText.reference;
	__asm        mov    ecx, [ebp-0x10FC];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T64b;
_T5a6:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x10E8], eax;
	__asm        cmp    dword ptr [ebp-0x10E8], 0;
	__asm        je     _T5e7;

	__asm        mov    eax, [ebp-0x10FC];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10DC];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x10E8];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x10E4], eax;
	__asm        jmp    _T5f1;
_T5e7:
	__asm        mov    dword ptr [ebp-0x10E4], 0;
_T5f1:
	__asm        mov    eax, sText.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T638;

	__asm        mov    eax, sText.reference;
	__asm        mov    [ebp-0x10F8], eax;
	__asm        mov    eax, [ebp-0x10F8];
	__asm        mov    [ebp-0x10F4], eax;
	__asm        cmp    dword ptr [ebp-0x10F4], 0;
	__asm        je     _T638;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x10F4];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T638;
_T638:
	__asm        jmp    _T63d;
_T63d:
	__asm        mov    eax, [ebp-0x10E4];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _T68a;
_T64b:
	__asm        cmp    dword ptr [ebp-0x10FC], 0;
	__asm        je     _T68a;

	__asm        jmp    _T65d;
_T65d:
	__asm        mov    eax, sText.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x10EC], eax;
	__asm        mov    eax, [ebp-0x10FC];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10DC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x10EC];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T68a;
_T68a:
	__asm        mov    eax, [ebp-0x10FC];
	__asm        mov    ecx, sText.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T69b;
_T69b:
	__asm        jmp    _T6a0;
_T6a0:
	__asm        jmp    _T6a5;
// LINE 1124:
_T6a5:
	__asm        push   0xA4;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x64], eax;
	__asm        cmp    dword ptr [ebp-0x64], 0;
	__asm        je     _T713;

	__asm        jmp    _T6c4;
_T6c4:
	__asm        mov    dword ptr [ebp-0x74], 0x20;
	__asm        mov    dword ptr [ebp-0x70], 0x148;
	__asm        mov    dword ptr [ebp-0x6C], 0x126;
	__asm        mov    dword ptr [ebp-0x68], 0x19E;
	__asm        jmp    _T6e5;
_T6e5:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        push   4;
	__asm        lea    eax, [ebp-0x74];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x64];
	__asm        call   TextWindow::TextWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x84], eax;
	__asm        jmp    _T723;
_T713:
	this->myStatusTextWindow = 0x0;
// LINE 1125:
_T723:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x84];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x84];
	__asm        call   dword ptr [edx+4];
// LINE 1126:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x10;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x84];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x84];
	__asm        call   dword ptr [edx+0xCC];
// LINE 1127:
	__asm        push   0x5C2794;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x84];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x84];
	__asm        call   dword ptr [edx+0xD4];
// LINE 1128:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x84];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x84];
	__asm        call   dword ptr [edx+0xE4];
// LINE 1129:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x84];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x84];
	__asm        call   dword ptr [edx+0x28];
// LINE 1132:
	__asm        push   0x94;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x78], eax;
	__asm        cmp    dword ptr [ebp-0x78], 0;
	__asm        je     _T83b;

	__asm        jmp    _T7e9;
_T7e9:
	__asm        mov    dword ptr [ebp-0x88], 0x146;
	__asm        mov    dword ptr [ebp-0x84], 0x17C;
	__asm        mov    dword ptr [ebp-0x80], 0x146;
	__asm        mov    dword ptr [ebp-0x7C], 0x17D;
	__asm        jmp    _T810;
_T810:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   1;
	__asm        lea    eax, [ebp-0x88];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x78];
	__asm        call   SoundButtonWindow::SoundButtonWindow;
	__asm        mov    tempButtonWindow, eax;
	__asm        jmp    _T842;
_T83b:
	tempButtonWindow = 0x0;
// LINE 1133:
_T842:
	__asm        push   0;
	__asm        push   0x14;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1134:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x20FC];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x2100], eax;
	__asm        cmp    dword ptr [ebp-0x2100], 0;
	__asm        jne    _T8fe;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x20FC];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x2100], eax;
	__asm        jmp    _T8b0;
_T8b0:
	__asm        lea    eax, [ebp-0x20FC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x20FC];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T8d4;
_T8d4:
	__asm        jmp    _T8d9;
_T8d9:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T8f9;
_T8f9:
	__asm        jmp    _Ta92;
_T8fe:
	__asm        jmp    _T903;
_T903:
	__asm        lea    eax, [ebp-0x20FC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x211C], eax;
	__asm        cmp    dword ptr [ebp-0x211C], 0xFFFFFFFF;
	__asm        jne    _T95d;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x2110], eax;
	__asm        mov    eax, [ebp-0x2110];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T94e;
_T94e:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T95d;
_T95d:
	__asm        jmp    _T962;
_T962:
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T993;

	__asm        cmp    dword ptr [ebp-0x211C], 0;
	__asm        je     _Ta38;

	__asm        jmp    _T981;
_T981:
	__asm        mov    eax, sText.reference;
	__asm        mov    ecx, [ebp-0x211C];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _Ta38;
_T993:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x2108], eax;
	__asm        cmp    dword ptr [ebp-0x2108], 0;
	__asm        je     _T9d4;

	__asm        mov    eax, [ebp-0x211C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x20FC];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x2108];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x2104], eax;
	__asm        jmp    _T9de;
_T9d4:
	__asm        mov    dword ptr [ebp-0x2104], 0;
_T9de:
	__asm        mov    eax, sText.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _Ta25;

	__asm        mov    eax, sText.reference;
	__asm        mov    [ebp-0x2118], eax;
	__asm        mov    eax, [ebp-0x2118];
	__asm        mov    [ebp-0x2114], eax;
	__asm        cmp    dword ptr [ebp-0x2114], 0;
	__asm        je     _Ta25;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x2114];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _Ta25;
_Ta25:
	__asm        jmp    _Ta2a;
_Ta2a:
	__asm        mov    eax, [ebp-0x2104];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _Ta77;
_Ta38:
	__asm        cmp    dword ptr [ebp-0x211C], 0;
	__asm        je     _Ta77;

	__asm        jmp    _Ta4a;
_Ta4a:
	__asm        mov    eax, sText.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x210C], eax;
	__asm        mov    eax, [ebp-0x211C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x20FC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x210C];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _Ta77;
_Ta77:
	__asm        mov    eax, [ebp-0x211C];
	__asm        mov    ecx, sText.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _Ta88;
_Ta88:
	__asm        jmp    _Ta8d;
_Ta8d:
	__asm        jmp    _Ta92;
// LINE 1135:
_Ta92:
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0x48];
// LINE 1136:
	__asm        push   0x5C2794;
	__asm        push   0x5C2790;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0xD8];
// LINE 1137:
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1140:
	__asm        push   0x94;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x8C], eax;
	__asm        cmp    dword ptr [ebp-0x8C], 0;
	__asm        je     _Tb44;

	__asm        jmp    _Tae9;
_Tae9:
	__asm        mov    dword ptr [ebp-0x9C], 0x1BC;
	__asm        mov    dword ptr [ebp-0x98], 0x17C;
	__asm        mov    dword ptr [ebp-0x94], 0x1BD;
	__asm        mov    dword ptr [ebp-0x90], 0x17D;
	__asm        jmp    _Tb16;
_Tb16:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   2;
	__asm        lea    eax, [ebp-0x9C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x8C];
	__asm        call   SoundButtonWindow::SoundButtonWindow;
	__asm        mov    tempButtonWindow, eax;
	__asm        jmp    _Tb4b;
_Tb44:
	tempButtonWindow = 0x0;
// LINE 1141:
_Tb4b:
	__asm        push   0;
	__asm        push   0x15;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1142:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x311C];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x3120], eax;
	__asm        cmp    dword ptr [ebp-0x3120], 0;
	__asm        jne    _Tc07;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x311C];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x3120], eax;
	__asm        jmp    _Tbb9;
_Tbb9:
	__asm        lea    eax, [ebp-0x311C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x311C];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _Tbdd;
_Tbdd:
	__asm        jmp    _Tbe2;
_Tbe2:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _Tc02;
_Tc02:
	__asm        jmp    _Td9b;
_Tc07:
	__asm        jmp    _Tc0c;
_Tc0c:
	__asm        lea    eax, [ebp-0x311C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x313C], eax;
	__asm        cmp    dword ptr [ebp-0x313C], 0xFFFFFFFF;
	__asm        jne    _Tc66;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x3130], eax;
	__asm        mov    eax, [ebp-0x3130];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _Tc57;
_Tc57:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _Tc66;
_Tc66:
	__asm        jmp    _Tc6b;
_Tc6b:
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _Tc9c;

	__asm        cmp    dword ptr [ebp-0x313C], 0;
	__asm        je     _Td41;

	__asm        jmp    _Tc8a;
_Tc8a:
	__asm        mov    eax, sText.reference;
	__asm        mov    ecx, [ebp-0x313C];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _Td41;
_Tc9c:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x3128], eax;
	__asm        cmp    dword ptr [ebp-0x3128], 0;
	__asm        je     _Tcdd;

	__asm        mov    eax, [ebp-0x313C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x311C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x3128];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x3124], eax;
	__asm        jmp    _Tce7;
_Tcdd:
	__asm        mov    dword ptr [ebp-0x3124], 0;
_Tce7:
	__asm        mov    eax, sText.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _Td2e;

	__asm        mov    eax, sText.reference;
	__asm        mov    [ebp-0x3138], eax;
	__asm        mov    eax, [ebp-0x3138];
	__asm        mov    [ebp-0x3134], eax;
	__asm        cmp    dword ptr [ebp-0x3134], 0;
	__asm        je     _Td2e;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x3134];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _Td2e;
_Td2e:
	__asm        jmp    _Td33;
_Td33:
	__asm        mov    eax, [ebp-0x3124];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _Td80;
_Td41:
	__asm        cmp    dword ptr [ebp-0x313C], 0;
	__asm        je     _Td80;

	__asm        jmp    _Td53;
_Td53:
	__asm        mov    eax, sText.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x312C], eax;
	__asm        mov    eax, [ebp-0x313C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x311C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x312C];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _Td80;
_Td80:
	__asm        mov    eax, [ebp-0x313C];
	__asm        mov    ecx, sText.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _Td91;
_Td91:
	__asm        jmp    _Td96;
_Td96:
	__asm        jmp    _Td9b;
// LINE 1143:
_Td9b:
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0x48];
// LINE 1144:
	__asm        push   0x5C2794;
	__asm        push   0x5C2790;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0xD8];
// LINE 1145:
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1148:
	__asm        push   0x94;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xA0], eax;
	__asm        cmp    dword ptr [ebp-0xA0], 0;
	__asm        je     _Te4d;

	__asm        jmp    _Tdf2;
_Tdf2:
	__asm        mov    dword ptr [ebp-0xB0], 0x146;
	__asm        mov    dword ptr [ebp-0xAC], 0x15A;
	__asm        mov    dword ptr [ebp-0xA8], 0x147;
	__asm        mov    dword ptr [ebp-0xA4], 0x15B;
	__asm        jmp    _Te1f;
_Te1f:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   9;
	__asm        lea    eax, [ebp-0xB0];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0xA0];
	__asm        call   SoundButtonWindow::SoundButtonWindow;
	__asm        mov    tempButtonWindow, eax;
	__asm        jmp    _Te54;
_Te4d:
	tempButtonWindow = 0x0;
// LINE 1149:
_Te54:
	__asm        push   0;
	__asm        push   8;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1150:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x413C];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x4140], eax;
	__asm        cmp    dword ptr [ebp-0x4140], 0;
	__asm        jne    _Tf10;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x413C];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x4140], eax;
	__asm        jmp    _Tec2;
_Tec2:
	__asm        lea    eax, [ebp-0x413C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x413C];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _Tee6;
_Tee6:
	__asm        jmp    _Teeb;
_Teeb:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _Tf0b;
_Tf0b:
	__asm        jmp    _T10a4;
_Tf10:
	__asm        jmp    _Tf15;
_Tf15:
	__asm        lea    eax, [ebp-0x413C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x415C], eax;
	__asm        cmp    dword ptr [ebp-0x415C], 0xFFFFFFFF;
	__asm        jne    _Tf6f;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x4150], eax;
	__asm        mov    eax, [ebp-0x4150];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _Tf60;
_Tf60:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _Tf6f;
_Tf6f:
	__asm        jmp    _Tf74;
_Tf74:
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _Tfa5;

	__asm        cmp    dword ptr [ebp-0x415C], 0;
	__asm        je     _T104a;

	__asm        jmp    _Tf93;
_Tf93:
	__asm        mov    eax, sText.reference;
	__asm        mov    ecx, [ebp-0x415C];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T104a;
_Tfa5:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x4148], eax;
	__asm        cmp    dword ptr [ebp-0x4148], 0;
	__asm        je     _Tfe6;

	__asm        mov    eax, [ebp-0x415C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x413C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x4148];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x4144], eax;
	__asm        jmp    _Tff0;
_Tfe6:
	__asm        mov    dword ptr [ebp-0x4144], 0;
_Tff0:
	__asm        mov    eax, sText.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T1037;

	__asm        mov    eax, sText.reference;
	__asm        mov    [ebp-0x4158], eax;
	__asm        mov    eax, [ebp-0x4158];
	__asm        mov    [ebp-0x4154], eax;
	__asm        cmp    dword ptr [ebp-0x4154], 0;
	__asm        je     _T1037;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x4154];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T1037;
_T1037:
	__asm        jmp    _T103c;
_T103c:
	__asm        mov    eax, [ebp-0x4144];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _T1089;
_T104a:
	__asm        cmp    dword ptr [ebp-0x415C], 0;
	__asm        je     _T1089;

	__asm        jmp    _T105c;
_T105c:
	__asm        mov    eax, sText.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x414C], eax;
	__asm        mov    eax, [ebp-0x415C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x413C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x414C];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T1089;
_T1089:
	__asm        mov    eax, [ebp-0x415C];
	__asm        mov    ecx, sText.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T109a;
_T109a:
	__asm        jmp    _T109f;
_T109f:
	__asm        jmp    _T10a4;
// LINE 1151:
_T10a4:
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0x48];
// LINE 1152:
	__asm        push   0x5C2794;
	__asm        push   0x5C2790;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0xD8];
// LINE 1153:
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1156:
	__asm        push   0x94;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xB4], eax;
	__asm        cmp    dword ptr [ebp-0xB4], 0;
	__asm        je     _T1156;

	__asm        jmp    _T10fb;
_T10fb:
	__asm        mov    dword ptr [ebp-0xC4], 0x1BC;
	__asm        mov    dword ptr [ebp-0xC0], 0x15A;
	__asm        mov    dword ptr [ebp-0xBC], 0x1BD;
	__asm        mov    dword ptr [ebp-0xB8], 0x15B;
	__asm        jmp    _T1128;
_T1128:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   3;
	__asm        lea    eax, [ebp-0xC4];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0xB4];
	__asm        call   SoundButtonWindow::SoundButtonWindow;
	__asm        mov    tempButtonWindow, eax;
	__asm        jmp    _T115d;
_T1156:
	tempButtonWindow = 0x0;
// LINE 1157:
_T115d:
	__asm        push   0;
	__asm        push   5;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1158:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x515C];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x5160], eax;
	__asm        cmp    dword ptr [ebp-0x5160], 0;
	__asm        jne    _T1219;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x515C];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x5160], eax;
	__asm        jmp    _T11cb;
_T11cb:
	__asm        lea    eax, [ebp-0x515C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x515C];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T11ef;
_T11ef:
	__asm        jmp    _T11f4;
_T11f4:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T1214;
_T1214:
	__asm        jmp    _T1247;
_T1219:
	__asm        jmp    _T121e;
_T121e:
	__asm        lea    eax, [ebp-0x515C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x515C];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T1242;
_T1242:
	__asm        jmp    _T1247;
// LINE 1159:
_T1247:
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0x48];
// LINE 1160:
	__asm        push   0x5C2794;
	__asm        push   0x5C2790;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0xD8];
// LINE 1161:
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1163:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC4];
// LINE 1164:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0xC8];
// LINE 1165:
	this->bInitializing = 0x0;
// LINE 1166:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1168:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   GraphicWindow::MakeModal;
	__asm        add    esp, 4;
// LINE 1169:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   GraphicWindow::MakeFocus;
	__asm        add    esp, 4;
// LINE 1171:
	__asm        mov    dword ptr [ebp-0xC8], 1;
	__asm        mov    eax, sText.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T1344;

	__asm        mov    eax, sText.reference;
	__asm        mov    [ebp-0xDC], eax;
	__asm        mov    eax, [ebp-0xDC];
	__asm        mov    [ebp-0xD8], eax;
	__asm        cmp    dword ptr [ebp-0xD8], 0;
	__asm        je     _T1344;

	__asm        mov    ecx, [ebp-0xD8];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T132b;
_T132b:
	__asm        mov    eax, [ebp-0xD8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T133f;
_T133f:
	__asm        jmp    _T1344;
_T1344:
	__asm        jmp    _T1349;
_T1349:
	__asm        cmp    sText.c_str_ptr, 0;
	__asm        je     _T1377;

	__asm        mov    eax, sText.c_str_ptr;
	__asm        mov    [ebp-0xD0], eax;
	__asm        mov    eax, [ebp-0xD0];
	__asm        mov    [ebp-0xD4], eax;
	__asm        mov    eax, [ebp-0xD4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T1377:
	__asm        jmp    _T137c;
_T137c:
	__asm        mov    eax, [ebp-0xC8];
	__asm        jmp    __RETURN;
// LINE 1172:
__RETURN:
}

// FUNCTION: COPTER_D 0x00407d47
long UserInputWindow::DoKeyDown(long lKey, char chModifiers) {
// LINE 1179:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        jne    _T20;
// LINE 1180:
	return 0x0;
// LINE 1182:
_T20:
	__asm        cmp    lKey, 0x1B;
	__asm        jne    _T59;
// LINE 1183:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T59;
// LINE 1184:
	__asm        push   0;
	__asm        push   0x3EA;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 1186:
_T59:
	return 0x1;
// LINE 1187:
}

// FUNCTION: COPTER_D 0x00407db1
int32_t UserInputWindow::DoMessage(/*unpacked*/ class GraphicWindow *gwSource, long lWindowID, long lMessage, void * __ptr32 pMessageData) {
	/*bp-0x4*/   /*packed*/ class ControlDisplayWindow *tempControlDisplayWindow;

// LINE 1198:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0xAC], 0;
	__asm        je     _T23;
// LINE 1199:
	return 0x0;
// LINE 1201:
_T23:
	__asm        mov    eax, lWindowID;
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    _T330;
// LINE 1203:
_T2e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T5d;
// LINE 1204:
	__asm        push   0;
	__asm        push   0x3E9;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 1205:
_T5d:
	return 0x1;
// LINE 1207:
_T67:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T96;
// LINE 1208:
	__asm        push   0;
	__asm        push   0x3EA;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 1209:
_T96:
	return 0x1;
// LINE 1212:
_Ta0:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x24], eax;
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _Tb7;
_Tb7:
	__asm        jmp    _Tbc;
_Tbc:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x28], eax;
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Td5;
_Td5:
	__asm        jmp    _Tda;
_Tda:
	__asm        mov    eax, [ebp-8];
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, [ebp-0xC];
	__asm        mov    [ebp-0x44], eax;
_Te6:
	__asm        mov    eax, [ebp-0x40];
	__asm        cmp    [ebp-0x44], eax;
	__asm        jne    _Tfc;

	__asm        jmp    _T110;

	__asm        jmp    _Tfc;
_Tfc:
	__asm        jmp    _T10b;

	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        jne    _T110;
_T10b:
	__asm        jmp    _T115;
_T110:
	__asm        jmp    _T197;
_T115:
	__asm        jmp    _T124;

	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _T197;
_T124:
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x44], eax;
	__asm        jmp    _T137;
_T137:
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T142;
_T142:
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x3C];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x3C];
	__asm        mov    ecx, [ecx];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T168;
_T168:
	__asm        jmp    _T16d;
_T16d:
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    ecx, [ebp-0x3C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        jmp    _T184;
_T184:
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+0xA4];
	__asm        jmp    _T192;
_T192:
	__asm        jmp    _Te6;
_T197:
	__asm        jmp    _T19c;
// LINE 1213:
_T19c:
	__asm        mov    eax, this;
	__asm        add    eax, 0xA0;
	__asm        push   eax;
	__asm        call   MakeDefaultConfigurableShortcuts;
	__asm        add    esp, 4;
// LINE 1214:
	this->bCommandsHaveChanged = 0x1;
// LINE 1215:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1216:
	return 0x1;
// LINE 1218:
_T1ce:
	__asm        mov    eax, pMessageData;
	__asm        push   eax;
	__asm        mov    eax, lMessage;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DoKeyboardWindowMessage;
// LINE 1219:
	return 0x1;
// LINE 1221:
_T1e8:
	__asm        mov    eax, pMessageData;
	__asm        push   eax;
	__asm        mov    eax, lMessage;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DoJoystickWindowMessage;
// LINE 1222:
	return 0x1;
// LINE 1224:
_T202:
	__asm        mov    eax, pMessageData;
	__asm        push   eax;
	__asm        mov    eax, lMessage;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DoInputDeviceListBoxWindowMessage;
// LINE 1225:
	return 0x1;
// LINE 1227:
_T21c:
	__asm        mov    eax, pMessageData;
	__asm        push   eax;
	__asm        mov    eax, lMessage;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DoCommandListBoxWindowMessage;
// LINE 1228:
	return 0x1;
// LINE 1230:
_T236:
	__asm        push   0x80;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x10], eax;
	__asm        cmp    dword ptr [ebp-0x10], 0;
	__asm        je     _T29b;

	__asm        jmp    _T255;
_T255:
	__asm        mov    dword ptr [ebp-0x20], 0;
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        mov    dword ptr [ebp-0x18], 1;
	__asm        mov    dword ptr [ebp-0x14], 1;
	__asm        jmp    _T276;
_T276:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, GraphicWindow::screenWindow;
	__asm        push   eax;
	__asm        push   0x2711;
	__asm        lea    eax, [ebp-0x20];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x10];
	__asm        call   ControlDisplayWindow::ControlDisplayWindow;
	__asm        mov    tempControlDisplayWindow, eax;
	__asm        jmp    _T2a2;
_T29b:
	tempControlDisplayWindow = 0x0;
// LINE 1231:
_T2a2:
	__asm        mov    eax, tempControlDisplayWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempControlDisplayWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1232:
	__asm        mov    eax, GraphicWindow::screenWindow;
	__asm        push   eax;
	__asm        mov    eax, tempControlDisplayWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempControlDisplayWindow;
	__asm        call   dword ptr [eax+0x40];
// LINE 1233:
	__asm        mov    eax, this;
	__asm        add    eax, 0xA0;
	__asm        push   eax;
	__asm        mov    eax, tempControlDisplayWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempControlDisplayWindow;
	__asm        call   dword ptr [eax+0xC4];
// LINE 1234:
	__asm        mov    eax, this;
	__asm        add    eax, 0x98;
	__asm        push   eax;
	__asm        mov    eax, tempControlDisplayWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempControlDisplayWindow;
	__asm        call   dword ptr [eax+0xC4];
// LINE 1235:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 0;
	__asm        jmp    _T2fb;
// LINE 1236:
_T2fb:
	return 0x1;
// LINE 1238:
_T305:
	__asm        cmp    lMessage, 0x3E9;
	__asm        jne    _T321;
// LINE 1239:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 1;
	__asm        jmp    _T321;
// LINE 1240:
_T321:
	return 0x1;
// LINE 1241:
	__asm        jmp    _T383;
_T330:
	__asm        cmp    dword ptr [ebp-0x4C], 0x2711;
	__asm        jg     _T383;

	__asm        je     _T305;

	__asm        dec    dword ptr [ebp-0x4C];
	__asm        cmp    dword ptr [ebp-0x4C], 8;
	__asm        ja     _T383;

	__asm        mov    eax, [ebp-0x4C];
	__asm        jmp    _Switch_35a[0][eax*4];
// Switch pointers:
//   _T2e
//   _T67
//   _Ta0
//   _T383
//   _T1ce
//   _T1e8
//   _T202
//   _T21c
//   _T236

	__asm        jmp    _T383;
// LINE 1243:
_T383:
	return 0x0;
// LINE 1244:
}

// FUNCTION: COPTER_D 0x00408142
int32_t UserInputWindow::DoJoystickWindowMessage(long lMessage, void * __ptr32 pMessageData) {
	/*bp-0x18*/  /*packed*/ struct Shortcut tempShortcut; // 0x18 bytes
	/*bp-0x1c*/  enum UserInputWindow::KeyUsageType tempKeyUsageType;
	/*bp-0x20*/  long lCurrentCommand;
	/*bp-0x24*/  long lDevice;
	/*bp-0x28*/  long lControl;

// LINE 1259:
	__asm        cmp    lMessage, 0x10001;
	__asm        je     _T2c;

	__asm        cmp    lMessage, 0x10002;
	__asm        jne    _T893;
// LINE 1261:
_T2c:
	__asm        mov    eax, pMessageData;
	__asm        mov    eax, [eax];
	__asm        mov    lControl, eax;
// LINE 1262:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    eax, [eax+0x74];
	__asm        inc    eax;
	__asm        mov    lDevice, eax;
// LINE 1263:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetCurrentCommand;
	__asm        mov    lCurrentCommand, eax;
// LINE 1264:
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    eax, lControl;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetKeyUsageType;
	__asm        mov    tempKeyUsageType, eax;
// LINE 1266:
	__asm        cmp    lControl, 0;
	__asm        jl     _T454;

	__asm        cmp    lControl, 5;
	__asm        jg     _T454;
// LINE 1268:
	__asm        cmp    tempKeyUsageType, 0;
	__asm        jne    _T3d4;
// LINE 1269:
	__asm        mov    eax, lControl;
	__asm        push   eax;
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::RemoveJoystickTwinCommand;
// LINE 1270:
	tempShortcut.lDeviceID = lDevice;
// LINE 1271:
	tempShortcut.lCommand = lCurrentCommand;
// LINE 1272:
	tempShortcut.lKey = lControl;
// LINE 1273:
	tempShortcut.lModifiers = 0x0;
// LINE 1274:
	tempShortcut.lPush = 0x0;
// LINE 1275:
	tempShortcut.lIgnoreModifiers = 0x0;
// LINE 1276:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x34], eax;
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _Tde;
_Tde:
	__asm        jmp    _Te3;
_Te3:
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x90], eax;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0x40], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _T11b;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _T304;
_T11b:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T2ec;

	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        push   8;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x78], eax;
	__asm        cmp    dword ptr [ebp-0x78], 0;
	__asm        jne    _T17a;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T170;
_T170:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T17a:
	__asm        jmp    _T17f;
_T17f:
	__asm        jmp    _T184;
_T184:
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    [ebp-0x4C], eax;
	__asm        mov    dword ptr [ebp-0x50], 0x80;
	__asm        lea    eax, [ebp-0x50];
	__asm        mov    [ebp-0x58], eax;
	__asm        mov    dword ptr [ebp-0x54], 1;
	__asm        lea    eax, [ebp-0x54];
	__asm        mov    [ebp-0x5C], eax;
	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    ecx, [ebp-0x58];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T1bf;

	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    [ebp-0x60], eax;
	__asm        jmp    _T1c5;
_T1bf:
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    [ebp-0x60], eax;
_T1c5:
	__asm        jmp    _T1ca;
_T1ca:
	__asm        jmp    _T1cf;
_T1cf:
	__asm        jmp    _T1d4;
_T1d4:
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x88], eax;
	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x88];
	__asm        shl    eax, 5;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x80], eax;
	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        jne    _T23b;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x84], eax;
	__asm        mov    eax, [ebp-0x84];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T231;
_T231:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T23b:
	__asm        jmp    _T240;
_T240:
	__asm        jmp    _T245;
_T245:
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    ecx, [ebp-0x4C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    ecx, [ebp-0x4C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    list<Shortcut>::buffer_list, eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<Shortcut>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x64], 0x80;
	__asm        lea    eax, [ebp-0x64];
	__asm        mov    [ebp-0x6C], eax;
	__asm        mov    dword ptr [ebp-0x68], 1;
	__asm        lea    eax, [ebp-0x68];
	__asm        mov    [ebp-0x70], eax;
	__asm        mov    eax, [ebp-0x70];
	__asm        mov    ecx, [ebp-0x6C];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T2a2;

	__asm        mov    eax, [ebp-0x70];
	__asm        mov    [ebp-0x74], eax;
	__asm        jmp    _T2a8;
_T2a2:
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    [ebp-0x74], eax;
_T2a8:
	__asm        jmp    _T2ad;
_T2ad:
	__asm        jmp    _T2b2;
_T2b2:
	__asm        jmp    _T2b7;
_T2b7:
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 5;
	__asm        add    eax, list<Shortcut>::next_avail;
	__asm        mov    list<Shortcut>::last, eax;
	__asm        jmp    _T2cf;
_T2cf:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x44], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _T304;
_T2ec:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x48], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x8C], eax;
_T304:
	__asm        jmp    _T309;
_T309:
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    [ebp-0x38], eax;
	__asm        jmp    _T317;
_T317:
	__asm        mov    eax, [ebp-0x38];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    _T325;
_T325:
	__asm        cmp    dword ptr [ebp-0x3C], 0;
	__asm        je     _T341;

	__asm        lea    esi, tempShortcut.lDeviceID;
	__asm        mov    edi, [ebp-0x3C];
	__asm        mov    ecx, 6;
	__asm        rep movsd;
	__asm        jmp    _T341;
_T341:
	__asm        jmp    _T346;
_T346:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    ecx, [ebp-0x38];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x38];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    ecx, [ebp-0x90];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    ecx, [ebp-0x90];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+0xA4];
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _T391;
_T391:
	__asm        jmp    _T396;
_T396:
	__asm        jmp    _T39b;
// LINE 1277:
_T39b:
	__asm        mov    eax, lControl;
	__asm        push   eax;
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::AddJoystickTwinCommand;
// LINE 1278:
	this->bCommandsHaveChanged = 0x1;
// LINE 1279:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1281:
	__asm        jmp    _T44f;
_T3d4:
	__asm        cmp    tempKeyUsageType, 2;
	__asm        jne    _T42e;
// LINE 1282:
	__asm        mov    eax, lControl;
	__asm        push   eax;
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::RemoveShortcutFromList;
// LINE 1283:
	__asm        mov    eax, lControl;
	__asm        push   eax;
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::RemoveJoystickTwinCommand;
// LINE 1284:
	this->bCommandsHaveChanged = 0x1;
// LINE 1285:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1287:
	__asm        jmp    _T44f;
_T42e:
	__asm        cmp    tempKeyUsageType, 3;
	__asm        jne    _T44f;
// LINE 1288:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DisplayError;
// LINE 1289:
	return 0x1;
// LINE 1292:
_T44f:
	__asm        jmp    _T893;
// LINE 1293:
_T454:
	__asm        cmp    tempKeyUsageType, 0;
	__asm        jne    _T82f;
// LINE 1294:
	tempShortcut.lDeviceID = lDevice;
// LINE 1295:
	tempShortcut.lCommand = lCurrentCommand;
// LINE 1296:
	tempShortcut.lKey = lControl;
// LINE 1297:
	tempShortcut.lModifiers = 0x0;
// LINE 1298:
	tempShortcut.lPush = 0x0;
// LINE 1299:
	tempShortcut.lIgnoreModifiers = 0x0;
// LINE 1300:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x9C], eax;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0x94], eax;
	__asm        jmp    _T4a8;
_T4a8:
	__asm        jmp    _T4ad;
_T4ad:
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0xF8], eax;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0xA8], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _T4ee;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    [ebp-0xF4], eax;
	__asm        jmp    _T755;
_T4ee:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T737;

	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        push   8;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xE0], eax;
	__asm        cmp    dword ptr [ebp-0xE0], 0;
	__asm        jne    _T559;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0xE4], eax;
	__asm        mov    eax, [ebp-0xE4];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T54f;
_T54f:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T559:
	__asm        jmp    _T55e;
_T55e:
	__asm        jmp    _T563;
_T563:
	__asm        mov    eax, [ebp-0xE0];
	__asm        mov    [ebp-0xB4], eax;
	__asm        mov    dword ptr [ebp-0xB8], 0x80;
	__asm        lea    eax, [ebp-0xB8];
	__asm        mov    [ebp-0xC0], eax;
	__asm        mov    dword ptr [ebp-0xBC], 1;
	__asm        lea    eax, [ebp-0xBC];
	__asm        mov    [ebp-0xC4], eax;
	__asm        mov    eax, [ebp-0xC4];
	__asm        mov    ecx, [ebp-0xC0];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T5c2;

	__asm        mov    eax, [ebp-0xC4];
	__asm        mov    [ebp-0xC8], eax;
	__asm        jmp    _T5ce;
_T5c2:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    [ebp-0xC8], eax;
_T5ce:
	__asm        jmp    _T5d3;
_T5d3:
	__asm        jmp    _T5d8;
_T5d8:
	__asm        jmp    _T5dd;
_T5dd:
	__asm        mov    eax, [ebp-0xC8];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xF0], eax;
	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0xF0];
	__asm        shl    eax, 5;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xE8], eax;
	__asm        cmp    dword ptr [ebp-0xE8], 0;
	__asm        jne    _T64d;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0xEC], eax;
	__asm        mov    eax, [ebp-0xEC];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T643;
_T643:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T64d:
	__asm        jmp    _T652;
_T652:
	__asm        jmp    _T657;
_T657:
	__asm        mov    eax, [ebp-0xE8];
	__asm        mov    ecx, [ebp-0xB4];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    ecx, [ebp-0xB4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xB4];
	__asm        mov    list<Shortcut>::buffer_list, eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<Shortcut>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0xCC], 0x80;
	__asm        lea    eax, [ebp-0xCC];
	__asm        mov    [ebp-0xD4], eax;
	__asm        mov    dword ptr [ebp-0xD0], 1;
	__asm        lea    eax, [ebp-0xD0];
	__asm        mov    [ebp-0xD8], eax;
	__asm        mov    eax, [ebp-0xD8];
	__asm        mov    ecx, [ebp-0xD4];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T6de;

	__asm        mov    eax, [ebp-0xD8];
	__asm        mov    [ebp-0xDC], eax;
	__asm        jmp    _T6ea;
_T6de:
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    [ebp-0xDC], eax;
_T6ea:
	__asm        jmp    _T6ef;
_T6ef:
	__asm        jmp    _T6f4;
_T6f4:
	__asm        jmp    _T6f9;
_T6f9:
	__asm        mov    eax, [ebp-0xDC];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 5;
	__asm        add    eax, list<Shortcut>::next_avail;
	__asm        mov    list<Shortcut>::last, eax;
	__asm        jmp    _T714;
_T714:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0xAC], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    [ebp-0xF4], eax;
	__asm        jmp    _T755;
_T737:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0xB0], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0xB0];
	__asm        mov    [ebp-0xF4], eax;
_T755:
	__asm        jmp    _T75a;
_T75a:
	__asm        mov    eax, [ebp-0xF4];
	__asm        mov    [ebp-0xA0], eax;
	__asm        jmp    _T76b;
_T76b:
	__asm        mov    eax, [ebp-0xA0];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0xA4], eax;
	__asm        jmp    _T77f;
_T77f:
	__asm        cmp    dword ptr [ebp-0xA4], 0;
	__asm        je     _T7a1;

	__asm        lea    esi, tempShortcut.lDeviceID;
	__asm        mov    edi, [ebp-0xA4];
	__asm        mov    ecx, 6;
	__asm        rep movsd;
	__asm        jmp    _T7a1;
_T7a1:
	__asm        jmp    _T7a6;
_T7a6:
	__asm        mov    eax, [ebp-0xF8];
	__asm        mov    ecx, [ebp-0xA0];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xF8];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xA0];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    ecx, [ebp-0xF8];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    ecx, [ebp-0xF8];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+0xA4];
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    [ebp-0x98], eax;
	__asm        jmp    _T803;
_T803:
	__asm        jmp    _T808;
_T808:
	__asm        jmp    _T80d;
// LINE 1301:
_T80d:
	this->bCommandsHaveChanged = 0x1;
// LINE 1302:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1304:
	__asm        jmp    _T893;
_T82f:
	__asm        cmp    tempKeyUsageType, 2;
	__asm        jne    _T872;
// LINE 1305:
	__asm        mov    eax, lControl;
	__asm        push   eax;
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::RemoveShortcutFromList;
// LINE 1306:
	this->bCommandsHaveChanged = 0x1;
// LINE 1307:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1309:
	__asm        jmp    _T893;
_T872:
	__asm        cmp    tempKeyUsageType, 3;
	__asm        jne    _T893;
// LINE 1310:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DisplayError;
// LINE 1311:
	return 0x1;
// LINE 1315:
_T893:
	return 0x1;
// LINE 1316:
}

// FUNCTION: COPTER_D 0x004089e6
void UserInputWindow::AddJoystickTwinCommand(long lCommand, long lDevice, long lControl) {
	/*bp-0x18*/  /*packed*/ struct Shortcut tempShortcut; // 0x18 bytes
	/*bp-0x1c*/  long lTwinCommand;

// LINE 1344:
	__asm        mov    eax, lCommand;
	__asm        push   eax;
	__asm        call   GetJoystickCommandTwin;
	__asm        add    esp, 4;
	__asm        mov    lTwinCommand, eax;
// LINE 1346:
	__asm        cmp    lTwinCommand, 0;
	__asm        je     _T312;
// LINE 1347:
	tempShortcut.lDeviceID = lDevice;
// LINE 1348:
	tempShortcut.lCommand = lTwinCommand;
// LINE 1349:
	tempShortcut.lKey = lControl;
// LINE 1350:
	tempShortcut.lModifiers = 0x0;
// LINE 1351:
	tempShortcut.lPush = 0x0;
// LINE 1352:
	tempShortcut.lIgnoreModifiers = 0x0;
// LINE 1353:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x28], eax;
	__asm        mov    eax, [ebp-0x28];
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T6c;
_T6c:
	__asm        jmp    _T71;
_T71:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x84], eax;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0x34], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _Ta6;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0x34];
	__asm        mov    [ebp-0x80], eax;
	__asm        jmp    _T27d;
_Ta6:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T268;

	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        push   8;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x6C], eax;
	__asm        cmp    dword ptr [ebp-0x6C], 0;
	__asm        jne    _T105;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x70], eax;
	__asm        mov    eax, [ebp-0x70];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _Tfb;
_Tfb:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T105:
	__asm        jmp    _T10a;
_T10a:
	__asm        jmp    _T10f;
_T10f:
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    dword ptr [ebp-0x44], 0x80;
	__asm        lea    eax, [ebp-0x44];
	__asm        mov    [ebp-0x4C], eax;
	__asm        mov    dword ptr [ebp-0x48], 1;
	__asm        lea    eax, [ebp-0x48];
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    ecx, [ebp-0x4C];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T14a;

	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x54], eax;
	__asm        jmp    _T150;
_T14a:
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    [ebp-0x54], eax;
_T150:
	__asm        jmp    _T155;
_T155:
	__asm        jmp    _T15a;
_T15a:
	__asm        jmp    _T15f;
_T15f:
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x7C], eax;
	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x7C];
	__asm        shl    eax, 5;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x74], eax;
	__asm        cmp    dword ptr [ebp-0x74], 0;
	__asm        jne    _T1ba;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    eax, [ebp-0x78];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T1b0;
_T1b0:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T1ba:
	__asm        jmp    _T1bf;
_T1bf:
	__asm        jmp    _T1c4;
_T1c4:
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    ecx, [ebp-0x40];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    ecx, [ebp-0x40];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    list<Shortcut>::buffer_list, eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<Shortcut>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x58], 0x80;
	__asm        lea    eax, [ebp-0x58];
	__asm        mov    [ebp-0x60], eax;
	__asm        mov    dword ptr [ebp-0x5C], 1;
	__asm        lea    eax, [ebp-0x5C];
	__asm        mov    [ebp-0x64], eax;
	__asm        mov    eax, [ebp-0x64];
	__asm        mov    ecx, [ebp-0x60];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T221;

	__asm        mov    eax, [ebp-0x64];
	__asm        mov    [ebp-0x68], eax;
	__asm        jmp    _T227;
_T221:
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    [ebp-0x68], eax;
_T227:
	__asm        jmp    _T22c;
_T22c:
	__asm        jmp    _T231;
_T231:
	__asm        jmp    _T236;
_T236:
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 5;
	__asm        add    eax, list<Shortcut>::next_avail;
	__asm        mov    list<Shortcut>::last, eax;
	__asm        jmp    _T24e;
_T24e:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x38], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x80], eax;
	__asm        jmp    _T27d;
_T268:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x3C], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x80], eax;
_T27d:
	__asm        jmp    _T282;
_T282:
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    [ebp-0x2C], eax;
	__asm        jmp    _T28d;
_T28d:
	__asm        mov    eax, [ebp-0x2C];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _T29b;
_T29b:
	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        je     _T2b7;

	__asm        lea    esi, tempShortcut.lDeviceID;
	__asm        mov    edi, [ebp-0x30];
	__asm        mov    ecx, 6;
	__asm        rep movsd;
	__asm        jmp    _T2b7;
_T2b7:
	__asm        jmp    _T2bc;
_T2bc:
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    ecx, [ebp-0x2C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x2C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    ecx, [ebp-0x84];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    ecx, [ebp-0x84];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        add    dword ptr [eax+0xA4], 1;
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T308;
_T308:
	__asm        jmp    _T30d;
_T30d:
	__asm        jmp    _T312;
// LINE 1355:
_T312:
	return;
}

// FUNCTION: COPTER_D 0x00408d04
void UserInputWindow::RemoveJoystickTwinCommand(long lCommand, long lDevice, long lControl) {
	/*bp-0x4*/   long lTwinCommand;

// LINE 1366:
	__asm        mov    eax, lCommand;
	__asm        push   eax;
	__asm        call   GetJoystickCommandTwin;
	__asm        add    esp, 4;
	__asm        mov    lTwinCommand, eax;
// LINE 1368:
	__asm        cmp    lTwinCommand, 0;
	__asm        je     _T39;
// LINE 1369:
	__asm        mov    eax, lControl;
	__asm        push   eax;
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    eax, lTwinCommand;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::RemoveShortcutFromList;
// LINE 1370:
_T39:
	return;
}

// FUNCTION: COPTER_D 0x00408d49
int32_t UserInputWindow::DoKeyboardWindowMessage(long lMessage, void * __ptr32 pMessageData) {
	/*bp-0x4*/   long lIgnoreModifiers;
	/*bp-0x1c*/  /*packed*/ struct Shortcut tempShortcut; // 0x18 bytes
	/*bp-0x20*/  enum UserInputWindow::KeyUsageType tempKeyUsageType;
	/*bp-0x24*/  long lKey;
	/*bp-0x28*/  long lPush;
	/*bp-0x2c*/  long lCurrentCommand;

// LINE 1386:
	__asm        cmp    lMessage, 0x10001;
	__asm        jne    _T43e;
// LINE 1387:
	__asm        mov    eax, pMessageData;
	__asm        mov    eax, [eax];
	__asm        mov    lKey, eax;
// LINE 1388:
	__asm        push   0;
	__asm        mov    eax, lKey;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetKeyUsageType;
	__asm        mov    tempKeyUsageType, eax;
// LINE 1389:
	__asm        cmp    tempKeyUsageType, 1;
	__asm        jne    _T61;
// LINE 1390:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DisplayError;
// LINE 1391:
	return 0x1;
// LINE 1393:
	__asm        jmp    _T439;
_T61:
	__asm        cmp    tempKeyUsageType, 0;
	__asm        jne    _T3bf;
// LINE 1394:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetCurrentCommand;
	__asm        mov    lCurrentCommand, eax;
// LINE 1395:
	__asm        lea    eax, lIgnoreModifiers;
	__asm        push   eax;
	__asm        lea    eax, lPush;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        call   GetPushAndIgnoreSettingsForCommand;
	__asm        add    esp, 0xC;
// LINE 1396:
	tempShortcut.lDeviceID = 0x0;
// LINE 1397:
	tempShortcut.lCommand = lCurrentCommand;
// LINE 1398:
	tempShortcut.lKey = lKey;
// LINE 1399:
	tempShortcut.lModifiers = 0x0;
// LINE 1400:
	tempShortcut.lPush = lPush;
// LINE 1401:
	tempShortcut.lIgnoreModifiers = lIgnoreModifiers;
// LINE 1402:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x38], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _Tcd;
_Tcd:
	__asm        jmp    _Td2;
_Td2:
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0x44], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _T10a;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T2fc;
_T10a:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T2e4;

	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        push   8;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x7C], eax;
	__asm        cmp    dword ptr [ebp-0x7C], 0;
	__asm        jne    _T169;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x80], eax;
	__asm        mov    eax, [ebp-0x80];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T15f;
_T15f:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T169:
	__asm        jmp    _T16e;
_T16e:
	__asm        jmp    _T173;
_T173:
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    dword ptr [ebp-0x54], 0x80;
	__asm        lea    eax, [ebp-0x54];
	__asm        mov    [ebp-0x5C], eax;
	__asm        mov    dword ptr [ebp-0x58], 1;
	__asm        lea    eax, [ebp-0x58];
	__asm        mov    [ebp-0x60], eax;
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    ecx, [ebp-0x5C];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T1ae;

	__asm        mov    eax, [ebp-0x60];
	__asm        mov    [ebp-0x64], eax;
	__asm        jmp    _T1b4;
_T1ae:
	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    [ebp-0x64], eax;
_T1b4:
	__asm        jmp    _T1b9;
_T1b9:
	__asm        jmp    _T1be;
_T1be:
	__asm        jmp    _T1c3;
_T1c3:
	__asm        mov    eax, [ebp-0x64];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x8C], eax;
	__asm        push   0;
	__asm        call   set_new_handler;
	__asm        add    esp, 4;
	__asm        mov    eax, [ebp-0x8C];
	__asm        shl    eax, 5;
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x84], eax;
	__asm        cmp    dword ptr [ebp-0x84], 0;
	__asm        jne    _T230;

	__asm        push   0x5971AC;
	__asm        mov    ecx, 0x638BA0;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x88], eax;
	__asm        mov    eax, [ebp-0x88];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T226;
_T226:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
_T230:
	__asm        jmp    _T235;
_T235:
	__asm        jmp    _T23a;
_T23a:
	__asm        mov    eax, [ebp-0x84];
	__asm        mov    ecx, [ebp-0x50];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    ecx, [ebp-0x50];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    list<Shortcut>::buffer_list, eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<Shortcut>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x68], 0x80;
	__asm        lea    eax, [ebp-0x68];
	__asm        mov    [ebp-0x70], eax;
	__asm        mov    dword ptr [ebp-0x6C], 1;
	__asm        lea    eax, [ebp-0x6C];
	__asm        mov    [ebp-0x74], eax;
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    ecx, [ebp-0x70];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T29a;

	__asm        mov    eax, [ebp-0x74];
	__asm        mov    [ebp-0x78], eax;
	__asm        jmp    _T2a0;
_T29a:
	__asm        mov    eax, [ebp-0x70];
	__asm        mov    [ebp-0x78], eax;
_T2a0:
	__asm        jmp    _T2a5;
_T2a5:
	__asm        jmp    _T2aa;
_T2aa:
	__asm        jmp    _T2af;
_T2af:
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 5;
	__asm        add    eax, list<Shortcut>::next_avail;
	__asm        mov    list<Shortcut>::last, eax;
	__asm        jmp    _T2c7;
_T2c7:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x48], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T2fc;
_T2e4:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x4C], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    [ebp-0x90], eax;
_T2fc:
	__asm        jmp    _T301;
_T301:
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0x3C], eax;
	__asm        jmp    _T30f;
_T30f:
	__asm        mov    eax, [ebp-0x3C];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x40], eax;
	__asm        jmp    _T31d;
_T31d:
	__asm        cmp    dword ptr [ebp-0x40], 0;
	__asm        je     _T339;

	__asm        lea    esi, tempShortcut.lDeviceID;
	__asm        mov    edi, [ebp-0x40];
	__asm        mov    ecx, 6;
	__asm        rep movsd;
	__asm        jmp    _T339;
_T339:
	__asm        jmp    _T33e;
_T33e:
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    ecx, [ebp-0x3C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x3C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    ecx, [ebp-0x94];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    ecx, [ebp-0x94];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        inc    dword ptr [eax+0xA4];
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T389;
_T389:
	__asm        jmp    _T38e;
_T38e:
	__asm        jmp    _T393;
// LINE 1403:
_T393:
	this->bCommandsHaveChanged = 0x1;
// LINE 1404:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1405:
	return 0x1;
// LINE 1407:
	__asm        jmp    _T439;
_T3bf:
	__asm        cmp    tempKeyUsageType, 2;
	__asm        jne    _T418;
// LINE 1408:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetCurrentCommand;
	__asm        mov    lCurrentCommand, eax;
// LINE 1409:
	__asm        mov    eax, lKey;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::RemoveShortcutFromList;
// LINE 1410:
	this->bCommandsHaveChanged = 0x1;
// LINE 1411:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1412:
	return 0x1;
// LINE 1414:
	__asm        jmp    _T439;
_T418:
	__asm        cmp    tempKeyUsageType, 3;
	__asm        jne    _T439;
// LINE 1415:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DisplayError;
// LINE 1416:
	return 0x1;
// LINE 1419:
_T439:
	__asm        jmp    _T4b7;
_T43e:
	__asm        cmp    lMessage, 0x10002;
	__asm        jne    _T457;
// LINE 1420:
	return 0x0;
// LINE 1422:
	__asm        jmp    _T4b7;
_T457:
	__asm        cmp    lMessage, 0x10003;
	__asm        jne    _T48a;
// LINE 1423:
	__asm        mov    eax, pMessageData;
	__asm        mov    eax, [eax];
	__asm        mov    lKey, eax;
// LINE 1424:
	__asm        lea    eax, lKey;
	__asm        push   eax;
	__asm        push   0x10001;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DoKeyboardWindowMessage;
	__asm        jmp    __RETURN;
// LINE 1426:
	__asm        jmp    _T4b7;
_T48a:
	__asm        cmp    lMessage, 0x10004;
	__asm        jne    _T4a3;
// LINE 1427:
	return 0x0;
// LINE 1429:
	__asm        jmp    _T4b7;
_T4a3:
	__asm        cmp    lMessage, 0x10005;
	__asm        jne    _T4b7;
// LINE 1431:
	return 0x0;
// LINE 1434:
_T4b7:
	return 0x0;
// LINE 1435:
__RETURN:
}

// FUNCTION: COPTER_D 0x0040920e
enum UserInputWindow::KeyUsageType UserInputWindow::GetKeyUsageType(long lKey, long lDevice) {
	/*bp-0x4*/   long lCurrentCommand;

// LINE 1446:
	__asm        cmp    lDevice, 0;
	__asm        jne    _T134;
// LINE 1447:
// Block start:
	/*bp-0x8*/   /*packed*/ class list<Shortcut>::iterator iterator;
	__asm        mov    eax, lKey;
	__asm        push   eax;
	__asm        call   IsKeyReserved;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T34;
// LINE 1448:
	return 0x1;
// LINE 1449:
_T34:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetCurrentCommand;
	__asm        mov    lCurrentCommand, eax;
// LINE 1450:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    iterator.node, eax;
	__asm        jmp    _T58;
_T58:
	__asm        jmp    _T5d;
// LINE 1451:
_T5d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T74;
_T74:
	__asm        jmp    _T79;
_T79:
	__asm        mov    eax, iterator.node;
	__asm        cmp    [ebp-0x10], eax;
	__asm        jne    _T8f;

	__asm        jmp    _Ta3;

	__asm        jmp    _T8f;
_T8f:
	__asm        jmp    _T9e;

	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        jne    _Ta3;
_T9e:
	__asm        jmp    _Ta8;
_Ta3:
	__asm        jmp    _T12f;
_Ta8:
	__asm        jmp    _Tb7;

	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _T12f;
// LINE 1453:
_Tb7:
	__asm        jmp    _Tbc;
_Tbc:
	__asm        mov    eax, iterator.node;
	__asm        mov    ecx, lDevice;
	__asm        cmp    [eax+8], ecx;
	__asm        jne    _T10c;

	__asm        jmp    _Td0;
_Td0:
	__asm        mov    eax, iterator.node;
	__asm        mov    ecx, lKey;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T10c;
// LINE 1454:
	__asm        jmp    _Te4;
_Te4:
	__asm        mov    eax, iterator.node;
	__asm        mov    ecx, lCurrentCommand;
	__asm        cmp    [eax+0xC], ecx;
	__asm        jne    _T102;
// LINE 1455:
	return 0x2;
// LINE 1456:
	__asm        jmp    _T10c;
// LINE 1457:
_T102:
	return 0x3;
// LINE 1459:
_T10c:
	__asm        mov    eax, iterator.node;
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, iterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    iterator.node, eax;
	__asm        jmp    _T11f;
_T11f:
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T12a;
// LINE 1460:
_T12a:
	__asm        jmp    _T5d;
// LINE 1463:
// Block end:
_T12f:
	__asm        jmp    _T278;
_T134:
	__asm        cmp    lDevice, 1;
	__asm        jge    _T148;

	__asm        cmp    lDevice, 4;
	__asm        jg     _T14d;
_T148:
	__asm        jmp    _T152;
_T14d:
	__asm        jmp    _T278;
_T152:
	__asm        jmp    _T161;

	__asm        cmp    dword ptr [ebp-0x24], 0;
	__asm        je     _T278;
// LINE 1464:
// Block start:
	/*bp-0xc*/   /*packed*/ class list<Shortcut>::iterator iterator;
_T161:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetCurrentCommand;
	__asm        mov    lCurrentCommand, eax;
// LINE 1465:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    iterator.node, eax;
	__asm        jmp    _T185;
_T185:
	__asm        jmp    _T18a;
// LINE 1466:
_T18a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T1a1;
_T1a1:
	__asm        jmp    _T1a6;
_T1a6:
	__asm        mov    eax, iterator.node;
	__asm        cmp    [ebp-0x18], eax;
	__asm        jne    _T1bc;

	__asm        jmp    _T1d0;

	__asm        jmp    _T1bc;
_T1bc:
	__asm        jmp    _T1cb;

	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        jne    _T1d0;
_T1cb:
	__asm        jmp    _T1d5;
_T1d0:
	__asm        jmp    _T278;
_T1d5:
	__asm        jmp    _T1e4;

	__asm        cmp    dword ptr [ebp-0x2C], 0;
	__asm        je     _T278;
// LINE 1468:
_T1e4:
	__asm        jmp    _T1e9;
_T1e9:
	__asm        mov    eax, iterator.node;
	__asm        mov    ecx, lDevice;
	__asm        cmp    [eax+8], ecx;
	__asm        jne    _T255;

	__asm        jmp    _T1fd;
_T1fd:
	__asm        mov    eax, iterator.node;
	__asm        mov    ecx, lKey;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T255;
// LINE 1470:
	__asm        jmp    _T211;
_T211:
	__asm        mov    eax, iterator.node;
	__asm        mov    ecx, lCurrentCommand;
	__asm        cmp    [eax+0xC], ecx;
	__asm        je     _T23c;

	__asm        mov    eax, lKey;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    eax, lDevice;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DoesTwinCommandExistForShortcut;
	__asm        test   eax, eax;
	__asm        je     _T24b;
// LINE 1472:
_T23c:
	return 0x2;
// LINE 1474:
	__asm        jmp    _T255;
// LINE 1475:
_T24b:
	return 0x3;
// LINE 1477:
_T255:
	__asm        mov    eax, iterator.node;
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, iterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    iterator.node, eax;
	__asm        jmp    _T268;
_T268:
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T273;
// LINE 1478:
_T273:
	__asm        jmp    _T18a;
// LINE 1481:
// Block end:
_T278:
	return 0x0;
// LINE 1482:
}

// FUNCTION: COPTER_D 0x00409494
void UserInputWindow::RemoveShortcutFromList(long lCommand, long lDevice, long lKey) {
	/*bp-0x18*/  /*packed*/ struct Shortcut tempShortcut; // 0x18 bytes
	/*bp-0x1c*/  /*packed*/ class list<Shortcut>::iterator tempShortcutListIterator;

// LINE 1490:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T25;
_T25:
	__asm        jmp    _T2a;
// LINE 1493:
_T2a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T41;
_T41:
	__asm        jmp    _T46;
_T46:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        cmp    [ebp-0x20], eax;
	__asm        jne    _T5c;

	__asm        jmp    _T70;

	__asm        jmp    _T5c;
_T5c:
	__asm        jmp    _T6b;

	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        jne    _T70;
_T6b:
	__asm        jmp    _T75;
_T70:
	__asm        jmp    _T169;
_T75:
	__asm        jmp    _T84;

	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _T169;
// LINE 1494:
_T84:
	__asm        jmp    _T89;
_T89:
	tempShortcut.lDeviceID = tempShortcutListIterator.node->data.lDeviceID;
// LINE 1495:
	__asm        jmp    _T97;
_T97:
	tempShortcut.lCommand = tempShortcutListIterator.node->data.lCommand;
// LINE 1496:
	__asm        jmp    _Ta5;
_Ta5:
	tempShortcut.lKey = tempShortcutListIterator.node->data.lKey;
// LINE 1499:
	__asm        mov    eax, lDevice;
	__asm        cmp    tempShortcut.lDeviceID, eax;
	__asm        jne    _T146;

	__asm        mov    eax, lCommand;
	__asm        cmp    tempShortcut.lCommand, eax;
	__asm        jne    _T146;

	__asm        mov    eax, lKey;
	__asm        cmp    tempShortcut.lKey, eax;
	__asm        jne    _T146;
// LINE 1501:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    [ebp-0x2C], eax;
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _Te5;
_Te5:
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _Tf0;
_Tf0:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x44];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x44];
	__asm        mov    ecx, [ecx];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T116;
_T116:
	__asm        jmp    _T11b;
_T11b:
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    ecx, [ebp-0x44];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        jmp    _T132;
_T132:
	__asm        mov    eax, this;
	__asm        add    dword ptr [eax+0xA4], 0xFFFFFFFF;
	__asm        jmp    _T141;
// LINE 1503:
_T141:
	__asm        jmp    _T164;
// LINE 1504:
_T146:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T159;
_T159:
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _T164;
// LINE 1505:
_T164:
	__asm        jmp    _T2a;
// LINE 1506:
_T169:
	return;
}

// FUNCTION: COPTER_D 0x00409609
int32_t UserInputWindow::DoInputDeviceListBoxWindowMessage(long lMessage, void * __ptr32 pMessageData) {
// LINE 1513:
	__asm        cmp    lMessage, 0x10001;
	__asm        jne    _T2d;
// LINE 1514:
	__asm        push   1;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1515:
	return 0x1;
// LINE 1517:
_T2d:
	return 0x0;
// LINE 1518:
}

// FUNCTION: COPTER_D 0x00409644
int32_t UserInputWindow::DoCommandListBoxWindowMessage(long lMessage, void * __ptr32 pMessageData) {
// LINE 1525:
	__asm        cmp    lMessage, 0x10001;
	__asm        jne    _T2d;
// LINE 1526:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1527:
	return 0x1;
// LINE 1529:
_T2d:
	return 0x0;
// LINE 1530:
}

// FUNCTION: COPTER_D 0x0040967f
long UserInputWindow::GetCurrentDevice() {
	/*bp-0x4*/   long lCurrentInputDeviceIndex;
	/*bp-0x8*/   int32_t i;
	/*bp-0xc*/   /*packed*/ class list<StringIDAssociation>::iterator tempIterator;
	/*bp-0x10*/  int32_t nDeviceCount;

// LINE 1538:
	i = 0x0;
// LINE 1539:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xE0];
	__asm        mov    lCurrentInputDeviceIndex, eax;
// LINE 1541:
	__asm        jmp    _T2f;
// LINE 1543:
_T2f:
	__asm        jmp    _T34;
_T34:
	nDeviceCount = this->myInputDeviceStringIDAssociationList.length;
// LINE 1544:
	__asm        mov    eax, lCurrentInputDeviceIndex;
	__asm        cmp    nDeviceCount, eax;
	__asm        jg     _T56;
// LINE 1545:
	return 0xffffffff;
// LINE 1546:
_T56:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x88];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T6f;
_T6f:
	__asm        jmp    _T74;
_T74:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    tempIterator.node, eax;
// LINE 1547:
_T7a:
	__asm        mov    eax, i;
	__asm        cmp    lCurrentInputDeviceIndex, eax;
	__asm        jle    _Tac;
// LINE 1548:
	__asm        mov    eax, tempIterator.node;
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, tempIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempIterator.node, eax;
	__asm        jmp    _T99;
_T99:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _Ta4;
// LINE 1549:
_Ta4:
	i++;
// LINE 1550:
	__asm        jmp    _T7a;
// LINE 1551:
_Tac:
	__asm        jmp    _Tb1;
_Tb1:
	return tempIterator.node->data.lID;
// LINE 1552:
}

// FUNCTION: COPTER_D 0x00409740
long UserInputWindow::GetCurrentCommand() {
	/*bp-0x4*/   int32_t nCommandCount;
	/*bp-0x8*/   long lCurrentCommandIndex;
	/*bp-0xc*/   int32_t i;
	/*bp-0x10*/  /*packed*/ class list<StringIDAssociation>::iterator tempIterator;

// LINE 1560:
	i = 0x0;
// LINE 1561:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+0xE0];
	__asm        mov    lCurrentCommandIndex, eax;
// LINE 1563:
	__asm        jmp    _T35;
// LINE 1565:
_T35:
	__asm        jmp    _T3a;
_T3a:
	nCommandCount = this->myCommandStringIDAssociationList.length;
// LINE 1566:
	__asm        mov    eax, lCurrentCommandIndex;
	__asm        cmp    nCommandCount, eax;
	__asm        jg     _T59;
// LINE 1567:
	return 0x0;
// LINE 1568:
_T59:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1C], eax;
	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T72;
_T72:
	__asm        jmp    _T77;
_T77:
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    tempIterator.node, eax;
// LINE 1569:
_T7d:
	__asm        mov    eax, i;
	__asm        cmp    lCurrentCommandIndex, eax;
	__asm        jle    _Taf;
// LINE 1570:
	__asm        mov    eax, tempIterator.node;
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, tempIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempIterator.node, eax;
	__asm        jmp    _T9c;
_T9c:
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _Ta7;
// LINE 1571:
_Ta7:
	i++;
// LINE 1572:
	__asm        jmp    _T7d;
// LINE 1573:
_Taf:
	__asm        jmp    _Tb4;
_Tb4:
	return tempIterator.node->data.lID;
// LINE 1574:
}

// FUNCTION: COPTER_D 0x00409804
void UserInputWindow::UpdateDisplay(int32_t bRedrawBackground) {
	/*bp-0x8*/   /*packed*/ struct KeyColors tempKeyColors; // 0x8 bytes
	/*bp-0x20*/  /*packed*/ struct Shortcut tempShortcut; // 0x18 bytes
	/*bp-0x60*/  long lReservedKeys[16]; // 0x40 bytes
	/*bp-0x64*/  long lCurrentDevice;
	/*bp-0x68*/  int32_t i;
	/*bp-0x6c*/  long lCurrentCommand;

// LINE 1593:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetCurrentDevice;
	__asm        mov    lCurrentDevice, eax;
// LINE 1594:
	__asm        cmp    lCurrentDevice, 0xFFFFFFFF;
	__asm        jne    _T2f;
// LINE 1595:
	return;
// LINE 1596:
_T2f:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::GetCurrentCommand;
	__asm        mov    lCurrentCommand, eax;
// LINE 1597:
	__asm        cmp    lCurrentCommand, 0;
	__asm        jne    _T4c;
// LINE 1598:
	return;
// LINE 1601:
_T4c:
	__asm        cmp    lCurrentDevice, 0;
	__asm        jne    _T898;
// LINE 1602:
	__asm        cmp    bRedrawBackground, 0;
	__asm        je     _T6b;
// LINE 1603:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::ClearDeviceArea;
// LINE 1604:
_T6b:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x74], 0;
	__asm        je     _Tb3;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0xC0], eax;
// LINE 1605:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    dword ptr [eax+0x54], 0;
	__asm        jmp    _T9c;
// LINE 1606:
_T9c:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x74];
	__asm        call   dword ptr [edx+0x14];
// LINE 1608:
_Tb3:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x78], 0;
	__asm        je     _T893;
// LINE 1609:
// Block start:
	/*bp-0x70*/  /*packed*/ class list<Shortcut>::iterator tempShortcutListIterator;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x10];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        mov    [ebp-0xC4], eax;
// LINE 1610:
	__asm        mov    eax, [ebp-0xC4];
	__asm        mov    dword ptr [eax+0x54], 1;
	__asm        jmp    _Tfd;
// LINE 1611:
_Tfd:
	__asm        push   1;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x30];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        add    eax, 0x90;
	__asm        mov    [ebp-0xB4], eax;
// LINE 1613:
	__asm        mov    eax, [ebp-0xB4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0xB0];
	__asm        mov    [ebp-0x78], eax;
	__asm        jmp    _T148;
_T148:
	__asm        jmp    _T14d;
_T14d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        add    eax, 0x90;
	__asm        mov    [ebp-0xBC], eax;
	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xB8], eax;
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    [ebp-0x7C], eax;
	__asm        jmp    _T17f;
_T17f:
	__asm        jmp    _T184;
_T184:
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    [ebp-0x168], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    [ebp-0x16C], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        add    eax, 0x90;
	__asm        mov    [ebp-0x170], eax;
_T1aa:
	__asm        mov    eax, [ebp-0x168];
	__asm        cmp    [ebp-0x16C], eax;
	__asm        jne    _T1c6;

	__asm        jmp    _T1dd;

	__asm        jmp    _T1c6;
_T1c6:
	__asm        jmp    _T1d8;

	__asm        cmp    dword ptr [ebp-0x15C], 0;
	__asm        jne    _T1dd;
_T1d8:
	__asm        jmp    _T1e2;
_T1dd:
	__asm        jmp    _T291;
_T1e2:
	__asm        jmp    _T1f4;

	__asm        cmp    dword ptr [ebp-0x160], 0;
	__asm        je     _T291;
_T1f4:
	__asm        mov    eax, [ebp-0x16C];
	__asm        mov    [ebp-0x158], eax;
	__asm        mov    eax, [ebp-0x16C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x16C], eax;
	__asm        jmp    _T213;
_T213:
	__asm        mov    eax, [ebp-0x158];
	__asm        mov    [ebp-0x154], eax;
	__asm        jmp    _T224;
_T224:
	__asm        mov    eax, [ebp-0x154];
	__asm        mov    [ebp-0x164], eax;
	__asm        mov    eax, [ebp-0x164];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0x164];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x164];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x164];
	__asm        mov    ecx, [ecx];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T25c;
_T25c:
	__asm        jmp    _T261;
_T261:
	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    ecx, [ebp-0x164];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x164];
	__asm        mov    list<KeyColors>::free_list, eax;
	__asm        jmp    _T27e;
_T27e:
	__asm        mov    eax, [ebp-0x170];
	__asm        dec    dword ptr [eax+4];
	__asm        jmp    _T28c;
_T28c:
	__asm        jmp    _T1aa;
_T291:
	__asm        jmp    _T296;
// LINE 1616:
_T296:
	__asm        lea    eax, lReservedKeys[0];
	__asm        push   eax;
	__asm        call   GetReservedKeyArray;
	__asm        add    esp, 4;
// LINE 1617:
	i = 0x0;
// LINE 1618:
_T2a9:
	__asm        mov    eax, i;
	__asm        cmp    dword ptr [ebp+eax*4-0x60], 0;
	__asm        je     _T45c;
// LINE 1619:
	__asm        mov    eax, i;
	__asm        mov    eax, [ebp+eax*4-0x60];
	__asm        mov    tempKeyColors.lKey, eax;
// LINE 1620:
	__asm        mov    tempKeyColors.lColorIndex, 0x36;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        add    eax, 0x90;
	__asm        mov    [ebp-0xF8], eax;
// LINE 1621:
	__asm        mov    eax, [ebp-0xF8];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xD8], eax;
	__asm        mov    eax, [ebp-0xD8];
	__asm        mov    [ebp-0xD0], eax;
	__asm        jmp    _T2fb;
_T2fb:
	__asm        jmp    _T300;
_T300:
	__asm        mov    eax, [ebp-0xD0];
	__asm        mov    [ebp-0xF4], eax;
	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    [ebp-0xE4], eax;
	__asm        cmp    list<KeyColors>::free_list, 0;
	__asm        je     _T341;

	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<KeyColors>::free_list, eax;
	__asm        mov    eax, [ebp-0xE4];
	__asm        mov    [ebp-0xF0], eax;
	__asm        jmp    _T39e;
_T341:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        cmp    list<KeyColors>::last, eax;
	__asm        jne    _T380;

	__asm        mov    ecx, [ebp-0xF8];
	__asm        call   list<KeyColors>::add_new_buffer;
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0xE8], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0xE8];
	__asm        mov    [ebp-0xF0], eax;
	__asm        jmp    _T39e;
_T380:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0xEC], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0xEC];
	__asm        mov    [ebp-0xF0], eax;
_T39e:
	__asm        jmp    _T3a3;
_T3a3:
	__asm        mov    eax, [ebp-0xF0];
	__asm        mov    [ebp-0xDC], eax;
	__asm        jmp    _T3b4;
_T3b4:
	__asm        mov    eax, [ebp-0xDC];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0xE0], eax;
	__asm        jmp    _T3c8;
_T3c8:
	__asm        cmp    dword ptr [ebp-0xE0], 0;
	__asm        je     _T3eb;

	__asm        mov    eax, tempKeyColors.lKey;
	__asm        mov    ecx, tempKeyColors.lColorIndex;
	__asm        mov    edx, [ebp-0xE0];
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
	__asm        jmp    _T3eb;
_T3eb:
	__asm        jmp    _T3f0;
_T3f0:
	__asm        mov    eax, [ebp-0xF4];
	__asm        mov    ecx, [ebp-0xDC];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xF4];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xDC];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0xDC];
	__asm        mov    ecx, [ebp-0xF4];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xDC];
	__asm        mov    ecx, [ebp-0xF4];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0xF8];
	__asm        inc    dword ptr [eax+4];
	__asm        mov    eax, [ebp-0xDC];
	__asm        mov    [ebp-0xD4], eax;
	__asm        jmp    _T44a;
_T44a:
	__asm        jmp    _T44f;
_T44f:
	__asm        jmp    _T454;
// LINE 1622:
_T454:
	i++;
// LINE 1623:
	__asm        jmp    _T2a9;
// LINE 1626:
_T45c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xC8], eax;
	__asm        mov    eax, [ebp-0xC8];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T47e;
_T47e:
	__asm        jmp    _T483;
// LINE 1627:
_T483:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0xA4], eax;
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    [ebp-0x80], eax;
	__asm        jmp    _T4a3;
_T4a3:
	__asm        jmp    _T4a8;
_T4a8:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        cmp    [ebp-0x80], eax;
	__asm        jne    _T4be;

	__asm        jmp    _T4d5;

	__asm        jmp    _T4be;
_T4be:
	__asm        jmp    _T4d0;

	__asm        cmp    dword ptr [ebp-0xA8], 0;
	__asm        jne    _T4d5;
_T4d0:
	__asm        jmp    _T4da;
_T4d5:
	__asm        jmp    _T893;
_T4da:
	__asm        jmp    _T4ec;

	__asm        cmp    dword ptr [ebp-0xAC], 0;
	__asm        je     _T893;
// LINE 1628:
_T4ec:
	__asm        jmp    _T4f1;
_T4f1:
	tempShortcut.lDeviceID = tempShortcutListIterator.node->data.lDeviceID;
// LINE 1629:
	__asm        jmp    _T4ff;
_T4ff:
	tempShortcut.lCommand = tempShortcutListIterator.node->data.lCommand;
// LINE 1630:
	__asm        jmp    _T50d;
_T50d:
	tempShortcut.lKey = tempShortcutListIterator.node->data.lKey;
// LINE 1631:
	__asm        mov    eax, lCurrentDevice;
	__asm        cmp    tempShortcut.lDeviceID, eax;
	__asm        jne    _T867;
// LINE 1632:
	__asm        mov    eax, lCurrentCommand;
	__asm        cmp    tempShortcut.lCommand, eax;
	__asm        jne    _T6cd;
// LINE 1635:
	tempKeyColors.lKey = tempShortcut.lKey;
// LINE 1636:
	__asm        mov    tempKeyColors.lColorIndex, 0x9D;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        add    eax, 0x90;
	__asm        mov    [ebp-0x124], eax;
// LINE 1637:
	__asm        mov    eax, [ebp-0x124];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x104], eax;
	__asm        mov    eax, [ebp-0x104];
	__asm        mov    [ebp-0xFC], eax;
	__asm        jmp    _T56e;
_T56e:
	__asm        jmp    _T573;
_T573:
	__asm        mov    eax, [ebp-0xFC];
	__asm        mov    [ebp-0x120], eax;
	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    [ebp-0x110], eax;
	__asm        cmp    list<KeyColors>::free_list, 0;
	__asm        je     _T5b4;

	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<KeyColors>::free_list, eax;
	__asm        mov    eax, [ebp-0x110];
	__asm        mov    [ebp-0x11C], eax;
	__asm        jmp    _T611;
_T5b4:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        cmp    list<KeyColors>::last, eax;
	__asm        jne    _T5f3;

	__asm        mov    ecx, [ebp-0x124];
	__asm        call   list<KeyColors>::add_new_buffer;
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0x114], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0x114];
	__asm        mov    [ebp-0x11C], eax;
	__asm        jmp    _T611;
_T5f3:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0x118], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0x118];
	__asm        mov    [ebp-0x11C], eax;
_T611:
	__asm        jmp    _T616;
_T616:
	__asm        mov    eax, [ebp-0x11C];
	__asm        mov    [ebp-0x108], eax;
	__asm        jmp    _T627;
_T627:
	__asm        mov    eax, [ebp-0x108];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x10C], eax;
	__asm        jmp    _T63b;
_T63b:
	__asm        cmp    dword ptr [ebp-0x10C], 0;
	__asm        je     _T65e;

	__asm        mov    eax, tempKeyColors.lKey;
	__asm        mov    ecx, tempKeyColors.lColorIndex;
	__asm        mov    edx, [ebp-0x10C];
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
	__asm        jmp    _T65e;
_T65e:
	__asm        jmp    _T663;
_T663:
	__asm        mov    eax, [ebp-0x120];
	__asm        mov    ecx, [ebp-0x108];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x120];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x108];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x108];
	__asm        mov    ecx, [ebp-0x120];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x108];
	__asm        mov    ecx, [ebp-0x120];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x124];
	__asm        add    dword ptr [eax+4], 1;
	__asm        mov    eax, [ebp-0x108];
	__asm        mov    [ebp-0x100], eax;
	__asm        jmp    _T6be;
_T6be:
	__asm        jmp    _T6c3;
_T6c3:
	__asm        jmp    _T6c8;
// LINE 1639:
_T6c8:
	__asm        jmp    _T867;
// LINE 1640:
_T6cd:
	tempKeyColors.lKey = tempShortcut.lKey;
// LINE 1641:
	__asm        mov    tempKeyColors.lColorIndex, 0x64;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        add    eax, 0x90;
	__asm        mov    [ebp-0x150], eax;
// LINE 1642:
	__asm        mov    eax, [ebp-0x150];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x130], eax;
	__asm        mov    eax, [ebp-0x130];
	__asm        mov    [ebp-0x128], eax;
	__asm        jmp    _T70d;
_T70d:
	__asm        jmp    _T712;
_T712:
	__asm        mov    eax, [ebp-0x128];
	__asm        mov    [ebp-0x14C], eax;
	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    [ebp-0x13C], eax;
	__asm        cmp    list<KeyColors>::free_list, 0;
	__asm        je     _T753;

	__asm        mov    eax, list<KeyColors>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<KeyColors>::free_list, eax;
	__asm        mov    eax, [ebp-0x13C];
	__asm        mov    [ebp-0x148], eax;
	__asm        jmp    _T7b0;
_T753:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        cmp    list<KeyColors>::last, eax;
	__asm        jne    _T792;

	__asm        mov    ecx, [ebp-0x150];
	__asm        call   list<KeyColors>::add_new_buffer;
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0x140], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0x140];
	__asm        mov    [ebp-0x148], eax;
	__asm        jmp    _T7b0;
_T792:
	__asm        mov    eax, list<KeyColors>::next_avail;
	__asm        mov    [ebp-0x144], eax;
	__asm        add    list<KeyColors>::next_avail, 0x10;
	__asm        mov    eax, [ebp-0x144];
	__asm        mov    [ebp-0x148], eax;
_T7b0:
	__asm        jmp    _T7b5;
_T7b5:
	__asm        mov    eax, [ebp-0x148];
	__asm        mov    [ebp-0x134], eax;
	__asm        jmp    _T7c6;
_T7c6:
	__asm        mov    eax, [ebp-0x134];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x138], eax;
	__asm        jmp    _T7da;
_T7da:
	__asm        cmp    dword ptr [ebp-0x138], 0;
	__asm        je     _T7fd;

	__asm        mov    eax, tempKeyColors.lKey;
	__asm        mov    ecx, tempKeyColors.lColorIndex;
	__asm        mov    edx, [ebp-0x138];
	__asm        mov    [edx], eax;
	__asm        mov    [edx+4], ecx;
	__asm        jmp    _T7fd;
_T7fd:
	__asm        jmp    _T802;
_T802:
	__asm        mov    eax, [ebp-0x14C];
	__asm        mov    ecx, [ebp-0x134];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x14C];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x134];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x134];
	__asm        mov    ecx, [ebp-0x14C];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x134];
	__asm        mov    ecx, [ebp-0x14C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x150];
	__asm        add    dword ptr [eax+4], 1;
	__asm        mov    eax, [ebp-0x134];
	__asm        mov    [ebp-0x12C], eax;
	__asm        jmp    _T85d;
_T85d:
	__asm        jmp    _T862;
_T862:
	__asm        jmp    _T867;
// LINE 1645:
_T867:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    [ebp-0x174], eax;
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T87d;
_T87d:
	__asm        mov    eax, [ebp-0x174];
	__asm        mov    [ebp-0x84], eax;
	__asm        jmp    _T88e;
// LINE 1646:
_T88e:
	__asm        jmp    _T483;
// LINE 1649:
// Block end:
_T893:
	__asm        jmp    _Tb35;
_T898:
	__asm        cmp    lCurrentDevice, 1;
	__asm        jl     _Tb35;

	__asm        cmp    lCurrentDevice, 4;
	__asm        jg     _Tb35;
// LINE 1650:
	__asm        cmp    bRedrawBackground, 0;
	__asm        je     _T8c1;
// LINE 1651:
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::ClearDeviceArea;
// LINE 1652:
_T8c1:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x78], 0;
	__asm        je     _T909;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x78];
	__asm        mov    [ebp-0x94], eax;
// LINE 1653:
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    dword ptr [eax+0x54], 0;
	__asm        jmp    _T8f2;
// LINE 1654:
_T8f2:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x14];
// LINE 1656:
_T909:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x74], 0;
	__asm        je     _Tb35;
// LINE 1657:
// Block start:
	/*bp-0x74*/  /*packed*/ class list<Shortcut>::iterator tempShortcutListIterator;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x74];
	__asm        call   dword ptr [edx+0x10];
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    [ebp-0x98], eax;
// LINE 1658:
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    dword ptr [eax+0x54], 1;
	__asm        jmp    _T953;
// LINE 1659:
_T953:
	__asm        push   1;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x74];
	__asm        call   dword ptr [edx+0x30];
// LINE 1660:
	__asm        mov    eax, lCurrentDevice;
	__asm        dec    eax;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x74];
	__asm        call   dword ptr [edx+0xC4];
// LINE 1663:
	__asm        mov    i, 0;
	__asm        jmp    _T99c;
_T999:
	i++;
_T99c:
	__asm        cmp    i, 0xE;
	__asm        jge    _T9bf;
// LINE 1664:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x74];
	__asm        mov    ecx, i;
	__asm        mov    byte ptr [eax+ecx+0xB0], 0;
	__asm        jmp    _T999;
// LINE 1667:
_T9bf:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xCC], eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T9e1;
_T9e1:
	__asm        jmp    _T9e6;
// LINE 1668:
_T9e6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x90], eax;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0x88], eax;
	__asm        jmp    _Ta09;
_Ta09:
	__asm        jmp    _Ta0e;
_Ta0e:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        cmp    [ebp-0x88], eax;
	__asm        jne    _Ta27;

	__asm        jmp    _Ta3e;

	__asm        jmp    _Ta27;
_Ta27:
	__asm        jmp    _Ta39;

	__asm        cmp    dword ptr [ebp-0x9C], 0;
	__asm        jne    _Ta3e;
_Ta39:
	__asm        jmp    _Ta43;
_Ta3e:
	__asm        jmp    _Tb35;
_Ta43:
	__asm        jmp    _Ta55;

	__asm        cmp    dword ptr [ebp-0xA0], 0;
	__asm        je     _Tb35;
// LINE 1669:
_Ta55:
	__asm        jmp    _Ta5a;
_Ta5a:
	tempShortcut.lDeviceID = tempShortcutListIterator.node->data.lDeviceID;
// LINE 1670:
	__asm        jmp    _Ta68;
_Ta68:
	tempShortcut.lCommand = tempShortcutListIterator.node->data.lCommand;
// LINE 1671:
	__asm        jmp    _Ta76;
_Ta76:
	tempShortcut.lKey = tempShortcutListIterator.node->data.lKey;
// LINE 1672:
	__asm        mov    eax, lCurrentDevice;
	__asm        cmp    tempShortcut.lDeviceID, eax;
	__asm        jne    _Tb09;
// LINE 1673:
	__asm        cmp    tempShortcut.lKey, 0xE;
	__asm        jge    _Tb09;
// LINE 1675:
	__asm        mov    eax, lCurrentCommand;
	__asm        cmp    tempShortcut.lCommand, eax;
	__asm        je     _Tac0;

	__asm        mov    eax, tempShortcut.lKey;
	__asm        push   eax;
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        mov    eax, lCurrentDevice;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::DoesTwinCommandExistForShortcut;
	__asm        test   eax, eax;
	__asm        je     _Tad9;
// LINE 1677:
_Tac0:
	__asm        mov    eax, tempShortcut.lKey;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    byte ptr [eax+ecx+0xB0], 2;
// LINE 1679:
	__asm        jmp    _Tb09;
_Tad9:
	__asm        mov    eax, tempShortcut.lKey;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        movsx  eax, byte ptr [eax+ecx+0xB0];
	__asm        test   eax, eax;
	__asm        jne    _Tb09;
// LINE 1680:
	__asm        mov    eax, tempShortcut.lKey;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x74];
	__asm        mov    byte ptr [eax+ecx+0xB0], 1;
// LINE 1683:
_Tb09:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    [ebp-0x178], eax;
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _Tb1f;
_Tb1f:
	__asm        mov    eax, [ebp-0x178];
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _Tb30;
// LINE 1684:
_Tb30:
	__asm        jmp    _T9e6;
// LINE 1687:
// Block end:
_Tb35:
	return;
}

// FUNCTION: COPTER_D 0x0040a345
int32_t UserInputWindow::DoesTwinCommandExistForShortcut(long lDevice, long lCommand, long lKey) {
	/*bp-0x4*/   /*packed*/ class list<Shortcut>::iterator tempShortcutListIterator;
	/*bp-0x8*/   long lTwinCommand;

// LINE 1695:
	__asm        mov    eax, lCommand;
	__asm        push   eax;
	__asm        call   GetJoystickCommandTwin;
	__asm        add    esp, 4;
	__asm        mov    lTwinCommand, eax;
// LINE 1697:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T34;
_T34:
	__asm        jmp    _T39;
// LINE 1698:
_T39:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x14], eax;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T50;
_T50:
	__asm        jmp    _T55;
_T55:
	__asm        mov    eax, [ebp-0xC];
	__asm        cmp    tempShortcutListIterator.node, eax;
	__asm        jne    _T6b;

	__asm        jmp    _T7f;

	__asm        jmp    _T6b;
_T6b:
	__asm        jmp    _T7a;

	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        jne    _T7f;
_T7a:
	__asm        jmp    _T84;
_T7f:
	__asm        jmp    _T106;
_T84:
	__asm        jmp    _T93;

	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T106;
// LINE 1702:
_T93:
	__asm        jmp    _T98;
_T98:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    ecx, lDevice;
	__asm        cmp    [eax+8], ecx;
	__asm        jne    _Te3;

	__asm        jmp    _Tac;
_Tac:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    ecx, lTwinCommand;
	__asm        cmp    [eax+0xC], ecx;
	__asm        jne    _Te3;

	__asm        jmp    _Tc0;
_Tc0:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    ecx, lKey;
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _Te3;

	__asm        cmp    lCommand, 5;
	__asm        jg     _Te3;
// LINE 1704:
	return 0x1;
// LINE 1706:
_Te3:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    [ebp-0x24], eax;
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _Tf6;
_Tf6:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T101;
// LINE 1707:
_T101:
	__asm        jmp    _T39;
// LINE 1708:
_T106:
	return 0x0;
// LINE 1709:
}

// FUNCTION: COPTER_D 0x0040a459
void UserInputWindow::ClearDeviceArea() {
	/*bp-0x104*/ char szFilePath[260]; // 0x104 bytes
	/*bp-0x238*/ /*unpacked*/ class CBackBuffer tempImage;
	/*bp-0x240*/ /*packed*/ class MPoint ptDeviceArea; // 0x8 bytes

// LINE 1717:
	__asm        jmp    _T17;
_T17:
	__asm        mov    ptDeviceArea.x, 0x28;
	__asm        mov    ptDeviceArea.y, 9;
	__asm        jmp    _T30;
// LINE 1720:
_T30:
	__asm        lea    eax, szFilePath[0];
	__asm        push   eax;
	__asm        mov    eax, SZ_USER_INPUT_WINDOW_BACKGROUND_FILE_NAME;
	__asm        push   eax;
	__asm        push   0;
	__asm        push   6;
	__asm        call   GetPathForFile;
	__asm        add    esp, 0x10;
// LINE 1722:
	__asm        lea    eax, szFilePath[0];
	__asm        push   eax;
	__asm        lea    ecx, tempImage<CBackBuffer+0x00:None>;
	__asm        call   CBackBuffer::CBackBuffer;
// LINE 1724:
	__asm        jmp    _T60;
_T60:
	__asm        jmp    _T65;
_T65:
	__asm        mov    eax, [ebp-0x22C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x230];
	__asm        push   eax;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, ptDeviceArea.y;
	__asm        push   eax;
	__asm        mov    eax, ptDeviceArea.x;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x40];
	__asm        push   eax;
	__asm        lea    ecx, tempImage<CBackBuffer+0x00:None>;
	__asm        call   CBackBuffer::Compose;
// LINE 1725:
	__asm        lea    ecx, tempImage<CBackBuffer+0x00:None>;
	__asm        call   CBackBuffer::~CBackBuffer;
	__asm        jmp    __RETURN;
__RETURN:
}

// FUNCTION: COPTER_D 0x0040a508
void UserInputWindow::SetupAllInputDevices() {
	/*bp-0x40*/  char szJoystickName[64]; // 0x40 bytes
	/*bp-0x44*/  int32_t nJoystickCount;
	/*bp-0x48*/  unsigned long nFullStringID;
	/*bp-0x4c*/  int32_t i;
	/*bp-0x54*/  /*packed*/ class basic_string<char> sDeviceName; // 0x8 bytes

// LINE 1733:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xB8], eax;
	__asm        cmp    dword ptr [ebp-0xB8], 0;
	__asm        je     _T7e;

	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xB8];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T70;
_T70:
	__asm        mov    eax, [ebp-0xB8];
	__asm        mov    sDeviceName.reference, eax;
	__asm        jmp    _T85;
_T7e:
	sDeviceName.reference = 0x0;
_T85:
	__asm        mov    sDeviceName.c_str_ptr, 0;
	__asm        jmp    _T91;
// LINE 1741:
_T91:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x88];
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    [ebp-0x58], eax;
	__asm        jmp    _Tb1;
_Tb1:
	__asm        jmp    _Tb6;
_Tb6:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x88];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x9C], eax;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0x5C], eax;
	__asm        jmp    _Td8;
_Td8:
	__asm        jmp    _Tdd;
_Tdd:
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    [ebp-0xD0], eax;
	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    [ebp-0xD4], eax;
_Tef:
	__asm        mov    eax, [ebp-0xD0];
	__asm        cmp    [ebp-0xD4], eax;
	__asm        jne    _T10b;

	__asm        jmp    _T122;

	__asm        jmp    _T10b;
_T10b:
	__asm        jmp    _T11d;

	__asm        cmp    dword ptr [ebp-0xC4], 0;
	__asm        jne    _T122;
_T11d:
	__asm        jmp    _T127;
_T122:
	__asm        jmp    _T1e9;
_T127:
	__asm        jmp    _T139;

	__asm        cmp    dword ptr [ebp-0xC8], 0;
	__asm        je     _T1e9;
_T139:
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    [ebp-0xC0], eax;
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xD4], eax;
	__asm        jmp    _T158;
_T158:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    [ebp-0xBC], eax;
	__asm        jmp    _T169;
_T169:
	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    [ebp-0xCC], eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    eax, [eax];
	__asm        mov    ecx, [ebp-0xCC];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xCC];
	__asm        mov    ecx, [ecx];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T1a1;
_T1a1:
	__asm        push   0;
	__asm        mov    ecx, [ebp-0xCC];
	__asm        add    ecx, 8;
	__asm        call   StringIDAssociation::`scalar deleting destructor';
	__asm        jmp    _T1b6;
_T1b6:
	__asm        mov    eax, list<StringIDAssociation>::free_list;
	__asm        mov    ecx, [ebp-0xCC];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    list<StringIDAssociation>::free_list, eax;
	__asm        jmp    _T1d3;
_T1d3:
	__asm        mov    eax, this;
	__asm        dec    dword ptr [eax+0x8C];
	__asm        jmp    _T1e4;
_T1e4:
	__asm        jmp    _Tef;
_T1e9:
	__asm        jmp    _T1ee;
// LINE 1744:
_T1ee:
	__asm        push   0;
	__asm        push   9;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1745:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x10D8], eax;
	__asm        cmp    dword ptr [ebp-0x10D8], 0;
	__asm        jne    _T2aa;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x10D8], eax;
	__asm        jmp    _T25c;
_T25c:
	__asm        lea    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        lea    ecx, sDeviceName.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T280;
_T280:
	__asm        jmp    _T285;
_T285:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sDeviceName.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T2a5;
_T2a5:
	__asm        jmp    _T2d8;
_T2aa:
	__asm        jmp    _T2af;
_T2af:
	__asm        lea    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        lea    ecx, sDeviceName.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T2d3;
_T2d3:
	__asm        jmp    _T2d8;
// LINE 1747:
_T2d8:
	__asm        push   0xFFFFFFFF;
	__asm        push   0;
	__asm        lea    eax, sDeviceName.c_str_ptr;
	__asm        push   eax;
	__asm        lea    ecx, [ebp-0x68];
	__asm        call   basic_string<char>::basic_string<char>;
	__asm        mov    dword ptr [ebp-0x60], 0;
	__asm        jmp    _T2f4;
_T2f4:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x88];
	__asm        mov    [ebp-0xB4], eax;
	__asm        mov    eax, [ebp-0xB4];
	__asm        mov    [ebp-0xAC], eax;
	__asm        jmp    _T317;
_T317:
	__asm        jmp    _T31c;
_T31c:
	__asm        lea    eax, [ebp-0x68];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xAC];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0xB0];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x88;
	__asm        call   list<StringIDAssociation>::insert;
	__asm        jmp    _T344;
_T344:
	__asm        jmp    _T349;
_T349:
	__asm        lea    ecx, [ebp-0x68];
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    dword ptr [ebp-0x68], 0;
	__asm        je     _T37f;

	__asm        mov    eax, [ebp-0x68];
	__asm        mov    [ebp-0x90], eax;
	__asm        mov    eax, [ebp-0x90];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T37f:
	__asm        jmp    _T384;
// LINE 1748:
_T384:
	__asm        push   0xFFFFFFFF;
	__asm        lea    eax, sDeviceName.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xD4];
// LINE 1751:
	__asm        mov    eax, gJoystickManager.nJoystickCount;
	__asm        mov    nJoystickCount, eax;
	__asm        jmp    _T3b1;
// LINE 1752:
_T3b1:
	__asm        mov    i, 0;
	__asm        jmp    _T3c0;
_T3bd:
	i++;
_T3c0:
	__asm        mov    eax, nJoystickCount;
	__asm        cmp    i, eax;
	__asm        jge    _T4c6;
// LINE 1753:
	__asm        lea    eax, szJoystickName[0];
	__asm        push   eax;
	__asm        mov    eax, i;
	__asm        push   eax;
	__asm        mov    ecx, 0x604C78;
	__asm        call   JoystickManager::GetJoystickName;
// LINE 1754:
	__asm        jmp    _T3e3;
_T3e3:
	__asm        lea    eax, szJoystickName[0];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, szJoystickName[0];
	__asm        push   eax;
	__asm        lea    ecx, sDeviceName.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T401;
// LINE 1756:
_T401:
	__asm        push   0xFFFFFFFF;
	__asm        push   0;
	__asm        lea    eax, sDeviceName.c_str_ptr;
	__asm        push   eax;
	__asm        lea    ecx, [ebp-0x74];
	__asm        call   basic_string<char>::basic_string<char>;
	__asm        mov    eax, i;
	__asm        inc    eax;
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T41d;
_T41d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x88];
	__asm        mov    [ebp-0xA8], eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    [ebp-0xA0], eax;
	__asm        jmp    _T440;
_T440:
	__asm        jmp    _T445;
_T445:
	__asm        lea    eax, [ebp-0x74];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0xA4];
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x88;
	__asm        call   list<StringIDAssociation>::insert;
	__asm        jmp    _T46d;
_T46d:
	__asm        jmp    _T472;
_T472:
	__asm        lea    ecx, [ebp-0x74];
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    dword ptr [ebp-0x74], 0;
	__asm        je     _T49c;

	__asm        mov    eax, [ebp-0x74];
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T49c:
	__asm        jmp    _T4a1;
// LINE 1757:
_T4a1:
	__asm        push   0xFFFFFFFF;
	__asm        lea    eax, sDeviceName.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xD4];
// LINE 1758:
	__asm        jmp    _T3bd;
// LINE 1759:
_T4c6:
	__asm        mov    eax, sDeviceName.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sDeviceName.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T50d;

	__asm        mov    eax, sDeviceName.reference;
	__asm        mov    [ebp-0x8C], eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    [ebp-0x88], eax;
	__asm        cmp    dword ptr [ebp-0x88], 0;
	__asm        je     _T50d;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x88];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T50d;
_T50d:
	__asm        jmp    _T512;
_T512:
	__asm        cmp    sDeviceName.c_str_ptr, 0;
	__asm        je     _T53a;

	__asm        mov    eax, sDeviceName.c_str_ptr;
	__asm        mov    [ebp-0x80], eax;
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    [ebp-0x84], eax;
	__asm        mov    eax, [ebp-0x84];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T53a:
	__asm        jmp    _T53f;
_T53f:
	return;
}

// FUNCTION: COPTER_D 0x0040aa51
void UserInputWindow::SetupAllCommands() {
	/*bp-0x4*/   uint32_t nFullStringID;
	/*bp-0x8*/   int32_t i;
	/*bp-0x10*/  /*packed*/ class basic_string<char> sCommandName; // 0x8 bytes

// LINE 1768:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x60], eax;
	__asm        cmp    dword ptr [ebp-0x60], 0;
	__asm        je     _T66;

	__asm        mov    eax, [ebp-0x60];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x60];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T5b;
_T5b:
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    sCommandName.reference, eax;
	__asm        jmp    _T6d;
_T66:
	sCommandName.reference = 0x0;
_T6d:
	__asm        mov    sCommandName.c_str_ptr, 0;
	__asm        jmp    _T79;
// LINE 1772:
_T79:
	__asm        mov    i, 2;
	__asm        jmp    _T88;
_T85:
	i++;
_T88:
	__asm        cmp    i, 0x21;
	__asm        jge    _T3a9;
// LINE 1773:
	__asm        push   0;
	__asm        mov    eax, i;
	__asm        add    eax, 0x96;
	__asm        push   eax;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1774:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1064], eax;
	__asm        cmp    dword ptr [ebp-0x1064], 0;
	__asm        jne    _T155;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1064], eax;
	__asm        jmp    _T107;
_T107:
	__asm        lea    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        lea    ecx, sCommandName.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T12b;
_T12b:
	__asm        jmp    _T130;
_T130:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sCommandName.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T150;
_T150:
	__asm        jmp    _T183;
_T155:
	__asm        jmp    _T15a;
_T15a:
	__asm        lea    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        lea    ecx, sCommandName.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T17e;
_T17e:
	__asm        jmp    _T183;
// LINE 1775:
_T183:
	__asm        jmp    _T188;
_T188:
	__asm        mov    eax, sCommandName.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        jae    _T1c7;

	__asm        push   0x59722C;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, [ebp-0x48];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T1b8;
_T1b8:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T1c7;
_T1c7:
	__asm        jmp    _T1cc;
_T1cc:
	__asm        mov    eax, sCommandName.reference;
	__asm        cmp    dword ptr [eax+4], 0xFFFFFFFF;
	__asm        jae    _T1ec;

	__asm        jmp    _T1de;
_T1de:
	__asm        mov    eax, sCommandName.reference;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x40], eax;
	__asm        jmp    _T1f3;
_T1ec:
	__asm        mov    dword ptr [ebp-0x40], 0xFFFFFFFF;
_T1f3:
	__asm        jmp    _T1f8;
_T1f8:
	__asm        mov    eax, sCommandName.reference;
	__asm        mov    ecx, [ebp-0x40];
	__asm        cmp    [eax+4], ecx;
	__asm        jne    _T22b;

	__asm        jmp    _T20c;
_T20c:
	__asm        mov    eax, sCommandName.reference;
	__asm        cmp    dword ptr [eax+0xC], 0xFFFFFFFF;
	__asm        je     _T22b;

	__asm        mov    eax, sCommandName.reference;
	__asm        mov    [ebp-0x18], eax;
	__asm        mov    eax, [ebp-0x18];
	__asm        add    dword ptr [eax+0xC], 1;
	__asm        jmp    _T263;
_T22b:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x44], eax;
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        je     _T25c;

	__asm        mov    eax, [ebp-0x40];
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, sCommandName.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x44];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T263;
_T25c:
	__asm        mov    dword ptr [ebp-0x18], 0;
_T263:
	__asm        mov    dword ptr [ebp-0x1C], 0;
	__asm        jmp    _T26f;
_T26f:
	__asm        mov    eax, i;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T27a;
_T27a:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x90];
	__asm        mov    [ebp-0x54], eax;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    _T294;
_T294:
	__asm        jmp    _T299;
_T299:
	__asm        mov    eax, [ebp-0x4C];
	__asm        mov    [ebp-0x5C], eax;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x90;
	__asm        call   list<StringIDAssociation>::get_node;
	__asm        mov    [ebp-0x58], eax;
	__asm        jmp    _T2b8;
_T2b8:
	__asm        lea    eax, [ebp-0x1C];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        add    eax, 8;
	__asm        push   eax;
	__asm        call   construct;
	__asm        add    esp, 8;
	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    ecx, [ebp-0x58];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x5C];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x58];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    ecx, [ebp-0x5C];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    ecx, [ebp-0x5C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        add    dword ptr [eax+0x94], 1;
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    [ebp-0x50], eax;
	__asm        jmp    _T30b;
_T30b:
	__asm        jmp    _T310;
_T310:
	__asm        jmp    _T315;
_T315:
	__asm        jmp    _T31a;
_T31a:
	__asm        mov    eax, [ebp-0x18];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, [ebp-0x18];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T352;

	__asm        mov    eax, [ebp-0x18];
	__asm        mov    [ebp-0x2C], eax;
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x28], eax;
	__asm        cmp    dword ptr [ebp-0x28], 0;
	__asm        je     _T352;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x28];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T352;
_T352:
	__asm        jmp    _T357;
_T357:
	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T379;

	__asm        mov    eax, [ebp-0x1C];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    [ebp-0x24], eax;
	__asm        mov    eax, [ebp-0x24];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T379:
	__asm        jmp    _T37e;
// LINE 1776:
_T37e:
	__asm        push   0xFFFFFFFF;
	__asm        lea    eax, sCommandName.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x80];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x80];
	__asm        call   dword ptr [edx+0xD4];
// LINE 1777:
	__asm        jmp    _T85;
// LINE 1778:
_T3a9:
	__asm        mov    eax, sCommandName.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCommandName.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T3f5;

	__asm        mov    eax, sCommandName.reference;
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x38], eax;
	__asm        cmp    dword ptr [ebp-0x38], 0;
	__asm        je     _T3f5;

	__asm        mov    ecx, [ebp-0x38];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T3df;
_T3df:
	__asm        mov    eax, [ebp-0x38];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T3f0;
_T3f0:
	__asm        jmp    _T3f5;
_T3f5:
	__asm        jmp    _T3fa;
_T3fa:
	__asm        cmp    sCommandName.c_str_ptr, 0;
	__asm        je     _T41c;

	__asm        mov    eax, sCommandName.c_str_ptr;
	__asm        mov    [ebp-0x30], eax;
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x34], eax;
	__asm        mov    eax, [ebp-0x34];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T41c:
	__asm        jmp    _T421;
_T421:
	return;
}

// FUNCTION: COPTER_D 0x0040ae7c
void UserInputWindow::ReadShortcuts(/*packed*/ class list<Shortcut>& shortCutList) {
	/*bp-0x4*/   /*packed*/ class list<Shortcut>::iterator tempShortcutListIterator;
	/*bp-0x8*/   long lCurrentCommand;

// LINE 1786:
	__asm        mov    eax, shortCutList;
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x20], eax;
	__asm        mov    eax, [ebp-0x20];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T27;
_T27:
	__asm        jmp    _T2c;
// LINE 1789:
_T2c:
	__asm        mov    eax, shortCutList;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x14], eax;
	__asm        mov    eax, [ebp-0x14];
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _T3f;
_T3f:
	__asm        jmp    _T44;
_T44:
	__asm        mov    eax, [ebp-0xC];
	__asm        cmp    tempShortcutListIterator.node, eax;
	__asm        jne    _T5a;

	__asm        jmp    _T6e;

	__asm        jmp    _T5a;
_T5a:
	__asm        jmp    _T69;

	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        jne    _T6e;
_T69:
	__asm        jmp    _T73;
_T6e:
	__asm        jmp    _T5dc;
_T73:
	__asm        jmp    _T82;

	__asm        cmp    dword ptr [ebp-0x1C], 0;
	__asm        je     _T5dc;
// LINE 1790:
_T82:
	__asm        jmp    _T87;
_T87:
	lCurrentCommand = tempShortcutListIterator.node->data.lCommand;
// LINE 1791:
	__asm        mov    eax, lCurrentCommand;
	__asm        push   eax;
	__asm        call   IsCommandConfigurable;
	__asm        add    esp, 4;
	__asm        test   eax, eax;
	__asm        je     _T2d1;
// LINE 1792:
	__asm        jmp    _Ta9;
_Ta9:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xA0];
	__asm        mov    [ebp-0x2C], eax;
	__asm        mov    eax, [ebp-0x2C];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _Tcc;
_Tcc:
	__asm        jmp    _Td1;
_Td1:
	__asm        mov    eax, [ebp-0x24];
	__asm        mov    [ebp-0x78], eax;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0x38], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _T103;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x74], eax;
	__asm        jmp    _T243;
_T103:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T22e;

	__asm        jmp    _T119;
_T119:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    dword ptr [ebp-0x48], 0x80;
	__asm        lea    eax, [ebp-0x48];
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    dword ptr [ebp-0x4C], 1;
	__asm        lea    eax, [ebp-0x4C];
	__asm        mov    [ebp-0x54], eax;
	__asm        mov    eax, [ebp-0x54];
	__asm        mov    ecx, [ebp-0x50];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T15d;

	__asm        mov    eax, [ebp-0x54];
	__asm        mov    [ebp-0x58], eax;
	__asm        jmp    _T163;
_T15d:
	__asm        mov    eax, [ebp-0x50];
	__asm        mov    [ebp-0x58], eax;
_T163:
	__asm        jmp    _T168;
_T168:
	__asm        jmp    _T16d;
_T16d:
	__asm        jmp    _T172;
_T172:
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x70], eax;
	__asm        jmp    _T17f;
_T17f:
	__asm        push   0;
	__asm        mov    eax, [ebp-0x70];
	__asm        push   eax;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    ecx, [ebp-0x44];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    ecx, [ebp-0x44];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    list<Shortcut>::buffer_list, eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<Shortcut>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0x5C], 0x80;
	__asm        lea    eax, [ebp-0x5C];
	__asm        mov    [ebp-0x64], eax;
	__asm        mov    dword ptr [ebp-0x60], 1;
	__asm        lea    eax, [ebp-0x60];
	__asm        mov    [ebp-0x68], eax;
	__asm        mov    eax, [ebp-0x68];
	__asm        mov    ecx, [ebp-0x64];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T1e7;

	__asm        mov    eax, [ebp-0x68];
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T1ed;
_T1e7:
	__asm        mov    eax, [ebp-0x64];
	__asm        mov    [ebp-0x6C], eax;
_T1ed:
	__asm        jmp    _T1f2;
_T1f2:
	__asm        jmp    _T1f7;
_T1f7:
	__asm        jmp    _T1fc;
_T1fc:
	__asm        mov    eax, [ebp-0x6C];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 5;
	__asm        add    eax, list<Shortcut>::next_avail;
	__asm        mov    list<Shortcut>::last, eax;
	__asm        jmp    _T214;
_T214:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x3C], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x3C];
	__asm        mov    [ebp-0x74], eax;
	__asm        jmp    _T243;
_T22e:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x40], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    [ebp-0x74], eax;
_T243:
	__asm        jmp    _T248;
_T248:
	__asm        mov    eax, [ebp-0x74];
	__asm        mov    [ebp-0x30], eax;
	__asm        jmp    _T253;
_T253:
	__asm        mov    eax, [ebp-0x30];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x34], eax;
	__asm        jmp    _T261;
_T261:
	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        je     _T27d;

	__asm        mov    edi, [ebp-0x34];
	__asm        mov    esi, [ebp-0x7C];
	__asm        mov    ecx, 6;
	__asm        rep movsd;
	__asm        jmp    _T27d;
_T27d:
	__asm        jmp    _T282;
_T282:
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    ecx, [ebp-0x30];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x78];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x30];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    ecx, [ebp-0x78];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    ecx, [ebp-0x78];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        add    dword ptr [eax+0xA4], 1;
	__asm        mov    eax, [ebp-0x30];
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _T2c2;
_T2c2:
	__asm        jmp    _T2c7;
_T2c7:
	__asm        jmp    _T2cc;
// LINE 1793:
_T2cc:
	__asm        jmp    _T5b3;
// LINE 1794:
_T2d1:
	__asm        jmp    _T2d6;
_T2d6:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        add    eax, 8;
	__asm        mov    [ebp-0xD8], eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x98];
	__asm        mov    [ebp-0x88], eax;
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    [ebp-0x80], eax;
	__asm        jmp    _T302;
_T302:
	__asm        jmp    _T307;
_T307:
	__asm        mov    eax, [ebp-0x80];
	__asm        mov    [ebp-0xD4], eax;
	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    [ebp-0x94], eax;
	__asm        cmp    list<Shortcut>::free_list, 0;
	__asm        je     _T345;

	__asm        mov    eax, list<Shortcut>::free_list;
	__asm        mov    eax, [eax];
	__asm        mov    list<Shortcut>::free_list, eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0xD0], eax;
	__asm        jmp    _T4f7;
_T345:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        cmp    list<Shortcut>::last, eax;
	__asm        jne    _T4d9;

	__asm        jmp    _T35b;
_T35b:
	__asm        push   0;
	__asm        push   1;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    [ebp-0xA0], eax;
	__asm        mov    dword ptr [ebp-0xA4], 0x80;
	__asm        lea    eax, [ebp-0xA4];
	__asm        mov    [ebp-0xAC], eax;
	__asm        mov    dword ptr [ebp-0xA8], 1;
	__asm        lea    eax, [ebp-0xA8];
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0xB0];
	__asm        mov    ecx, [ebp-0xAC];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T3c0;

	__asm        mov    eax, [ebp-0xB0];
	__asm        mov    [ebp-0xB4], eax;
	__asm        jmp    _T3cc;
_T3c0:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    [ebp-0xB4], eax;
_T3cc:
	__asm        jmp    _T3d1;
_T3d1:
	__asm        jmp    _T3d6;
_T3d6:
	__asm        jmp    _T3db;
_T3db:
	__asm        mov    eax, [ebp-0xB4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0xCC], eax;
	__asm        jmp    _T3ee;
_T3ee:
	__asm        push   0;
	__asm        mov    eax, [ebp-0xCC];
	__asm        push   eax;
	__asm        call   allocate;
	__asm        add    esp, 8;
	__asm        mov    ecx, [ebp-0xA0];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    ecx, [ebp-0xA0];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    list<Shortcut>::buffer_list, eax;
	__asm        mov    eax, list<Shortcut>::buffer_list;
	__asm        mov    eax, [eax+4];
	__asm        mov    list<Shortcut>::next_avail, eax;
	__asm        mov    dword ptr [ebp-0xB8], 0x80;
	__asm        lea    eax, [ebp-0xB8];
	__asm        mov    [ebp-0xC0], eax;
	__asm        mov    dword ptr [ebp-0xBC], 1;
	__asm        lea    eax, [ebp-0xBC];
	__asm        mov    [ebp-0xC4], eax;
	__asm        mov    eax, [ebp-0xC4];
	__asm        mov    ecx, [ebp-0xC0];
	__asm        mov    ecx, [ecx];
	__asm        cmp    [eax], ecx;
	__asm        jb     _T480;

	__asm        mov    eax, [ebp-0xC4];
	__asm        mov    [ebp-0xC8], eax;
	__asm        jmp    _T48c;
_T480:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    [ebp-0xC8], eax;
_T48c:
	__asm        jmp    _T491;
_T491:
	__asm        jmp    _T496;
_T496:
	__asm        jmp    _T49b;
_T49b:
	__asm        mov    eax, [ebp-0xC8];
	__asm        mov    eax, [eax];
	__asm        shl    eax, 5;
	__asm        add    eax, list<Shortcut>::next_avail;
	__asm        mov    list<Shortcut>::last, eax;
	__asm        jmp    _T4b6;
_T4b6:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x98], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    [ebp-0xD0], eax;
	__asm        jmp    _T4f7;
_T4d9:
	__asm        mov    eax, list<Shortcut>::next_avail;
	__asm        mov    [ebp-0x9C], eax;
	__asm        add    list<Shortcut>::next_avail, 0x20;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0xD0], eax;
_T4f7:
	__asm        jmp    _T4fc;
_T4fc:
	__asm        mov    eax, [ebp-0xD0];
	__asm        mov    [ebp-0x8C], eax;
	__asm        jmp    _T50d;
_T50d:
	__asm        mov    eax, [ebp-0x8C];
	__asm        add    eax, 8;
	__asm        mov    [ebp-0x90], eax;
	__asm        jmp    _T521;
_T521:
	__asm        cmp    dword ptr [ebp-0x90], 0;
	__asm        je     _T546;

	__asm        mov    edi, [ebp-0x90];
	__asm        mov    esi, [ebp-0xD8];
	__asm        mov    ecx, 6;
	__asm        rep movsd;
	__asm        jmp    _T546;
_T546:
	__asm        jmp    _T54b;
_T54b:
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    ecx, [ebp-0x8C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x8C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    ecx, [ebp-0xD4];
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    ecx, [ebp-0xD4];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, this;
	__asm        add    dword ptr [eax+0x9C], 1;
	__asm        mov    eax, [ebp-0x8C];
	__asm        mov    [ebp-0x84], eax;
	__asm        jmp    _T5a9;
_T5a9:
	__asm        jmp    _T5ae;
_T5ae:
	__asm        jmp    _T5b3;
// LINE 1795:
_T5b3:
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    [ebp-0xDC], eax;
	__asm        mov    eax, tempShortcutListIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    tempShortcutListIterator.node, eax;
	__asm        jmp    _T5c9;
_T5c9:
	__asm        mov    eax, [ebp-0xDC];
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T5d7;
// LINE 1796:
_T5d7:
	__asm        jmp    _T2c;
// LINE 1797:
_T5dc:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   UserInputWindow::UpdateDisplay;
// LINE 1798:
	return;
}

// FUNCTION: COPTER_D 0x0040b471
void UserInputWindow::WriteShortcutsToPreferenceFile() {
// LINE 1806:
	__asm        mov    eax, this;
	__asm        add    eax, 0xA0;
	__asm        push   eax;
	__asm        call   WriteShortcutPrefsFile;
	__asm        add    esp, 4;
// LINE 1807:
	return;
}

// FUNCTION: COPTER_D 0x0040b498
void UserInputWindow::DisplayError(int32_t nErrorType) {
// LINE 1815:
	return;
}

// FUNCTION: COPTER_D 0x0040b4b0
void ControlDisplayWindow::ControlDisplayWindow(/*packed*/ class MRect& rectNewPosition, int32_t nNewID, /*unpacked*/ class GraphicWindow *windowNewParent, /*packed*/ class GraphicWindowOwner *myNewOwner, int32_t bAddToParentList) {

	__asm        mov    eax, GraphicWindow::colorConstants.nPaletteIndexTransparent;
	__asm        push   eax;
	__asm        mov    eax, bAddToParentList;
	__asm        push   eax;
	__asm        mov    eax, myNewOwner;
	__asm        push   eax;
	__asm        mov    eax, windowNewParent;
	__asm        push   eax;
	__asm        mov    eax, nNewID;
	__asm        push   eax;
	__asm        mov    eax, rectNewPosition;
	__asm        push   eax;
	__asm        mov    eax, SZ_CONTROL_DISPLAY_WINDOW_IMAGE_FILE_NAME;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::GraphicWindow;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x74], 1;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x78], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x7C], 0;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x58F300;
// LINE 1854:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0040b51a
int32_t ControlDisplayWindow::Initialize() {
	/*bp-0x4*/   int32_t nFullStringID;
	/*bp-0xc*/   /*packed*/ class basic_string<char> sText; // 0x8 bytes
	/*bp-0x10*/  /*packed*/ class TextWindow *tempTextWindow;
	/*bp-0x14*/  /*packed*/ class ButtonWindow *tempButtonWindow;

// LINE 1864:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xAC], eax;
	__asm        cmp    dword ptr [ebp-0xAC], 0;
	__asm        je     _T7e;

	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xAC];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T70;
_T70:
	__asm        mov    eax, [ebp-0xAC];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _T85;
_T7e:
	sText.reference = 0x0;
_T85:
	__asm        mov    sText.c_str_ptr, 0;
	__asm        jmp    _T91;
// LINE 1868:
_T91:
	__asm        mov    ecx, this;
	__asm        call   GraphicWindow::Initialize;
// LINE 1871:
	__asm        push   0;
	__asm        push   0xDC;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1872:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x10BC];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x10C0], eax;
	__asm        cmp    dword ptr [ebp-0x10C0], 0;
	__asm        jne    _T15b;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x10BC];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x10C0], eax;
	__asm        jmp    _T10d;
_T10d:
	__asm        lea    eax, [ebp-0x10BC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10BC];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T131;
_T131:
	__asm        jmp    _T136;
_T136:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T156;
_T156:
	__asm        jmp    _T2ab;
_T15b:
	__asm        jmp    _T160;
_T160:
	__asm        lea    eax, [ebp-0x10BC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x10D4], eax;
	__asm        cmp    dword ptr [ebp-0x10D4], 0xFFFFFFFF;
	__asm        jne    _T1ba;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x10D0], eax;
	__asm        mov    eax, [ebp-0x10D0];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T1ab;
_T1ab:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T1ba;
_T1ba:
	__asm        jmp    _T1bf;
_T1bf:
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T1f0;

	__asm        cmp    dword ptr [ebp-0x10D4], 0;
	__asm        je     _T251;

	__asm        jmp    _T1de;
_T1de:
	__asm        mov    eax, sText.reference;
	__asm        mov    ecx, [ebp-0x10D4];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T251;
_T1f0:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x10C8], eax;
	__asm        cmp    dword ptr [ebp-0x10C8], 0;
	__asm        je     _T231;

	__asm        mov    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10BC];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x10C8];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x10C4], eax;
	__asm        jmp    _T23b;
_T231:
	__asm        mov    dword ptr [ebp-0x10C4], 0;
_T23b:
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        mov    eax, [ebp-0x10C4];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _T290;
_T251:
	__asm        cmp    dword ptr [ebp-0x10D4], 0;
	__asm        je     _T290;

	__asm        jmp    _T263;
_T263:
	__asm        mov    eax, sText.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x10CC], eax;
	__asm        mov    eax, [ebp-0x10D4];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x10BC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x10CC];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T290;
_T290:
	__asm        mov    eax, [ebp-0x10D4];
	__asm        mov    ecx, sText.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T2a1;
_T2a1:
	__asm        jmp    _T2a6;
_T2a6:
	__asm        jmp    _T2ab;
// LINE 1873:
_T2ab:
	__asm        push   0xA4;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x18], eax;
	__asm        cmp    dword ptr [ebp-0x18], 0;
	__asm        je     _T310;

	__asm        jmp    _T2ca;
_T2ca:
	__asm        mov    dword ptr [ebp-0x28], 0x70;
	__asm        mov    dword ptr [ebp-0x24], 0x28;
	__asm        mov    dword ptr [ebp-0x20], 0x18E;
	__asm        mov    dword ptr [ebp-0x1C], 0x42;
	__asm        jmp    _T2eb;
_T2eb:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, [ebp-0x28];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x18];
	__asm        call   TextWindow::TextWindow;
	__asm        mov    tempTextWindow, eax;
	__asm        jmp    _T317;
_T310:
	tempTextWindow = 0x0;
// LINE 1874:
_T317:
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1875:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x1C;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0xCC];
// LINE 1876:
	__asm        push   1;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0xD0];
// LINE 1877:
	__asm        push   0x5C2794;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0xD4];
// LINE 1878:
	__asm        jmp    _T35e;
_T35e:
	__asm        push   0xFFFFFFFF;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x18];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x10];
	__asm        cdq;
	__asm        sub    eax, edx;
	__asm        sar    eax, 1;
	__asm        push   eax;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0x3C];
// LINE 1880:
	__asm        push   0;
	__asm        push   0xDF;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1881:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x20D4];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x20D8], eax;
	__asm        cmp    dword ptr [ebp-0x20D8], 0;
	__asm        jne    _T443;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x20D4];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x20D8], eax;
	__asm        jmp    _T3f5;
_T3f5:
	__asm        lea    eax, [ebp-0x20D4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x20D4];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T419;
_T419:
	__asm        jmp    _T41e;
_T41e:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T43e;
_T43e:
	__asm        jmp    _T593;
_T443:
	__asm        jmp    _T448;
_T448:
	__asm        lea    eax, [ebp-0x20D4];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x20EC], eax;
	__asm        cmp    dword ptr [ebp-0x20EC], 0xFFFFFFFF;
	__asm        jne    _T4a2;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x20E8], eax;
	__asm        mov    eax, [ebp-0x20E8];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T493;
_T493:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T4a2;
_T4a2:
	__asm        jmp    _T4a7;
_T4a7:
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T4d8;

	__asm        cmp    dword ptr [ebp-0x20EC], 0;
	__asm        je     _T539;

	__asm        jmp    _T4c6;
_T4c6:
	__asm        mov    eax, sText.reference;
	__asm        mov    ecx, [ebp-0x20EC];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T539;
_T4d8:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x20E0], eax;
	__asm        cmp    dword ptr [ebp-0x20E0], 0;
	__asm        je     _T519;

	__asm        mov    eax, [ebp-0x20EC];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x20D4];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x20E0];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x20DC], eax;
	__asm        jmp    _T523;
_T519:
	__asm        mov    dword ptr [ebp-0x20DC], 0;
_T523:
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        mov    eax, [ebp-0x20DC];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _T578;
_T539:
	__asm        cmp    dword ptr [ebp-0x20EC], 0;
	__asm        je     _T578;

	__asm        jmp    _T54b;
_T54b:
	__asm        mov    eax, sText.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x20E4], eax;
	__asm        mov    eax, [ebp-0x20EC];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x20D4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x20E4];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T578;
_T578:
	__asm        mov    eax, [ebp-0x20EC];
	__asm        mov    ecx, sText.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T589;
_T589:
	__asm        jmp    _T58e;
_T58e:
	__asm        jmp    _T593;
// LINE 1882:
_T593:
	__asm        push   0xA4;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x2C], eax;
	__asm        cmp    dword ptr [ebp-0x2C], 0;
	__asm        je     _T5f8;

	__asm        jmp    _T5b2;
_T5b2:
	__asm        mov    dword ptr [ebp-0x3C], 0x40;
	__asm        mov    dword ptr [ebp-0x38], 0x62;
	__asm        mov    dword ptr [ebp-0x34], 0xDC;
	__asm        mov    dword ptr [ebp-0x30], 0x74;
	__asm        jmp    _T5d3;
_T5d3:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, [ebp-0x3C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x2C];
	__asm        call   TextWindow::TextWindow;
	__asm        mov    tempTextWindow, eax;
	__asm        jmp    _T5ff;
_T5f8:
	tempTextWindow = 0x0;
// LINE 1883:
_T5ff:
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1884:
	__asm        mov    byte ptr [ebp-0x40], 0x40;
	__asm        mov    byte ptr [ebp-0x3F], 0;
	__asm        mov    byte ptr [ebp-0x3E], 0;
	__asm        jmp    _T61b;
_T61b:
	__asm        lea    eax, [ebp-0x40];
	__asm        push   eax;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0xD4];
// LINE 1885:
	__asm        push   1;
	__asm        push   0;
	__asm        push   0xE;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0xCC];
// LINE 1886:
	__asm        push   1;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0x28];
// LINE 1888:
	__asm        push   0;
	__asm        push   0xE0;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1889:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x30EC];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x30F0], eax;
	__asm        cmp    dword ptr [ebp-0x30F0], 0;
	__asm        jne    _T70d;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x30EC];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x30F0], eax;
	__asm        jmp    _T6bf;
_T6bf:
	__asm        lea    eax, [ebp-0x30EC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x30EC];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T6e3;
_T6e3:
	__asm        jmp    _T6e8;
_T6e8:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T708;
_T708:
	__asm        jmp    _T85d;
_T70d:
	__asm        jmp    _T712;
_T712:
	__asm        lea    eax, [ebp-0x30EC];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x3104], eax;
	__asm        cmp    dword ptr [ebp-0x3104], 0xFFFFFFFF;
	__asm        jne    _T76c;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x3100], eax;
	__asm        mov    eax, [ebp-0x3100];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T75d;
_T75d:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T76c;
_T76c:
	__asm        jmp    _T771;
_T771:
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T7a2;

	__asm        cmp    dword ptr [ebp-0x3104], 0;
	__asm        je     _T803;

	__asm        jmp    _T790;
_T790:
	__asm        mov    eax, sText.reference;
	__asm        mov    ecx, [ebp-0x3104];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T803;
_T7a2:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x30F8], eax;
	__asm        cmp    dword ptr [ebp-0x30F8], 0;
	__asm        je     _T7e3;

	__asm        mov    eax, [ebp-0x3104];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x30EC];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x30F8];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x30F4], eax;
	__asm        jmp    _T7ed;
_T7e3:
	__asm        mov    dword ptr [ebp-0x30F4], 0;
_T7ed:
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        mov    eax, [ebp-0x30F4];
	__asm        mov    sText.reference, eax;
	__asm        jmp    _T842;
_T803:
	__asm        cmp    dword ptr [ebp-0x3104], 0;
	__asm        je     _T842;

	__asm        jmp    _T815;
_T815:
	__asm        mov    eax, sText.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x30FC], eax;
	__asm        mov    eax, [ebp-0x3104];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x30EC];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x30FC];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T842;
_T842:
	__asm        mov    eax, [ebp-0x3104];
	__asm        mov    ecx, sText.reference;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T853;
_T853:
	__asm        jmp    _T858;
_T858:
	__asm        jmp    _T85d;
// LINE 1890:
_T85d:
	__asm        push   0xA4;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x44], eax;
	__asm        cmp    dword ptr [ebp-0x44], 0;
	__asm        je     _T8c2;

	__asm        jmp    _T87c;
_T87c:
	__asm        mov    dword ptr [ebp-0x54], 0xDC;
	__asm        mov    dword ptr [ebp-0x50], 0x62;
	__asm        mov    dword ptr [ebp-0x4C], 0x1BE;
	__asm        mov    dword ptr [ebp-0x48], 0x74;
	__asm        jmp    _T89d;
_T89d:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        push   0;
	__asm        lea    eax, [ebp-0x54];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x44];
	__asm        call   TextWindow::TextWindow;
	__asm        mov    tempTextWindow, eax;
	__asm        jmp    _T8c9;
_T8c2:
	tempTextWindow = 0x0;
// LINE 1891:
_T8c9:
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1892:
	__asm        mov    byte ptr [ebp-0x58], 0x40;
	__asm        mov    byte ptr [ebp-0x57], 0;
	__asm        mov    byte ptr [ebp-0x56], 0;
	__asm        jmp    _T8e5;
_T8e5:
	__asm        lea    eax, [ebp-0x58];
	__asm        push   eax;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0xD4];
// LINE 1893:
	__asm        push   1;
	__asm        push   0;
	__asm        push   0xE;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0xCC];
// LINE 1894:
	__asm        push   1;
	__asm        mov    eax, tempTextWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempTextWindow;
	__asm        call   dword ptr [eax+0x28];
// LINE 1897:
	__asm        push   0xCC;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x5C], eax;
	__asm        cmp    dword ptr [ebp-0x5C], 0;
	__asm        je     _T984;

	__asm        jmp    _T937;
_T937:
	__asm        mov    dword ptr [ebp-0x6C], 0x40;
	__asm        mov    dword ptr [ebp-0x68], 0x74;
	__asm        mov    dword ptr [ebp-0x64], 0xDC;
	__asm        mov    dword ptr [ebp-0x60], 0x146;
	__asm        jmp    _T958;
_T958:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   3;
	__asm        lea    eax, [ebp-0x6C];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x5C];
	__asm        call   ListBoxWindow::ListBoxWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x78], eax;
	__asm        jmp    _T991;
_T984:
	this->myCommandListBoxWindow = 0x0;
// LINE 1898:
_T991:
	__asm        mov    byte ptr [ebp-0x70], 0xEF;
	__asm        mov    byte ptr [ebp-0x6F], 0xC5;
	__asm        mov    byte ptr [ebp-0x6E], 0xC5;
	__asm        jmp    _T9a2;
_T9a2:
	__asm        mov    byte ptr [ebp-0x74], 0x40;
	__asm        mov    byte ptr [ebp-0x73], 0;
	__asm        mov    byte ptr [ebp-0x72], 0;
	__asm        jmp    _T9b3;
_T9b3:
	__asm        lea    eax, [ebp-0x70];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x74];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x124];
// LINE 1899:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+4];
// LINE 1900:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0xE;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x128];
// LINE 1901:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0xD8];
// LINE 1902:
	__asm        push   0xFFFFFFFF;
	__asm        push   0xBD;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x120];
// LINE 1904:
	__asm        push   0xCC;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x78], eax;
	__asm        cmp    dword ptr [ebp-0x78], 0;
	__asm        je     _Tabc;

	__asm        jmp    _Ta66;
_Ta66:
	__asm        mov    dword ptr [ebp-0x88], 0xDC;
	__asm        mov    dword ptr [ebp-0x84], 0x74;
	__asm        mov    dword ptr [ebp-0x80], 0x1BE;
	__asm        mov    dword ptr [ebp-0x7C], 0x146;
	__asm        jmp    _Ta8d;
_Ta8d:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   4;
	__asm        lea    eax, [ebp-0x88];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x78];
	__asm        call   ListBoxWindow::ListBoxWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x7C], eax;
	__asm        jmp    _Tac9;
_Tabc:
	this->myKeysListBoxWindow = 0x0;
// LINE 1905:
_Tac9:
	__asm        mov    byte ptr [ebp-0x8C], 0xEF;
	__asm        mov    byte ptr [ebp-0x8B], 0xC5;
	__asm        mov    byte ptr [ebp-0x8A], 0xC5;
	__asm        jmp    _Tae3;
_Tae3:
	__asm        mov    byte ptr [ebp-0x90], 0x40;
	__asm        mov    byte ptr [ebp-0x8F], 0;
	__asm        mov    byte ptr [ebp-0x8E], 0;
	__asm        jmp    _Tafd;
_Tafd:
	__asm        lea    eax, [ebp-0x8C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x90];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x124];
// LINE 1906:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+4];
// LINE 1907:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0xE;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x128];
// LINE 1908:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xD8];
// LINE 1909:
	__asm        push   0xFFFFFFFF;
	__asm        push   0xBD;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x120];
// LINE 1910:
	__asm        push   0;
	__asm        push   0;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x12C];
// LINE 1913:
	__asm        push   0;
	__asm        push   0xDD;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 1914:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x4104];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x4108], eax;
	__asm        cmp    dword ptr [ebp-0x4108], 0;
	__asm        jne    _Tc76;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x4104];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x4108], eax;
	__asm        jmp    _Tc28;
_Tc28:
	__asm        lea    eax, [ebp-0x4104];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x4104];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _Tc4c;
_Tc4c:
	__asm        jmp    _Tc51;
_Tc51:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _Tc71;
_Tc71:
	__asm        jmp    _Tca4;
_Tc76:
	__asm        jmp    _Tc7b;
_Tc7b:
	__asm        lea    eax, [ebp-0x4104];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x4104];
	__asm        push   eax;
	__asm        lea    ecx, sText.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _Tc9f;
_Tc9f:
	__asm        jmp    _Tca4;
// LINE 1915:
_Tca4:
	__asm        push   0x94;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x94], eax;
	__asm        cmp    dword ptr [ebp-0x94], 0;
	__asm        je     _Td24;

	__asm        jmp    _Tcc9;
_Tcc9:
	__asm        mov    dword ptr [ebp-0xA4], 0x162;
	__asm        mov    dword ptr [ebp-0xA0], 0x16C;
	__asm        mov    dword ptr [ebp-0x9C], 0x163;
	__asm        mov    dword ptr [ebp-0x98], 0x16D;
	__asm        jmp    _Tcf6;
_Tcf6:
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        push   1;
	__asm        lea    eax, [ebp-0xA4];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x94];
	__asm        call   SoundButtonWindow::SoundButtonWindow;
	__asm        mov    tempButtonWindow, eax;
	__asm        jmp    _Td2b;
_Td24:
	tempButtonWindow = 0x0;
// LINE 1916:
_Td2b:
	__asm        lea    eax, sText.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0x48];
// LINE 1917:
	__asm        push   0x5C2794;
	__asm        push   0x5C2790;
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+0xD8];
// LINE 1918:
	__asm        mov    eax, tempButtonWindow;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, tempButtonWindow;
	__asm        call   dword ptr [eax+4];
// LINE 1920:
	this->bInitializing = 0x0;
// LINE 1921:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   GraphicWindow::MakeModal;
	__asm        add    esp, 4;
// LINE 1922:
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        call   GraphicWindow::MakeFocus;
	__asm        add    esp, 4;
// LINE 1923:
	__asm        mov    dword ptr [ebp-0xA8], 1;
	__asm        mov    eax, sText.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sText.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _Tdf0;

	__asm        mov    eax, sText.reference;
	__asm        mov    [ebp-0xBC], eax;
	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    [ebp-0xB8], eax;
	__asm        cmp    dword ptr [ebp-0xB8], 0;
	__asm        je     _Tdf0;

	__asm        mov    ecx, [ebp-0xB8];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _Tdd7;
_Tdd7:
	__asm        mov    eax, [ebp-0xB8];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _Tdeb;
_Tdeb:
	__asm        jmp    _Tdf0;
_Tdf0:
	__asm        jmp    _Tdf5;
_Tdf5:
	__asm        cmp    sText.c_str_ptr, 0;
	__asm        je     _Te23;

	__asm        mov    eax, sText.c_str_ptr;
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0xB0];
	__asm        mov    [ebp-0xB4], eax;
	__asm        mov    eax, [ebp-0xB4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_Te23:
	__asm        jmp    _Te28;
_Te28:
	__asm        mov    eax, [ebp-0xA8];
	__asm        jmp    __RETURN;
// LINE 1924:
__RETURN:
}

// FUNCTION: COPTER_D 0x0040c352
int32_t ControlDisplayWindow::DoMessage(/*unpacked*/ class GraphicWindow *gwSource, long lWindowID, long lMessage, void * __ptr32 pMessageData) {
// LINE 1932:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x74], 0;
	__asm        je     _T20;
// LINE 1933:
	return 0x0;
// LINE 1936:
_T20:
	__asm        cmp    lWindowID, 3;
	__asm        je     _T34;

	__asm        cmp    lWindowID, 4;
	__asm        jne    _T20a;
// LINE 1940:
_T34:
	__asm        cmp    lMessage, 0x10002;
	__asm        jne    _T11f;
// LINE 1941:
	__asm        mov    eax, this;
	__asm        mov    ecx, gwSource;
	__asm        cmp    [eax+0x78], ecx;
	__asm        jne    _Tb0;
// LINE 1943:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x118];
	__asm        mov    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x118];
	__asm        cmp    ebx, eax;
	__asm        je     _Tab;
// LINE 1944:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x118];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x110];
// LINE 1946:
_Tab:
	__asm        jmp    _T11a;
_Tb0:
	__asm        mov    eax, this;
	__asm        mov    ecx, gwSource;
	__asm        cmp    [eax+0x7C], ecx;
	__asm        jne    _T11a;
// LINE 1948:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x118];
	__asm        mov    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x118];
	__asm        cmp    ebx, eax;
	__asm        je     _T11a;
// LINE 1949:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0x118];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0x110];
// LINE 1952:
_T11a:
	__asm        jmp    _T205;
_T11f:
	__asm        cmp    lMessage, 0x10001;
	__asm        jne    _T205;
// LINE 1953:
	__asm        mov    eax, this;
	__asm        mov    ecx, gwSource;
	__asm        cmp    [eax+0x78], ecx;
	__asm        jne    _T19b;
// LINE 1955:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0xE0];
	__asm        mov    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xE0];
	__asm        cmp    ebx, eax;
	__asm        je     _T196;
// LINE 1956:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0xE0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xDC];
// LINE 1958:
_T196:
	__asm        jmp    _T205;
_T19b:
	__asm        mov    eax, this;
	__asm        mov    ecx, gwSource;
	__asm        cmp    [eax+0x7C], ecx;
	__asm        jne    _T205;
// LINE 1960:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0xE0];
	__asm        mov    ebx, eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xE0];
	__asm        cmp    ebx, eax;
	__asm        je     _T205;
// LINE 1961:
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xE0];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0xDC];
// LINE 1966:
_T205:
	__asm        jmp    _T24e;
_T20a:
	__asm        cmp    lWindowID, 1;
	__asm        jne    _T24e;
// LINE 1967:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x38], 0;
	__asm        je     _T243;
// LINE 1968:
	__asm        push   0;
	__asm        push   0x3E9;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x38];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x38];
	__asm        call   dword ptr [edx];
// LINE 1969:
_T243:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x6C];
// LINE 1972:
_T24e:
	return 0x1;
// LINE 1973:
}

// FUNCTION: COPTER_D 0x0040c5b1
void ControlDisplayWindow::ReadShortcuts(/*packed*/ class list<Shortcut> *addedShortcutList) {
	/*bp-0x4*/   int32_t nLastShowableCommandIndex;
	/*bp-0x8*/   int32_t nKeyCountForCommand;
	/*bp-0xc*/   int32_t nTempForDebugging;
	/*bp-0x10*/  /*packed*/ struct Shortcut *tempShortcut;
	/*bp-0x18*/  /*packed*/ class basic_string<char> sCurrentKeys; // 0x8 bytes
	/*bp-0x1c*/  /*packed*/ class rb_tree<long,long,ident<long,long>,less<long>>::const_iterator tempLongSetIterator;
	/*bp-0x20*/  int32_t nFirstShowableCommandIndex;
	/*bp-0x30*/  /*packed*/ class set<long,less<long>> tempLongSet; // 0xd bytes
	/*bp-0x38*/  /*packed*/ class basic_string<char> sCurrentCommand; // 0x8 bytes
	/*bp-0x3c*/  /*packed*/ class list<Shortcut>::iterator shortcutIterator;

// LINE 1983:
	__asm        jmp    _T17;
// LINE 1985:
_T17:
	__asm        mov    tempLongSet.t.node_count, 0;
	__asm        mov    tempLongSet.t.insert_always, 0;
	__asm        mov    al, [ebp-0x40];
	__asm        mov    tempLongSet.t.key_compare<less<long>+0x00>, al;
	__asm        lea    ecx, tempLongSet.t.header;
	__asm        call   rb_tree<long,long,ident<long,long>,less<long>>::init;
	__asm        jmp    _T38;
_T38:
	__asm        jmp    _T3d;
// LINE 1986:
_T3d:
	__asm        jmp    _T42;
// LINE 1988:
_T42:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xA0], eax;
	__asm        cmp    dword ptr [ebp-0xA0], 0;
	__asm        je     _Taa;

	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xA0];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T9c;
_T9c:
	__asm        mov    eax, [ebp-0xA0];
	__asm        mov    sCurrentCommand.reference, eax;
	__asm        jmp    _Tb1;
_Taa:
	sCurrentCommand.reference = 0x0;
_Tb1:
	__asm        mov    sCurrentCommand.c_str_ptr, 0;
	__asm        jmp    _Tbd;
// LINE 1989:
_Tbd:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0xA4], eax;
	__asm        cmp    dword ptr [ebp-0xA4], 0;
	__asm        je     _T125;

	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    dword ptr [eax+4], 0;
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0xA4];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    dword ptr [eax], 0;
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T117;
_T117:
	__asm        mov    eax, [ebp-0xA4];
	__asm        mov    sCurrentKeys.reference, eax;
	__asm        jmp    _T12c;
_T125:
	sCurrentKeys.reference = 0x0;
_T12c:
	__asm        mov    sCurrentKeys.c_str_ptr, 0;
	__asm        jmp    _T138;
// LINE 1993:
_T138:
	this->bInitializing = 0x1;
// LINE 1995:
	nFirstShowableCommandIndex = 0x1;
// LINE 1996:
	nLastShowableCommandIndex = 0x39;
// LINE 2000:
	__asm        jmp    _T158;
_T158:
	nTempForDebugging = addedShortcutList->length;
// LINE 2001:
	__asm        mov    eax, addedShortcutList;
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x98], eax;
	__asm        mov    eax, [ebp-0x98];
	__asm        mov    [ebp-0x44], eax;
	__asm        jmp    _T17c;
_T17c:
	__asm        jmp    _T181;
_T181:
	__asm        mov    eax, [ebp-0x44];
	__asm        mov    shortcutIterator.node, eax;
// LINE 2002:
_T187:
	__asm        mov    eax, addedShortcutList;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x88], eax;
	__asm        mov    eax, [ebp-0x88];
	__asm        mov    [ebp-0x48], eax;
	__asm        jmp    _T1a0;
_T1a0:
	__asm        jmp    _T1a5;
_T1a5:
	__asm        mov    eax, shortcutIterator.node;
	__asm        cmp    [ebp-0x48], eax;
	__asm        jne    _T1bb;

	__asm        jmp    _T1d2;

	__asm        jmp    _T1bb;
_T1bb:
	__asm        jmp    _T1cd;

	__asm        cmp    dword ptr [ebp-0x8C], 0;
	__asm        jne    _T1d2;
_T1cd:
	__asm        jmp    _T1d7;
_T1d2:
	__asm        jmp    _T28e;
_T1d7:
	__asm        jmp    _T1e9;

	__asm        cmp    dword ptr [ebp-0x90], 0;
	__asm        je     _T28e;
// LINE 2004:
_T1e9:
	__asm        jmp    _T1ee;
_T1ee:
	__asm        mov    eax, shortcutIterator.node;
	__asm        mov    ecx, nFirstShowableCommandIndex;
	__asm        cmp    [eax+0xC], ecx;
	__asm        jl     _T265;

	__asm        jmp    _T202;
_T202:
	__asm        mov    eax, shortcutIterator.node;
	__asm        mov    ecx, nLastShowableCommandIndex;
	__asm        cmp    [eax+0xC], ecx;
	__asm        jg     _T265;
// LINE 2009:
	__asm        jmp    _T216;
_T216:
	__asm        mov    eax, shortcutIterator.node;
	__asm        add    eax, 0xC;
	__asm        mov    [ebp-0xD8], eax;
	__asm        mov    eax, [ebp-0xD8];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0xD0];
	__asm        push   eax;
	__asm        lea    ecx, tempLongSet.t.header;
	__asm        call   rb_tree<long,long,ident<long,long>,less<long>>::insert;
	__asm        mov    eax, [ebp-0xD0];
	__asm        mov    [ebp-0xD4], eax;
	__asm        jmp    _T249;
_T249:
	__asm        mov    eax, [ebp-0xD4];
	__asm        mov    [ebp-0x50], eax;
	__asm        mov    eax, [ebp-0xCC];
	__asm        mov    [ebp-0x4C], eax;
	__asm        jmp    _T260;
_T260:
	__asm        jmp    _T265;
// LINE 2011:
_T265:
	__asm        mov    eax, shortcutIterator.node;
	__asm        mov    [ebp-0xC0], eax;
	__asm        mov    eax, shortcutIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    shortcutIterator.node, eax;
	__asm        jmp    _T27b;
_T27b:
	__asm        mov    eax, [ebp-0xC0];
	__asm        mov    [ebp-0x54], eax;
	__asm        jmp    _T289;
// LINE 2012:
_T289:
	__asm        jmp    _T187;
// LINE 2014:
_T28e:
	__asm        jmp    _T293;
_T293:
	__asm        jmp    _T298;
_T298:
	__asm        mov    eax, tempLongSet.t.header;
	__asm        mov    eax, [eax+8];
	__asm        mov    [ebp-0x94], eax;
	__asm        mov    eax, [ebp-0x94];
	__asm        mov    [ebp-0x58], eax;
	__asm        jmp    _T2b2;
_T2b2:
	__asm        jmp    _T2b7;
_T2b7:
	__asm        jmp    _T2bc;
_T2bc:
	__asm        mov    eax, [ebp-0x58];
	__asm        mov    tempLongSetIterator.node, eax;
// LINE 2015:
_T2c2:
	__asm        mov    eax, tempLongSet.t.header;
	__asm        mov    [ebp-0x7C], eax;
	__asm        mov    eax, [ebp-0x7C];
	__asm        mov    [ebp-0x5C], eax;
	__asm        jmp    _T2d3;
_T2d3:
	__asm        jmp    _T2d8;
_T2d8:
	__asm        jmp    _T2dd;
_T2dd:
	__asm        mov    eax, tempLongSetIterator.node;
	__asm        cmp    [ebp-0x5C], eax;
	__asm        jne    _T2f3;

	__asm        jmp    _T307;

	__asm        jmp    _T2f3;
_T2f3:
	__asm        jmp    _T302;

	__asm        cmp    dword ptr [ebp-0x80], 0;
	__asm        jne    _T307;
_T302:
	__asm        jmp    _T30c;
_T307:
	__asm        jmp    _T4c1;
_T30c:
	__asm        jmp    _T31e;

	__asm        cmp    dword ptr [ebp-0x84], 0;
	__asm        je     _T4c1;
// LINE 2016:
_T31e:
	__asm        jmp    _T323;
_T323:
	__asm        jmp    _T328;
_T328:
	__asm        mov    eax, tempLongSetIterator.node;
	__asm        mov    eax, [eax+0x10];
	__asm        push   eax;
	__asm        lea    eax, sCurrentCommand.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ControlDisplayWindow::GetCommandString;
// LINE 2017:
	__asm        mov    eax, addedShortcutList;
	__asm        mov    eax, [eax];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x9C], eax;
	__asm        mov    eax, [ebp-0x9C];
	__asm        mov    [ebp-0x60], eax;
	__asm        jmp    _T359;
_T359:
	__asm        jmp    _T35e;
_T35e:
	__asm        mov    eax, [ebp-0x60];
	__asm        mov    shortcutIterator.node, eax;
// LINE 2018:
	nKeyCountForCommand = 0x0;
// LINE 2019:
_T36b:
	__asm        mov    eax, addedShortcutList;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x70], eax;
	__asm        mov    eax, [ebp-0x70];
	__asm        mov    [ebp-0x64], eax;
	__asm        jmp    _T37e;
_T37e:
	__asm        jmp    _T383;
_T383:
	__asm        mov    eax, [ebp-0x64];
	__asm        cmp    shortcutIterator.node, eax;
	__asm        jne    _T399;

	__asm        jmp    _T3ad;

	__asm        jmp    _T399;
_T399:
	__asm        jmp    _T3a8;

	__asm        cmp    dword ptr [ebp-0x74], 0;
	__asm        jne    _T3ad;
_T3a8:
	__asm        jmp    _T3b2;
_T3ad:
	__asm        jmp    _T445;
_T3b2:
	__asm        jmp    _T3c1;

	__asm        cmp    dword ptr [ebp-0x78], 0;
	__asm        je     _T445;
// LINE 2020:
_T3c1:
	__asm        jmp    _T3c6;
_T3c6:
	tempShortcut = (shortcutIterator.node + 0x8);
// LINE 2022:
	__asm        jmp    _T3d4;
_T3d4:
	__asm        jmp    _T3d9;
_T3d9:
	__asm        mov    eax, tempLongSetIterator.node;
	__asm        mov    ecx, tempShortcut;
	__asm        mov    ecx, [ecx+4];
	__asm        cmp    [eax+0x10], ecx;
	__asm        jne    _T41c;

	__asm        mov    eax, tempShortcut;
	__asm        cmp    dword ptr [eax], 0;
	__asm        jne    _T41c;
// LINE 2024:
	__asm        mov    eax, nKeyCountForCommand;
	__asm        push   eax;
	__asm        mov    eax, tempShortcut;
	__asm        mov    eax, [eax+0xC];
	__asm        push   eax;
	__asm        mov    eax, tempShortcut;
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        lea    eax, sCurrentKeys.c_str_ptr;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ControlDisplayWindow::AppendKeysString;
// LINE 2025:
	nKeyCountForCommand += 0x1;
// LINE 2027:
_T41c:
	__asm        mov    eax, shortcutIterator.node;
	__asm        mov    [ebp-0xC4], eax;
	__asm        mov    eax, shortcutIterator.node;
	__asm        mov    eax, [eax];
	__asm        mov    shortcutIterator.node, eax;
	__asm        jmp    _T432;
_T432:
	__asm        mov    eax, [ebp-0xC4];
	__asm        mov    [ebp-0x68], eax;
	__asm        jmp    _T440;
// LINE 2028:
_T440:
	__asm        jmp    _T36b;
// LINE 2029:
_T445:
	__asm        push   0xFFFFFFFF;
	__asm        lea    eax, sCurrentCommand.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x78];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x78];
	__asm        call   dword ptr [edx+0xD4];
// LINE 2030:
	__asm        push   0xFFFFFFFF;
	__asm        lea    eax, sCurrentKeys.c_str_ptr;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x7C];
	__asm        mov    edx, [ecx];
	__asm        mov    ecx, [eax+0x7C];
	__asm        call   dword ptr [edx+0xD4];
// LINE 2031:
	__asm        push   0xFFFFFFFF;
	__asm        push   0;
	__asm        lea    ecx, sCurrentCommand.c_str_ptr;
	__asm        call   basic_string<char>::remove;
// LINE 2032:
	__asm        push   0xFFFFFFFF;
	__asm        push   0;
	__asm        lea    ecx, sCurrentKeys.c_str_ptr;
	__asm        call   basic_string<char>::remove;
// LINE 2033:
	__asm        mov    eax, tempLongSetIterator.node;
	__asm        mov    [ebp-0xC8], eax;
	__asm        lea    ecx, tempLongSetIterator.node;
	__asm        call   rb_tree<long,long,ident<long,long>,less<long>>::const_iterator::operator++;
	__asm        mov    eax, [ebp-0xC8];
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T4bc;
// LINE 2034:
_T4bc:
	__asm        jmp    _T2c2;
// LINE 2035:
_T4c1:
	this->bInitializing = 0x0;
// LINE 2036:
	__asm        lea    ecx, sCurrentKeys.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    sCurrentKeys.c_str_ptr, 0;
	__asm        je     _T504;

	__asm        mov    eax, sCurrentKeys.c_str_ptr;
	__asm        mov    [ebp-0xA8], eax;
	__asm        mov    eax, [ebp-0xA8];
	__asm        mov    [ebp-0xAC], eax;
	__asm        mov    eax, [ebp-0xAC];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T504:
	__asm        jmp    _T509;
_T509:
	__asm        mov    eax, sCurrentCommand.reference;
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCurrentCommand.reference;
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T550;

	__asm        mov    eax, sCurrentCommand.reference;
	__asm        mov    [ebp-0xBC], eax;
	__asm        mov    eax, [ebp-0xBC];
	__asm        mov    [ebp-0xB8], eax;
	__asm        cmp    dword ptr [ebp-0xB8], 0;
	__asm        je     _T550;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0xB8];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T550;
_T550:
	__asm        jmp    _T555;
_T555:
	__asm        cmp    sCurrentCommand.c_str_ptr, 0;
	__asm        je     _T583;

	__asm        mov    eax, sCurrentCommand.c_str_ptr;
	__asm        mov    [ebp-0xB0], eax;
	__asm        mov    eax, [ebp-0xB0];
	__asm        mov    [ebp-0xB4], eax;
	__asm        mov    eax, [ebp-0xB4];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T583:
	__asm        jmp    _T588;
_T588:
	__asm        jmp    _T58d;
_T58d:
	__asm        lea    ecx, tempLongSet.t.header;
	__asm        call   rb_tree<long,long,ident<long,long>,less<long>>::~rb_tree<long,long,ident<long,long>,less<long>>;
	__asm        jmp    __RETURN;
__RETURN:
}

// FUNCTION: COPTER_D 0x0040cb52
void ControlDisplayWindow::GetCommandString(/*packed*/ class basic_string<char>& sCommand, long lCommand) {
	/*bp-0x4*/   uint32_t nFullStringID;

// LINE 2046:
	__asm        push   0;
	__asm        mov    eax, lCommand;
	__asm        add    eax, 0x96;
	__asm        push   eax;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 2047:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1008], eax;
	__asm        cmp    dword ptr [ebp-0x1008], 0;
	__asm        jne    _T44a;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1008], eax;
	__asm        jmp    _T8b;
_T8b:
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1024], eax;
	__asm        cmp    dword ptr [ebp-0x1024], 0xFFFFFFFF;
	__asm        jne    _Te5;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1018], eax;
	__asm        mov    eax, [ebp-0x1018];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _Td6;
_Td6:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _Te5;
_Te5:
	__asm        jmp    _Tea;
_Tea:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T121;

	__asm        cmp    dword ptr [ebp-0x1024], 0;
	__asm        je     _T1d2;

	__asm        jmp    _T10c;
_T10c:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x1024];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T1d2;
_T121:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1010], eax;
	__asm        cmp    dword ptr [ebp-0x1010], 0;
	__asm        je     _T162;

	__asm        mov    eax, [ebp-0x1024];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x1010];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x100C], eax;
	__asm        jmp    _T16c;
_T162:
	__asm        mov    dword ptr [ebp-0x100C], 0;
_T16c:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T1bc;

	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1020], eax;
	__asm        mov    eax, [ebp-0x1020];
	__asm        mov    [ebp-0x101C], eax;
	__asm        cmp    dword ptr [ebp-0x101C], 0;
	__asm        je     _T1bc;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x101C];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T1bc;
_T1bc:
	__asm        jmp    _T1c1;
_T1c1:
	__asm        mov    eax, [ebp-0x100C];
	__asm        mov    ecx, sCommand;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T214;
_T1d2:
	__asm        cmp    dword ptr [ebp-0x1024], 0;
	__asm        je     _T214;

	__asm        jmp    _T1e4;
_T1e4:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1014], eax;
	__asm        mov    eax, [ebp-0x1024];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1014];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T214;
_T214:
	__asm        mov    eax, [ebp-0x1024];
	__asm        mov    ecx, sCommand;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T228;
_T228:
	__asm        jmp    _T22d;
_T22d:
	__asm        jmp    _T232;
_T232:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x1044], eax;
	__asm        jmp    _T24a;
_T24a:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, 0xFFFFFFFF;
	__asm        sub    ecx, [ebp-0x1044];
	__asm        cmp    [eax+4], ecx;
	__asm        jb     _T29c;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1038], eax;
	__asm        mov    eax, [ebp-0x1038];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T28d;
_T28d:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T29c;
_T29c:
	__asm        jmp    _T2a1;
_T2a1:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T2d9;

	__asm        jmp    _T2b6;
_T2b6:
	__asm        jmp    _T2bb;
_T2bb:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, sCommand;
	__asm        mov    ecx, [ecx+4];
	__asm        sub    eax, [ecx+4];
	__asm        cmp    eax, [ebp-0x1044];
	__asm        jae    _T3de;
_T2d9:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x102C], eax;
	__asm        cmp    dword ptr [ebp-0x102C], 0;
	__asm        je     _T373;

	__asm        jmp    _T2fb;
_T2fb:
	__asm        jmp    _T300;
_T300:
	__asm        jmp    _T305;
_T305:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T32d;

	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1034], eax;
	__asm        jmp    _T33c;

	__asm        jmp    _T33c;
_T32d:
	__asm        mov    dword ptr [ebp-0x1034], 0;
	__asm        jmp    _T33c;
_T33c:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        add    eax, [ebp-0x1044];
	__asm        push   eax;
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1034];
	__asm        push   eax;
	__asm        mov    ecx, [ebp-0x102C];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    [ebp-0x1028], eax;
	__asm        jmp    _T37d;
_T373:
	__asm        mov    dword ptr [ebp-0x1028], 0;
_T37d:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T3cd;

	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1040], eax;
	__asm        mov    eax, [ebp-0x1040];
	__asm        mov    [ebp-0x103C], eax;
	__asm        cmp    dword ptr [ebp-0x103C], 0;
	__asm        je     _T3cd;

	__asm        push   1;
	__asm        mov    ecx, [ebp-0x103C];
	__asm        call   basic_string_ref<char>::`scalar deleting destructor';
	__asm        jmp    _T3cd;
_T3cd:
	__asm        jmp    _T3d2;
_T3d2:
	__asm        mov    eax, [ebp-0x1028];
	__asm        mov    ecx, sCommand;
	__asm        mov    [ecx+4], eax;
_T3de:
	__asm        cmp    dword ptr [ebp-0x1044], 0;
	__asm        je     _T42c;

	__asm        jmp    _T3f0;
_T3f0:
	__asm        jmp    _T3f5;
_T3f5:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, sCommand;
	__asm        mov    ecx, [ecx+4];
	__asm        add    eax, [ecx];
	__asm        mov    [ebp-0x1030], eax;
	__asm        mov    eax, [ebp-0x1044];
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        mov    eax, [ebp-0x1030];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T42c;
_T42c:
	__asm        mov    eax, [ebp-0x1044];
	__asm        mov    ecx, sCommand;
	__asm        mov    ecx, [ecx+4];
	__asm        add    [ecx+4], eax;
	__asm        jmp    _T440;
_T440:
	__asm        jmp    _T445;
_T445:
	__asm        jmp    _T6ec;
_T44a:
	__asm        jmp    _T44f;
_T44f:
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x106C], eax;
	__asm        cmp    dword ptr [ebp-0x106C], 0xFFFFFFFF;
	__asm        jne    _T4a9;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1054], eax;
	__asm        mov    eax, [ebp-0x1054];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T49a;
_T49a:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T4a9;
_T4a9:
	__asm        jmp    _T4ae;
_T4ae:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 1;
	__asm        ja     _T4e5;

	__asm        cmp    dword ptr [ebp-0x106C], 0;
	__asm        je     _T68c;

	__asm        jmp    _T4d0;
_T4d0:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x106C];
	__asm        cmp    [eax+8], ecx;
	__asm        jae    _T68c;
_T4e5:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x104C], eax;
	__asm        cmp    dword ptr [ebp-0x104C], 0;
	__asm        je     _T605;

	__asm        cmp    dword ptr [ebp-0x106C], 0xFFFFFFFF;
	__asm        jne    _T547;

	__asm        push   0x5971E4;
	__asm        mov    ecx, 0x638C00;
	__asm        call   ostream::operator<<;
	__asm        mov    [ebp-0x1068], eax;
	__asm        mov    eax, [ebp-0x1068];
	__asm        push   eax;
	__asm        call   endl;
	__asm        add    esp, 4;
	__asm        jmp    _T538;
_T538:
	__asm        push   1;
	__asm        call   exit;
	__asm        add    esp, 4;
	__asm        jmp    _T547;
_T547:
	__asm        mov    eax, [ebp-0x106C];
	__asm        mov    ecx, [ebp-0x104C];
	__asm        mov    [ecx+4], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax+4];
	__asm        mov    ecx, [ebp-0x104C];
	__asm        mov    [ecx+8], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        cmp    dword ptr [eax+8], 0;
	__asm        je     _T5d6;

	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax+8];
	__asm        push   eax;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    ecx, [ebp-0x104C];
	__asm        mov    [ecx], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x1060], eax;
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1064], eax;
	__asm        mov    eax, [ebp-0x1060];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1064];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T5d1;
_T5d1:
	__asm        jmp    _T5e2;
_T5d6:
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    dword ptr [eax], 0;
_T5e2:
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    dword ptr [eax+0xC], 1;
	__asm        jmp    _T5f4;
_T5f4:
	__asm        mov    eax, [ebp-0x104C];
	__asm        mov    [ebp-0x1048], eax;
	__asm        jmp    _T60f;
_T605:
	__asm        mov    dword ptr [ebp-0x1048], 0;
_T60f:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        dec    dword ptr [eax+0xC];
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        cmp    dword ptr [eax+0xC], 0;
	__asm        jne    _T676;

	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    [ebp-0x105C], eax;
	__asm        mov    eax, [ebp-0x105C];
	__asm        mov    [ebp-0x1058], eax;
	__asm        cmp    dword ptr [ebp-0x1058], 0;
	__asm        je     _T676;

	__asm        mov    ecx, [ebp-0x1058];
	__asm        call   basic_string_ref<char>::delete_ptr;
	__asm        jmp    _T65d;
_T65d:
	__asm        mov    eax, [ebp-0x1058];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
	__asm        jmp    _T671;
_T671:
	__asm        jmp    _T676;
_T676:
	__asm        jmp    _T67b;
_T67b:
	__asm        mov    eax, [ebp-0x1048];
	__asm        mov    ecx, sCommand;
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T6ce;
_T68c:
	__asm        cmp    dword ptr [ebp-0x106C], 0;
	__asm        je     _T6ce;

	__asm        jmp    _T69e;
_T69e:
	__asm        mov    eax, sCommand;
	__asm        mov    eax, [eax+4];
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x1050], eax;
	__asm        mov    eax, [ebp-0x106C];
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x1004];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x1050];
	__asm        push   eax;
	__asm        call   memcpy;
	__asm        add    esp, 0xC;
	__asm        jmp    _T6ce;
_T6ce:
	__asm        mov    eax, [ebp-0x106C];
	__asm        mov    ecx, sCommand;
	__asm        mov    ecx, [ecx+4];
	__asm        mov    [ecx+4], eax;
	__asm        jmp    _T6e2;
_T6e2:
	__asm        jmp    _T6e7;
_T6e7:
	__asm        jmp    _T6ec;
// LINE 2048:
_T6ec:
	return;
}

// FUNCTION: COPTER_D 0x0040d24a
void ControlDisplayWindow::AppendKeysString(/*packed*/ class basic_string<char>& sKeys, long lKey, long lModifiers, int32_t nKeyIndex) {
	/*bp-0x8*/   /*packed*/ class basic_string<char> sKey; // 0x8 bytes
	/*bp-0x10*/  /*packed*/ class basic_string<char> sSeparator; // 0x8 bytes
	/*bp-0x14*/  int32_t bAtLeastOneModifierFoundAlready;
	/*bp-0x18*/  uint32_t nFullStringID;
	/*bp-0x20*/  /*packed*/ class basic_string<char> sModifier; // 0x8 bytes

// LINE 2055:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x2C], eax;
	__asm        cmp    dword ptr [ebp-0x2C], 0;
	__asm        je     _T3d;

	__asm        mov    ecx, [ebp-0x2C];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    sSeparator.reference, eax;
	__asm        jmp    _T44;
_T3d:
	sSeparator.reference = 0x0;
_T44:
	__asm        mov    sSeparator.c_str_ptr, 0;
	__asm        jmp    _T50;
// LINE 2056:
_T50:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x30], eax;
	__asm        cmp    dword ptr [ebp-0x30], 0;
	__asm        je     _T77;

	__asm        mov    ecx, [ebp-0x30];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    sModifier.reference, eax;
	__asm        jmp    _T7e;
_T77:
	sModifier.reference = 0x0;
_T7e:
	__asm        mov    sModifier.c_str_ptr, 0;
	__asm        jmp    _T8a;
// LINE 2057:
_T8a:
	__asm        push   0x10;
	__asm        call   operator new;
	__asm        add    esp, 4;
	__asm        mov    [ebp-0x34], eax;
	__asm        cmp    dword ptr [ebp-0x34], 0;
	__asm        je     _Tb1;

	__asm        mov    ecx, [ebp-0x34];
	__asm        call   basic_string_ref<char>::basic_string_ref<char>;
	__asm        mov    sKey.reference, eax;
	__asm        jmp    _Tb8;
_Tb1:
	sKey.reference = 0x0;
_Tb8:
	__asm        mov    sKey.c_str_ptr, 0;
	__asm        jmp    _Tc4;
// LINE 2061:
_Tc4:
	__asm        cmp    nKeyIndex, 0;
	__asm        je     _T208;
// LINE 2062:
	__asm        push   0;
	__asm        push   0xE1;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 2063:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x104C];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1050], eax;
	__asm        cmp    dword ptr [ebp-0x1050], 0;
	__asm        jne    _T18d;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x104C];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x1050], eax;
	__asm        jmp    _T13f;
_T13f:
	__asm        lea    eax, [ebp-0x104C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x104C];
	__asm        push   eax;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T163;
_T163:
	__asm        jmp    _T168;
_T168:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T188;
_T188:
	__asm        jmp    _T1bb;
_T18d:
	__asm        jmp    _T192;
_T192:
	__asm        lea    eax, [ebp-0x104C];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x104C];
	__asm        push   eax;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T1b6;
_T1b6:
	__asm        jmp    _T1bb;
// LINE 2064:
_T1bb:
	__asm        jmp    _T1c0;
_T1c0:
	__asm        jmp    _T1c5;
_T1c5:
	__asm        mov    eax, sSeparator.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T1e4;

	__asm        mov    eax, sSeparator.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T1f0;

	__asm        jmp    _T1f0;
_T1e4:
	__asm        mov    dword ptr [ebp-0x24], 0;
	__asm        jmp    _T1f0;
_T1f0:
	__asm        mov    eax, sSeparator.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x24];
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T208;
// LINE 2068:
_T208:
	__asm        push   0;
	__asm        push   0xE2;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 2069:
	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x2050];
	__asm        push   eax;
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x2054], eax;
	__asm        cmp    dword ptr [ebp-0x2054], 0;
	__asm        jne    _T2c7;

	__asm        push   0xFFF;
	__asm        lea    eax, [ebp-0x2050];
	__asm        push   eax;
	__asm        mov    ecx, 0x3E8;
	__asm        mov    eax, nFullStringID;
	__asm        sub    edx, edx;
	__asm        div    ecx;
	__asm        push   edx;
	__asm        mov    eax, _ghWindowsInstance;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C38B4];
	__asm        mov    [ebp-0x2054], eax;
	__asm        jmp    _T279;
_T279:
	__asm        lea    eax, [ebp-0x2050];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x2050];
	__asm        push   eax;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T29d;
_T29d:
	__asm        jmp    _T2a2;
_T2a2:
	__asm        push   0x597200;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        push   0x597200;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T2c2;
_T2c2:
	__asm        jmp    _T2f5;
_T2c7:
	__asm        jmp    _T2cc;
_T2cc:
	__asm        lea    eax, [ebp-0x2050];
	__asm        push   eax;
	__asm        call   strlen;
	__asm        add    esp, 4;
	__asm        push   eax;
	__asm        lea    eax, [ebp-0x2050];
	__asm        push   eax;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::assign_str;
	__asm        jmp    _T2f0;
_T2f0:
	__asm        jmp    _T2f5;
// LINE 2070:
_T2f5:
	bAtLeastOneModifierFoundAlready = 0x0;
// LINE 2072:
	__asm        test   reinterpret_cast<uint8_t>(lModifiers), 2;
	__asm        je     _T37c;
// LINE 2073:
	bAtLeastOneModifierFoundAlready = 0x1;
// LINE 2074:
	__asm        push   0;
	__asm        push   0xE3;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 2075:
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        lea    eax, sModifier.c_str_ptr;
	__asm        push   eax;
	__asm        call   SetStringFromStringResource;
	__asm        add    esp, 8;
// LINE 2076:
	__asm        jmp    _T334;
_T334:
	__asm        jmp    _T339;
_T339:
	__asm        mov    eax, sModifier.reference;
	__asm        cmp    dword ptr [eax+4], 0;
	__asm        je     _T358;

	__asm        mov    eax, sModifier.reference;
	__asm        mov    eax, [eax];
	__asm        mov    [ebp-0x28], eax;
	__asm        jmp    _T364;

	__asm        jmp    _T364;
_T358:
	__asm        mov    dword ptr [ebp-0x28], 0;
	__asm        jmp    _T364;
_T364:
	__asm        mov    eax, sModifier.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        mov    eax, [ebp-0x28];
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T37c;
// LINE 2079:
_T37c:
	__asm        test   reinterpret_cast<uint8_t>(lModifiers), 4;
	__asm        je     _T3fd;
// LINE 2080:
	__asm        cmp    bAtLeastOneModifierFoundAlready, 0;
	__asm        je     _T3b2;
// LINE 2081:
	__asm        jmp    _T395;
_T395:
	__asm        mov    eax, sSeparator.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T3b2;
// LINE 2082:
_T3b2:
	bAtLeastOneModifierFoundAlready = 0x1;
// LINE 2083:
	__asm        push   0;
	__asm        push   0xE4;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 2084:
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        lea    eax, sModifier.c_str_ptr;
	__asm        push   eax;
	__asm        call   SetStringFromStringResource;
	__asm        add    esp, 8;
// LINE 2085:
	__asm        jmp    _T3e0;
_T3e0:
	__asm        mov    eax, sModifier.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        lea    ecx, sModifier.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T3fd;
// LINE 2088:
_T3fd:
	__asm        test   reinterpret_cast<uint8_t>(lModifiers), 1;
	__asm        je     _T47e;
// LINE 2089:
	__asm        cmp    bAtLeastOneModifierFoundAlready, 0;
	__asm        je     _T433;
// LINE 2090:
	__asm        jmp    _T416;
_T416:
	__asm        mov    eax, sSeparator.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T433;
// LINE 2091:
_T433:
	bAtLeastOneModifierFoundAlready = 0x1;
// LINE 2092:
	__asm        push   0;
	__asm        push   0xE5;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 2093:
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        lea    eax, sModifier.c_str_ptr;
	__asm        push   eax;
	__asm        call   SetStringFromStringResource;
	__asm        add    esp, 8;
// LINE 2094:
	__asm        jmp    _T461;
_T461:
	__asm        mov    eax, sModifier.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        lea    ecx, sModifier.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T47e;
// LINE 2097:
_T47e:
	__asm        cmp    bAtLeastOneModifierFoundAlready, 0;
	__asm        je     _T4aa;
// LINE 2098:
	__asm        jmp    _T48d;
_T48d:
	__asm        mov    eax, sSeparator.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T4aa;
// LINE 2099:
_T4aa:
	__asm        push   0;
	__asm        mov    eax, lKey;
	__asm        add    eax, 0x2BC;
	__asm        push   eax;
	__asm        call   LanguageManager::GetFullStringID;
	__asm        add    esp, 8;
	__asm        mov    nFullStringID, eax;
// LINE 2100:
	__asm        mov    eax, nFullStringID;
	__asm        push   eax;
	__asm        lea    eax, sKey.c_str_ptr;
	__asm        push   eax;
	__asm        call   SetStringFromStringResource;
	__asm        add    esp, 8;
// LINE 2101:
	__asm        jmp    _T4d5;
_T4d5:
	__asm        mov    eax, sKey.reference;
	__asm        mov    eax, [eax+4];
	__asm        push   eax;
	__asm        lea    ecx, sKey.c_str_ptr;
	__asm        call   basic_string<char>::data;
	__asm        push   eax;
	__asm        mov    ecx, sKeys;
	__asm        call   basic_string<char>::append_str;
	__asm        jmp    _T4f2;
// LINE 2102:
_T4f2:
	__asm        lea    ecx, sKey.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    sKey.c_str_ptr, 0;
	__asm        je     _T51c;

	__asm        mov    eax, sKey.c_str_ptr;
	__asm        mov    [ebp-0x38], eax;
	__asm        mov    eax, [ebp-0x38];
	__asm        mov    [ebp-0x3C], eax;
	__asm        mov    eax, [ebp-0x3C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T51c:
	__asm        jmp    _T521;
_T521:
	__asm        lea    ecx, sModifier.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    sModifier.c_str_ptr, 0;
	__asm        je     _T54b;

	__asm        mov    eax, sModifier.c_str_ptr;
	__asm        mov    [ebp-0x40], eax;
	__asm        mov    eax, [ebp-0x40];
	__asm        mov    [ebp-0x44], eax;
	__asm        mov    eax, [ebp-0x44];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T54b:
	__asm        jmp    _T550;
_T550:
	__asm        lea    ecx, sSeparator.c_str_ptr;
	__asm        call   basic_string<char>::delete_ref;
	__asm        cmp    sSeparator.c_str_ptr, 0;
	__asm        je     _T57a;

	__asm        mov    eax, sSeparator.c_str_ptr;
	__asm        mov    [ebp-0x48], eax;
	__asm        mov    eax, [ebp-0x48];
	__asm        mov    [ebp-0x4C], eax;
	__asm        mov    eax, [ebp-0x4C];
	__asm        push   eax;
	__asm        call   operator delete;
	__asm        add    esp, 4;
_T57a:
	__asm        jmp    _T57f;
_T57f:
	return;
}



// Contribution: 1:0000c7e0-0000c800 Module: 75, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0000c810-0000c830 Module: 75, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0000c840-0000c8a6 Module: 75, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0000c8b0-0000c91b Module: 75, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0000c920-0000cac7 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040d920
// list<KeyColors>::add_new_buffer



// Contribution: 1:0000cad0-0000cb08 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0040dad0
// KeyboardWindow::`scalar deleting destructor'



// Contribution: 1:0000cb10-0000cb4b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040db10
// list<HotSpot>::iterator::operator++



// Contribution: 1:0000cb50-0000cc16 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040db50
// list<HotSpot>::erase



// Contribution: 1:0000cc20-0000cc79 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040dc20
// list<KeyColors>::erase



// Contribution: 1:0000cc80-0000cc9d Module: 75, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0000cca0-0000ccd8 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0040dca0
// JoystickWindow::`scalar deleting destructor'



// Contribution: 1:0000cce0-0000ce87 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040dce0
// list<Shortcut>::add_new_buffer



// Contribution: 1:0000ce90-0000d37a Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0040de90
// UserInputWindow::`scalar deleting destructor'



// Contribution: 1:0000d380-0000d3bb Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040e380
// list<Shortcut>::iterator::operator++



// Contribution: 1:0000d3c0-0000d419 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040e3c0
// list<Shortcut>::erase



// Contribution: 1:0000d420-0000d45b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040e420
// list<StringIDAssociation>::iterator::operator++



// Contribution: 1:0000d460-0000d595 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040e460
// list<StringIDAssociation>::erase



// Contribution: 1:0000d5a0-0000d9f1 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040e5a0
// list<StringIDAssociation>::insert



// Contribution: 1:0000da00-0000dc15 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040ea00
// list<StringIDAssociation>::get_node



// Contribution: 1:0000dc20-0000dc5d Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0040ec20
// ControlDisplayWindow::`scalar deleting destructor'



// Contribution: 1:0000dc60-0000dd37 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040ec60
// rb_tree<long,long,ident<long,long>,less<long>>::const_iterator::operator++



// Contribution: 1:0000dd40-0000e303 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040ed40
// rb_tree<long,long,ident<long,long>,less<long>>::init



// Contribution: 1:0000e310-0000e62b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040f310
// rb_tree<long,long,ident<long,long>,less<long>>::~rb_tree<long,long,ident<long,long>,less<long>>



// Contribution: 1:0000e630-0000e707 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040f630
// rb_tree<long,long,ident<long,long>,less<long>>::iterator::operator++



// Contribution: 1:0000e710-0000ee53 Module: 75, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0000ee60-0000ee7d Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040fe60
// basic_string<char>::point



// Contribution: 1:0000ee80-0000ee9e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040fe80
// basic_string<char>::len



// Contribution: 1:0000eea0-0000eebe Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040fea0
// basic_string<char>::ref_count



// Contribution: 1:0000eec0-0000eed6 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040fec0
// basic_string<char>::eos



// Contribution: 1:0000eee0-0000f129 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0040fee0
// basic_string<char>::assign_str



// Contribution: 1:0000f130-0000f3c1 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00410130
// basic_string<char>::append_str



// Contribution: 1:0000f3d0-0000f7ad Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004103d0
// basic_string<char>::insert_str



// Contribution: 1:0000f7b0-0000fc3a Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004107b0
// basic_string<char>::replace_str



// Contribution: 1:0000fc40-0000fd77 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00410c40
// basic_string<char>::compare_str



// Contribution: 1:0000fd80-0000ff88 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00410d80
// basic_string<char>::find_str



// Contribution: 1:0000ff90-00010267 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00410f90
// basic_string<char>::rfind_str



// Contribution: 1:00010270-00010383 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411270
// basic_string<char>::find_first_of_str



// Contribution: 1:00010390-000104ce Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411390
// basic_string<char>::find_last_of_str



// Contribution: 1:000104d0-000105cc Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004114d0
// basic_string<char>::find_first_not_of_str



// Contribution: 1:000105d0-00010715 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004115d0
// basic_string<char>::find_last_not_of_str



// Contribution: 1:00010720-00010855 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411720
// basic_string<char>::basic_string<char>



// Contribution: 1:00010860-00010982 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411860
// basic_string<char>::basic_string<char>



// Contribution: 1:00010990-00010a6d Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411990
// basic_string<char>::basic_string<char>



// Contribution: 1:00010a70-00010b7b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411a70
// basic_string<char>::basic_string<char>



// Contribution: 1:00010b80-00010d50 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411b80
// basic_string<char>::basic_string<char>



// Contribution: 1:00010d60-00010ed7 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411d60
// basic_string<char>::basic_string<char>



// Contribution: 1:00010ee0-00010f5e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411ee0
// basic_string<char>::basic_string<char>



// Contribution: 1:00010f60-0001107f Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00411f60
// basic_string<char>::basic_string<char>



// Contribution: 1:00011080-00011121 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412080
// basic_string<char>::delete_ref



// Contribution: 1:00011130-000111fc Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412130
// basic_string<char>::~basic_string<char>



// Contribution: 1:00011200-000113ff Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412200
// basic_string<char>::operator=



// Contribution: 1:00011400-00011665 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412400
// basic_string<char>::operator=



// Contribution: 1:00011670-00011849 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412670
// basic_string<char>::operator=



// Contribution: 1:00011850-00011abf Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412850
// basic_string<char>::operator+=



// Contribution: 1:00011ac0-00011d6d Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412ac0
// basic_string<char>::operator+=



// Contribution: 1:00011d70-00012050 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00412d70
// basic_string<char>::operator+=



// Contribution: 1:00012060-0001230b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00413060
// basic_string<char>::append



// Contribution: 1:00012310-000125bd Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00413310
// basic_string<char>::append



// Contribution: 1:000125c0-00012859 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004135c0
// basic_string<char>::append



// Contribution: 1:00012860-00012bb4 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00413860
// basic_string<char>::append



// Contribution: 1:00012bc0-00012e30 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00413bc0
// basic_string<char>::assign



// Contribution: 1:00012e40-000130a5 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00413e40
// basic_string<char>::assign



// Contribution: 1:000130b0-00013301 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004140b0
// basic_string<char>::assign



// Contribution: 1:00013310-000136f6 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00414310
// basic_string<char>::assign



// Contribution: 1:00013700-00013b2c Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00414700
// basic_string<char>::insert



// Contribution: 1:00013b30-00013f29 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00414b30
// basic_string<char>::insert



// Contribution: 1:00013f30-00014315 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00414f30
// basic_string<char>::insert



// Contribution: 1:00014320-000147c0 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00415320
// basic_string<char>::insert



// Contribution: 1:000147d0-00014b67 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004157d0
// basic_string<char>::remove



// Contribution: 1:00014b70-000155a3 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00415b70
// basic_string<char>::replace



// Contribution: 1:000155b0-00015a8f Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004165b0
// basic_string<char>::replace



// Contribution: 1:00015a90-00015f5b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00416a90
// basic_string<char>::replace



// Contribution: 1:00015f60-000164e6 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00416f60
// basic_string<char>::replace



// Contribution: 1:000164f0-00016590 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004174f0
// basic_string<char>::get_at



// Contribution: 1:000165a0-00016826 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004175a0
// basic_string<char>::put_at



// Contribution: 1:00016830-00016a57 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00417830
// basic_string<char>::operator[]



// Contribution: 1:00016a60-00016ada Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00417a60
// basic_string<char>::operator[]



// Contribution: 1:00016ae0-00016bf3 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00417ae0
// basic_string<char>::c_str



// Contribution: 1:00016c00-00016c3e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00417c00
// basic_string<char>::data



// Contribution: 1:00016c40-00016c5e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00417c40
// basic_string<char>::length



// Contribution: 1:00016c60-00016ef7 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00417c60
// basic_string<char>::resize



// Contribution: 1:00016f00-00017184 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00417f00
// basic_string<char>::resize



// Contribution: 1:00017190-0001738b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00418190
// basic_string<char>::reserve



// Contribution: 1:00017390-000173ae Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00418390
// basic_string<char>::reserve



// Contribution: 1:000173b0-000174b3 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004183b0
// basic_string<char>::copy



// Contribution: 1:000174c0-0001757f Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004184c0
// basic_string<char>::find



// Contribution: 1:00017580-000177ad Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00418580
// basic_string<char>::find



// Contribution: 1:000177b0-000179c9 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004187b0
// basic_string<char>::find



// Contribution: 1:000179d0-00017c30 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004189d0
// basic_string<char>::find



// Contribution: 1:00017c40-00017da0 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00418c40
// basic_string<char>::rfind



// Contribution: 1:00017db0-000180ac Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00418db0
// basic_string<char>::rfind



// Contribution: 1:000180b0-00018398 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004190b0
// basic_string<char>::rfind



// Contribution: 1:000183a0-000186cf Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004193a0
// basic_string<char>::rfind



// Contribution: 1:000186d0-000187a3 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004196d0
// basic_string<char>::find_first_of



// Contribution: 1:000187b0-000188dc Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004197b0
// basic_string<char>::find_first_of



// Contribution: 1:000188e0-000189f8 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x004198e0
// basic_string<char>::find_first_of



// Contribution: 1:00018a00-00018b5f Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00419a00
// basic_string<char>::find_first_of



// Contribution: 1:00018b60-00018cd5 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00419b60
// basic_string<char>::find_last_of



// Contribution: 1:00018ce0-00018e3a Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00419ce0
// basic_string<char>::find_last_of



// Contribution: 1:00018e40-00018f86 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00419e40
// basic_string<char>::find_last_of



// Contribution: 1:00018f90-00019123 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x00419f90
// basic_string<char>::find_last_of



// Contribution: 1:00019130-000191ef Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a130
// basic_string<char>::find_first_not_of



// Contribution: 1:000191f0-00019308 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a1f0
// basic_string<char>::find_first_not_of



// Contribution: 1:00019310-00019414 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a310
// basic_string<char>::find_first_not_of



// Contribution: 1:00019420-0001956b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a420
// basic_string<char>::find_first_not_of



// Contribution: 1:00019570-000196d0 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a570
// basic_string<char>::find_last_not_of



// Contribution: 1:000196e0-00019841 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a6e0
// basic_string<char>::find_last_not_of



// Contribution: 1:00019850-0001999d Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a850
// basic_string<char>::find_last_not_of



// Contribution: 1:000199a0-00019b3a Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041a9a0
// basic_string<char>::find_last_not_of



// Contribution: 1:00019b40-0001a034 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041ab40
// basic_string<char>::substr



// Contribution: 1:0001a040-0001a241 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b040
// basic_string<char>::compare



// Contribution: 1:0001a250-0001a3c5 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b250
// basic_string<char>::compare



// Contribution: 1:0001a3d0-0001a56d Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b3d0
// basic_string<char>::compare



// Contribution: 1:0001a570-0001a73d Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b570
// basic_string<char>::compare



// Contribution: 1:0001a740-0001a7a8 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b740
// allocate



// Contribution: 1:0001a7b0-0001a81b Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b7b0
// allocate



// Contribution: 1:0001a820-0001a888 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b820
// allocate



// Contribution: 1:0001a890-0001a8f8 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b890
// allocate



// Contribution: 1:0001a900-0001a968 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b900
// allocate



// Contribution: 1:0001a970-0001a9df Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b970
// allocate



// Contribution: 1:0001a9e0-0001abcd Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041b9e0
// construct



// Contribution: 1:0001abd0-0001ac5e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041bbd0
// list<HotSpot>::deallocate_buffers



// Contribution: 1:0001ac60-0001acee Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041bc60
// list<Shortcut>::deallocate_buffers



// Contribution: 1:0001acf0-0001ad7e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041bcf0
// list<KeyColors>::deallocate_buffers



// Contribution: 1:0001ad80-0001ae0e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041bd80
// list<StringIDAssociation>::deallocate_buffers



// Contribution: 1:0001ae10-0001b69f Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041be10
// rb_tree<long,long,ident<long,long>,less<long>>::insert



// Contribution: 1:0001b6a0-0001b8b6 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041c6a0
// rb_tree<long,long,ident<long,long>,less<long>>::get_node



// Contribution: 1:0001b8c0-0001b9cb Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041c8c0
// rb_tree<long,long,ident<long,long>,less<long>>::iterator::operator--



// Contribution: 1:0001b9d0-0001cd6c Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041c9d0
// rb_tree<long,long,ident<long,long>,less<long>>::erase



// Contribution: 1:0001cd70-0001cde4 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0041dd70
// basic_string_ref<char>::`scalar deleting destructor'



// Contribution: 1:0001cdf0-0001cee1 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0041ddf0
// StringIDAssociation::`scalar deleting destructor'



// Contribution: 1:0001cef0-0001cfdc Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0041def0
// basic_string<char>::`scalar deleting destructor'



// Contribution: 1:0001cfe0-0001d080 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041dfe0
// basic_string_ref<char>::basic_string_ref<char>



// Contribution: 1:0001d090-0001d15e Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041e090
// basic_string_ref<char>::basic_string_ref<char>



// Contribution: 1:0001d160-0001d1fc Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041e160
// basic_string_ref<char>::basic_string_ref<char>



// Contribution: 1:0001d200-0001d2cb Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041e200
// basic_string_ref<char>::basic_string_ref<char>



// Contribution: 1:0001d2d0-0001d311 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041e2d0
// basic_string_ref<char>::basic_string_ref<char>



// Contribution: 1:0001d320-0001e162 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041e320
// rb_tree<long,long,ident<long,long>,less<long>>::__insert



// Contribution: 1:0001e170-0001e1e9 Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041f170
// rb_tree<long,long,ident<long,long>,less<long>>::__erase



// Contribution: 1:0001e1f0-0001e34c Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041f1f0
// rb_tree<long,long,ident<long,long>,less<long>>::rotate_left



// Contribution: 1:0001e350-0001e4ac Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041f350
// rb_tree<long,long,ident<long,long>,less<long>>::rotate_right



// Contribution: 1:0001e4b0-0001e4ff Module: 75, 16 byte alignment, code, (comdat), execute, read, 
// LIBRARY: MSVC 0x0041f4b0
// basic_string_ref<char>::delete_ptr



// Contribution: 2:00000058-0000013b Module: 75, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for KeyboardWindow @ 0x0058f058
//   00: GraphicWindowOwner::DoMessage @ 0x004a17be
//   01: KeyboardWindow::Initialize @ 0x0040200d
//   02: GraphicWindow::CreateAllImages @ 0x004a6dc5
//   03: GraphicWindow::DestroyAllImages @ 0x004a6ea7
//   04: KeyboardWindow::CreateImage @ 0x00402108
//   05: KeyboardWindow::DestroyImage @ 0x00402659
//   06: KeyboardWindow::ComposeSelf @ 0x00403508
//   07: GraphicWindow::SetImageToDrawOnto @ 0x004a6bcd
//   08: GraphicWindow::SetAllImagesToDrawOnto @ 0x004a6cf0
//   09: GraphicWindow::SetTransparentColor @ 0x004a4d1c
//   10: GraphicWindow::SetBorderDrawing @ 0x0040d810
//   11: GraphicWindow::DrawBorder @ 0x004a6f7c
//   12: GraphicWindow::SetChanged @ 0x004a50e0
//   13: GraphicWindow::MoveWindow @ 0x004a4d7e
//   14: GraphicWindow::SetWidthAndHeight @ 0x004a4df1
//   15: GraphicWindow::CenterWindow @ 0x004a4ea8
//   16: GraphicWindow::CenterWindow @ 0x004a4e55
//   17: GraphicWindow::SetWindowPosition @ 0x0040d840
//   18: GraphicWindow::SetWindowTitle @ 0x004a51d0
//   19: GraphicWindow::InvalidateAllOverlaps @ 0x004a6256
//   20: GraphicWindow::InvalidateAllChildren @ 0x004a6399
//   21: GraphicWindow::AddChild @ 0x004a53be
//   22: GraphicWindow::DeleteChild @ 0x004a5837
//   23: GraphicWindow::DeleteChild @ 0x004a569a
//   24: GraphicWindow::RemoveChild @ 0x004a5a11
//   25: GraphicWindow::DeleteAllChildren @ 0x004a5b58
//   26: GraphicWindow::RemoveAllChildren @ 0x004a5cd8
//   27: GraphicWindow::DeleteSelf @ 0x004a603c
//   28: GraphicWindow::RemoveSelf @ 0x004a606b
//   29: GraphicWindow::FindChild @ 0x004a5dd1
//   30: GraphicWindow::SetParent @ 0x0040d7e0
//   31: GraphicWindow::CanWeRespondToMessage @ 0x004a786b
//   32: GraphicWindow::DoCharacter @ 0x004a6568
//   33: KeyboardWindow::DoKeyDown @ 0x00404485
//   34: KeyboardWindow::DoKeyUp @ 0x004044e7
//   35: KeyboardWindow::DoCursorDown @ 0x00404549
//   36: KeyboardWindow::DoCursorUp @ 0x004045cb
//   37: KeyboardWindow::DoCursorMove @ 0x00404641
//   38: GraphicWindow::CaptureCursorStart @ 0x004a6607
//   39: GraphicWindow::CaptureCursorEnd @ 0x004a6640
//   40: GraphicWindow::WindowToScreenCoordinates @ 0x004a667d
//   41: GraphicWindow::ScreenToWindowCoordinates @ 0x004a66cc
//   42: GraphicWindow::IsPointInWindow @ 0x0040d8b0
//   43: KeyboardWindow::`scalar deleting destructor' @ 0x0040dad0
//   44: GraphicWindow::GetImage @ 0x004a6720
//   45: GraphicWindow::GetImagePath @ 0x004a673c
//   46: GraphicWindow::DrawChildren @ 0x004a6180
//   47: GraphicWindow::DrawSelf @ 0x004a6168
//   48: KeyboardWindow::DoesWindowNeedUpdating @ 0x00404400
//   49: KeyboardWindow::DoesKeyExistOnKeyboard @ 0x00402e31
//   50: KeyboardWindow::DrawKeyColorsOnKeyboard @ 0x0040364f
//   51: KeyboardWindow::DrawCharactersOnKeyboard @ 0x00403a8f
//   52: KeyboardWindow::DrawLightsOnKeyboard @ 0x004042e5
//   53: KeyboardWindow::DoesKeyRequireTextDraw @ 0x004031a1
//   54: KeyboardWindow::DoesPositionHitKey @ 0x00402fcd
//   55: KeyboardWindow::ConvertKeyToString @ 0x00402725
//   56: KeyboardWindow::GetRectOfNonTextImage @ 0x00403247
//   57 entries



// Contribution: 2:00000140-00000227 Module: 75, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for JoystickWindow @ 0x0058f140
//   00: GraphicWindowOwner::DoMessage @ 0x004a17be
//   01: JoystickWindow::Initialize @ 0x00404c0d
//   02: GraphicWindow::CreateAllImages @ 0x004a6dc5
//   03: GraphicWindow::DestroyAllImages @ 0x004a6ea7
//   04: JoystickWindow::CreateImage @ 0x00404c35
//   05: JoystickWindow::DestroyImage @ 0x00405383
//   06: JoystickWindow::ComposeSelf @ 0x004054fd
//   07: GraphicWindow::SetImageToDrawOnto @ 0x004a6bcd
//   08: GraphicWindow::SetAllImagesToDrawOnto @ 0x004a6cf0
//   09: GraphicWindow::SetTransparentColor @ 0x004a4d1c
//   10: GraphicWindow::SetBorderDrawing @ 0x0040d810
//   11: GraphicWindow::DrawBorder @ 0x004a6f7c
//   12: GraphicWindow::SetChanged @ 0x004a50e0
//   13: GraphicWindow::MoveWindow @ 0x004a4d7e
//   14: GraphicWindow::SetWidthAndHeight @ 0x004a4df1
//   15: GraphicWindow::CenterWindow @ 0x004a4ea8
//   16: GraphicWindow::CenterWindow @ 0x004a4e55
//   17: GraphicWindow::SetWindowPosition @ 0x0040d840
//   18: GraphicWindow::SetWindowTitle @ 0x004a51d0
//   19: GraphicWindow::InvalidateAllOverlaps @ 0x004a6256
//   20: GraphicWindow::InvalidateAllChildren @ 0x004a6399
//   21: GraphicWindow::AddChild @ 0x004a53be
//   22: GraphicWindow::DeleteChild @ 0x004a5837
//   23: GraphicWindow::DeleteChild @ 0x004a569a
//   24: GraphicWindow::RemoveChild @ 0x004a5a11
//   25: GraphicWindow::DeleteAllChildren @ 0x004a5b58
//   26: GraphicWindow::RemoveAllChildren @ 0x004a5cd8
//   27: GraphicWindow::DeleteSelf @ 0x004a603c
//   28: GraphicWindow::RemoveSelf @ 0x004a606b
//   29: GraphicWindow::FindChild @ 0x004a5dd1
//   30: GraphicWindow::SetParent @ 0x0040d7e0
//   31: GraphicWindow::CanWeRespondToMessage @ 0x004a786b
//   32: GraphicWindow::DoCharacter @ 0x004a6568
//   33: GraphicWindow::DoKeyDown @ 0x004a6582
//   34: GraphicWindow::DoKeyUp @ 0x004a659c
//   35: JoystickWindow::DoCursorDown @ 0x00405db8
//   36: JoystickWindow::DoCursorUp @ 0x00405e34
//   37: JoystickWindow::DoCursorMove @ 0x00405e51
//   38: GraphicWindow::CaptureCursorStart @ 0x004a6607
//   39: GraphicWindow::CaptureCursorEnd @ 0x004a6640
//   40: GraphicWindow::WindowToScreenCoordinates @ 0x004a667d
//   41: GraphicWindow::ScreenToWindowCoordinates @ 0x004a66cc
//   42: GraphicWindow::IsPointInWindow @ 0x0040d8b0
//   43: JoystickWindow::`scalar deleting destructor' @ 0x0040dca0
//   44: GraphicWindow::GetImage @ 0x004a6720
//   45: GraphicWindow::GetImagePath @ 0x004a673c
//   46: GraphicWindow::DrawChildren @ 0x004a6180
//   47: GraphicWindow::DrawSelf @ 0x004a6168
//   48: JoystickWindow::DoesWindowNeedUpdating @ 0x00405d58
//   49: JoystickWindow::SetCurrentJoystick @ 0x00405d73
//   50: JoystickWindow::GetHandleImageToUse @ 0x00405c7a
//   51: JoystickWindow::DrawCurrentJoystick @ 0x004055ec
//   52: JoystickWindow::DrawButton @ 0x004056b8
//   53: JoystickWindow::DrawSlider @ 0x00405781
//   54: JoystickWindow::DrawHandle @ 0x00405867
//   55: JoystickWindow::GetNewJoystickControlStates @ 0x00405ca4
//   56: JoystickWindow::DoesPositionHitKey @ 0x00405e6e
//   57: JoystickWindow::GetSourceHandleBaseRects @ 0x004059eb
//   58 entries



// Contribution: 2:00000228-000002fb Module: 75, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for UserInputWindow @ 0x0058f228
//   00: UserInputWindow::DoMessage @ 0x00407db1
//   01: UserInputWindow::Initialize @ 0x004069bb
//   02: GraphicWindow::CreateAllImages @ 0x004a6dc5
//   03: GraphicWindow::DestroyAllImages @ 0x004a6ea7
//   04: GraphicWindow::CreateImage @ 0x004a4aa0
//   05: GraphicWindow::DestroyImage @ 0x004a4cab
//   06: GraphicWindow::ComposeSelf @ 0x004a60a3
//   07: GraphicWindow::SetImageToDrawOnto @ 0x004a6bcd
//   08: GraphicWindow::SetAllImagesToDrawOnto @ 0x004a6cf0
//   09: GraphicWindow::SetTransparentColor @ 0x004a4d1c
//   10: GraphicWindow::SetBorderDrawing @ 0x0040d810
//   11: GraphicWindow::DrawBorder @ 0x004a6f7c
//   12: GraphicWindow::SetChanged @ 0x004a50e0
//   13: GraphicWindow::MoveWindow @ 0x004a4d7e
//   14: GraphicWindow::SetWidthAndHeight @ 0x004a4df1
//   15: GraphicWindow::CenterWindow @ 0x004a4ea8
//   16: GraphicWindow::CenterWindow @ 0x004a4e55
//   17: GraphicWindow::SetWindowPosition @ 0x0040d840
//   18: GraphicWindow::SetWindowTitle @ 0x004a51d0
//   19: GraphicWindow::InvalidateAllOverlaps @ 0x004a6256
//   20: GraphicWindow::InvalidateAllChildren @ 0x004a6399
//   21: GraphicWindow::AddChild @ 0x004a53be
//   22: GraphicWindow::DeleteChild @ 0x004a5837
//   23: GraphicWindow::DeleteChild @ 0x004a569a
//   24: GraphicWindow::RemoveChild @ 0x004a5a11
//   25: GraphicWindow::DeleteAllChildren @ 0x004a5b58
//   26: GraphicWindow::RemoveAllChildren @ 0x004a5cd8
//   27: GraphicWindow::DeleteSelf @ 0x004a603c
//   28: GraphicWindow::RemoveSelf @ 0x004a606b
//   29: GraphicWindow::FindChild @ 0x004a5dd1
//   30: GraphicWindow::SetParent @ 0x0040d7e0
//   31: GraphicWindow::CanWeRespondToMessage @ 0x004a786b
//   32: GraphicWindow::DoCharacter @ 0x004a6568
//   33: UserInputWindow::DoKeyDown @ 0x00407d47
//   34: GraphicWindow::DoKeyUp @ 0x004a659c
//   35: GraphicWindow::DoCursorDown @ 0x004a65b6
//   36: GraphicWindow::DoCursorUp @ 0x004a65d0
//   37: GraphicWindow::DoCursorMove @ 0x004a65ed
//   38: GraphicWindow::CaptureCursorStart @ 0x004a6607
//   39: GraphicWindow::CaptureCursorEnd @ 0x004a6640
//   40: GraphicWindow::WindowToScreenCoordinates @ 0x004a667d
//   41: GraphicWindow::ScreenToWindowCoordinates @ 0x004a66cc
//   42: GraphicWindow::IsPointInWindow @ 0x0040d8b0
//   43: UserInputWindow::`scalar deleting destructor' @ 0x0040de90
//   44: GraphicWindow::GetImage @ 0x004a6720
//   45: GraphicWindow::GetImagePath @ 0x004a673c
//   46: GraphicWindow::DrawChildren @ 0x004a6180
//   47: GraphicWindow::DrawSelf @ 0x004a6168
//   48: GraphicWindow::DoesWindowNeedUpdating @ 0x004a646b
//   49: UserInputWindow::SetupAllInputDevices @ 0x0040a508
//   50: UserInputWindow::SetupAllCommands @ 0x0040aa51
//   51: UserInputWindow::ReadShortcuts @ 0x0040ae7c
//   52: UserInputWindow::WriteShortcutsToPreferenceFile @ 0x0040b471
//   53 entries



// Contribution: 2:00000300-000003c7 Module: 75, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for ControlDisplayWindow @ 0x0058f300
//   00: ControlDisplayWindow::DoMessage @ 0x0040c352
//   01: ControlDisplayWindow::Initialize @ 0x0040b51a
//   02: GraphicWindow::CreateAllImages @ 0x004a6dc5
//   03: GraphicWindow::DestroyAllImages @ 0x004a6ea7
//   04: GraphicWindow::CreateImage @ 0x004a4aa0
//   05: GraphicWindow::DestroyImage @ 0x004a4cab
//   06: GraphicWindow::ComposeSelf @ 0x004a60a3
//   07: GraphicWindow::SetImageToDrawOnto @ 0x004a6bcd
//   08: GraphicWindow::SetAllImagesToDrawOnto @ 0x004a6cf0
//   09: GraphicWindow::SetTransparentColor @ 0x004a4d1c
//   10: GraphicWindow::SetBorderDrawing @ 0x0040d810
//   11: GraphicWindow::DrawBorder @ 0x004a6f7c
//   12: GraphicWindow::SetChanged @ 0x004a50e0
//   13: GraphicWindow::MoveWindow @ 0x004a4d7e
//   14: GraphicWindow::SetWidthAndHeight @ 0x004a4df1
//   15: GraphicWindow::CenterWindow @ 0x004a4ea8
//   16: GraphicWindow::CenterWindow @ 0x004a4e55
//   17: GraphicWindow::SetWindowPosition @ 0x0040d840
//   18: GraphicWindow::SetWindowTitle @ 0x004a51d0
//   19: GraphicWindow::InvalidateAllOverlaps @ 0x004a6256
//   20: GraphicWindow::InvalidateAllChildren @ 0x004a6399
//   21: GraphicWindow::AddChild @ 0x004a53be
//   22: GraphicWindow::DeleteChild @ 0x004a5837
//   23: GraphicWindow::DeleteChild @ 0x004a569a
//   24: GraphicWindow::RemoveChild @ 0x004a5a11
//   25: GraphicWindow::DeleteAllChildren @ 0x004a5b58
//   26: GraphicWindow::RemoveAllChildren @ 0x004a5cd8
//   27: GraphicWindow::DeleteSelf @ 0x004a603c
//   28: GraphicWindow::RemoveSelf @ 0x004a606b
//   29: GraphicWindow::FindChild @ 0x004a5dd1
//   30: GraphicWindow::SetParent @ 0x0040d7e0
//   31: GraphicWindow::CanWeRespondToMessage @ 0x004a786b
//   32: GraphicWindow::DoCharacter @ 0x004a6568
//   33: GraphicWindow::DoKeyDown @ 0x004a6582
//   34: GraphicWindow::DoKeyUp @ 0x004a659c
//   35: GraphicWindow::DoCursorDown @ 0x004a65b6
//   36: GraphicWindow::DoCursorUp @ 0x004a65d0
//   37: GraphicWindow::DoCursorMove @ 0x004a65ed
//   38: GraphicWindow::CaptureCursorStart @ 0x004a6607
//   39: GraphicWindow::CaptureCursorEnd @ 0x004a6640
//   40: GraphicWindow::WindowToScreenCoordinates @ 0x004a667d
//   41: GraphicWindow::ScreenToWindowCoordinates @ 0x004a66cc
//   42: GraphicWindow::IsPointInWindow @ 0x0040d8b0
//   43: ControlDisplayWindow::`scalar deleting destructor' @ 0x0040ec20
//   44: GraphicWindow::GetImage @ 0x004a6720
//   45: GraphicWindow::GetImagePath @ 0x004a673c
//   46: GraphicWindow::DrawChildren @ 0x004a6180
//   47: GraphicWindow::DrawSelf @ 0x004a6168
//   48: GraphicWindow::DoesWindowNeedUpdating @ 0x004a646b
//   49: ControlDisplayWindow::ReadShortcuts @ 0x0040c5b1
//   50 entries



// Contribution: 3:00000018-0000001f Module: 75, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x00597018
static void (*$S98)() = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x0059701c
static void (*$S101)() = { 0 /* todo */ };



// Contribution: 3:000000f0-000001a9 Module: 75, 4 byte alignment, initialized_data, read, write, 
// GLOBAL: COPTER_D 0x005970f0
char * SZ_KEYBOARD_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005970f4
char * SZ_KEYBOARD_LIGHT_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005970f8
char * SZ_KEYBOARD_NON_TEXT_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x005970fc
char * SZ_JOYSTICK_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00597100
char * SZ_JOYSTICK_BUTTON_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00597104
char * SZ_JOYSTICK_SLIDER_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00597108
char * SZ_JOYSTICK_HANDLE_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x0059710c
char * SZ_JOYSTICK_HANDLE_BASE_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00597110
char * SZ_USER_INPUT_WINDOW_IMAGE_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00597114
char * SZ_USER_INPUT_WINDOW_BACKGROUND_FILE_NAME = { 0 /* todo */ };

// GLOBAL: COPTER_D 0x00597118
char * SZ_CONTROL_DISPLAY_WINDOW_IMAGE_FILE_NAME = { 0 /* todo */ };



// Contribution: 3:000001ac-000001b9 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "out of memory"


// Contribution: 3:000001bc-000001bf Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971bc
uint32_t list<KeyColors>::number_of_lists = 0;



// Contribution: 3:000001c0-000001c3 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971c0
/*packed*/ struct list<KeyColors>::list_node *list<KeyColors>::last = { 0 /* todo */ };



// Contribution: 3:000001c4-000001c7 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971c4
/*packed*/ struct list<KeyColors>::list_node *list<KeyColors>::next_avail = { 0 /* todo */ };



// Contribution: 3:000001c8-000001cb Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971c8
/*packed*/ struct list<KeyColors>::list_node *list<KeyColors>::free_list = { 0 /* todo */ };



// Contribution: 3:000001cc-000001cf Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971cc
uint32_t list<HotSpot>::number_of_lists = 0;



// Contribution: 3:000001d0-000001d3 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971d0
/*packed*/ struct list<HotSpot>::list_node *list<HotSpot>::last = { 0 /* todo */ };



// Contribution: 3:000001d4-000001d7 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971d4
/*packed*/ struct list<HotSpot>::list_node *list<HotSpot>::next_avail = { 0 /* todo */ };



// Contribution: 3:000001d8-000001db Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971d8
/*packed*/ struct list<HotSpot>::list_node *list<HotSpot>::free_list = { 0 /* todo */ };



// Contribution: 3:000001dc-000001df Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971dc
/*packed*/ struct list<HotSpot>::list_node_buffer *list<HotSpot>::buffer_list = { 0 /* todo */ };



// Contribution: 3:000001e0-000001e3 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x005971e0
/*packed*/ struct list<KeyColors>::list_node_buffer *list<KeyColors>::buffer_list = { 0 /* todo */ };



// Contribution: 3:000001e4-000001fd Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "Length exception occurred"


// Contribution: 3:00000200-00000203 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "(!)"


// Contribution: 3:00000204-00000207 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597204
uint32_t list<StringIDAssociation>::number_of_lists = 0;



// Contribution: 3:00000208-0000020b Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597208
/*packed*/ struct list<StringIDAssociation>::list_node *list<StringIDAssociation>::last = { 0 /* todo */ };



// Contribution: 3:0000020c-0000020f Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x0059720c
/*packed*/ struct list<StringIDAssociation>::list_node *list<StringIDAssociation>::next_avail = { 0 /* todo */ };



// Contribution: 3:00000210-00000213 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597210
/*packed*/ struct list<StringIDAssociation>::list_node *list<StringIDAssociation>::free_list = { 0 /* todo */ };



// Contribution: 3:00000214-00000217 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597214
/*packed*/ struct list<StringIDAssociation>::list_node_buffer *list<StringIDAssociation>::buffer_list = { 0 /* todo */ };



// Contribution: 3:00000218-0000021b Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597218
uint32_t list<Shortcut>::number_of_lists = 0;



// Contribution: 3:0000021c-0000021f Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x0059721c
/*packed*/ struct list<Shortcut>::list_node *list<Shortcut>::last = { 0 /* todo */ };



// Contribution: 3:00000220-00000223 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597220
/*packed*/ struct list<Shortcut>::list_node *list<Shortcut>::next_avail = { 0 /* todo */ };



// Contribution: 3:00000224-00000227 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597224
/*packed*/ struct list<Shortcut>::list_node *list<Shortcut>::free_list = { 0 /* todo */ };



// Contribution: 3:00000228-0000022b Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597228
/*packed*/ struct list<Shortcut>::list_node_buffer *list<Shortcut>::buffer_list = { 0 /* todo */ };



// Contribution: 3:0000022c-0000024b Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// string literal: "Out of range exception occurred"


// Contribution: 3:0000024c-0000024f Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x0059724c
/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *rb_tree<long,long,ident<long,long>,less<long>>::NIL = { 0 /* todo */ };



// Contribution: 3:00000250-00000253 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597250
uint32_t rb_tree<long,long,ident<long,long>,less<long>>::number_of_trees = 0;



// Contribution: 3:00000254-00000257 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597254
/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *rb_tree<long,long,ident<long,long>,less<long>>::last = { 0 /* todo */ };



// Contribution: 3:00000258-0000025b Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597258
/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *rb_tree<long,long,ident<long,long>,less<long>>::next_avail = { 0 /* todo */ };



// Contribution: 3:0000025c-0000025f Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x0059725c
/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node *rb_tree<long,long,ident<long,long>,less<long>>::free_list = { 0 /* todo */ };



// Contribution: 3:00000260-00000263 Module: 75, 4 byte alignment, initialized_data, (comdat), read, write, 
// GLOBAL: COPTER_D 0x00597260
/*packed*/ struct rb_tree<long,long,ident<long,long>,less<long>>::rb_tree_node_buffer *rb_tree<long,long,ident<long,long>,less<long>>::buffer_list = { 0 /* todo */ };



// Contribution: 3:0002b790-0002b797 Module: 75, 4 byte alignment, uninitialized_data, read, write, 
// GLOBAL: COPTER_D 0x005c2790
/*packed*/ struct SparkalColor colorTextGamePaletteNormal;

// GLOBAL: COPTER_D 0x005c2794
/*packed*/ struct SparkalColor colorTextGamePaletteHighlighted;

