// Module: Miff.obj
// Source: C:\Copter\source\sparkal\Miff.cpp
// autogenerated by simcopter_tool from PDB file

// Type: void * __ptr32;

// Type: long;

// Type: char *;

// Type: int32_t;

// Type: /*packed*/ class MIFF (forward reference);
// VTABLE: COPTER_D 0x00591950
class MIFF : public PFile
{ // packed(0x148 bytes) TI: 0x428e
public:
	void MIFF(char *);
	void MIFF();
	virtual void ~MIFF() /* override */;
	virtual long OpenForReading(); // vtable+0x4
	virtual long OpenForWriting(long, long, long); // vtable+0x8
	virtual long OpenForAppending(); // vtable+0xc
	virtual long Close(); // vtable+0x10
	virtual long GetPresentRecordType(); // vtable+0x14
	virtual long GetPresentRecordSize(); // vtable+0x18
	virtual long GetPresentRecordDataSize(); // vtable+0x1c
	virtual long GetPresentRecordIndex(); // vtable+0x20
	virtual long VerifyFile(); // vtable+0x24
	virtual long ReadMIFFHeader(); // vtable+0x28
	virtual long ReadRecordHeader(); // vtable+0x2c
	virtual long ReadFileCreator(); // vtable+0x30
	virtual long ReadFileType(); // vtable+0x34
	virtual long ReadFileVersion(); // vtable+0x38
	virtual long ReadPresentRecord(/*packed*/ struct MIFFRecord*, long); // vtable+0x3c
	virtual long ReadPresentRecordData(char *, long); // vtable+0x40
	virtual long GoToFirstRecord(); // vtable+0x44
	virtual long GoToNextRecord(); // vtable+0x48
	virtual long GoToPreviousRecord(); // vtable+0x4c
	virtual long GoToFirstRecordOfGivenType(long); // vtable+0x50
	virtual long GoToNextRecordOfGivenType(long); // vtable+0x54
	virtual long GoToNthRecord(long); // vtable+0x58
	virtual long CountRecords(); // vtable+0x5c
	virtual long WriteMIFFRecord(/*packed*/ struct MIFFRecord*, long); // vtable+0x60
	virtual long WriteDataRecord(long, char *, long); // vtable+0x64
	virtual long WriteFileHeader(long, long, long); // vtable+0x68
	virtual long WriteEnd(); // vtable+0x6c
	/*+0x110*/ long lPresentRecordStart;
	/*+0x114*/ long lPresentRecordType;
	/*+0x118*/ long lPresentRecordLength;
	/*+0x11c*/ long lPresentRecordIndex;
	/*+0x120*/ long lReadWriteMode;
	/*+0x124*/ long bFileEndWritten;
	/*+0x128*/ long bFileAppearsCorrupt;
	/*+0x12c*/ /*packed*/ struct MIFFHeader myMIFFHeader; // 0x1c bytes
};

// Type: void;

// Type: /*packed*/ struct MIFFRecord (forward reference);
struct MIFFRecord{ // packed(0xc bytes) TI: 0x148f
	/*+0x0*/   long lRecordType;
	/*+0x4*/   long lRecordLength;
	/*+0x8*/   char chRecordData[4];
};

// Type: uint32_t;

// Type: /*packed*/ class PFile;
// VTABLE: COPTER_D 0x00590468
class PFile{ // packed(0x110 bytes) TI: 0x453c
	enum /* __unnamed */ {
		FileNull = -1,
	};
	enum SeekTypes {
		N_SEEK_FROM_FILE_START = 0,
		N_SEEK_FROM_FILE_CURRENT = 1,
		N_SEEK_FROM_FILE_END = 2,
	};
	enum AccessTypes {
		ReadOnly = 0,
		ReadWrite = 2,
		WriteOnly = 1,
		Create = 768,
		CreateExcl = 1280,
		Append = 8,
		Binary = 32768,
		Compat = 0,
		DenyNone = 64,
		DenyRead = 48,
		DenyWrite = 32,
		DenyRdWr = 16,
		NoInherit = 128,
	};
	enum PermissionTypes {
		PermRead = 256,
		PermWrite = 128,
		PermRdWr = 384,
	};
	enum seek_dir {
		beg = 0,
		cur = 1,
		end = 2,
	};
public:
	void PFile(char *);
	void PFile(const /*packed*/ class PFile&);
	void PFile(int32_t);
	void PFile();
	virtual void ~PFile(); // vtable+0x0
	int32_t Open(char *, unsigned short, unsigned short, int32_t);
	int32_t Close();
	int32_t GetHandle();
	long Position();
	void Length(long);
	long Length();
	long Seek(long, int32_t);
	long SeekToBegin();
	long SeekToEnd();
	int32_t IsOpen();
	int32_t Read(void * __ptr32, int32_t);
	int32_t Write(void * __ptr32, int32_t);
	void Flush();
	// calltype: NearC
	static void Remove(char *);
	// calltype: NearC
	static void Rename(char *, char *);
	// calltype: NearC
	static unsigned long Checksum(char *);
	long SetPath(char *);
	long FileCreate(char *, int32_t);
	long FileExists(char *);
	/*+0x4*/   char szFilePath[260]; // 0x104 bytes
	/*+0x108*/ int32_t Handle;
private:
	/*+0x10c*/ int32_t ShouldClose;
};



// Contribution: 1:000aa530-000ab9b5 Module: 6, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x004ab530
int32_t ReadFirstMIFFChunk(void * __ptr32 miffReader, long lDataType, char * ptrData, long lDataLength) {
// LINE 18:
	__asm        mov    eax, miffReader;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, miffReader;
	__asm        call   dword ptr [eax+0x44];
// LINE 19:
	__asm        mov    eax, lDataType;
	__asm        push   eax;
	__asm        mov    eax, miffReader;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, miffReader;
	__asm        call   dword ptr [eax+0x54];
	__asm        test   eax, eax;
	__asm        jne    _T2f;
// LINE 20:
	return 0x0;
// LINE 21:
_T2f:
	__asm        mov    eax, lDataLength;
	__asm        push   eax;
	__asm        mov    eax, ptrData;
	__asm        push   eax;
	__asm        mov    eax, miffReader;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, miffReader;
	__asm        call   dword ptr [eax+0x40];
	__asm        jmp    __RETURN;
// LINE 22:
__RETURN:
}

// FUNCTION: COPTER_D 0x004ab57c
int32_t ReadNextMIFFChunk(void * __ptr32 miffReader, long lDataType, char * ptrData, long lDataLength) {
// LINE 30:
	__asm        mov    eax, lDataType;
	__asm        push   eax;
	__asm        mov    eax, miffReader;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, miffReader;
	__asm        call   dword ptr [eax+0x54];
	__asm        test   eax, eax;
	__asm        jne    _T24;
// LINE 31:
	return 0x0;
// LINE 32:
_T24:
	__asm        mov    eax, lDataLength;
	__asm        push   eax;
	__asm        mov    eax, ptrData;
	__asm        push   eax;
	__asm        mov    eax, miffReader;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, miffReader;
	__asm        call   dword ptr [eax+0x40];
	__asm        jmp    __RETURN;
// LINE 33:
__RETURN:
}

// FUNCTION: COPTER_D 0x004ab5bd
int32_t WriteMIFFChunk(void * __ptr32 miffWriter, long lDataType, char * ptrData, long lDataLength) {
// LINE 41:
	__asm        mov    eax, lDataLength;
	__asm        push   eax;
	__asm        mov    eax, ptrData;
	__asm        push   eax;
	__asm        mov    eax, lDataType;
	__asm        push   eax;
	__asm        mov    eax, miffWriter;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, miffWriter;
	__asm        call   dword ptr [eax+0x64];
	__asm        jmp    __RETURN;
// LINE 42:
__RETURN:
}

// FUNCTION: COPTER_D 0x004ab5e4
void MIFF::MIFF() {

	this->Handle = 0xffffffff;
	this->ShouldClose = 0x0;
	this-><MIFF+0x00> = 0x590468;
	_fmode = 0x8000;
	this->szFilePath[0] = 0x0;
	__asm        jmp    _T45;
_T45:
	this-><MIFF+0x00> = 0x591950;
// LINE 57:
	this->lPresentRecordStart = 0x0;
// LINE 58:
	this->lPresentRecordType = 0x0;
// LINE 59:
	this->lPresentRecordLength = 0x0;
// LINE 60:
	this->lPresentRecordIndex = 0x0;
// LINE 61:
	this->lReadWriteMode = 0x0;
// LINE 62:
	this->bFileEndWritten = 0x0;
// LINE 63:
	this->bFileAppearsCorrupt = 0x0;
// LINE 64:
	this->myMIFFHeader.lMIFFIdentifier = 0x0;
// LINE 65:
	this->myMIFFHeader.lMIFFVersion = 0x0;
// LINE 66:
	this->myMIFFHeader.lFileCreator = 0x0;
// LINE 67:
	this->myMIFFHeader.lFileType = 0x0;
// LINE 68:
	this->myMIFFHeader.lFileVersion = 0x0;
// LINE 69:
	this->myMIFFHeader.lFileLength = 0x0;
// LINE 70:
	this->myMIFFHeader.lByteOrdering = 0x0;
// LINE 71:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004ab6f5
void MIFF::MIFF(char * szFileOrPath) {

	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x10C], 1;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x590468;
	__asm        mov    _fmode, 0x8000;
	__asm        cmp    szFileOrPath, 0;
	__asm        je     _T5b;

	strcpy(szFileOrPath, (this + 0x4));
	__asm        jmp    _T62;
_T5b:
	this->szFilePath[0] = 0x0;
_T62:
	__asm        jmp    _T67;
_T67:
	this-><MIFF+0x00> = 0x591950;
// LINE 84:
	this->lPresentRecordStart = 0x0;
// LINE 85:
	this->lPresentRecordLength = 0x0;
// LINE 86:
	this->lPresentRecordType = 0x0;
// LINE 87:
	this->lPresentRecordIndex = 0x0;
// LINE 88:
	this->lReadWriteMode = 0x0;
// LINE 89:
	this->bFileAppearsCorrupt = 0x0;
// LINE 90:
	this->bFileEndWritten = 0x0;
// LINE 91:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x004ab7cf
void MIFF::~MIFF() {

	this-><MIFF+0x00> = 0x591950;
// LINE 98:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T2a;

	__asm        jmp    _T2f;
_T2a:
	__asm        jmp    _T46;
_T2f:
	__asm        jmp    _T3e;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T46;
// LINE 99:
_T3e:
	this->MIFF::Close();
// LINE 101:
_T46:
	__asm        jmp    _T4b;
_T4b:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x590468;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T69;

	__asm        jmp    _T6e;
_T69:
	__asm        jmp    _T9f;
_T6e:
	__asm        jmp    _T7d;

	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T9f;
_T7d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x10C], 0;
	__asm        je     _T9f;

	_close(this->Handle);
_T9f:
	return;
}

// FUNCTION: COPTER_D 0x004ab878
long MIFF::OpenForReading() {
// LINE 114:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::FileExists;
	__asm        test   eax, eax;
	__asm        je     _Tb3;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T38;

	__asm        jmp    _Tb3;

	__asm        jmp    _T38;
_T38:
	__asm        jmp    _T47;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        jne    _Tb3;
// LINE 115:
_T47:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0x8020;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::Open;
// LINE 116:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T72;

	__asm        jmp    _T77;
_T72:
	__asm        jmp    _Tb3;
_T77:
	__asm        jmp    _T86;

	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _Tb3;
// LINE 117:
_T86:
	this->lReadWriteMode = 0x1;
// LINE 118:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x28];
// LINE 119:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 120:
	return 0x1;
// LINE 123:
_Tb3:
	return 0x0;
// LINE 124:
}

// FUNCTION: COPTER_D 0x004ab937
long MIFF::OpenForWriting(long lFileCreator, long lFileType, long lFileVersion) {
// LINE 139:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::FileExists;
	__asm        test   eax, eax;
	__asm        jne    _T46;
// LINE 140:
	_fmode = 0x8000;
// LINE 141:
	__asm        push   0x180;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::FileCreate;
	__asm        test   eax, eax;
	__asm        jne    _T46;
// LINE 142:
	return 0x0;
// LINE 144:
_T46:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T60;

	__asm        jmp    _T85;

	__asm        jmp    _T60;
_T60:
	__asm        jmp    _T6f;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        jne    _T85;
// LINE 145:
_T6f:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0x8002;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::Open;
// LINE 147:
_T85:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T9a;

	__asm        jmp    _T9f;
_T9a:
	__asm        jmp    _Te7;
_T9f:
	__asm        jmp    _Tae;

	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _Te7;
// LINE 148:
_Tae:
	this->lReadWriteMode = 0x2;
// LINE 149:
	__asm        mov    eax, lFileVersion;
	__asm        push   eax;
	__asm        mov    eax, lFileType;
	__asm        push   eax;
	__asm        mov    eax, lFileCreator;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x68];
// LINE 150:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 151:
	return 0x1;
// LINE 153:
_Te7:
	return 0x0;
// LINE 154:
}

// FUNCTION: COPTER_D 0x004aba2c
long MIFF::OpenForAppending() {
// LINE 169:
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::FileExists;
	__asm        test   eax, eax;
	__asm        jne    _T46;
// LINE 170:
	_fmode = 0x8000;
// LINE 171:
	__asm        push   0x180;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::FileCreate;
	__asm        test   eax, eax;
	__asm        jne    _T46;
// LINE 172:
	return 0x0;
// LINE 174:
_T46:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T60;

	__asm        jmp    _T85;

	__asm        jmp    _T60;
_T60:
	__asm        jmp    _T6f;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        jne    _T85;
// LINE 175:
_T6f:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0x8002;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::Open;
// LINE 177:
_T85:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T9a;

	__asm        jmp    _T9f;
_T9a:
	__asm        jmp    _T10f;
_T9f:
	__asm        jmp    _Tae;

	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T10f;
// LINE 178:
_Tae:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x28];
// LINE 179:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x12C], 0x4646494D;
	__asm        je     _Tdd;
// LINE 180:
	__asm        push   1;
	__asm        push   1;
	__asm        push   1;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x68];
// LINE 181:
_Tdd:
	this->lReadWriteMode = 0x2;
// LINE 182:
	_lseek(0x2, 0x0, this->Handle);
	__asm        jmp    _T105;
// LINE 183:
_T105:
	return 0x1;
// LINE 185:
_T10f:
	return 0x0;
// LINE 186:
}

// FUNCTION: COPTER_D 0x004abb47
long MIFF::Close() {
// LINE 194:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x120], 2;
	__asm        jne    _T37;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x124], 0;
	__asm        jne    _T37;
// LINE 195:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x6C];
// LINE 196:
_T37:
	this->PFile::Close();
// LINE 197:
	return 0x1;
// LINE 198:
}

// FUNCTION: COPTER_D 0x004abb95
long MIFF::VerifyFile() {
// LINE 206:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T26;

	__asm        jmp    _T70;

	__asm        jmp    _T26;
_T26:
	__asm        jmp    _T35;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        jne    _T70;
// LINE 207:
_T35:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 208:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T5a;

	__asm        jmp    _T70;

	__asm        jmp    _T5a;
_T5a:
	__asm        jmp    _T69;

	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        jne    _T70;
// LINE 209:
_T69:
	return 0x0;
// LINE 211:
_T70:
	__asm        mov    ecx, this;
	__asm        call   PFile::Length;
	__asm        mov    ecx, this;
	__asm        cmp    eax, [ecx+0x140];
	__asm        jne    _T91;
// LINE 212:
	return 0x1;
// LINE 213:
_T91:
	return 0x0;
// LINE 214:
}

// FUNCTION: COPTER_D 0x004abc32
long MIFF::ReadMIFFHeader() {
// LINE 223:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T21;

	__asm        jmp    _T26;
_T21:
	__asm        jmp    _T7c;
_T26:
	__asm        jmp    _T35;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T7c;
// LINE 224:
_T35:
	_lseek(0x0, 0x0, this->Handle);
	__asm        jmp    _T50;
// LINE 225:
_T50:
	_read(0x1c, (this + 0x12c), this->Handle);
	__asm        jmp    _T72;
// LINE 226:
_T72:
	return 0x1;
// LINE 228:
_T7c:
	return 0x0;
// LINE 229:
}

// FUNCTION: COPTER_D 0x004abcba
long MIFF::ReadFileCreator() {
	/*bp-0x4*/   long bWeOpenedFile;
	/*bp-0x8*/   long lResult;

// LINE 237:
	bWeOpenedFile = 0x0;
// LINE 240:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T2d;

	__asm        jmp    _T5d;

	__asm        jmp    _T2d;
_T2d:
	__asm        jmp    _T3c;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T5d;
// LINE 241:
_T3c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        test   eax, eax;
	__asm        jne    _T56;
// LINE 242:
	return 0x0;
// LINE 243:
_T56:
	bWeOpenedFile = 0x1;
// LINE 245:
_T5d:
	lResult = this->myMIFFHeader.lFileCreator;
// LINE 246:
	__asm        cmp    bWeOpenedFile, 0;
	__asm        je     _T7e;
// LINE 247:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
// LINE 249:
_T7e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-0x10], eax;
	__asm        push   0;
	__asm        mov    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _Ta7;
// LINE 250:
_Ta7:
	return lResult;
// LINE 251:
}

// FUNCTION: COPTER_D 0x004abd6e
long MIFF::ReadFileType() {
	/*bp-0x4*/   long bWeOpenedFile;
	/*bp-0x8*/   long lResult;

// LINE 259:
	bWeOpenedFile = 0x0;
// LINE 262:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T2d;

	__asm        jmp    _T5d;

	__asm        jmp    _T2d;
_T2d:
	__asm        jmp    _T3c;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T5d;
// LINE 263:
_T3c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        test   eax, eax;
	__asm        jne    _T56;
// LINE 264:
	return 0x0;
// LINE 265:
_T56:
	bWeOpenedFile = 0x1;
// LINE 267:
_T5d:
	lResult = this->myMIFFHeader.lFileType;
// LINE 268:
	__asm        cmp    bWeOpenedFile, 0;
	__asm        je     _T7e;
// LINE 269:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
// LINE 271:
_T7e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-0x10], eax;
	__asm        push   0;
	__asm        mov    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _Ta7;
// LINE 272:
_Ta7:
	return lResult;
// LINE 273:
}

// FUNCTION: COPTER_D 0x004abe22
long MIFF::ReadFileVersion() {
	/*bp-0x4*/   long bWeOpenedFile;
	/*bp-0x8*/   long lResult;

// LINE 280:
	bWeOpenedFile = 0x0;
// LINE 283:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T2d;

	__asm        jmp    _T5d;

	__asm        jmp    _T2d;
_T2d:
	__asm        jmp    _T3c;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T5d;
// LINE 284:
_T3c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
	__asm        test   eax, eax;
	__asm        jne    _T56;
// LINE 285:
	return 0x0;
// LINE 286:
_T56:
	bWeOpenedFile = 0x1;
// LINE 288:
_T5d:
	lResult = this->myMIFFHeader.lFileVersion;
// LINE 289:
	__asm        cmp    bWeOpenedFile, 0;
	__asm        je     _T7e;
// LINE 290:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
// LINE 292:
_T7e:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-0x10], eax;
	__asm        push   0;
	__asm        mov    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _Ta7;
// LINE 293:
_Ta7:
	return lResult;
// LINE 294:
}

// FUNCTION: COPTER_D 0x004abed6
long MIFF::ReadRecordHeader() {
	/*bp-0x4*/   long lBytesRead;

// LINE 314:
	_read(0x4, (this + 0x114), this->Handle);
	__asm        jmp    _T2e;
// LINE 315:
_T2e:
	__asm        jmp    _T33;
_T33:
	lBytesRead = _read(0x4, (this + 0x118), this->Handle);
// LINE 316:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x118], 0;
	__asm        jge    _T77;
// LINE 317:
	this->bFileAppearsCorrupt = 0x1;
// LINE 318:
	return 0x0;
// LINE 321:
_T77:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-8], eax;
	__asm        push   0;
	__asm        mov    eax, [ebp-8];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _Ta0;
// LINE 322:
_Ta0:
	__asm        cmp    lBytesRead, 0;
	__asm        jg     _Tb1;
// LINE 323:
	return 0x0;
// LINE 324:
_Tb1:
	__asm        mov    ecx, this;
	__asm        call   PFile::Length;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+0x118];
	__asm        mov    edx, this;
	__asm        add    ecx, [edx+0x110];
	__asm        cmp    eax, ecx;
	__asm        jge    _Te7;
// LINE 325:
	this->bFileAppearsCorrupt = 0x1;
// LINE 326:
	return 0x0;
// LINE 328:
_Te7:
	return 0x1;
// LINE 329:
}

// FUNCTION: COPTER_D 0x004abfcc
long MIFF::CountRecords() {
	/*bp-0x4*/   long bWeOpenedFile;
	/*bp-0x8*/   long lCount;

// LINE 352:
	bWeOpenedFile = 0x0;
// LINE 353:
	lCount = 0x0;
// LINE 355:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T34;

	__asm        jmp    _T74;

	__asm        jmp    _T34;
_T34:
	__asm        jmp    _T43;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        jne    _T74;
// LINE 356:
_T43:
	__asm        push   0;
	__asm        push   0x180;
	__asm        push   0x8020;
	__asm        push   0;
	__asm        mov    ecx, this;
	__asm        call   PFile::Open;
	__asm        test   eax, eax;
	__asm        jne    _T68;
// LINE 357:
	return 0x0;
// LINE 358:
_T68:
	bWeOpenedFile = 0x1;
// LINE 360:
	__asm        jmp    _T8b;
_T74:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _T8b;
// LINE 361:
	return 0x0;
// LINE 363:
_T8b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 365:
_T96:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x48];
	__asm        test   eax, eax;
	__asm        jne    _Tb3;
// LINE 366:
	__asm        jmp    _Tbb;
// LINE 367:
	__asm        jmp    _Tb6;
// LINE 368:
_Tb3:
	lCount++;
// LINE 369:
_Tb6:
	__asm        jmp    _T96;
// LINE 370:
_Tbb:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 371:
	__asm        cmp    bWeOpenedFile, 0;
	__asm        je     _Tdb;
// LINE 372:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x10];
// LINE 373:
_Tdb:
	return lCount;
// LINE 374:
}

// FUNCTION: COPTER_D 0x004ac0b4
long MIFF::GoToFirstRecord() {
// LINE 391:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T21;

	__asm        jmp    _T26;
_T21:
	__asm        jmp    _T45;
_T26:
	__asm        jmp    _T35;

	__asm        cmp    dword ptr [ebp-4], 0;
	__asm        je     _T45;
_T35:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _T4c;
// LINE 392:
_T45:
	return 0x0;
// LINE 393:
_T4c:
	_lseek(0x0, 0x1c, this->Handle);
	__asm        jmp    _T67;
// LINE 394:
_T67:
	this->lPresentRecordStart = 0x1c;
// LINE 395:
	this->lPresentRecordIndex = 0x0;
// LINE 396:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x2C];
// LINE 397:
	return 0x1;
// LINE 398:
}

// FUNCTION: COPTER_D 0x004ac14f
long MIFF::GoToNextRecord() {
	/*bp-0x4*/   long lSavedPreviousStart;
	/*bp-0x8*/   long lResult;

// LINE 420:
	lSavedPreviousStart = this->lPresentRecordStart;
// LINE 422:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T2d;

	__asm        jmp    _T32;
_T2d:
	__asm        jmp    _T51;
_T32:
	__asm        jmp    _T41;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T51;
_T41:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _T58;
// LINE 423:
_T51:
	return 0x0;
// LINE 425:
_T58:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x118], 0x8000;
	__asm        jg     _T7b;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x118], 0;
	__asm        jg     _Tab;
_T7b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-0x10], eax;
// LINE 426:
	__asm        push   0;
	__asm        mov    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _Ta4;
// LINE 427:
_Ta4:
	return 0x0;
// LINE 432:
_Tab:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x118];
	__asm        mov    [ebp-0x14], eax;
	__asm        push   1;
	__asm        mov    eax, [ebp-0x14];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        mov    lResult, eax;
	__asm        jmp    _Td7;
// LINE 433:
_Td7:
	__asm        cmp    lResult, 0xFFFFFFFF;
	__asm        jne    _T111;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-0x18], eax;
// LINE 436:
	__asm        push   0;
	__asm        mov    eax, [ebp-0x18];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _T10a;
// LINE 437:
_T10a:
	return 0x0;
// LINE 440:
_T111:
	this->lPresentRecordStart = lResult;
// LINE 441:
	__asm        mov    eax, this;
	__asm        mov    ecx, lSavedPreviousStart;
	__asm        cmp    [eax+0x110], ecx;
	__asm        jg     _T153;
// LINE 442:
	_lseek(0x0, lSavedPreviousStart, this->Handle);
	__asm        jmp    _T14c;
// LINE 443:
_T14c:
	return 0x0;
// LINE 446:
_T153:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x2C];
	__asm        test   eax, eax;
	__asm        jne    _T18a;
// LINE 447:
	_lseek(0x0, lSavedPreviousStart, this->Handle);
	__asm        jmp    _T183;
// LINE 448:
_T183:
	return 0x0;
// LINE 450:
_T18a:
	this->lPresentRecordIndex++;
// LINE 451:
	return 0x1;
// LINE 452:
}

// FUNCTION: COPTER_D 0x004ac2f1
long MIFF::GoToPreviousRecord() {
	/*bp-0x4*/   long lTempPresentRecord;

// LINE 473:
	lTempPresentRecord = this->lPresentRecordIndex;
// LINE 474:
	__asm        cmp    lTempPresentRecord, 0;
	__asm        je     _T25;
// LINE 475:
	lTempPresentRecord--;
// LINE 476:
_T25:
	__asm        mov    eax, lTempPresentRecord;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x58];
// LINE 477:
	return lTempPresentRecord;
// LINE 478:
}

// FUNCTION: COPTER_D 0x004ac332
long MIFF::GoToFirstRecordOfGivenType(long lRecordType) {
// LINE 492:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 493:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
	__asm        cmp    eax, lRecordType;
	__asm        jne    _T35;
// LINE 494:
	return 0x1;
// LINE 496:
_T35:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x48];
	__asm        test   eax, eax;
	__asm        je     _T6b;
// LINE 497:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
	__asm        cmp    eax, lRecordType;
	__asm        jne    _T66;
// LINE 498:
	return 0x1;
// LINE 499:
_T66:
	__asm        jmp    _T35;
// LINE 500:
_T6b:
	return 0x0;
// LINE 501:
}

// FUNCTION: COPTER_D 0x004ac3ab
long MIFF::GoToNextRecordOfGivenType(long lRecordType) {
// LINE 515:
_T0c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x48];
	__asm        test   eax, eax;
	__asm        je     _T42;
// LINE 516:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x14];
	__asm        cmp    eax, lRecordType;
	__asm        jne    _T3d;
// LINE 517:
	return 0x1;
// LINE 518:
_T3d:
	__asm        jmp    _T0c;
// LINE 519:
_T42:
	return 0x0;
// LINE 520:
}

// FUNCTION: COPTER_D 0x004ac3fb
long MIFF::GoToNthRecord(long lRecordToGoTo) {
	/*bp-0x4*/   long lTempPresentRecord;

// LINE 540:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x44];
// LINE 541:
	lTempPresentRecord = 0x0;
	__asm        jmp    _T26;
_T23:
	lTempPresentRecord++;
_T26:
	__asm        mov    eax, lRecordToGoTo;
	__asm        cmp    lTempPresentRecord, eax;
	__asm        jge    _T42;
// LINE 542:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x48];
	__asm        jmp    _T23;
// LINE 543:
_T42:
	return 0x1;
// LINE 544:
}

// FUNCTION: COPTER_D 0x004ac44e
long MIFF::ReadPresentRecord(/*packed*/ struct MIFFRecord *miffRecordToRead, long lMaxBytesToRead) {
	/*bp-0x4*/   long lActualDataBytesToRead;
	/*bp-0x8*/   long lReturnValue;

// LINE 563:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T21;

	__asm        jmp    _T26;
_T21:
	__asm        jmp    _T45;
_T26:
	__asm        jmp    _T35;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T45;
_T35:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _T4c;
// LINE 564:
_T45:
	return 0x0;
// LINE 567:
_T4c:
	lMaxBytesToRead -= 0x8;
// LINE 568:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x118];
	__asm        mov    ecx, lMaxBytesToRead;
	__asm        cmp    eax, ecx;
	__asm        jl     _T66;

	__asm        mov    eax, ecx;
_T66:
	__asm        mov    lActualDataBytesToRead, eax;
// LINE 569:
	miffRecordToRead->lRecordType = this->lPresentRecordType;
// LINE 570:
	miffRecordToRead->lRecordLength = this->lPresentRecordLength;
// LINE 572:
	__asm        jmp    _T8b;
_T8b:
	__asm        mov    eax, lActualDataBytesToRead;
	__asm        push   eax;
	__asm        mov    eax, miffRecordToRead;
	__asm        add    eax, 8;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    lReturnValue, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-0x10], eax;
// LINE 578:
	__asm        push   0;
	__asm        mov    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _Td4;
// LINE 579:
_Td4:
	__asm        cmp    lReturnValue, 0xFFFFFFFF;
	__asm        jne    _Te5;
// LINE 580:
	return 0x0;
// LINE 581:
_Te5:
	return 0x1;
// LINE 582:
}

// FUNCTION: COPTER_D 0x004ac544
long MIFF::ReadPresentRecordData(char * chBuffer, long lMaxBytesToRead) {
	/*bp-0x4*/   long lActualBytesToRead;
	/*bp-0x8*/   long lReturnValue;

// LINE 601:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T21;

	__asm        jmp    _T26;
_T21:
	__asm        jmp    _T45;
_T26:
	__asm        jmp    _T35;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T45;
_T35:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x128], 0;
	__asm        je     _T4c;
// LINE 602:
_T45:
	return 0x0;
// LINE 605:
_T4c:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x118];
	__asm        mov    ecx, lMaxBytesToRead;
	__asm        cmp    eax, ecx;
	__asm        jl     _T62;

	__asm        mov    eax, ecx;
_T62:
	__asm        mov    lActualBytesToRead, eax;
// LINE 607:
	_lseek(0x1, 0x8, this->Handle);
	__asm        jmp    _T80;
// LINE 609:
_T80:
	__asm        jmp    _T85;
_T85:
	__asm        mov    eax, lActualBytesToRead;
	__asm        push   eax;
	__asm        mov    eax, chBuffer;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _read;
	__asm        add    esp, 0xC;
	__asm        mov    lReturnValue, eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x110];
	__asm        mov    [ebp-0x10], eax;
// LINE 615:
	__asm        push   0;
	__asm        mov    eax, [ebp-0x10];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x108];
	__asm        push   eax;
	__asm        call   _lseek;
	__asm        add    esp, 0xC;
	__asm        jmp    _Tcb;
// LINE 616:
_Tcb:
	__asm        cmp    lReturnValue, 0xFFFFFFFF;
	__asm        je     _Tdf;

	__asm        cmp    lReturnValue, 0;
	__asm        jne    _Te6;
// LINE 617:
_Tdf:
	return 0x0;
// LINE 618:
_Te6:
	return 0x1;
// LINE 619:
}

// FUNCTION: COPTER_D 0x004ac63b
long MIFF::WriteFileHeader(long lCreatorType, long lFileType, long lFileVersion) {
	/*bp-0x4*/   long lReturnValue;

// LINE 645:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T21;

	__asm        jmp    _T26;
_T21:
	__asm        jmp    _T45;
_T26:
	__asm        jmp    _T35;

	__asm        cmp    dword ptr [ebp-8], 0;
	__asm        je     _T45;
_T35:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x120], 2;
	__asm        je     _T4c;
// LINE 646:
_T45:
	return 0x0;
// LINE 648:
_T4c:
	this->myMIFFHeader.lMIFFIdentifier = 0x4646494d;
// LINE 649:
	this->myMIFFHeader.lMIFFVersion = 0x2;
// LINE 650:
	this->myMIFFHeader.lFileCreator = lCreatorType;
// LINE 651:
	this->myMIFFHeader.lFileType = lFileType;
// LINE 652:
	this->myMIFFHeader.lFileVersion = lFileVersion;
// LINE 653:
	this->myMIFFHeader.lFileLength = 0x1c;
// LINE 654:
	this->myMIFFHeader.lByteOrdering = 0x1;
// LINE 656:
	this->bFileEndWritten = 0x0;
// LINE 657:
	_lseek(0x0, 0x0, this->Handle);
	__asm        jmp    _Tcc;
// LINE 658:
_Tcc:
	__asm        jmp    _Td1;
_Td1:
	lReturnValue = _write(0x1c, (this + 0x12c), this->Handle);
// LINE 659:
	__asm        cmp    lReturnValue, 0xFFFFFFFF;
	__asm        je     _T105;

	__asm        cmp    lReturnValue, 0;
	__asm        jne    _T10c;
// LINE 660:
_T105:
	return 0x0;
// LINE 661:
_T10c:
	return 0x1;
// LINE 662:
}

// FUNCTION: COPTER_D 0x004ac758
long MIFF::WriteMIFFRecord(/*packed*/ struct MIFFRecord *miffRecordToWrite, long lSizeOfMIFFRecordData) {
	/*bp-0x4*/   long lAmountOfDataToWrite;
	/*bp-0x8*/   long lReturnValue;

// LINE 678:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T21;

	__asm        jmp    _T26;
_T21:
	__asm        jmp    _T45;
_T26:
	__asm        jmp    _T35;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T45;
_T35:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x120], 2;
	__asm        je     _T4c;
// LINE 679:
_T45:
	return 0x0;
// LINE 680:
_T4c:
	this->bFileEndWritten = 0x0;
// LINE 681:
	lAmountOfDataToWrite = (lSizeOfMIFFRecordData + 0x8);
// LINE 682:
	miffRecordToWrite->lRecordLength = lAmountOfDataToWrite;
// LINE 685:
	__asm        jmp    _T70;
_T70:
	lReturnValue = _write(lAmountOfDataToWrite, miffRecordToWrite, this->Handle);
// LINE 690:
	__asm        cmp    lReturnValue, 0xFFFFFFFF;
	__asm        je     _Ta1;

	__asm        cmp    lReturnValue, 0;
	__asm        jne    _Ta8;
// LINE 691:
_Ta1:
	return 0x0;
// LINE 692:
_Ta8:
	return 0x1;
// LINE 693:
}

// FUNCTION: COPTER_D 0x004ac811
long MIFF::WriteDataRecord(long lRecordType, char * ptrData, long lDataLength) {
	/*bp-0x4*/   long lRecordLength;
	/*bp-0x8*/   long lReturnValue;

// LINE 704:
	lRecordLength = (lDataLength + 0x8);
// LINE 707:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x108], 0xFFFFFFFF;
	__asm        jle    _T2a;

	__asm        jmp    _T2f;
_T2a:
	__asm        jmp    _T4e;
_T2f:
	__asm        jmp    _T3e;

	__asm        cmp    dword ptr [ebp-0xC], 0;
	__asm        je     _T4e;
_T3e:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x120], 2;
	__asm        je     _T55;
// LINE 708:
_T4e:
	return 0x0;
// LINE 709:
_T55:
	this->bFileEndWritten = 0x0;
// LINE 711:
	_write(0x4, lRecordType, this->Handle);
	__asm        jmp    _T7f;
// LINE 712:
_T7f:
	_write(0x4, lRecordLength, this->Handle);
	__asm        jmp    _T9c;
// LINE 715:
_T9c:
	__asm        jmp    _Ta1;
_Ta1:
	lReturnValue = _write(lDataLength, ptrData, this->Handle);
// LINE 721:
	__asm        cmp    lReturnValue, 0xFFFFFFFF;
	__asm        je     _Td2;

	__asm        cmp    lReturnValue, 0;
	__asm        jne    _Td9;
// LINE 722:
_Td2:
	return 0x0;
// LINE 723:
_Td9:
	return 0x1;
// LINE 724:
}

// FUNCTION: COPTER_D 0x004ac8fb
long MIFF::WriteEnd() {
	/*bp-0x4*/   long lFileLength;
	/*bp-0x8*/   long lPresentPosition;

// LINE 739:
	lPresentPosition = _tell(this->Handle);
	__asm        jmp    _T26;
// LINE 741:
_T26:
	_chsize(lPresentPosition, this->Handle);
	__asm        jmp    _T41;
// LINE 742:
_T41:
	lFileLength = this->PFile::Length();
// LINE 743:
	_lseek(0x0, 0x14, this->Handle);
	__asm        jmp    _T67;
// LINE 744:
_T67:
	_write(0x4, lFileLength, this->Handle);
	__asm        jmp    _T84;
// LINE 745:
_T84:
	this->bFileEndWritten = 0x1;
// LINE 746:
	_lseek(0x2, 0x0, this->Handle);
	__asm        jmp    _Tac;
// LINE 747:
_Tac:
	return 0x1;
// LINE 748:
}



// Contribution: 1:000ab9c0-000ab9de Module: 6, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000ab9e0-000ab9fe Module: 6, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000aba00-000aba21 Module: 6, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000aba30-000aba4e Module: 6, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:000aba50-000aba88 Module: 6, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x004aca50
// MIFF::`scalar deleting destructor'



// Contribution: 2:00002950-000029bf Module: 6, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for MIFF @ 0x00591950
//   00: MIFF::`scalar deleting destructor' @ 0x004aca50
//   01: MIFF::OpenForReading @ 0x004ab878
//   02: MIFF::OpenForWriting @ 0x004ab937
//   03: MIFF::OpenForAppending @ 0x004aba2c
//   04: MIFF::Close @ 0x004abb47
//   05: MIFF::GetPresentRecordType @ 0x004ac9c0
//   06: MIFF::GetPresentRecordSize @ 0x004ac9e0
//   07: MIFF::GetPresentRecordDataSize @ 0x004aca00
//   08: MIFF::GetPresentRecordIndex @ 0x004aca30
//   09: MIFF::VerifyFile @ 0x004abb95
//   10: MIFF::ReadMIFFHeader @ 0x004abc32
//   11: MIFF::ReadRecordHeader @ 0x004abed6
//   12: MIFF::ReadFileCreator @ 0x004abcba
//   13: MIFF::ReadFileType @ 0x004abd6e
//   14: MIFF::ReadFileVersion @ 0x004abe22
//   15: MIFF::ReadPresentRecord @ 0x004ac44e
//   16: MIFF::ReadPresentRecordData @ 0x004ac544
//   17: MIFF::GoToFirstRecord @ 0x004ac0b4
//   18: MIFF::GoToNextRecord @ 0x004ac14f
//   19: MIFF::GoToPreviousRecord @ 0x004ac2f1
//   20: MIFF::GoToFirstRecordOfGivenType @ 0x004ac332
//   21: MIFF::GoToNextRecordOfGivenType @ 0x004ac3ab
//   22: MIFF::GoToNthRecord @ 0x004ac3fb
//   23: MIFF::CountRecords @ 0x004abfcc
//   24: MIFF::WriteMIFFRecord @ 0x004ac758
//   25: MIFF::WriteDataRecord @ 0x004ac811
//   26: MIFF::WriteFileHeader @ 0x004ac63b
//   27: MIFF::WriteEnd @ 0x004ac8fb
//   28 entries

