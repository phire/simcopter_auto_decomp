// Module: scrnbuf.obj
// Source: C:\Copter\source\sparkal\scrnbuf.cpp
// autogenerated by simcopter_tool from PDB file

// Type: class ScreenBuffer (forward reference);
class ScreenBuffer : public CBackBuffer
{
public:
	class CSparkalWindow* pWindow;
	long bOK;
	void ScreenBuffer(class CSparkalWindow*, long, long, struct SparkalColor*, int32_t, enum tagModeType, int32_t);
	void ScreenBuffer();
	// vtable: 100
	intro void ~ScreenBuffer();
	virtual unsigned long Swap(class CSparkalWindow*, long, long);
	// vtable: 104
	intro int32_t DeleteSurfaces();
	// vtable: 108
	intro int32_t CreateSurfaces();
	// vtable: 112
	intro int32_t ClearSurfaces(int32_t);
	// vtable: 116
	intro int32_t UsePalette(struct SparkalColor*);
	// vtable: 120
	intro void FreePalette();
	// vtable: 124
	intro void SetPalette();
	virtual unsigned long FillRect(long, struct SparkalRect*);
	// vtable: 128
	intro void SetWindowRect(struct SparkalRect*);
	// vtable: 132
	intro void SetNewModeType(enum tagModeType);
	// vtable: 136
	intro void WaitTillReadyToFlip();
protected:
	struct SparkalRect rectBuffer;
	short nBackBuffers;
	enum tagModeType nCurrentModeType;
	int32_t bUsingFlipping;
	struct IDirectDrawClipper* lpClipper;
	struct tagRECT rectDirectDrawBackBuffer;
};

// Type: struct SparkalRect;
struct SparkalRect{
	long left;
	long top;
	long right;
	long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: void;

// Type: class CSparkalWindow (forward reference);
// CSparkalWindow Class implementation not found

// Type: long;

// Type: struct SparkalColor (forward reference);
struct SparkalColor{
	unsigned char Blue;
	unsigned char Green;
	unsigned char Red;
	unsigned char Padding;
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: int32_t;

// Type: enum tagModeType;
enum tagModeType {
	nModeTypeFullScreen = 0,
	nModeTypeWindowed = 1,
};

// Type: struct _DDSCAPS;
struct _DDSCAPS{
	unsigned long dwCaps;
};

// Type: struct _DDBLTFX;
struct _DDBLTFX{
	unsigned long dwSize;
	unsigned long dwDDFX;
	unsigned long dwROP;
	unsigned long dwDDROP;
	unsigned long dwRotationAngle;
	unsigned long dwZBufferOpCode;
	unsigned long dwZBufferLow;
	unsigned long dwZBufferHigh;
	unsigned long dwZBufferBaseDest;
	unsigned long dwZDestConstBitDepth;
	unsigned long dwZDestConst;
	struct IDirectDrawSurface* lpDDSZBufferDest;
	unsigned long dwZSrcConstBitDepth;
	unsigned long dwZSrcConst;
	struct IDirectDrawSurface* lpDDSZBufferSrc;
	unsigned long dwAlphaEdgeBlendBitDepth;
	unsigned long dwAlphaEdgeBlend;
	unsigned long dwReserved;
	unsigned long dwAlphaDestConstBitDepth;
	unsigned long dwAlphaDestConst;
	struct IDirectDrawSurface* lpDDSAlphaDest;
	unsigned long dwAlphaSrcConstBitDepth;
	unsigned long dwAlphaSrcConst;
	struct IDirectDrawSurface* lpDDSAlphaSrc;
	unsigned long dwFillColor;
	struct IDirectDrawSurface* lpDDSPattern;
	struct _DDCOLORKEY ddckDestColorkey;
	struct _DDCOLORKEY ddckSrcColorkey;
};

// Type: unsigned long;

// Type: struct tagPALETTEENTRY (forward reference);
// tagPALETTEENTRY Class implementation not found

// Type: void * __ptr32;

// Type: struct SparkalRect (forward reference);
struct SparkalRect{
	long left;
	long top;
	long right;
	long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: struct tagRECT;
struct tagRECT{
	long left;
	long top;
	long right;
	long bottom;
};

// Type: uint32_t;

// Type: class CBackBuffer;
class CBackBuffer : public IBackBuffer
{
public:
	void CBackBuffer(long, long, const struct SparkalColor*);
	void CBackBuffer(char *);
	void CBackBuffer();
	// vtable: 40
	intro void InitializeMemberVariables();
	void ~CBackBuffer();
	unsigned long Load();
	virtual unsigned long Lock();
	virtual unsigned long Unlock();
	// calltype: NearC
	static int32_t GetPaletteFromImage(char *, struct SparkalColor*);
	virtual unsigned long Swap(class CSparkalWindow*, long, long);
	virtual unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long);
	virtual unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long);
	// vtable: 44
	intro unsigned long Compose(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&);
	virtual unsigned long Compose(class IFlatImage*, long, long, long, long, long, long);
	virtual unsigned long StretchCompose(class IFlatImage*, long, long, long, long, long, long, long, long);
	// vtable: 48
	intro unsigned long StretchCompose(class IFlatImage*, const struct SparkalRect&, const struct SparkalRect&);
	// vtable: 52
	intro unsigned long Duplicate(class CBackBuffer*, int32_t);
	// vtable: 56
	intro unsigned long ComposeNoClip(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&);
	// vtable: 60
	intro unsigned long ComposeNoClip(class IFlatImage*, long, long, long, long, long, long);
	void UpdatePalette(long, long, const struct SparkalColor*);
	virtual void SetTransparentColor(int32_t, long);
	unsigned long GetTransparentColor(long&);
	unsigned long SetFont(class MFont*);
	void SetFontColor(struct SparkalColor&);
	void SetFontIndex(int32_t);
	void SetColor(struct SparkalColor&);
	void SetColorIndex(int32_t);
	// vtable: 64
	intro unsigned long DrawLine(long, long, long, long, long);
	// vtable: 68
	intro unsigned long FillRect(long, const struct SparkalRect*);
	// vtable: 72
	intro unsigned long DrawBufferText(char *, long, unsigned long, const class MRect&, class MFont*);
	// vtable: 76
	intro unsigned long DrawBufferText(char *, unsigned long, long *, long *, long *, long *, class MFont*);
	// vtable: 80
	intro unsigned long DrawLineUnclipped(long, long, long, long, long);
	// vtable: 84
	intro unsigned long DrawLineClipped(long, long, long, long, long);
	// vtable: 88
	intro unsigned long DrawRectangleOutline(const struct SparkalRect&, long);
	// vtable: 92
	intro unsigned long DrawRectangleOutlineUnclipped(const struct SparkalRect&, long);
	long IsLost();
	long Restore();
	char * szFilePath;
	struct tagRECT rectDirectDrawBuffer;
protected:
	int32_t bSurfacePrimary;
	int32_t bSurfaceTransparent;
	class MFont* mFont;
	struct SparkalColor colorFontCurrent;
	struct SparkalColor colorCurrent;
	int32_t nColorIndexFontCurrent;
	int32_t nColorIndexCurrent;
	int32_t nColorIndexTransparent;
	struct IDirectDrawSurface* mpFrontSurface;
	struct IDirectDrawSurface* mpBackSurface;
	struct IDirectDrawPalette* mpPalette;
	struct _DDSURFACEDESC mDDdesc;
	struct _DDBLTFX mDDBltFx;
	void * __ptr32 hPen;
	int32_t nPenThickness;
	struct SparkalColor colorPenCurrent;
	// vtable: 96
	intro struct IDirectDrawSurface* GetDDSurface();
};

// Type: class IBackBuffer;
class IBackBuffer : public IFlatImage
{
public:
	// vtable: 28
	intro unsigned long Swap(class CSparkalWindow*, long, long);
	// vtable: 32
	intro unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long);
	// vtable: 36
	intro unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long);
};

// Type: class IFlatImage;
class IFlatImage{
public:
	void IFlatImage();
	// vtable: 0
	intro unsigned long Lock();
	// vtable: 4
	intro unsigned long Unlock();
	unsigned long GetLockCount();
	// vtable: 8
	intro void SetTransparentColor(int32_t, long);
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	// vtable: 12
	intro unsigned long Compose(class IFlatImage*, long, long, long, long, long, long);
	unsigned long Compose(class IFlatImage*, long, long);
	// vtable: 16
	intro unsigned long StretchCompose(class IFlatImage*, long, long, long, long, long, long, long, long);
	// vtable: 20
	intro unsigned long StretchCompose(class IFlatImage*, struct SparkalRect, struct SparkalRect);
	// vtable: 24
	intro unsigned long FillRect(long, struct SparkalRect*);
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	unsigned long mLockCount;
	long mWidth;
	long mHeight;
	void * __ptr32 mpBits;
	long mStride;
};



// Contribution: 1:0009d450-0009e705 Module: 12, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0049e450
void ScreenBuffer::ScreenBuffer() {
	struct SparkalRect rectWindowTemp;


	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        jmp    near ptr 0x0049E469;

	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5915B0;
// LINE 25:
	__asm        jmp    near ptr 0x0049E477;
// LINE 26:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x134], 0;
// LINE 27:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+8], 0x280;
// LINE 28:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC], 0x1E0;
// LINE 29:
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x14C], 2;
// LINE 30:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x14E], 0;
// LINE 31:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x152], 0;
// LINE 33:
	__asm        mov    rectWindowTemp.left, 0;
// LINE 34:
	__asm        mov    rectWindowTemp.top, 0;
// LINE 35:
	__asm        mov    rectWindowTemp.right, 0;
// LINE 36:
	__asm        mov    rectWindowTemp.bottom, 0;
// LINE 41:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::SetWindowRect;
// LINE 44:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 45:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15A], 0;
// LINE 46:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15E], 0;
// LINE 47:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x162], 0;
// LINE 48:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x166], 0;
// LINE 51:
	__asm        jmp    near ptr 0x0049E52C;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0049e534
void ScreenBuffer::ScreenBuffer(class CSparkalWindow* pNewWindow, long nNewWidth, long nNewHeight, struct SparkalColor* pColors, int32_t nNewBackBuffers, enum tagModeType nNewCurrentModeType, int32_t bNewUsingFlipping) {
	struct SparkalRect rectWindowTemp;


	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        jmp    near ptr 0x0049E54D;

	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5915B0;
// LINE 63:
	__asm        jmp    near ptr 0x0049E55B;
// LINE 65:
	__asm        mov    eax, pNewWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x134], eax;
// LINE 66:
	__asm        mov    eax, nNewWidth;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
// LINE 67:
	__asm        mov    eax, nNewHeight;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xC], eax;
// LINE 68:
	__asm        mov    eax, nNewBackBuffers;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14C], ax;
// LINE 69:
	__asm        mov    eax, nNewCurrentModeType;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14E], eax;
// LINE 70:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 71:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x2C], 1;
// LINE 72:
	__asm        mov    rectWindowTemp.left, 0;
// LINE 73:
	__asm        mov    rectWindowTemp.top, 0;
// LINE 74:
	__asm        mov    eax, nNewWidth;
	__asm        mov    rectWindowTemp.right, eax;
// LINE 75:
	__asm        mov    eax, nNewHeight;
	__asm        mov    rectWindowTemp.bottom, eax;
// LINE 76:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 1;
// LINE 77:
	__asm        mov    eax, bNewUsingFlipping;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x152], eax;
// LINE 83:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 1;
	__asm        jne    _Tc5;
// LINE 84:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x152], 0;
// LINE 89:
_Tc5:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::SetWindowRect;
// LINE 92:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 93:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15A], 0;
// LINE 94:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15E], 0;
// LINE 95:
	__asm        mov    eax, nNewWidth;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x162], eax;
// LINE 96:
	__asm        mov    eax, nNewHeight;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x166], eax;
// LINE 100:
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::CreateSurfaces;
// LINE 101:
	__asm        mov    eax, pColors;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::UsePalette;
// LINE 103:
	__asm        jmp    near ptr 0x0049E65D;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0049e667
void ScreenBuffer::~ScreenBuffer() {

	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5915B0;
// LINE 112:
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::DeleteSurfaces;
// LINE 114:
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::FreePalette;
// LINE 115:
	__asm        jmp    near ptr 0x0049E691;

	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::~CBackBuffer;
}

// FUNCTION: COPTER_D 0x0049e69e
int32_t ScreenBuffer::CreateSurfaces() {
	long hResult;

// LINE 131:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 132:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 133:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T150;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T150;
// LINE 136:
// Block start:
	struct _DDSCAPS ddsBackBufferCaps;
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 137:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 138:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x5C], 0x20;
// LINE 141:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC0], 0x218;
// LINE 142:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x14C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x6C], eax;
// LINE 144:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 145:
	__asm        cmp    hResult, 0;
	__asm        je     _Tdd;
// LINE 146:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 147:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    near ptr 0x0049E767;

	__asm        push   0x59A340;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 148:
	__asm        xor    eax, eax;
	__asm        jmp    _T3c7;
// LINE 153:
_Tdd:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x14C];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+8];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0xC];
	__asm        add    IFlatImage::lTotalMemoryUsage, eax;
// LINE 159:
	__asm        mov    ddsBackBufferCaps.dwCaps, 4;
// LINE 160:
	__asm        mov    eax, this;
	__asm        add    eax, 0x50;
	__asm        push   eax;
	__asm        lea    eax, ddsBackBufferCaps.dwCaps;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x30];
	__asm        mov    hResult, eax;
// LINE 162:
	__asm        cmp    hResult, 0;
	__asm        je     _T14b;
// LINE 163:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    near ptr 0x0049E7D5;

	__asm        push   0x59A380;
	__asm        lea    ecx, [ebp-0x10];
	__asm        call   DirectDrawError::DisplayError;
// LINE 164:
	__asm        xor    eax, eax;
	__asm        jmp    _T3c7;
// LINE 167:
// Block end:
_T14b:
	__asm        jmp    _T39b;
// LINE 169:
_T150:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 170:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 171:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x5C], 0;
// LINE 172:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC0], 0x200;
// LINE 173:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 174:
	__asm        cmp    hResult, 0;
	__asm        je     _T1e7;
// LINE 175:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 176:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 177:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    near ptr 0x0049E871;

	__asm        push   0x59A3C4;
	__asm        lea    ecx, [ebp-0x14];
	__asm        call   DirectDrawError::DisplayError;
// LINE 178:
	__asm        xor    eax, eax;
	__asm        jmp    _T3c7;
// LINE 182:
_T1e7:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 183:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 184:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x5C], 6;
// LINE 185:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC0], 0x840;
// LINE 186:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x64], eax;
// LINE 187:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x60], eax;
// LINE 188:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x50;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 189:
	__asm        cmp    hResult, 0;
	__asm        je     _T2b2;
// LINE 190:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 191:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 192:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 193:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 194:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    near ptr 0x0049E93C;

	__asm        push   0x59A404;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   DirectDrawError::DisplayError;
// LINE 195:
	__asm        xor    eax, eax;
	__asm        jmp    _T3c7;
// LINE 200:
_T2b2:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0xC];
	__asm        add    eax, eax;
	__asm        add    IFlatImage::lTotalMemoryUsage, eax;
// LINE 207:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 1;
	__asm        je     _T2e7;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        jne    _T39b;
// LINE 212:
_T2e7:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x156], 0;
	__asm        jne    _T317;
// LINE 213:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x156;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x10];
	__asm        mov    hResult, eax;
// LINE 214:
_T317:
	__asm        cmp    hResult, 0;
	__asm        je     _T34d;
// LINE 215:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 216:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    near ptr 0x0049E9D7;

	__asm        push   0x59A444;
	__asm        lea    ecx, [ebp-0x1C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 217:
	__asm        xor    eax, eax;
	__asm        jmp    _T3c7;
// LINE 219:
_T34d:
	__asm        jmp    near ptr 0x0049E9F0;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x20];
	__asm        mov    hResult, eax;
// LINE 220:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x70];
	__asm        mov    hResult, eax;
// LINE 225:
_T39b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax];
// LINE 226:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 227:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x70];
// LINE 229:
	__asm        mov    eax, 1;
	__asm        jmp    _T3c7;
// LINE 230:
_T3c7:
}

// FUNCTION: COPTER_D 0x0049ea6a
int32_t ScreenBuffer::DeleteSurfaces() {
// LINE 240:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        je     _T68;
// LINE 241:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 242:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 243:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T4f;
// LINE 244:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 248:
_T4f:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    IFlatImage::lTotalMemoryUsage, eax;
// LINE 257:
_T68:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x50], 0;
	__asm        je     _Taa;
// LINE 258:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 259:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 263:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    IFlatImage::lTotalMemoryUsage, eax;
// LINE 267:
_Taa:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x156], 0;
	__asm        je     _Tdf;
// LINE 268:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 269:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 272:
_Tdf:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x0049EB53;
// LINE 273:
}

// FUNCTION: COPTER_D 0x0049eb58
int32_t ScreenBuffer::ClearSurfaces(int32_t nClearPaletteIndex) {
	long hResult;
	struct _DDBLTFX ddbltfx;

// LINE 286:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T12b;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T12b;
// LINE 287:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T8a;
// LINE 288:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 289:
	__asm        cmp    hResult, 0;
	__asm        je     _T8a;
// LINE 290:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    near ptr 0x0049EBCE;

	__asm        push   0x59A484;
	__asm        lea    ecx, [ebp-0x6C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 291:
	__asm        xor    eax, eax;
	__asm        jmp    _T2b6;
// LINE 294:
_T8a:
	__asm        mov    ddbltfx.dwSize, 0x64;
// LINE 295:
	__asm        mov    eax, nClearPaletteIndex;
	__asm        mov    ddbltfx.dwFillColor, eax;
// LINE 300:
_T97:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _Tcd;

	__asm        jmp    _T97;
// LINE 301:
_Tcd:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x2C];
// LINE 302:
	__asm        mov    ddbltfx.dwSize, 0x64;
// LINE 303:
	__asm        mov    eax, nClearPaletteIndex;
	__asm        mov    ddbltfx.dwFillColor, eax;
// LINE 308:
_Tf0:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _T126;

	__asm        jmp    _Tf0;
// LINE 310:
_T126:
	__asm        jmp    _T2ac;
// LINE 313:
_T12b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T186;
// LINE 314:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 315:
	__asm        cmp    hResult, 0;
	__asm        je     _T186;
// LINE 316:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x70], eax;
	__asm        jmp    near ptr 0x0049ECCA;

	__asm        push   0x59A4CC;
	__asm        lea    ecx, [ebp-0x70];
	__asm        call   DirectDrawError::DisplayError;
// LINE 317:
	__asm        xor    eax, eax;
	__asm        jmp    _T2b6;
// LINE 320:
_T186:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T1e1;
// LINE 321:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 322:
	__asm        cmp    hResult, 0;
	__asm        je     _T1e1;
// LINE 323:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x74], eax;
	__asm        jmp    near ptr 0x0049ED25;

	__asm        push   0x59A514;
	__asm        lea    ecx, [ebp-0x74];
	__asm        call   DirectDrawError::DisplayError;
// LINE 324:
	__asm        xor    eax, eax;
	__asm        jmp    _T2b6;
// LINE 327:
_T1e1:
	__asm        mov    ddbltfx.dwSize, 0x64;
// LINE 328:
	__asm        mov    eax, nClearPaletteIndex;
	__asm        mov    ddbltfx.dwFillColor, eax;
// LINE 333:
_T1ee:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _T224;

	__asm        jmp    _T1ee;
// LINE 334:
_T224:
	__asm        cmp    hResult, 0;
	__asm        je     _T24d;
// LINE 335:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x78], eax;
	__asm        jmp    near ptr 0x0049ED91;

	__asm        push   0x59A55C;
	__asm        lea    ecx, [ebp-0x78];
	__asm        call   DirectDrawError::DisplayError;
// LINE 336:
	__asm        xor    eax, eax;
	__asm        jmp    _T2b6;
// LINE 342:
_T24d:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _T283;

	__asm        jmp    _T24d;
// LINE 343:
_T283:
	__asm        cmp    hResult, 0;
	__asm        je     _T2ac;
// LINE 344:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x7C], eax;
	__asm        jmp    near ptr 0x0049EDF0;

	__asm        push   0x59A5A0;
	__asm        lea    ecx, [ebp-0x7C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 345:
	__asm        xor    eax, eax;
	__asm        jmp    _T2b6;
// LINE 349:
_T2ac:
	__asm        mov    eax, 1;
	__asm        jmp    _T2b6;
// LINE 350:
_T2b6:
}

// FUNCTION: COPTER_D 0x0049ee15
unsigned long ScreenBuffer::Swap(class CSparkalWindow* __formal, long __formal, long __formal) {
	long hResult;

// LINE 365:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _Tce;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _Tce;
// LINE 366:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T87;
// LINE 367:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 368:
	__asm        cmp    hResult, 0;
	__asm        je     _T87;
// LINE 369:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    near ptr 0x0049EE88;

	__asm        push   0x59A5E4;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 370:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e3;
// LINE 374:
_T87:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x2C];
	__asm        mov    hResult, eax;
// LINE 376:
	__asm        cmp    hResult, 0;
	__asm        je     _Tc9;
// LINE 377:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    near ptr 0x0049EECA;

	__asm        push   0x59A624;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 378:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e3;
// LINE 381:
_Tc9:
	__asm        jmp    _T1d9;
// LINE 382:
_Tce:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T129;
// LINE 383:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 384:
	__asm        cmp    hResult, 0;
	__asm        je     _T129;
// LINE 385:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    near ptr 0x0049EF2A;

	__asm        push   0x59A650;
	__asm        lea    ecx, [ebp-0x10];
	__asm        call   DirectDrawError::DisplayError;
// LINE 386:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e3;
// LINE 389:
_T129:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T184;
// LINE 390:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 391:
	__asm        cmp    hResult, 0;
	__asm        je     _T184;
// LINE 392:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    near ptr 0x0049EF85;

	__asm        push   0x59A690;
	__asm        lea    ecx, [ebp-0x14];
	__asm        call   DirectDrawError::DisplayError;
// LINE 393:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e3;
// LINE 401:
_T184:
	__asm        push   0;
	__asm        push   0x1000000;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x1C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 402:
	__asm        cmp    hResult, 0;
	__asm        je     _T1d9;
// LINE 403:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    near ptr 0x0049EFDA;

	__asm        push   0x59A6D0;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   DirectDrawError::DisplayError;
// LINE 404:
	__asm        xor    eax, eax;
	__asm        jmp    _T1e3;
// LINE 408:
_T1d9:
	__asm        mov    eax, 1;
	__asm        jmp    _T1e3;
// LINE 409:
_T1e3:
}

// FUNCTION: COPTER_D 0x0049efff
void ScreenBuffer::WaitTillReadyToFlip() {
	long hResult;
	int32_t bIsInVerticalBlank;

// LINE 426:
_T0c:
	__asm        lea    eax, bIsInVerticalBlank;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x44];
	__asm        mov    hResult, eax;
// LINE 427:
	__asm        cmp    bIsInVerticalBlank, 0;
	__asm        jne    _T37;

	__asm        cmp    hResult, 0;
	__asm        je     _T0c;
// LINE 429:
_T37:
	__asm        jmp    near ptr 0x0049F03B;
}

// FUNCTION: COPTER_D 0x0049f040
void ScreenBuffer::SetPalette() {
	long hResult;

// LINE 442:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        je     _Tb0;
// LINE 443:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T72;
// LINE 444:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 445:
	__asm        cmp    hResult, 0;
	__asm        je     _T72;
// LINE 446:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    near ptr 0x0049F0A0;

	__asm        push   0x59A6FC;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 447:
	__asm        jmp    _Tb5;
// LINE 450:
_T72:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x7C];
	__asm        mov    hResult, eax;
// LINE 451:
	__asm        cmp    hResult, 0;
	__asm        je     _Tb0;
// LINE 452:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    near ptr 0x0049F0E3;

	__asm        push   0x59A744;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 455:
_Tb0:
	__asm        jmp    _Tb5;
_Tb5:
}

// FUNCTION: COPTER_D 0x0049f0fa
int32_t ScreenBuffer::UsePalette(struct SparkalColor* pColors) {
	long hResult;

	// Function registers exception cleanup function at 0x0049f410

	__asm        mov    [ebp-0x10], esp;
	__asm        mov    this, ecx;
// LINE 475:
	__asm        cmp    pColors, 0;
	__asm        je     _T2d5;
// LINE 538:
// Block start:
	struct tagPALETTEENTRY palEntries[256];
	int32_t i;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T94;
// LINE 539:
// Block start:
	void * __ptr32 hdc;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 540:
	__asm        cmp    hdc, 0;
	__asm        je     _T8f;
// LINE 541:
	__asm        lea    eax, palEntries[0].peRed;
	__asm        push   eax;
	__asm        push   0x100;
	__asm        push   0;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3580];
// LINE 542:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 545:
// Block end:
_T8f:
	__asm        jmp    _T107;
// LINE 547:
_T94:
	__asm        mov    i, 0;
	__asm        jmp    _Ta3;
_Ta0:
	__asm        inc    i;
_Ta3:
	__asm        cmp    i, 0xA;
	__asm        jge    _T107;
// LINE 548:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 2;
// LINE 549:
	__asm        mov    al, reinterpret_cast<uint8_t>(i);
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 550:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x417], 0;
// LINE 551:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x416], 0;
// LINE 552:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3D], 2;
// LINE 553:
	__asm        mov    eax, i;
	__asm        add    eax, 0xF6;
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x40], al;
// LINE 554:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3F], 0;
// LINE 555:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3E], 0;
// LINE 556:
	__asm        jmp    _Ta0;
// LINE 558:
_T107:
	__asm        mov    i, 0xA;
	__asm        jmp    _T116;
_T113:
	__asm        inc    i;
_T116:
	__asm        cmp    i, 0xF5;
	__asm        jg     _T16e;
// LINE 559:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x416], al;
// LINE 560:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+1];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x417], al;
// LINE 561:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+2];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 562:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 5;
// LINE 563:
	__asm        jmp    _T113;
// LINE 564:
_T16e:
	__asm        cmp    lpPalette, 0;
	__asm        je     _T1cc;
// LINE 565:
	__asm        mov    dword ptr [ebp-4], 0;
// LINE 566:
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
	__asm        jmp    _T1bb;
// LINE 569:
_L40600:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x420], eax;
	__asm        jmp    near ptr 0x0049F29F;

	__asm        push   0x59A78C;
	__asm        lea    ecx, [ebp-0x420];
	__asm        call   DirectDrawError::DisplayError;
// LINE 570:
	__asm        mov    eax, 0x49F2B5;
	__asm        ret;
// LINE 571:
_L37298:
_L37298:
_T1bb:
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        mov    lpPalette, 0;
// LINE 573:
_T1cc:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 0;
// LINE 577:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x54;
	__asm        push   eax;
	__asm        lea    eax, palEntries[0].peRed;
	__asm        push   eax;
	__asm        push   4;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 578:
	__asm        cmp    hResult, 0;
	__asm        jne    _T2a5;
// LINE 579:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    lpPalette, eax;
// LINE 580:
	__asm        mov    dword ptr [ebp-4], 2;
// LINE 581:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x7C];
	__asm        jmp    _T25a;
// LINE 584:
_L40602:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x424], eax;
	__asm        jmp    near ptr 0x0049F33E;

	__asm        push   0x59A7CC;
	__asm        lea    ecx, [ebp-0x424];
	__asm        call   DirectDrawError::DisplayError;
// LINE 585:
	__asm        mov    eax, 0x49F354;
	__asm        ret;
// LINE 592:
_L37305:
_L37305:
_T25a:
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        jmp    near ptr 0x0049F360;

	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T2a0;
// LINE 593:
	__asm        jmp    near ptr 0x0049F37B;

	__asm        push   0;
	__asm        push   0;
	__asm        push   0x30F;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3880];
// LINE 596:
_T2a0:
	__asm        jmp    _T2d0;
// LINE 597:
_T2a5:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 0;
// LINE 598:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x428], eax;
	__asm        jmp    near ptr 0x0049F3BA;

	__asm        push   0x59A804;
	__asm        lea    ecx, [ebp-0x428];
	__asm        call   DirectDrawError::DisplayError;
// LINE 601:
// Block end:
_T2d0:
	__asm        jmp    _T30c;
// LINE 603:
_T2d5:
	__asm        cmp    lpPalette, 0;
	__asm        je     _T305;
// LINE 604:
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x7C];
// LINE 605:
	__asm        jmp    _T30c;
// LINE 606:
_T305:
	__asm        xor    eax, eax;
	__asm        jmp    _T320;
// LINE 610:
_T30c:
	__asm        mov    eax, 1;
	__asm        jmp    _T320;
// LINE 611:
_L40603:
	__asm        mov    eax, 0x595C58;
	__asm        jmp    near ptr 0x0056F590;
_T320:
	__asm        mov    ecx, [ebp-0xC];
	__asm        mov    fs:[0], ecx;
}

// FUNCTION: COPTER_D 0x0049f42b
void ScreenBuffer::FreePalette() {
// LINE 620:
	__asm        cmp    lpPalette, 0;
	__asm        je     _T3d;
// LINE 621:
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 622:
	__asm        mov    lpPalette, 0;
// LINE 623:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 0;
// LINE 626:
_T3d:
	__asm        jmp    near ptr 0x0049F46D;
}

// FUNCTION: COPTER_D 0x0049f472
unsigned long ScreenBuffer::FillRect(long nPaletteIndex, struct SparkalRect* rectFill) {
	long hResult;
	struct tagRECT rectFillTemp;

// LINE 654:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 655:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC4], 0x64;
// LINE 656:
	__asm        mov    eax, nPaletteIndex;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x114], eax;
// LINE 658:
	__asm        cmp    rectFill, 0;
	__asm        je     _T61;
// LINE 659:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax];
	__asm        mov    rectFillTemp.left, eax;
// LINE 660:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax+4];
	__asm        mov    rectFillTemp.top, eax;
// LINE 661:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax+8];
	__asm        mov    rectFillTemp.right, eax;
// LINE 662:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    rectFillTemp.bottom, eax;
// LINE 664:
	__asm        jmp    _T8d;
// LINE 665:
_T61:
	__asm        mov    rectFillTemp.left, 0;
// LINE 666:
	__asm        mov    rectFillTemp.top, 0;
// LINE 667:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x1C];
	__asm        mov    rectFillTemp.right, eax;
// LINE 668:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x20];
	__asm        mov    rectFillTemp.bottom, eax;
// LINE 670:
_T8d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T10d;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T10d;
// LINE 675:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T108;
// LINE 676:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 677:
	__asm        cmp    hResult, 0;
	__asm        je     _T108;
// LINE 678:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    near ptr 0x0049F566;

	__asm        push   0x59A840;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   DirectDrawError::DisplayError;
// LINE 679:
	__asm        xor    eax, eax;
	__asm        jmp    _T217;
// LINE 683:
_T108:
	__asm        jmp    _T1c3;
// LINE 686:
_T10d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T168;
// LINE 687:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 688:
	__asm        cmp    hResult, 0;
	__asm        je     _T168;
// LINE 689:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    near ptr 0x0049F5C6;

	__asm        push   0x59A884;
	__asm        lea    ecx, [ebp-0x1C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 690:
	__asm        xor    eax, eax;
	__asm        jmp    _T217;
// LINE 693:
_T168:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T1c3;
// LINE 694:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 695:
	__asm        cmp    hResult, 0;
	__asm        je     _T1c3;
// LINE 696:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    near ptr 0x0049F621;

	__asm        push   0x59A8C8;
	__asm        lea    ecx, [ebp-0x20];
	__asm        call   DirectDrawError::DisplayError;
// LINE 697:
	__asm        xor    eax, eax;
	__asm        jmp    _T217;
// LINE 705:
_T1c3:
	__asm        mov    eax, this;
	__asm        add    eax, 0xC4;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, rectFillTemp.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 706:
	__asm        cmp    hResult, 0;
	__asm        je     _T210;
// LINE 707:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    near ptr 0x0049F675;

	__asm        push   0x59A90C;
	__asm        lea    ecx, [ebp-0x24];
	__asm        call   DirectDrawError::DisplayError;
// LINE 710:
_T210:
	__asm        xor    eax, eax;
	__asm        jmp    _T217;
// LINE 711:
_T217:
}

// FUNCTION: COPTER_D 0x0049f690
void ScreenBuffer::SetWindowRect(struct SparkalRect* rectWindow) {
// LINE 721:
	__asm        mov    eax, rectWindow;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x13C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 727:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x13C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1C], eax;
// LINE 728:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x140];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x20], eax;
// LINE 729:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x144];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x24], eax;
// LINE 730:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x148];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x28], eax;
// LINE 732:
	__asm        jmp    near ptr 0x0049F6FF;
}



// Contribution: 1:0009e710-0009e733 Module: 12, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0009e740-0009e778 Module: 12, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0049f740
// ScreenBuffer::`scalar deleting destructor'



// Contribution: 2:000025b0-0000263b Module: 12, 8 byte alignment, initialized_data, (comdat), read, 
// GLOBAL: COPTER_D 0x005915b0
// GLOBAL: COPTER_D 0x005915b0
// ??_7ScreenBuffer@@6B@


// Contribution: 2:00006c58-00006cdf Module: 12, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00003340-00003949 Module: 12, 4 byte alignment, initialized_data, read, write, 
