// Module: scrnbuf.obj
// Source: C:\Copter\source\sparkal\scrnbuf.cpp
// autogenerated by simcopter_tool from PDB file

// Type: /*packed*/ class ScreenBuffer (forward reference);
// VTABLE: COPTER_D 0x005915b0
class ScreenBuffer : public CBackBuffer
{ // packed(0x16a bytes) TI: 0x2735
public:
	/*+0x134*/ /*unpacked*/ class CSparkalWindow *pWindow;
	/*+0x138*/ long bOK;
	void ScreenBuffer(/*unpacked*/ class CSparkalWindow*, long, long, /*packed*/ struct SparkalColor*, int32_t, enum tagModeType, int32_t);
	void ScreenBuffer();
	virtual void ~ScreenBuffer(); // vtable+0x64
	virtual unsigned long Swap(/*unpacked*/ class CSparkalWindow*, long, long) /* override */;
	virtual int32_t DeleteSurfaces(); // vtable+0x68
	virtual int32_t CreateSurfaces(); // vtable+0x6c
	virtual int32_t ClearSurfaces(int32_t); // vtable+0x70
	virtual int32_t UsePalette(/*packed*/ struct SparkalColor*); // vtable+0x74
	virtual void FreePalette(); // vtable+0x78
	virtual void SetPalette(); // vtable+0x7c
	virtual unsigned long FillRect(long, /*packed*/ struct SparkalRect*) /* override */;
	virtual void SetWindowRect(/*packed*/ struct SparkalRect*); // vtable+0x80
	virtual void SetNewModeType(enum tagModeType); // vtable+0x84
	virtual void WaitTillReadyToFlip(); // vtable+0x88
protected:
	/*+0x13c*/ /*packed*/ struct SparkalRect rectBuffer; // 0x10 bytes
	/*+0x14c*/ short nBackBuffers; // 0x2 bytes
	/*+0x14e*/ enum tagModeType nCurrentModeType;
	/*+0x152*/ int32_t bUsingFlipping;
	/*+0x156*/ /*packed*/ struct IDirectDrawClipper *lpClipper;
	/*+0x15a*/ /*packed*/ struct tagRECT rectDirectDrawBackBuffer; // 0x10 bytes
};

// Type: /*packed*/ struct SparkalRect;
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: void;

// Type: /*unpacked*/ class CSparkalWindow (forward reference);
// CSparkalWindow Class implementation not found

// Type: long;

// Type: /*packed*/ struct SparkalColor (forward reference);
struct SparkalColor{ // packed(0x4 bytes) TI: 0x12ee
	/*+0x0*/   unsigned char Blue; // 0x1 bytes
	/*+0x1*/   unsigned char Green; // 0x1 bytes
	/*+0x2*/   unsigned char Red; // 0x1 bytes
	/*+0x3*/   unsigned char Padding; // 0x1 bytes
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: int32_t;

// Type: enum tagModeType;
enum tagModeType {
	nModeTypeFullScreen = 0,
	nModeTypeWindowed = 1,
};

// Type: /*packed*/ struct _DDSCAPS;
struct _DDSCAPS{ // packed(0x4 bytes) TI: 0x176d
	/*+0x0*/   unsigned long dwCaps;
};

// Type: /*packed*/ struct _DDBLTFX;
struct _DDBLTFX{ // packed(0x64 bytes) TI: 0x12e7
	/*+0x0*/   unsigned long dwSize;
	/*+0x4*/   unsigned long dwDDFX;
	/*+0x8*/   unsigned long dwROP;
	/*+0xc*/   unsigned long dwDDROP;
	/*+0x10*/  unsigned long dwRotationAngle;
	/*+0x14*/  unsigned long dwZBufferOpCode;
	/*+0x18*/  unsigned long dwZBufferLow;
	/*+0x1c*/  unsigned long dwZBufferHigh;
	/*+0x20*/  unsigned long dwZBufferBaseDest;
	/*+0x24*/  unsigned long dwZDestConstBitDepth;
	/*+0x28*/  unsigned long dwZDestConst;
	/*+0x28*/  /*packed*/ struct IDirectDrawSurface *lpDDSZBufferDest;
	/*+0x2c*/  unsigned long dwZSrcConstBitDepth;
	/*+0x30*/  unsigned long dwZSrcConst;
	/*+0x30*/  /*packed*/ struct IDirectDrawSurface *lpDDSZBufferSrc;
	/*+0x34*/  unsigned long dwAlphaEdgeBlendBitDepth;
	/*+0x38*/  unsigned long dwAlphaEdgeBlend;
	/*+0x3c*/  unsigned long dwReserved;
	/*+0x40*/  unsigned long dwAlphaDestConstBitDepth;
	/*+0x44*/  unsigned long dwAlphaDestConst;
	/*+0x44*/  /*packed*/ struct IDirectDrawSurface *lpDDSAlphaDest;
	/*+0x48*/  unsigned long dwAlphaSrcConstBitDepth;
	/*+0x4c*/  unsigned long dwAlphaSrcConst;
	/*+0x4c*/  /*packed*/ struct IDirectDrawSurface *lpDDSAlphaSrc;
	/*+0x50*/  unsigned long dwFillColor;
	/*+0x50*/  /*packed*/ struct IDirectDrawSurface *lpDDSPattern;
	/*+0x54*/  /*packed*/ struct _DDCOLORKEY ddckDestColorkey; // 0x8 bytes
	/*+0x5c*/  /*packed*/ struct _DDCOLORKEY ddckSrcColorkey; // 0x8 bytes
};

// Type: unsigned long;

// Type: /*packed*/ struct tagPALETTEENTRY (forward reference);
struct tagPALETTEENTRY{ // packed(0x4 bytes) TI: 0x1be6
	/*+0x0*/   unsigned char peRed; // 0x1 bytes
	/*+0x1*/   unsigned char peGreen; // 0x1 bytes
	/*+0x2*/   unsigned char peBlue; // 0x1 bytes
	/*+0x3*/   unsigned char peFlags; // 0x1 bytes
};

// Type: void * __ptr32;

// Type: /*packed*/ struct SparkalRect (forward reference);
struct SparkalRect{ // packed(0x10 bytes) TI: 0x155f
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: /*packed*/ struct tagRECT;
struct tagRECT{ // packed(0x10 bytes) TI: 0x13c4
	/*+0x0*/   long left;
	/*+0x4*/   long top;
	/*+0x8*/   long right;
	/*+0xc*/   long bottom;
};

// Type: uint32_t;

// Type: /*unpacked*/ class CBackBuffer (forward reference);
// CBackBuffer Class implementation not found



// Contribution: 1:0009d450-0009e705 Module: 12, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0049e450
void ScreenBuffer::ScreenBuffer() {
	/*bp-0x10*/  /*packed*/ struct SparkalRect rectWindowTemp; // 0x10 bytes


	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        jmp    _T19;
_T19:
	this-><ScreenBuffer+0x00> = 0x5915b0;
// LINE 25:
	__asm        jmp    _T27;
// LINE 26:
_T27:
	this->pWindow = 0x0;
// LINE 27:
	this-><ScreenBuffer+0x08> = 0x280;
// LINE 28:
	this-><ScreenBuffer+0x0c> = 0x1e0;
// LINE 29:
	this->nBackBuffers = 0x2;
// LINE 30:
	this->nCurrentModeType = 0x0;
// LINE 31:
	this->bUsingFlipping = 0x0;
// LINE 33:
	rectWindowTemp.left = 0x0;
// LINE 34:
	rectWindowTemp.top = 0x0;
// LINE 35:
	rectWindowTemp.right = 0x0;
// LINE 36:
	rectWindowTemp.bottom = 0x0;
// LINE 41:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::SetWindowRect;
// LINE 44:
	this->lpClipper = 0x0;
// LINE 45:
	this->rectDirectDrawBackBuffer.left = 0x0;
// LINE 46:
	this->rectDirectDrawBackBuffer.top = 0x0;
// LINE 47:
	this->rectDirectDrawBackBuffer.right = 0x0;
// LINE 48:
	this->rectDirectDrawBackBuffer.bottom = 0x0;
// LINE 51:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0049e534
void ScreenBuffer::ScreenBuffer(/*unpacked*/ class CSparkalWindow *pNewWindow, long nNewWidth, long nNewHeight, /*packed*/ struct SparkalColor *pColors, int32_t nNewBackBuffers, enum tagModeType nNewCurrentModeType, int32_t bNewUsingFlipping) {
	/*bp-0x10*/  /*packed*/ struct SparkalRect rectWindowTemp; // 0x10 bytes


	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::CBackBuffer;
	__asm        jmp    _T19;
_T19:
	this-><ScreenBuffer+0x00> = 0x5915b0;
// LINE 63:
	__asm        jmp    _T27;
// LINE 65:
_T27:
	this->pWindow = pNewWindow;
// LINE 66:
	this-><ScreenBuffer+0x08> = nNewWidth;
// LINE 67:
	this-><ScreenBuffer+0x0c> = nNewHeight;
// LINE 68:
	__asm        mov    eax, nNewBackBuffers;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14C], ax;
// LINE 69:
	this->nCurrentModeType = nNewCurrentModeType;
// LINE 70:
	this->lpClipper = 0x0;
// LINE 71:
	this-><ScreenBuffer+0x2c> = 0x1;
// LINE 72:
	rectWindowTemp.left = 0x0;
// LINE 73:
	rectWindowTemp.top = 0x0;
// LINE 74:
	rectWindowTemp.right = nNewWidth;
// LINE 75:
	rectWindowTemp.bottom = nNewHeight;
// LINE 76:
	this->bOK = 0x1;
// LINE 77:
	this->bUsingFlipping = bNewUsingFlipping;
// LINE 83:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 1;
	__asm        jne    _Tc5;
// LINE 84:
	this->bUsingFlipping = 0x0;
// LINE 89:
_Tc5:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::SetWindowRect;
// LINE 92:
	this->lpClipper = 0x0;
// LINE 93:
	this->rectDirectDrawBackBuffer.left = 0x0;
// LINE 94:
	this->rectDirectDrawBackBuffer.top = 0x0;
// LINE 95:
	this->rectDirectDrawBackBuffer.right = nNewWidth;
// LINE 96:
	this->rectDirectDrawBackBuffer.bottom = nNewHeight;
// LINE 100:
	this->ScreenBuffer::CreateSurfaces();
// LINE 101:
	__asm        mov    eax, pColors;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::UsePalette;
// LINE 103:
	return;

	__asm        mov    eax, this;
}

// FUNCTION: COPTER_D 0x0049e667
void ScreenBuffer::~ScreenBuffer() {

	this-><ScreenBuffer+0x00> = 0x5915b0;
// LINE 112:
	this->ScreenBuffer::DeleteSurfaces();
// LINE 114:
	__asm        mov    ecx, this;
	__asm        call   ScreenBuffer::FreePalette;
// LINE 115:
	return;

	__asm        mov    ecx, this;
	__asm        call   CBackBuffer::~CBackBuffer;
}

// FUNCTION: COPTER_D 0x0049e69e
int32_t ScreenBuffer::CreateSurfaces() {
	/*bp-0x4*/   long hResult;

// LINE 131:
	this-><ScreenBuffer+0x4c> = 0x0;
// LINE 132:
	this-><ScreenBuffer+0x50> = 0x0;
// LINE 133:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T150;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T150;
// LINE 136:
// Block start:
	/*bp-0x8*/   /*packed*/ struct _DDSCAPS ddsBackBufferCaps;
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 137:
	this-><ScreenBuffer+0x58> = 0x6c;
// LINE 138:
	this-><ScreenBuffer+0x5c> = 0x20;
// LINE 141:
	this-><ScreenBuffer+0xc0> = 0x218;
// LINE 142:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x14C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x6C], eax;
// LINE 144:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 145:
	__asm        cmp    hResult, 0;
	__asm        je     _Tdd;
// LINE 146:
	this->bOK = 0x0;
// LINE 147:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Tc9;
_Tc9:
	__asm        push   0x59A340;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 148:
	return 0x0;
// LINE 153:
_Tdd:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x14C];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+8];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0xC];
	__asm        add    IFlatImage::lTotalMemoryUsage, eax;
// LINE 159:
	ddsBackBufferCaps.dwCaps = 0x4;
// LINE 160:
	__asm        mov    eax, this;
	__asm        add    eax, 0x50;
	__asm        push   eax;
	__asm        lea    eax, ddsBackBufferCaps.dwCaps;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x30];
	__asm        mov    hResult, eax;
// LINE 162:
	__asm        cmp    hResult, 0;
	__asm        je     _T14b;
// LINE 163:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T137;
_T137:
	__asm        push   0x59A380;
	__asm        lea    ecx, [ebp-0x10];
	__asm        call   DirectDrawError::DisplayError;
// LINE 164:
	return 0x0;
// LINE 167:
// Block end:
_T14b:
	__asm        jmp    _T39b;
// LINE 169:
_T150:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 170:
	this-><ScreenBuffer+0x58> = 0x6c;
// LINE 171:
	this-><ScreenBuffer+0x5c> = 0x0;
// LINE 172:
	this-><ScreenBuffer+0xc0> = 0x200;
// LINE 173:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 174:
	__asm        cmp    hResult, 0;
	__asm        je     _T1e7;
// LINE 175:
	this->bOK = 0x0;
// LINE 176:
	this-><ScreenBuffer+0x4c> = 0x0;
// LINE 177:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T1d3;
_T1d3:
	__asm        push   0x59A3C4;
	__asm        lea    ecx, [ebp-0x14];
	__asm        call   DirectDrawError::DisplayError;
// LINE 178:
	return 0x0;
// LINE 182:
_T1e7:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   memset;
	__asm        add    esp, 0xC;
// LINE 183:
	this-><ScreenBuffer+0x58> = 0x6c;
// LINE 184:
	this-><ScreenBuffer+0x5c> = 0x6;
// LINE 185:
	this-><ScreenBuffer+0xc0> = 0x840;
// LINE 186:
	this-><ScreenBuffer+0x64> = this-><ScreenBuffer+0x08>;
// LINE 187:
	this-><ScreenBuffer+0x60> = this-><ScreenBuffer+0x0c>;
// LINE 188:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x50;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 189:
	__asm        cmp    hResult, 0;
	__asm        je     _T2b2;
// LINE 190:
	this->bOK = 0x0;
// LINE 191:
	this-><ScreenBuffer+0x50> = 0x0;
// LINE 192:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 193:
	this-><ScreenBuffer+0x4c> = 0x0;
// LINE 194:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T29e;
_T29e:
	__asm        push   0x59A404;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   DirectDrawError::DisplayError;
// LINE 195:
	return 0x0;
// LINE 200:
_T2b2:
	IFlatImage::lTotalMemoryUsage += ((this-><ScreenBuffer+0x08> * this-><ScreenBuffer+0x0c>) + (this-><ScreenBuffer+0x08> * this-><ScreenBuffer+0x0c>));
// LINE 207:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 1;
	__asm        je     _T2e7;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        jne    _T39b;
// LINE 212:
_T2e7:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x156], 0;
	__asm        jne    _T317;
// LINE 213:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x156;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x10];
	__asm        mov    hResult, eax;
// LINE 214:
_T317:
	__asm        cmp    hResult, 0;
	__asm        je     _T34d;
// LINE 215:
	this->bOK = 0x0;
// LINE 216:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T339;
_T339:
	__asm        push   0x59A444;
	__asm        lea    ecx, [ebp-0x1C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 217:
	return 0x0;
// LINE 219:
_T34d:
	__asm        jmp    _T352;
_T352:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x20];
	__asm        mov    hResult, eax;
// LINE 220:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x70];
	__asm        mov    hResult, eax;
// LINE 225:
_T39b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax];
// LINE 226:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 227:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x70];
// LINE 229:
	return 0x1;
// LINE 230:
}

// FUNCTION: COPTER_D 0x0049ea6a
int32_t ScreenBuffer::DeleteSurfaces() {
// LINE 240:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        je     _T68;
// LINE 241:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 242:
	this-><ScreenBuffer+0x4c> = 0x0;
// LINE 243:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T4f;
// LINE 244:
	this-><ScreenBuffer+0x50> = 0x0;
// LINE 248:
_T4f:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    IFlatImage::lTotalMemoryUsage, eax;
// LINE 257:
_T68:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x50], 0;
	__asm        je     _Taa;
// LINE 258:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 259:
	this-><ScreenBuffer+0x50> = 0x0;
// LINE 263:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    IFlatImage::lTotalMemoryUsage, eax;
// LINE 267:
_Taa:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x156], 0;
	__asm        je     _Tdf;
// LINE 268:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 269:
	this->lpClipper = 0x0;
// LINE 272:
_Tdf:
	return 0x1;
// LINE 273:
}

// FUNCTION: COPTER_D 0x0049eb58
int32_t ScreenBuffer::ClearSurfaces(int32_t nClearPaletteIndex) {
	/*bp-0x64*/  /*packed*/ struct _DDBLTFX ddbltfx; // 0x64 bytes
	/*bp-0x68*/  long hResult;

// LINE 286:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T12b;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T12b;
// LINE 287:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T8a;
// LINE 288:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 289:
	__asm        cmp    hResult, 0;
	__asm        je     _T8a;
// LINE 290:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    _T76;
_T76:
	__asm        push   0x59A484;
	__asm        lea    ecx, [ebp-0x6C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 291:
	return 0x0;
// LINE 294:
_T8a:
	ddbltfx.dwSize = 0x64;
// LINE 295:
	ddbltfx.dwFillColor = nClearPaletteIndex;
// LINE 300:
_T97:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _Tcd;

	__asm        jmp    _T97;
// LINE 301:
_Tcd:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x2C];
// LINE 302:
	ddbltfx.dwSize = 0x64;
// LINE 303:
	ddbltfx.dwFillColor = nClearPaletteIndex;
// LINE 308:
_Tf0:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _T126;

	__asm        jmp    _Tf0;
// LINE 310:
_T126:
	__asm        jmp    _T2ac;
// LINE 313:
_T12b:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T186;
// LINE 314:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 315:
	__asm        cmp    hResult, 0;
	__asm        je     _T186;
// LINE 316:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x70], eax;
	__asm        jmp    _T172;
_T172:
	__asm        push   0x59A4CC;
	__asm        lea    ecx, [ebp-0x70];
	__asm        call   DirectDrawError::DisplayError;
// LINE 317:
	return 0x0;
// LINE 320:
_T186:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T1e1;
// LINE 321:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 322:
	__asm        cmp    hResult, 0;
	__asm        je     _T1e1;
// LINE 323:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x74], eax;
	__asm        jmp    _T1cd;
_T1cd:
	__asm        push   0x59A514;
	__asm        lea    ecx, [ebp-0x74];
	__asm        call   DirectDrawError::DisplayError;
// LINE 324:
	return 0x0;
// LINE 327:
_T1e1:
	ddbltfx.dwSize = 0x64;
// LINE 328:
	ddbltfx.dwFillColor = nClearPaletteIndex;
// LINE 333:
_T1ee:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _T224;

	__asm        jmp    _T1ee;
// LINE 334:
_T224:
	__asm        cmp    hResult, 0;
	__asm        je     _T24d;
// LINE 335:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x78], eax;
	__asm        jmp    _T239;
_T239:
	__asm        push   0x59A55C;
	__asm        lea    ecx, [ebp-0x78];
	__asm        call   DirectDrawError::DisplayError;
// LINE 336:
	return 0x0;
// LINE 342:
_T24d:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    _T283;

	__asm        jmp    _T24d;
// LINE 343:
_T283:
	__asm        cmp    hResult, 0;
	__asm        je     _T2ac;
// LINE 344:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x7C], eax;
	__asm        jmp    _T298;
_T298:
	__asm        push   0x59A5A0;
	__asm        lea    ecx, [ebp-0x7C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 345:
	return 0x0;
// LINE 349:
_T2ac:
	return 0x1;
// LINE 350:
}

// FUNCTION: COPTER_D 0x0049ee15
unsigned long ScreenBuffer::Swap(/*unpacked*/ class CSparkalWindow *__formal, long __formal, long __formal) {
	/*bp-0x4*/   long hResult;

// LINE 365:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _Tce;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _Tce;
// LINE 366:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T87;
// LINE 367:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 368:
	__asm        cmp    hResult, 0;
	__asm        je     _T87;
// LINE 369:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T73;
_T73:
	__asm        push   0x59A5E4;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 370:
	return 0x0;
// LINE 374:
_T87:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x2C];
	__asm        mov    hResult, eax;
// LINE 376:
	__asm        cmp    hResult, 0;
	__asm        je     _Tc9;
// LINE 377:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Tb5;
_Tb5:
	__asm        push   0x59A624;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 378:
	return 0x0;
// LINE 381:
_Tc9:
	__asm        jmp    _T1d9;
// LINE 382:
_Tce:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T129;
// LINE 383:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 384:
	__asm        cmp    hResult, 0;
	__asm        je     _T129;
// LINE 385:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    _T115;
_T115:
	__asm        push   0x59A650;
	__asm        lea    ecx, [ebp-0x10];
	__asm        call   DirectDrawError::DisplayError;
// LINE 386:
	return 0x0;
// LINE 389:
_T129:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T184;
// LINE 390:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 391:
	__asm        cmp    hResult, 0;
	__asm        je     _T184;
// LINE 392:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    _T170;
_T170:
	__asm        push   0x59A690;
	__asm        lea    ecx, [ebp-0x14];
	__asm        call   DirectDrawError::DisplayError;
// LINE 393:
	return 0x0;
// LINE 401:
_T184:
	__asm        push   0;
	__asm        push   0x1000000;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x1C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 402:
	__asm        cmp    hResult, 0;
	__asm        je     _T1d9;
// LINE 403:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _T1c5;
_T1c5:
	__asm        push   0x59A6D0;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   DirectDrawError::DisplayError;
// LINE 404:
	return 0x0;
// LINE 408:
_T1d9:
	return 0x1;
// LINE 409:
}

// FUNCTION: COPTER_D 0x0049efff
void ScreenBuffer::WaitTillReadyToFlip() {
	/*bp-0x4*/   int32_t bIsInVerticalBlank;
	/*bp-0x8*/   long hResult;

// LINE 426:
_T0c:
	__asm        lea    eax, bIsInVerticalBlank;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x44];
	__asm        mov    hResult, eax;
// LINE 427:
	__asm        cmp    bIsInVerticalBlank, 0;
	__asm        jne    _T37;

	__asm        cmp    hResult, 0;
	__asm        je     _T0c;
// LINE 429:
_T37:
	return;
}

// FUNCTION: COPTER_D 0x0049f040
void ScreenBuffer::SetPalette() {
	/*bp-0x4*/   long hResult;

// LINE 442:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        je     _Tb0;
// LINE 443:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T72;
// LINE 444:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 445:
	__asm        cmp    hResult, 0;
	__asm        je     _T72;
// LINE 446:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    _T60;
_T60:
	__asm        push   0x59A6FC;
	__asm        lea    ecx, [ebp-8];
	__asm        call   DirectDrawError::DisplayError;
// LINE 447:
	return;
// LINE 450:
_T72:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x7C];
	__asm        mov    hResult, eax;
// LINE 451:
	__asm        cmp    hResult, 0;
	__asm        je     _Tb0;
// LINE 452:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    _Ta3;
_Ta3:
	__asm        push   0x59A744;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   DirectDrawError::DisplayError;
// LINE 455:
_Tb0:
	return;
}

// FUNCTION: COPTER_D 0x0049f0fa
int32_t ScreenBuffer::UsePalette(/*packed*/ struct SparkalColor *pColors) {
	/*bp-0x14*/  long hResult;

	// Function registers exception cleanup function at 0x0049f410

	__asm        mov    [ebp-0x10], esp;
	__asm        mov    this, ecx;
// LINE 475:
	__asm        cmp    pColors, 0;
	__asm        je     _T2d5;
// LINE 538:
// Block start:
	/*bp-0x18*/  int32_t i;
	/*bp-0x418*/ /*packed*/ struct tagPALETTEENTRY palEntries[256]; // 0x400 bytes
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T94;
// LINE 539:
// Block start:
	/*bp-0x41c*/ void * __ptr32 hdc;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 540:
	__asm        cmp    hdc, 0;
	__asm        je     _T8f;
// LINE 541:
	__asm        lea    eax, palEntries[0].peRed;
	__asm        push   eax;
	__asm        push   0x100;
	__asm        push   0;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3580];
// LINE 542:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 545:
// Block end:
_T8f:
	__asm        jmp    _T107;
// LINE 547:
_T94:
	i = 0x0;
	__asm        jmp    _Ta3;
_Ta0:
	i++;
_Ta3:
	__asm        cmp    i, 0xA;
	__asm        jge    _T107;
// LINE 548:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 2;
// LINE 549:
	__asm        mov    al, reinterpret_cast<uint8_t>(i);
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 550:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x417], 0;
// LINE 551:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x416], 0;
// LINE 552:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3D], 2;
// LINE 553:
	__asm        mov    eax, i;
	__asm        add    eax, 0xF6;
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x40], al;
// LINE 554:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3F], 0;
// LINE 555:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3E], 0;
// LINE 556:
	__asm        jmp    _Ta0;
// LINE 558:
_T107:
	i = 0xa;
	__asm        jmp    _T116;
_T113:
	i++;
_T116:
	__asm        cmp    i, 0xF5;
	__asm        jg     _T16e;
// LINE 559:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x416], al;
// LINE 560:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+1];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x417], al;
// LINE 561:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+2];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 562:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 5;
// LINE 563:
	__asm        jmp    _T113;
// LINE 564:
_T16e:
	__asm        cmp    lpPalette, 0;
	__asm        je     _T1cc;
// LINE 565:
	__asm        mov    dword ptr [ebp-4], 0;
// LINE 566:
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
	__asm        jmp    _L37298;
// LINE 569:
_L40600:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x420], eax;
	__asm        jmp    _T1a5;
_T1a5:
	__asm        push   0x59A78C;
	__asm        lea    ecx, [ebp-0x420];
	__asm        call   DirectDrawError::DisplayError;
// LINE 570:
	__asm        mov    eax, 0x49F2B5;
	__asm        ret;
// LINE 571:
_L37298:
_L37298:
// No fallthrough
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        mov    lpPalette, 0;
// LINE 573:
_T1cc:
	this-><ScreenBuffer+0x54> = 0x0;
// LINE 577:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x54;
	__asm        push   eax;
	__asm        lea    eax, palEntries[0].peRed;
	__asm        push   eax;
	__asm        push   4;
	__asm        mov    eax, lpDD;
	__asm        push   eax;
	__asm        mov    eax, lpDD;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 578:
	__asm        cmp    hResult, 0;
	__asm        jne    _T2a5;
// LINE 579:
	lpPalette = this-><ScreenBuffer+0x54>;
// LINE 580:
	__asm        mov    dword ptr [ebp-4], 2;
// LINE 581:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x7C];
	__asm        jmp    _L37305;
// LINE 584:
_L40602:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x424], eax;
	__asm        jmp    _T244;
_T244:
	__asm        push   0x59A7CC;
	__asm        lea    ecx, [ebp-0x424];
	__asm        call   DirectDrawError::DisplayError;
// LINE 585:
	__asm        mov    eax, 0x49F354;
	__asm        ret;
// LINE 592:
_L37305:
_L37305:
// No fallthrough
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        jmp    _T266;
_T266:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     _T2a0;
// LINE 593:
	__asm        jmp    _T281;
_T281:
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x30F;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3880];
// LINE 596:
_T2a0:
	__asm        jmp    _T2d0;
// LINE 597:
_T2a5:
	this-><ScreenBuffer+0x54> = 0x0;
// LINE 598:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x428], eax;
	__asm        jmp    _T2c0;
_T2c0:
	__asm        push   0x59A804;
	__asm        lea    ecx, [ebp-0x428];
	__asm        call   DirectDrawError::DisplayError;
// LINE 601:
// Block end:
_T2d0:
	__asm        jmp    _T30c;
// LINE 603:
_T2d5:
	__asm        cmp    lpPalette, 0;
	__asm        je     _T305;
// LINE 604:
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x7C];
// LINE 605:
	__asm        jmp    _T30c;
// LINE 606:
_T305:
	return 0x0;
// LINE 610:
_T30c:
	return 0x1;
// LINE 611:
_L40603:
	__asm        mov    eax, 0x595C58;
	__asm        jmp    near ptr 0x0056F590;

	__asm        mov    ecx, [ebp-0xC];
	__asm        mov    fs:[0], ecx;
}

// FUNCTION: COPTER_D 0x0049f42b
void ScreenBuffer::FreePalette() {
// LINE 620:
	__asm        cmp    lpPalette, 0;
	__asm        je     _T3d;
// LINE 621:
	__asm        mov    eax, lpPalette;
	__asm        push   eax;
	__asm        mov    eax, lpPalette;
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 622:
	lpPalette = 0x0;
// LINE 623:
	this-><ScreenBuffer+0x54> = 0x0;
// LINE 626:
_T3d:
	return;
}

// FUNCTION: COPTER_D 0x0049f472
unsigned long ScreenBuffer::FillRect(long nPaletteIndex, /*packed*/ struct SparkalRect *rectFill) {
	/*bp-0x10*/  /*packed*/ struct tagRECT rectFillTemp; // 0x10 bytes
	/*bp-0x14*/  long hResult;

// LINE 654:
	this-><ScreenBuffer+0x58> = 0x6c;
// LINE 655:
	this-><ScreenBuffer+0xc4> = 0x64;
// LINE 656:
	this-><ScreenBuffer+0x114> = nPaletteIndex;
// LINE 658:
	__asm        cmp    rectFill, 0;
	__asm        je     _T61;
// LINE 659:
	rectFillTemp.left = rectFill->left;
// LINE 660:
	rectFillTemp.top = rectFill->top;
// LINE 661:
	rectFillTemp.right = rectFill->right;
// LINE 662:
	rectFillTemp.bottom = rectFill->bottom;
// LINE 664:
	__asm        jmp    _T8d;
// LINE 665:
_T61:
	rectFillTemp.left = 0x0;
// LINE 666:
	rectFillTemp.top = 0x0;
// LINE 667:
	rectFillTemp.right = (this-><ScreenBuffer+0x24> - this-><ScreenBuffer+0x1c>);
// LINE 668:
	rectFillTemp.bottom = (this-><ScreenBuffer+0x28> - this-><ScreenBuffer+0x20>);
// LINE 670:
_T8d:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    _T10d;

	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     _T10d;
// LINE 675:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T108;
// LINE 676:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 677:
	__asm        cmp    hResult, 0;
	__asm        je     _T108;
// LINE 678:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    _Tf4;
_Tf4:
	__asm        push   0x59A840;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   DirectDrawError::DisplayError;
// LINE 679:
	return 0x0;
// LINE 683:
_T108:
	__asm        jmp    _T1c3;
// LINE 686:
_T10d:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T168;
// LINE 687:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 688:
	__asm        cmp    hResult, 0;
	__asm        je     _T168;
// LINE 689:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    _T154;
_T154:
	__asm        push   0x59A884;
	__asm        lea    ecx, [ebp-0x1C];
	__asm        call   DirectDrawError::DisplayError;
// LINE 690:
	return 0x0;
// LINE 693:
_T168:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    _T1c3;
// LINE 694:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 695:
	__asm        cmp    hResult, 0;
	__asm        je     _T1c3;
// LINE 696:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    _T1af;
_T1af:
	__asm        push   0x59A8C8;
	__asm        lea    ecx, [ebp-0x20];
	__asm        call   DirectDrawError::DisplayError;
// LINE 697:
	return 0x0;
// LINE 705:
_T1c3:
	__asm        mov    eax, this;
	__asm        add    eax, 0xC4;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, rectFillTemp.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 706:
	__asm        cmp    hResult, 0;
	__asm        je     _T210;
// LINE 707:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    _T203;
_T203:
	__asm        push   0x59A90C;
	__asm        lea    ecx, [ebp-0x24];
	__asm        call   DirectDrawError::DisplayError;
// LINE 710:
_T210:
	return 0x0;
// LINE 711:
}

// FUNCTION: COPTER_D 0x0049f690
void ScreenBuffer::SetWindowRect(/*packed*/ struct SparkalRect *rectWindow) {
// LINE 721:
	__asm        mov    eax, rectWindow;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x13C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 727:
	this-><ScreenBuffer+0x1c> = this->rectBuffer.left;
// LINE 728:
	this-><ScreenBuffer+0x20> = this->rectBuffer.top;
// LINE 729:
	this-><ScreenBuffer+0x24> = this->rectBuffer.right;
// LINE 730:
	this-><ScreenBuffer+0x28> = this->rectBuffer.bottom;
// LINE 732:
	return;
}



// Contribution: 1:0009e710-0009e733 Module: 12, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0009e740-0009e778 Module: 12, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0049f740
// ScreenBuffer::`scalar deleting destructor'



// Contribution: 2:000025b0-0000263b Module: 12, 8 byte alignment, initialized_data, (comdat), read, 
// vftable for ScreenBuffer @ 0x005915b0
//   00: CBackBuffer::Lock @ 0x0047006f
//   01: CBackBuffer::Unlock @ 0x00470149
//   02: CBackBuffer::SetTransparentColor @ 0x0046ffe6
//   03: CBackBuffer::Compose @ 0x0046f948
//   04: CBackBuffer::StretchCompose @ 0x0046fe13
//   05: IFlatImage::StretchCompose @ 0x0048f32e
//   06: ScreenBuffer::FillRect @ 0x0049f472
//   07: ScreenBuffer::Swap @ 0x0049ee15
//   08: CBackBuffer::SwapRect @ 0x0046f828
//   09: CBackBuffer::StretchRect @ 0x0046ffcc
//   10: CBackBuffer::InitializeMemberVariables @ 0x0046eb58
//   11: CBackBuffer::Compose @ 0x0046fd33
//   12: CBackBuffer::StretchCompose @ 0x0046fd82
//   13: CBackBuffer::Duplicate @ 0x0046fe7c
//   14: CBackBuffer::ComposeNoClip @ 0x0046fce4
//   15: CBackBuffer::ComposeNoClip @ 0x0046fbb1
//   16: CBackBuffer::DrawLine @ 0x0046f5c6
//   17: CBackBuffer::FillRect @ 0x004702f1
//   18: CBackBuffer::DrawBufferText @ 0x0046f403
//   19: CBackBuffer::DrawBufferText @ 0x0046f1bd
//   20: CBackBuffer::DrawLineUnclipped @ 0x00470864
//   21: CBackBuffer::DrawLineClipped @ 0x00470c22
//   22: CBackBuffer::DrawRectangleOutline @ 0x004706e4
//   23: CBackBuffer::DrawRectangleOutlineUnclipped @ 0x004707a4
//   24: CBackBuffer::GetDDSurface @ 0x004704a7
//   25: ScreenBuffer::`scalar deleting destructor' @ 0x0049f740
//   26: ScreenBuffer::DeleteSurfaces @ 0x0049ea6a
//   27: ScreenBuffer::CreateSurfaces @ 0x0049e69e
//   28: ScreenBuffer::ClearSurfaces @ 0x0049eb58
//   29: ScreenBuffer::UsePalette @ 0x0049f0fa
//   30: ScreenBuffer::FreePalette @ 0x0049f42b
//   31: ScreenBuffer::SetPalette @ 0x0049f040
//   32: ScreenBuffer::SetWindowRect @ 0x0049f690
//   33: ScreenBuffer::SetNewModeType @ 0x0049f710
//   34: ScreenBuffer::WaitTillReadyToFlip @ 0x0049efff
//   35 entries



// Contribution: 2:00006c58-00006cdf Module: 12, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00003340-00003949 Module: 12, 4 byte alignment, initialized_data, read, write, 
