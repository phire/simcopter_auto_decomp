// Module: scrnbuf.obj
// Source: C:\Copter\source\sparkal\scrnbuf.cpp
// autogenerated by simcopter_tool from PDB file

// Type: class ScreenBuffer (forward reference);
class ScreenBuffer : public IFlatImage, public IBackBuffer, public CBackBuffer
{
public:
	void IFlatImage();
	// vtable: 0
	intro unsigned long Lock();
	// vtable: 4
	intro unsigned long Unlock();
	unsigned long GetLockCount();
	// vtable: 8
	intro void SetTransparentColor(int32_t, long);
	long GetHeight();
	long GetWidth();
	void * __ptr32 GetBitsPointer();
	long GetStride();
	// vtable: 12
	intro unsigned long ScreenBuffer(class IFlatImage*, long, long, long, long, long, long);
	unsigned long ScreenBuffer(class IFlatImage*, long, long);
	// vtable: 16
	intro unsigned long ScreenBuffer(class IFlatImage*, long, long, long, long, long, long, long, long);
	// vtable: 20
	intro unsigned long ScreenBuffer(class IFlatImage*, struct SparkalRect, struct SparkalRect);
	// vtable: 24
	intro unsigned long FillRect(long, struct SparkalRect*);
	void DrawPixel(unsigned char, long, long);
	unsigned char GetPixel(long, long);
	static unsigned long lTotalMemoryUsage;
	static unsigned long lTotalLockCount;
protected:
	unsigned long mLockCount;
	long mWidth;
	long mHeight;
	void * __ptr32 mpBits;
	long mStride;
public:
	// vtable: 28
	intro unsigned long Swap(class CSparkalWindow*, long, long);
	// vtable: 32
	intro unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long);
	// vtable: 36
	intro unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long);
	void ScreenBuffer(long, long, const struct SparkalColor*);
	void ScreenBuffer(char *);
	void ScreenBuffer();
	// vtable: 40
	intro void InitializeMemberVariables();
	void ~CBackBuffer();
	unsigned long Load();
	virtual unsigned long Lock();
	virtual unsigned long Unlock();
	// calltype: NearC
	static int32_t GetPaletteFromImage(char *, struct SparkalColor*);
	virtual unsigned long Swap(class CSparkalWindow*, long, long);
	virtual unsigned long SwapRect(class CSparkalWindow*, long, long, long, long, long, long);
	virtual unsigned long StretchRect(class CSparkalWindow*, long, long, long, long, long, long, long, long);
	// vtable: 44
	intro unsigned long ScreenBuffer(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&);
	virtual unsigned long ScreenBuffer(class IFlatImage*, long, long, long, long, long, long);
	virtual unsigned long ScreenBuffer(class IFlatImage*, long, long, long, long, long, long, long, long);
	// vtable: 48
	intro unsigned long ScreenBuffer(class IFlatImage*, const struct SparkalRect&, const struct SparkalRect&);
	// vtable: 52
	intro unsigned long Duplicate(class CBackBuffer*, int32_t);
	// vtable: 56
	intro unsigned long ScreenBuffer(class IFlatImage*, const struct SparkalPoint&, const struct SparkalRect&);
	// vtable: 60
	intro unsigned long ScreenBuffer(class IFlatImage*, long, long, long, long, long, long);
	void UpdatePalette(long, long, const struct SparkalColor*);
	virtual void SetTransparentColor(int32_t, long);
	unsigned long GetTransparentColor(long&);
	unsigned long SetFont(class MFont*);
	void SetFontColor(struct SparkalColor&);
	void SetFontIndex(int32_t);
	void SetColor(struct SparkalColor&);
	void SetColorIndex(int32_t);
	// vtable: 64
	intro unsigned long DrawLine(long, long, long, long, long);
	// vtable: 68
	intro unsigned long FillRect(long, const struct SparkalRect*);
	// vtable: 72
	intro unsigned long ScreenBuffer(char *, long, unsigned long, const class MRect&, class MFont*);
	// vtable: 76
	intro unsigned long ScreenBuffer(char *, unsigned long, long *, long *, long *, long *, class MFont*);
	// vtable: 80
	intro unsigned long DrawLineUnclipped(long, long, long, long, long);
	// vtable: 84
	intro unsigned long DrawLineClipped(long, long, long, long, long);
	// vtable: 88
	intro unsigned long DrawRectangleOutline(const struct SparkalRect&, long);
	// vtable: 92
	intro unsigned long DrawRectangleOutlineUnclipped(const struct SparkalRect&, long);
	long IsLost();
	long Restore();
	char * szFilePath;
	struct tagRECT rectDirectDrawBuffer;
protected:
	int32_t bSurfacePrimary;
	int32_t bSurfaceTransparent;
	class MFont* mFont;
	struct SparkalColor colorFontCurrent;
	struct SparkalColor colorCurrent;
	int32_t nColorIndexFontCurrent;
	int32_t nColorIndexCurrent;
	int32_t nColorIndexTransparent;
	struct IDirectDrawSurface* mpFrontSurface;
	struct IDirectDrawSurface* mpBackSurface;
	struct IDirectDrawPalette* mpPalette;
	struct _DDSURFACEDESC mDDdesc;
	struct _DDBLTFX mDDBltFx;
	void * __ptr32 hPen;
	int32_t nPenThickness;
	struct SparkalColor colorPenCurrent;
	// vtable: 96
	intro struct IDirectDrawSurface* GetDDSurface();
public:
	class CSparkalWindow* pWindow;
	long bOK;
	void ScreenBuffer(class CSparkalWindow*, long, long, struct SparkalColor*, int32_t, enum tagModeType, int32_t);
	void ScreenBuffer();
	// vtable: 100
	intro void ~ScreenBuffer();
	virtual unsigned long Swap(class CSparkalWindow*, long, long);
	// vtable: 104
	intro int32_t DeleteSurfaces();
	// vtable: 108
	intro int32_t CreateSurfaces();
	// vtable: 112
	intro int32_t ClearSurfaces(int32_t);
	// vtable: 116
	intro int32_t UsePalette(struct SparkalColor*);
	// vtable: 120
	intro void FreePalette();
	// vtable: 124
	intro void SetPalette();
	virtual unsigned long FillRect(long, struct SparkalRect*);
	// vtable: 128
	intro void SetWindowRect(struct SparkalRect*);
	// vtable: 132
	intro void SetNewModeType(enum tagModeType);
	// vtable: 136
	intro void WaitTillReadyToFlip();
protected:
	struct SparkalRect rectBuffer;
	short nBackBuffers;
	enum tagModeType nCurrentModeType;
	int32_t bUsingFlipping;
	struct IDirectDrawClipper* lpClipper;
	struct tagRECT rectDirectDrawBackBuffer;
};

// Type: struct SparkalRect;
class SparkalRect{
public:
	long left;
	long top;
	long right;
	long bottom;
	void SparkalRect(long, long, long, long);
	void SparkalRect();
};

// Type: void;
// Type: class CSparkalWindow (forward reference);
// Type: long;
// Type: struct SparkalColor (forward reference);
class SparkalColor{
public:
	unsigned char Blue;
	unsigned char Green;
	unsigned char Red;
	unsigned char Padding;
	void SparkalColor(unsigned char, unsigned char, unsigned char);
	void SparkalColor();
};

// Type: int32_t;
// Type: enum tagModeType;
// Type: struct _DDSCAPS;
class _DDSCAPS{
public:
	unsigned long dwCaps;
};

// Type: struct _DDBLTFX;
class _DDBLTFX{
public:
	unsigned long dwSize;
	unsigned long dwDDFX;
	unsigned long dwROP;
	unsigned long dwDDROP;
	unsigned long dwRotationAngle;
	unsigned long dwZBufferOpCode;
	unsigned long dwZBufferLow;
	unsigned long dwZBufferHigh;
	unsigned long dwZBufferBaseDest;
	unsigned long dwZDestConstBitDepth;
	unsigned long dwZDestConst;
	struct IDirectDrawSurface* lpDDSZBufferDest;
	unsigned long dwZSrcConstBitDepth;
	unsigned long dwZSrcConst;
	struct IDirectDrawSurface* lpDDSZBufferSrc;
	unsigned long dwAlphaEdgeBlendBitDepth;
	unsigned long dwAlphaEdgeBlend;
	unsigned long dwReserved;
	unsigned long dwAlphaDestConstBitDepth;
	unsigned long dwAlphaDestConst;
	struct IDirectDrawSurface* lpDDSAlphaDest;
	unsigned long dwAlphaSrcConstBitDepth;
	unsigned long dwAlphaSrcConst;
	struct IDirectDrawSurface* lpDDSAlphaSrc;
	unsigned long dwFillColor;
	struct IDirectDrawSurface* lpDDSPattern;
	struct _DDCOLORKEY ddckDestColorkey;
	struct _DDCOLORKEY ddckSrcColorkey;
};

// Type: unsigned long;
// Type: struct tagPALETTEENTRY[256];
// Type: void * __ptr32;
// Type: struct SparkalRect (forward reference);
public SparkalRect
// Type: struct tagRECT;
class tagRECT{
public:
	long left;
	long top;
	long right;
	long bottom;
};

// Type: uint32_t;


// Contribution: 1:0009d450-0009e705 Module: 12, 16 byte alignment, code, execute, read, 
// FUNCTION: COPTER_D 0x0049e450
void ScreenBuffer::ScreenBuffer() {
	struct SparkalRect rectWindowTemp;

// LINE 24:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x14;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
	__asm        mov    ecx, this;
	__asm        call   0x0046E690;
	__asm        jmp    near ptr 0x0049E469;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5915B0;
// LINE 25:
	__asm        jmp    near ptr 0x0049E477;
// LINE 26:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x134], 0;
// LINE 27:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+8], 0x280;
// LINE 28:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC], 0x1E0;
// LINE 29:
	__asm        mov    eax, this;
	__asm        mov    word ptr [eax+0x14C], 2;
// LINE 30:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x14E], 0;
// LINE 31:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x152], 0;
// LINE 33:
	__asm        mov    rectWindowTemp.left, 0;
// LINE 34:
	__asm        mov    rectWindowTemp.top, 0;
// LINE 35:
	__asm        mov    rectWindowTemp.right, 0;
// LINE 36:
	__asm        mov    rectWindowTemp.bottom, 0;
// LINE 41:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x0049F690;
// LINE 44:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 45:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15A], 0;
// LINE 46:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15E], 0;
// LINE 47:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x162], 0;
// LINE 48:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x166], 0;
// LINE 51:
	__asm        jmp    near ptr 0x0049E52C;
	__asm        mov    eax, this;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0049e534
void ScreenBuffer::ScreenBuffer(class CSparkalWindow* pNewWindow, long nNewWidth, long nNewHeight, struct SparkalColor* pColors, int32_t nNewBackBuffers, enum tagModeType nNewCurrentModeType, int32_t bNewUsingFlipping) {
	struct SparkalRect rectWindowTemp;

// LINE 62:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x14;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
	__asm        mov    ecx, this;
	__asm        call   0x0046E690;
	__asm        jmp    near ptr 0x0049E54D;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5915B0;
// LINE 63:
	__asm        jmp    near ptr 0x0049E55B;
// LINE 65:
	__asm        mov    eax, pNewWindow;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x134], eax;
// LINE 66:
	__asm        mov    eax, nNewWidth;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+8], eax;
// LINE 67:
	__asm        mov    eax, nNewHeight;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0xC], eax;
// LINE 68:
	__asm        mov    eax, nNewBackBuffers;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14C], ax;
// LINE 69:
	__asm        mov    eax, nNewCurrentModeType;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x14E], eax;
// LINE 70:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 71:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x2C], 1;
// LINE 72:
	__asm        mov    rectWindowTemp.left, 0;
// LINE 73:
	__asm        mov    rectWindowTemp.top, 0;
// LINE 74:
	__asm        mov    eax, nNewWidth;
	__asm        mov    rectWindowTemp.right, eax;
// LINE 75:
	__asm        mov    eax, nNewHeight;
	__asm        mov    rectWindowTemp.bottom, eax;
// LINE 76:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 1;
// LINE 77:
	__asm        mov    eax, bNewUsingFlipping;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x152], eax;
// LINE 83:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 1;
	__asm        jne    near ptr 0x0049E5F9;
// LINE 84:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x152], 0;
// LINE 89:
	__asm        lea    eax, rectWindowTemp.left;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x0049F690;
// LINE 92:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 93:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15A], 0;
// LINE 94:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x15E], 0;
// LINE 95:
	__asm        mov    eax, nNewWidth;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x162], eax;
// LINE 96:
	__asm        mov    eax, nNewHeight;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x166], eax;
// LINE 100:
	__asm        mov    ecx, this;
	__asm        call   0x0049E69E;
// LINE 101:
	__asm        mov    eax, pColors;
	__asm        push   eax;
	__asm        mov    ecx, this;
	__asm        call   0x0049F0FA;
// LINE 103:
	__asm        jmp    near ptr 0x0049E65D;
	__asm        mov    eax, this;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    0x1C;
}

// FUNCTION: COPTER_D 0x0049e667
void ScreenBuffer::~ScreenBuffer() {
// LINE 110:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax], 0x5915B0;
// LINE 112:
	__asm        mov    ecx, this;
	__asm        call   0x0049EA6A;
// LINE 114:
	__asm        mov    ecx, this;
	__asm        call   0x0049F42B;
// LINE 115:
	__asm        jmp    near ptr 0x0049E691;
	__asm        mov    ecx, this;
	__asm        call   0x0046EC7A;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0049e69e
int32_t ScreenBuffer::CreateSurfaces() {
	long hResult;

// LINE 127:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x20;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 131:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 132:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 133:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    near ptr 0x0049E7EE;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     near ptr 0x0049E7EE;
// LINE 136:
// Block start:
	struct _DDSCAPS ddsBackBufferCaps;
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   0x0056EB90;
	__asm        add    esp, 0xC;
// LINE 137:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 138:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x5C], 0x20;
// LINE 141:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC0], 0x218;
// LINE 142:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x14C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x6C], eax;
// LINE 144:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 145:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049E77B;
// LINE 146:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 147:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    near ptr 0x0049E767;
	__asm        push   0x59A340;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   0x0042D420;
// LINE 148:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EA65;
// LINE 153:
	__asm        mov    eax, this;
	__asm        movsx  eax, word ptr [eax+0x14C];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+8];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0xC];
	__asm        add    ds:[0x599DA0], eax;
// LINE 159:
	__asm        mov    ddsBackBufferCaps.dwCaps, 4;
// LINE 160:
	__asm        mov    eax, this;
	__asm        add    eax, 0x50;
	__asm        push   eax;
	__asm        lea    eax, ddsBackBufferCaps.dwCaps;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x30];
	__asm        mov    hResult, eax;
// LINE 162:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049E7E9;
// LINE 163:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    near ptr 0x0049E7D5;
	__asm        push   0x59A380;
	__asm        lea    ecx, [ebp-0x10];
	__asm        call   0x0042D420;
// LINE 164:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EA65;
// LINE 167:
// Block end:
	__asm        jmp    near ptr 0x0049EA39;
// LINE 169:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   0x0056EB90;
	__asm        add    esp, 0xC;
// LINE 170:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 171:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x5C], 0;
// LINE 172:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC0], 0x200;
// LINE 173:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x4C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 174:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049E885;
// LINE 175:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 176:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 177:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    near ptr 0x0049E871;
	__asm        push   0x59A3C4;
	__asm        lea    ecx, [ebp-0x14];
	__asm        call   0x0042D420;
// LINE 178:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EA65;
// LINE 182:
	__asm        push   0x6C;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        call   0x0056EB90;
	__asm        add    esp, 0xC;
// LINE 183:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 184:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x5C], 6;
// LINE 185:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC0], 0x840;
// LINE 186:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x64], eax;
// LINE 187:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x60], eax;
// LINE 188:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x50;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x58;
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x18];
	__asm        mov    hResult, eax;
// LINE 189:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049E950;
// LINE 190:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 191:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 192:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 193:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 194:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    near ptr 0x0049E93C;
	__asm        push   0x59A404;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   0x0042D420;
// LINE 195:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EA65;
// LINE 200:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+8];
	__asm        mov    ecx, this;
	__asm        imul   eax, [ecx+0xC];
	__asm        add    eax, eax;
	__asm        add    ds:[0x599DA0], eax;
// LINE 207:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 1;
	__asm        je     near ptr 0x0049E985;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        jne    near ptr 0x0049EA39;
// LINE 212:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x156], 0;
	__asm        jne    near ptr 0x0049E9B5;
// LINE 213:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x156;
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, ds:[0x597264];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x10];
	__asm        mov    hResult, eax;
// LINE 214:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049E9EB;
// LINE 215:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x138], 0;
// LINE 216:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    near ptr 0x0049E9D7;
	__asm        push   0x59A444;
	__asm        lea    ecx, [ebp-0x1C];
	__asm        call   0x0042D420;
// LINE 217:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EA65;
// LINE 219:
	__asm        jmp    near ptr 0x0049E9F0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x20];
	__asm        mov    hResult, eax;
// LINE 220:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x70];
	__asm        mov    hResult, eax;
// LINE 225:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax];
// LINE 226:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+4];
// LINE 227:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x70];
// LINE 229:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x0049EA65;
// LINE 230:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0049ea6a
int32_t ScreenBuffer::DeleteSurfaces() {
// LINE 238:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 240:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x4C], 0;
	__asm        je     near ptr 0x0049EAD2;
// LINE 241:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 242:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x4C], 0;
// LINE 243:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     near ptr 0x0049EAB9;
// LINE 244:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 248:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    ds:[0x599DA0], eax;
// LINE 257:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x50], 0;
	__asm        je     near ptr 0x0049EB14;
// LINE 258:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 259:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x50], 0;
// LINE 263:
	__asm        xor    eax, eax;
	__asm        mov    ecx, this;
	__asm        mov    ecx, [ecx+8];
	__asm        mov    edx, this;
	__asm        imul   ecx, [edx+0xC];
	__asm        sub    eax, ecx;
	__asm        neg    eax;
	__asm        sub    ds:[0x599DA0], eax;
// LINE 267:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x156], 0;
	__asm        je     near ptr 0x0049EB49;
// LINE 268:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x156];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 269:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x156], 0;
// LINE 272:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x0049EB53;
// LINE 273:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0049eb58
int32_t ScreenBuffer::ClearSurfaces(int32_t nClearPaletteIndex) {
	long hResult;
	struct _DDBLTFX ddbltfx;

// LINE 281:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x80;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 286:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    near ptr 0x0049EC83;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     near ptr 0x0049EC83;
// LINE 287:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049EBE2;
// LINE 288:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 289:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EBE2;
// LINE 290:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x6C], eax;
	__asm        jmp    near ptr 0x0049EBCE;
	__asm        push   0x59A484;
	__asm        lea    ecx, [ebp-0x6C];
	__asm        call   0x0042D420;
// LINE 291:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EE0E;
// LINE 294:
	__asm        mov    ddbltfx.dwSize, 0x64;
// LINE 295:
	__asm        mov    eax, nClearPaletteIndex;
	__asm        mov    ddbltfx.dwFillColor, eax;
// LINE 300:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    near ptr 0x0049EC25;
	__asm        jmp    near ptr 0x0049EBEF;
// LINE 301:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x2C];
// LINE 302:
	__asm        mov    ddbltfx.dwSize, 0x64;
// LINE 303:
	__asm        mov    eax, nClearPaletteIndex;
	__asm        mov    ddbltfx.dwFillColor, eax;
// LINE 308:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    near ptr 0x0049EC7E;
	__asm        jmp    near ptr 0x0049EC48;
// LINE 310:
	__asm        jmp    near ptr 0x0049EE04;
// LINE 313:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049ECDE;
// LINE 314:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 315:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049ECDE;
// LINE 316:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x70], eax;
	__asm        jmp    near ptr 0x0049ECCA;
	__asm        push   0x59A4CC;
	__asm        lea    ecx, [ebp-0x70];
	__asm        call   0x0042D420;
// LINE 317:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EE0E;
// LINE 320:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049ED39;
// LINE 321:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 322:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049ED39;
// LINE 323:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x74], eax;
	__asm        jmp    near ptr 0x0049ED25;
	__asm        push   0x59A514;
	__asm        lea    ecx, [ebp-0x74];
	__asm        call   0x0042D420;
// LINE 324:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EE0E;
// LINE 327:
	__asm        mov    ddbltfx.dwSize, 0x64;
// LINE 328:
	__asm        mov    eax, nClearPaletteIndex;
	__asm        mov    ddbltfx.dwFillColor, eax;
// LINE 333:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    near ptr 0x0049ED7C;
	__asm        jmp    near ptr 0x0049ED46;
// LINE 334:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EDA5;
// LINE 335:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x78], eax;
	__asm        jmp    near ptr 0x0049ED91;
	__asm        push   0x59A55C;
	__asm        lea    ecx, [ebp-0x78];
	__asm        call   0x0042D420;
// LINE 336:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EE0E;
// LINE 342:
	__asm        lea    eax, ddbltfx.dwSize;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
	__asm        cmp    hResult, 0x8876021C;
	__asm        jne    near ptr 0x0049EDDB;
	__asm        jmp    near ptr 0x0049EDA5;
// LINE 343:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EE04;
// LINE 344:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x7C], eax;
	__asm        jmp    near ptr 0x0049EDF0;
	__asm        push   0x59A5A0;
	__asm        lea    ecx, [ebp-0x7C];
	__asm        call   0x0042D420;
// LINE 345:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EE0E;
// LINE 349:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x0049EE0E;
// LINE 350:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}

// FUNCTION: COPTER_D 0x0049ee15
unsigned long ScreenBuffer::Swap(class CSparkalWindow* __formal, long __formal, long __formal) {
	long hResult;

// LINE 361:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x1C;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 365:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    near ptr 0x0049EEE3;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     near ptr 0x0049EEE3;
// LINE 366:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049EE9C;
// LINE 367:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 368:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EE9C;
// LINE 369:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    near ptr 0x0049EE88;
	__asm        push   0x59A5E4;
	__asm        lea    ecx, [ebp-8];
	__asm        call   0x0042D420;
// LINE 370:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EFF8;
// LINE 374:
	__asm        push   1;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x2C];
	__asm        mov    hResult, eax;
// LINE 376:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EEDE;
// LINE 377:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    near ptr 0x0049EECA;
	__asm        push   0x59A624;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   0x0042D420;
// LINE 378:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EFF8;
// LINE 381:
	__asm        jmp    near ptr 0x0049EFEE;
// LINE 382:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049EF3E;
// LINE 383:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 384:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EF3E;
// LINE 385:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x10], eax;
	__asm        jmp    near ptr 0x0049EF2A;
	__asm        push   0x59A650;
	__asm        lea    ecx, [ebp-0x10];
	__asm        call   0x0042D420;
// LINE 386:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EFF8;
// LINE 389:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049EF99;
// LINE 390:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 391:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EF99;
// LINE 392:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x14], eax;
	__asm        jmp    near ptr 0x0049EF85;
	__asm        push   0x59A690;
	__asm        lea    ecx, [ebp-0x14];
	__asm        call   0x0042D420;
// LINE 393:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EFF8;
// LINE 401:
	__asm        push   0;
	__asm        push   0x1000000;
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        add    eax, 0x1C;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 402:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049EFEE;
// LINE 403:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    near ptr 0x0049EFDA;
	__asm        push   0x59A6D0;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   0x0042D420;
// LINE 404:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049EFF8;
// LINE 408:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x0049EFF8;
// LINE 409:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    0xC;
}

// FUNCTION: COPTER_D 0x0049efff
void ScreenBuffer::WaitTillReadyToFlip() {
	long hResult;
	int32_t bIsInVerticalBlank;

// LINE 420:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0xC;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 426:
	__asm        lea    eax, bIsInVerticalBlank;
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x44];
	__asm        mov    hResult, eax;
// LINE 427:
	__asm        cmp    bIsInVerticalBlank, 0;
	__asm        jne    near ptr 0x0049F036;
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049F00B;
// LINE 429:
	__asm        jmp    near ptr 0x0049F03B;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0049f040
void ScreenBuffer::SetPalette() {
	long hResult;

// LINE 438:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x10;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 442:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x54], 0;
	__asm        je     near ptr 0x0049F0F0;
// LINE 443:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049F0B2;
// LINE 444:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 445:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049F0B2;
// LINE 446:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-8], eax;
	__asm        jmp    near ptr 0x0049F0A0;
	__asm        push   0x59A6FC;
	__asm        lea    ecx, [ebp-8];
	__asm        call   0x0042D420;
// LINE 447:
	__asm        jmp    near ptr 0x0049F0F5;
// LINE 450:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x7C];
	__asm        mov    hResult, eax;
// LINE 451:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049F0F0;
// LINE 452:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0xC], eax;
	__asm        jmp    near ptr 0x0049F0E3;
	__asm        push   0x59A744;
	__asm        lea    ecx, [ebp-0xC];
	__asm        call   0x0042D420;
// LINE 455:
	__asm        jmp    near ptr 0x0049F0F5;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0049f0fa
int32_t ScreenBuffer::UsePalette(struct SparkalColor* pColors) {
	long hResult;

// LINE 471:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        push   0xFFFFFFFF;
	__asm        push   0x49F410;
	__asm        mov    eax, fs:[0];
	__asm        push   eax;
	__asm        mov    fs:[0], esp;
	__asm        sub    esp, 4;
	__asm        sub    esp, 0x41C;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    [ebp-0x10], esp;
	__asm        mov    this, ecx;
// LINE 475:
	__asm        cmp    pColors, 0;
	__asm        je     near ptr 0x0049F3CF;
// LINE 538:
// Block start:
	struct tagPALETTEENTRY[256] palEntries;
	int32_t i;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    near ptr 0x0049F18E;
// LINE 539:
// Block start:
	void * __ptr32 hdc;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C3850];
	__asm        mov    hdc, eax;
// LINE 540:
	__asm        cmp    hdc, 0;
	__asm        je     near ptr 0x0049F189;
// LINE 541:
	__asm        lea    eax, palEntries[0].peRed;
	__asm        push   eax;
	__asm        push   0x100;
	__asm        push   0;
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3580];
// LINE 542:
	__asm        mov    eax, hdc;
	__asm        push   eax;
	__asm        push   0;
	__asm        call   dword ptr ds:[0x6C384C];
// LINE 545:
// Block end:
	__asm        jmp    near ptr 0x0049F201;
// LINE 547:
	__asm        mov    i, 0;
	__asm        jmp    near ptr 0x0049F19D;
	__asm        inc    i;
	__asm        cmp    i, 0xA;
	__asm        jge    near ptr 0x0049F201;
// LINE 548:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 2;
// LINE 549:
	__asm        mov    al, reinterpret_cast<uint8_t>(i);
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 550:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x417], 0;
// LINE 551:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x416], 0;
// LINE 552:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3D], 2;
// LINE 553:
	__asm        mov    eax, i;
	__asm        add    eax, 0xF6;
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x40], al;
// LINE 554:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3F], 0;
// LINE 555:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x3E], 0;
// LINE 556:
	__asm        jmp    near ptr 0x0049F19A;
// LINE 558:
	__asm        mov    i, 0xA;
	__asm        jmp    near ptr 0x0049F210;
	__asm        inc    i;
	__asm        cmp    i, 0xF5;
	__asm        jg     near ptr 0x0049F268;
// LINE 559:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x416], al;
// LINE 560:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+1];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x417], al;
// LINE 561:
	__asm        mov    eax, i;
	__asm        mov    ecx, pColors;
	__asm        mov    al, [ecx+eax*4+2];
	__asm        mov    ecx, i;
	__asm        mov    [ebp+ecx*4-0x418], al;
// LINE 562:
	__asm        mov    eax, i;
	__asm        mov    byte ptr [ebp+eax*4-0x415], 5;
// LINE 563:
	__asm        jmp    near ptr 0x0049F20D;
// LINE 564:
	__asm        cmp    dword ptr ds:[0x597268], 0;
	__asm        je     near ptr 0x0049F2C6;
// LINE 565:
	__asm        mov    dword ptr [ebp-4], 0;
// LINE 566:
	__asm        mov    eax, ds:[0x597268];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597268];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
	__asm        jmp    near ptr 0x0049F2B5;
// LINE 569:
_L40600:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x420], eax;
	__asm        jmp    near ptr 0x0049F29F;
	__asm        push   0x59A78C;
	__asm        lea    ecx, [ebp-0x420];
	__asm        call   0x0042D420;
// LINE 570:
	__asm        mov    eax, 0x49F2B5;
	__asm        ret;
// LINE 571:
_L37298:
_L37298:
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        mov    dword ptr ds:[0x597268], 0;
// LINE 573:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 0;
// LINE 577:
	__asm        push   0;
	__asm        mov    eax, this;
	__asm        add    eax, 0x54;
	__asm        push   eax;
	__asm        lea    eax, palEntries[0].peRed;
	__asm        push   eax;
	__asm        push   4;
	__asm        mov    eax, ds:[0x597264];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597264];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 578:
	__asm        cmp    hResult, 0;
	__asm        jne    near ptr 0x0049F39F;
// LINE 579:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x54];
	__asm        mov    ds:[0x597268], eax;
// LINE 580:
	__asm        mov    dword ptr [ebp-4], 2;
// LINE 581:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax];
	__asm        mov    ecx, this;
	__asm        call   dword ptr [eax+0x7C];
	__asm        jmp    near ptr 0x0049F354;
// LINE 584:
_L40602:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x424], eax;
	__asm        jmp    near ptr 0x0049F33E;
	__asm        push   0x59A7CC;
	__asm        lea    ecx, [ebp-0x424];
	__asm        call   0x0042D420;
// LINE 585:
	__asm        mov    eax, 0x49F354;
	__asm        ret;
// LINE 592:
_L37305:
_L37305:
	__asm        mov    dword ptr [ebp-4], 0xFFFFFFFF;
	__asm        jmp    near ptr 0x0049F360;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        cmp    dword ptr [eax+0x18], 0;
	__asm        je     near ptr 0x0049F39A;
// LINE 593:
	__asm        jmp    near ptr 0x0049F37B;
	__asm        push   0;
	__asm        push   0;
	__asm        push   0x30F;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x134];
	__asm        mov    eax, [eax+0x18];
	__asm        push   eax;
	__asm        call   dword ptr ds:[0x6C3880];
// LINE 596:
	__asm        jmp    near ptr 0x0049F3CA;
// LINE 597:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 0;
// LINE 598:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x428], eax;
	__asm        jmp    near ptr 0x0049F3BA;
	__asm        push   0x59A804;
	__asm        lea    ecx, [ebp-0x428];
	__asm        call   0x0042D420;
// LINE 601:
// Block end:
	__asm        jmp    near ptr 0x0049F406;
// LINE 603:
	__asm        cmp    dword ptr ds:[0x597268], 0;
	__asm        je     near ptr 0x0049F3FF;
// LINE 604:
	__asm        mov    eax, ds:[0x597268];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x7C];
// LINE 605:
	__asm        jmp    near ptr 0x0049F406;
// LINE 606:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049F41A;
// LINE 610:
	__asm        mov    eax, 1;
	__asm        jmp    near ptr 0x0049F41A;
// LINE 611:
_L40603:
	__asm        mov    eax, 0x595C58;
	__asm        jmp    near ptr 0x0056F590;
	__asm        mov    ecx, [ebp-0xC];
	__asm        mov    fs:[0], ecx;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}

// FUNCTION: COPTER_D 0x0049f42b
void ScreenBuffer::FreePalette() {
// LINE 618:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 620:
	__asm        cmp    dword ptr ds:[0x597268], 0;
	__asm        je     near ptr 0x0049F468;
// LINE 621:
	__asm        mov    eax, ds:[0x597268];
	__asm        push   eax;
	__asm        mov    eax, ds:[0x597268];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+8];
// LINE 622:
	__asm        mov    dword ptr ds:[0x597268], 0;
// LINE 623:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x54], 0;
// LINE 626:
	__asm        jmp    near ptr 0x0049F46D;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret;
}

// FUNCTION: COPTER_D 0x0049f472
unsigned long ScreenBuffer::FillRect(long nPaletteIndex, struct SparkalRect* rectFill) {
	long hResult;
	struct tagRECT rectFillTemp;

// LINE 649:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 0x28;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 654:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0x58], 0x6C;
// LINE 655:
	__asm        mov    eax, this;
	__asm        mov    dword ptr [eax+0xC4], 0x64;
// LINE 656:
	__asm        mov    eax, nPaletteIndex;
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x114], eax;
// LINE 658:
	__asm        cmp    rectFill, 0;
	__asm        je     near ptr 0x0049F4D3;
// LINE 659:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax];
	__asm        mov    rectFillTemp.left, eax;
// LINE 660:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax+4];
	__asm        mov    rectFillTemp.top, eax;
// LINE 661:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax+8];
	__asm        mov    rectFillTemp.right, eax;
// LINE 662:
	__asm        mov    eax, rectFill;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    rectFillTemp.bottom, eax;
// LINE 664:
	__asm        jmp    near ptr 0x0049F4FF;
// LINE 665:
	__asm        mov    rectFillTemp.left, 0;
// LINE 666:
	__asm        mov    rectFillTemp.top, 0;
// LINE 667:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x24];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x1C];
	__asm        mov    rectFillTemp.right, eax;
// LINE 668:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x28];
	__asm        mov    ecx, this;
	__asm        sub    eax, [ecx+0x20];
	__asm        mov    rectFillTemp.bottom, eax;
// LINE 670:
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x14E], 0;
	__asm        jne    near ptr 0x0049F57F;
	__asm        mov    eax, this;
	__asm        cmp    dword ptr [eax+0x152], 0;
	__asm        je     near ptr 0x0049F57F;
// LINE 675:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049F57A;
// LINE 676:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 677:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049F57A;
// LINE 678:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x18], eax;
	__asm        jmp    near ptr 0x0049F566;
	__asm        push   0x59A840;
	__asm        lea    ecx, [ebp-0x18];
	__asm        call   0x0042D420;
// LINE 679:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049F689;
// LINE 683:
	__asm        jmp    near ptr 0x0049F635;
// LINE 686:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049F5DA;
// LINE 687:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x4C];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 688:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049F5DA;
// LINE 689:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x1C], eax;
	__asm        jmp    near ptr 0x0049F5C6;
	__asm        push   0x59A884;
	__asm        lea    ecx, [ebp-0x1C];
	__asm        call   0x0042D420;
// LINE 690:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049F689;
// LINE 693:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x60];
	__asm        cmp    eax, 0x887601C2;
	__asm        jne    near ptr 0x0049F635;
// LINE 694:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x6C];
	__asm        mov    hResult, eax;
// LINE 695:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049F635;
// LINE 696:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x20], eax;
	__asm        jmp    near ptr 0x0049F621;
	__asm        push   0x59A8C8;
	__asm        lea    ecx, [ebp-0x20];
	__asm        call   0x0042D420;
// LINE 697:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049F689;
// LINE 705:
	__asm        mov    eax, this;
	__asm        add    eax, 0xC4;
	__asm        push   eax;
	__asm        push   0x1000400;
	__asm        push   0;
	__asm        push   0;
	__asm        lea    eax, rectFillTemp.left;
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        push   eax;
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x50];
	__asm        mov    eax, [eax];
	__asm        call   dword ptr [eax+0x14];
	__asm        mov    hResult, eax;
// LINE 706:
	__asm        cmp    hResult, 0;
	__asm        je     near ptr 0x0049F682;
// LINE 707:
	__asm        mov    eax, hResult;
	__asm        mov    [ebp-0x24], eax;
	__asm        jmp    near ptr 0x0049F675;
	__asm        push   0x59A90C;
	__asm        lea    ecx, [ebp-0x24];
	__asm        call   0x0042D420;
// LINE 710:
	__asm        xor    eax, eax;
	__asm        jmp    near ptr 0x0049F689;
// LINE 711:
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    8;
}

// FUNCTION: COPTER_D 0x0049f690
void ScreenBuffer::SetWindowRect(struct SparkalRect* rectWindow) {
// LINE 719:
	__asm        push   ebp;
	__asm        mov    ebp, esp;
	__asm        sub    esp, 4;
	__asm        push   ebx;
	__asm        push   esi;
	__asm        push   edi;
	__asm        mov    this, ecx;
// LINE 721:
	__asm        mov    eax, rectWindow;
	__asm        mov    ecx, this;
	__asm        add    ecx, 0x13C;
	__asm        mov    edx, [eax];
	__asm        mov    [ecx], edx;
	__asm        mov    edx, [eax+4];
	__asm        mov    [ecx+4], edx;
	__asm        mov    edx, [eax+8];
	__asm        mov    [ecx+8], edx;
	__asm        mov    eax, [eax+0xC];
	__asm        mov    [ecx+0xC], eax;
// LINE 727:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x13C];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x1C], eax;
// LINE 728:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x140];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x20], eax;
// LINE 729:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x144];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x24], eax;
// LINE 730:
	__asm        mov    eax, this;
	__asm        mov    eax, [eax+0x148];
	__asm        mov    ecx, this;
	__asm        mov    [ecx+0x28], eax;
// LINE 732:
	__asm        jmp    near ptr 0x0049F6FF;
	__asm        pop    edi;
	__asm        pop    esi;
	__asm        pop    ebx;
	__asm        leave;
	__asm        ret    4;
}



// Contribution: 1:0009e710-0009e733 Module: 12, 16 byte alignment, code, (comdat), execute, read, 


// Contribution: 1:0009e740-0009e778 Module: 12, 16 byte alignment, code, (comdat), execute, read, 
// FUNCTION: COPTER_D 0x0049f740
// ScreenBuffer::`scalar deleting destructor'



// Contribution: 2:000025b0-0000263b Module: 12, 8 byte alignment, initialized_data, (comdat), read, 
// GLOBAL: COPTER_D 0x005915b0
// ??_7ScreenBuffer@@6B@


// Contribution: 2:00006c58-00006cdf Module: 12, 8 byte alignment, initialized_data, read, 


// Contribution: 3:00003340-00003949 Module: 12, 4 byte alignment, initialized_data, read, write, 
